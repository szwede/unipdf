//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package fonts

import (
	_ee "bytes"
	_ca "encoding/binary"
	_fg "errors"
	_g "fmt"
	_aba "github.com/szwede/unipdf/v4/common"
	_b "github.com/szwede/unipdf/v4/core"
	_ab "github.com/szwede/unipdf/v4/internal/cmap"
	_cc "github.com/szwede/unipdf/v4/internal/textencoding"
	_d "io"
	_c "os"
	_ff "regexp"
	_e "sort"
	_a "strings"
	_fa "sync"
)

func (_dfe *ttfParser) ParseHhea() error {
	if _eba := _dfe.Seek("\u0068\u0068\u0065\u0061"); _eba != nil {
		return _eba
	}
	_dfe.Skip(4 + 15*2)
	_dfe._aea = _dfe.ReadUShort()
	return nil
}

func (_bga *ttfParser) parseCmapVersion(_cff int64) error {
	_aba.Log.Trace("p\u0061\u0072\u0073\u0065\u0043\u006da\u0070\u0056\u0065\u0072\u0073\u0069\u006f\u006e\u003a \u006f\u0066\u0066s\u0065t\u003d\u0025\u0064", _cff)
	if _bga._cgg.Chars == nil {
		_bga._cgg.Chars = make(map[rune]GID)
	}
	_bga._edg.Seek(int64(_bga._ggad["\u0063\u006d\u0061\u0070"])+_cff, _d.SeekStart)
	var _gdb, _febg uint32
	_fded := _bga.ReadUShort()
	if _fded < 8 {
		_gdb = uint32(_bga.ReadUShort())
		_febg = uint32(_bga.ReadUShort())
	} else {
		_bga.ReadUShort()
		_gdb = _bga.ReadULong()
		_febg = _bga.ReadULong()
	}
	_aba.Log.Debug("\u0070\u0061\u0072\u0073\u0065\u0043m\u0061\u0070\u0056\u0065\u0072\u0073\u0069\u006f\u006e\u003a\u0020\u0066\u006f\u0072\u006d\u0061\u0074\u003d\u0025\u0064 \u006c\u0065\u006e\u0067\u0074\u0068\u003d\u0025\u0064\u0020\u006c\u0061\u006e\u0067u\u0061g\u0065\u003d\u0025\u0064", _fded, _gdb, _febg)
	switch _fded {
	case 0:
		return _bga.parseCmapFormat0()
	case 6:
		return _bga.parseCmapFormat6()
	case 12:
		return _bga.parseCmapFormat12()
	default:
		_aba.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063m\u0061\u0070\u0020\u0066\u006f\u0072\u006da\u0074\u003d\u0025\u0064", _fded)
		return nil
	}
}

func (_aca StdFont) Encoder() _cc.TextEncoder { return _aca._fcg }

var _ded *RuneCharSafeMap

type Font interface {
	Encoder() _cc.TextEncoder
	GetRuneMetrics(_ec rune) (CharMetrics, bool)
}

var _aae *RuneCharSafeMap

type TtfType struct {
	UnitsPerEm             uint16
	PostScriptName         string
	Bold                   bool
	ItalicAngle            float64
	IsFixedPitch           bool
	TypoAscender           int16
	TypoDescender          int16
	UnderlinePosition      int16
	UnderlineThickness     int16
	Xmin, Ymin, Xmax, Ymax int16
	CapHeight              int16
	Widths                 []uint16
	Chars                  map[rune]GID
	GlyphNames             []GlyphName
}

func (_eec *RuneCharSafeMap) Read(b rune) (CharMetrics, bool) {
	_eec._fb.RLock()
	defer _eec._fb.RUnlock()
	_cd, _gg := _eec._bb[b]
	return _cd, _gg
}

type StdFontName string

func (_ge CharMetrics) String() string {
	return _g.Sprintf("<\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u003e", _ge.Wx, _ge.Wy)
}

func _feg(_ea map[string]uint32) string {
	var _aef []string
	for _baf := range _ea {
		_aef = append(_aef, _baf)
	}
	_e.Slice(_aef, func(_acf, _gad int) bool { return _ea[_aef[_acf]] < _ea[_aef[_gad]] })
	_bfe := []string{_g.Sprintf("\u0054\u0072\u0075\u0065Ty\u0070\u0065\u0020\u0074\u0061\u0062\u006c\u0065\u0073\u003a\u0020\u0025\u0064", len(_ea))}
	for _, _fga := range _aef {
		_bfe = append(_bfe, _g.Sprintf("\u0009%\u0071\u0020\u0025\u0035\u0064", _fga, _ea[_fga]))
	}
	return _a.Join(_bfe, "\u000a")
}

func (_bcc *ttfParser) ReadStr(length int) (string, error) {
	_ddf := make([]byte, length)
	_cccb, _afg := _bcc._edg.Read(_ddf)
	if _afg != nil {
		return "", _afg
	} else if _cccb != length {
		return "", _g.Errorf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0073", length)
	}
	return string(_ddf), nil
}

func NewStdFontWithEncoding(desc Descriptor, metrics *RuneCharSafeMap, encoder _cc.TextEncoder) StdFont {
	var _fbc rune = 0xA0
	if _, _dab := metrics.Read(_fbc); !_dab {
		_gae, _ := metrics.Read(0x20)
		metrics.Write(_fbc, _gae)
	}
	return StdFont{_ddb: desc, _aga: metrics, _fcg: encoder}
}

func (_defc *ttfParser) ReadSByte() (_bfeff int8) {
	_ca.Read(_defc._edg, _ca.BigEndian, &_bfeff)
	return _bfeff
}

func NewFontFile2FromPdfObject(obj _b.PdfObject) (TtfType, error) {
	obj = _b.TraceToDirectObject(obj)
	_gcad, _cad := obj.(*_b.PdfObjectStream)
	if !_cad {
		_aba.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0032\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u0073\u0074\u0072e\u0061\u006d \u0028\u0025\u0054\u0029", obj)
		return TtfType{}, _b.ErrTypeError
	}
	_geb, _ffdda := _b.DecodeStream(_gcad)
	if _ffdda != nil {
		return TtfType{}, _ffdda
	}
	_fbd := ttfParser{_edg: _ee.NewReader(_geb)}
	return _fbd.Parse()
}

func RegisterStdFont(name StdFontName, fnc func() StdFont, aliases ...StdFontName) {
	if _, _eg := _de.read(name); _eg {
		panic("\u0066o\u006e\u0074\u0020\u0061l\u0072\u0065\u0061\u0064\u0079 \u0072e\u0067i\u0073\u0074\u0065\u0072\u0065\u0064\u003a " + string(name))
	}
	_de.write(name, fnc)
	for _, _ed := range aliases {
		RegisterStdFont(_ed, fnc)
	}
}

func (_bfg *ttfParser) Parse() (TtfType, error) {
	_aed, _afe := _bfg.ReadStr(4)
	if _afe != nil {
		return TtfType{}, _afe
	}
	if _aed == "\u0074\u0074\u0063\u0066" {
		return _bfg.parseTTC()
	} else if _aed != "\u0000\u0001\u0000\u0000" && _aed != "\u0074\u0072\u0075\u0065" {
		_aba.Log.Debug("\u0055n\u0072\u0065c\u006f\u0067\u006ei\u007a\u0065\u0064\u0020\u0054\u0072\u0075e\u0054\u0079\u0070\u0065\u0020\u0066i\u006c\u0065\u0020\u0066\u006f\u0072\u006d\u0061\u0074\u002e\u0020v\u0065\u0072\u0073\u0069\u006f\u006e\u003d\u0025\u0071", _aed)
	}
	_bbeb := int(_bfg.ReadUShort())
	_bfg.Skip(3 * 2)
	_bfg._ggad = make(map[string]uint32)
	var _ede string
	for _gdd := 0; _gdd < _bbeb; _gdd++ {
		_ede, _afe = _bfg.ReadStr(4)
		if _afe != nil {
			return TtfType{}, _afe
		}
		_bfg.Skip(4)
		_dfb := _bfg.ReadULong()
		_bfg.Skip(4)
		_bfg._ggad[_ede] = _dfb
	}
	_aba.Log.Trace(_feg(_bfg._ggad))
	if _afe = _bfg.ParseComponents(); _afe != nil {
		return TtfType{}, _afe
	}
	return _bfg._cgg, nil
}

func (_bffb *ttfParser) parseCmapSubtable10(_gaef int64) error {
	if _bffb._cgg.Chars == nil {
		_bffb._cgg.Chars = make(map[rune]GID)
	}
	_bffb._edg.Seek(int64(_bffb._ggad["\u0063\u006d\u0061\u0070"])+_gaef, _d.SeekStart)
	var _gbce, _dgdc uint32
	_cfac := _bffb.ReadUShort()
	if _cfac < 8 {
		_gbce = uint32(_bffb.ReadUShort())
		_dgdc = uint32(_bffb.ReadUShort())
	} else {
		_bffb.ReadUShort()
		_gbce = _bffb.ReadULong()
		_dgdc = _bffb.ReadULong()
	}
	_aba.Log.Trace("\u0070\u0061r\u0073\u0065\u0043\u006d\u0061p\u0053\u0075\u0062\u0074\u0061b\u006c\u0065\u0031\u0030\u003a\u0020\u0066\u006f\u0072\u006d\u0061\u0074\u003d\u0025\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003d\u0025\u0064\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003d\u0025\u0064", _cfac, _gbce, _dgdc)
	if _cfac != 0 {
		return _fg.New("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006d\u0061p\u0020s\u0075\u0062\u0074\u0061\u0062\u006c\u0065\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	_efb, _ace := _bffb.ReadStr(256)
	if _ace != nil {
		return _ace
	}
	_ebe := []byte(_efb)
	for _ffb, _bcaf := range _ebe {
		_bffb._cgg.Chars[rune(_ffb)] = GID(_bcaf)
		if _bcaf != 0 {
			_g.Printf("\u0009\u0030\u0078\u002502\u0078\u0020\u279e\u0020\u0030\u0078\u0025\u0030\u0032\u0078\u003d\u0025\u0063\u000a", _ffb, _bcaf, rune(_bcaf))
		}
	}
	return nil
}

var _bgd *RuneCharSafeMap

func MakeRuneCharSafeMap(length int) *RuneCharSafeMap {
	return &RuneCharSafeMap{_bb: make(map[rune]CharMetrics, length)}
}

var _abg = []int16{667, 944, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 722, 722, 612, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 500, 667, 722, 722, 722, 778, 389, 389, 389, 389, 389, 389, 389, 389, 500, 667, 667, 611, 611, 611, 611, 611, 889, 722, 722, 722, 722, 722, 722, 944, 722, 722, 722, 722, 722, 722, 722, 722, 611, 722, 667, 667, 667, 667, 556, 556, 556, 556, 556, 611, 611, 611, 611, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 889, 667, 611, 611, 611, 611, 611, 611, 611, 500, 500, 500, 500, 333, 500, 722, 500, 500, 778, 500, 500, 570, 570, 500, 832, 500, 500, 278, 220, 348, 348, 333, 333, 333, 220, 350, 444, 444, 333, 444, 444, 333, 500, 333, 333, 250, 250, 747, 500, 500, 500, 500, 608, 500, 400, 333, 570, 500, 333, 278, 444, 444, 444, 444, 444, 444, 444, 500, 1000, 444, 1000, 500, 444, 570, 500, 389, 389, 333, 556, 500, 556, 500, 500, 167, 500, 500, 500, 500, 333, 570, 549, 500, 500, 333, 333, 556, 333, 333, 278, 278, 278, 278, 278, 278, 278, 278, 500, 500, 278, 278, 382, 278, 570, 549, 606, 494, 278, 778, 333, 606, 576, 570, 556, 556, 556, 556, 500, 549, 556, 500, 500, 500, 500, 500, 722, 333, 500, 500, 500, 500, 750, 750, 300, 266, 300, 500, 500, 500, 500, 333, 333, 494, 833, 250, 250, 1000, 570, 570, 500, 500, 500, 555, 500, 500, 500, 333, 333, 333, 278, 389, 389, 549, 389, 389, 747, 333, 389, 389, 389, 389, 389, 500, 333, 500, 500, 278, 250, 500, 600, 278, 366, 278, 500, 500, 750, 300, 333, 1000, 500, 300, 556, 556, 556, 556, 556, 556, 556, 500, 556, 556, 444, 667, 500, 444, 444, 444, 500, 389, 389, 389, 389, 500}

var _cgd _fa.Once

var _ccc = &RuneCharSafeMap{_bb: map[rune]CharMetrics{' ': {Wx: 278}, '→': {Wx: 838}, '↔': {Wx: 1016}, '↕': {Wx: 458}, '①': {Wx: 788}, '②': {Wx: 788}, '③': {Wx: 788}, '④': {Wx: 788}, '⑤': {Wx: 788}, '⑥': {Wx: 788}, '⑦': {Wx: 788}, '⑧': {Wx: 788}, '⑨': {Wx: 788}, '⑩': {Wx: 788}, '■': {Wx: 761}, '▲': {Wx: 892}, '▼': {Wx: 892}, '◆': {Wx: 788}, '●': {Wx: 791}, '◗': {Wx: 438}, '★': {Wx: 816}, '☎': {Wx: 719}, '☛': {Wx: 960}, '☞': {Wx: 939}, '♠': {Wx: 626}, '♣': {Wx: 776}, '♥': {Wx: 694}, '♦': {Wx: 595}, '✁': {Wx: 974}, '✂': {Wx: 961}, '✃': {Wx: 974}, '✄': {Wx: 980}, '✆': {Wx: 789}, '✇': {Wx: 790}, '✈': {Wx: 791}, '✉': {Wx: 690}, '✌': {Wx: 549}, '✍': {Wx: 855}, '✎': {Wx: 911}, '✏': {Wx: 933}, '✐': {Wx: 911}, '✑': {Wx: 945}, '✒': {Wx: 974}, '✓': {Wx: 755}, '✔': {Wx: 846}, '✕': {Wx: 762}, '✖': {Wx: 761}, '✗': {Wx: 571}, '✘': {Wx: 677}, '✙': {Wx: 763}, '✚': {Wx: 760}, '✛': {Wx: 759}, '✜': {Wx: 754}, '✝': {Wx: 494}, '✞': {Wx: 552}, '✟': {Wx: 537}, '✠': {Wx: 577}, '✡': {Wx: 692}, '✢': {Wx: 786}, '✣': {Wx: 788}, '✤': {Wx: 788}, '✥': {Wx: 790}, '✦': {Wx: 793}, '✧': {Wx: 794}, '✩': {Wx: 823}, '✪': {Wx: 789}, '✫': {Wx: 841}, '✬': {Wx: 823}, '✭': {Wx: 833}, '✮': {Wx: 816}, '✯': {Wx: 831}, '✰': {Wx: 923}, '✱': {Wx: 744}, '✲': {Wx: 723}, '✳': {Wx: 749}, '✴': {Wx: 790}, '✵': {Wx: 792}, '✶': {Wx: 695}, '✷': {Wx: 776}, '✸': {Wx: 768}, '✹': {Wx: 792}, '✺': {Wx: 759}, '✻': {Wx: 707}, '✼': {Wx: 708}, '✽': {Wx: 682}, '✾': {Wx: 701}, '✿': {Wx: 826}, '❀': {Wx: 815}, '❁': {Wx: 789}, '❂': {Wx: 789}, '❃': {Wx: 707}, '❄': {Wx: 687}, '❅': {Wx: 696}, '❆': {Wx: 689}, '❇': {Wx: 786}, '❈': {Wx: 787}, '❉': {Wx: 713}, '❊': {Wx: 791}, '❋': {Wx: 785}, '❍': {Wx: 873}, '❏': {Wx: 762}, '❐': {Wx: 762}, '❑': {Wx: 759}, '❒': {Wx: 759}, '❖': {Wx: 784}, '❘': {Wx: 138}, '❙': {Wx: 277}, '❚': {Wx: 415}, '❛': {Wx: 392}, '❜': {Wx: 392}, '❝': {Wx: 668}, '❞': {Wx: 668}, '❡': {Wx: 732}, '❢': {Wx: 544}, '❣': {Wx: 544}, '❤': {Wx: 910}, '❥': {Wx: 667}, '❦': {Wx: 760}, '❧': {Wx: 760}, '❶': {Wx: 788}, '❷': {Wx: 788}, '❸': {Wx: 788}, '❹': {Wx: 788}, '❺': {Wx: 788}, '❻': {Wx: 788}, '❼': {Wx: 788}, '❽': {Wx: 788}, '❾': {Wx: 788}, '❿': {Wx: 788}, '➀': {Wx: 788}, '➁': {Wx: 788}, '➂': {Wx: 788}, '➃': {Wx: 788}, '➄': {Wx: 788}, '➅': {Wx: 788}, '➆': {Wx: 788}, '➇': {Wx: 788}, '➈': {Wx: 788}, '➉': {Wx: 788}, '➊': {Wx: 788}, '➋': {Wx: 788}, '➌': {Wx: 788}, '➍': {Wx: 788}, '➎': {Wx: 788}, '➏': {Wx: 788}, '➐': {Wx: 788}, '➑': {Wx: 788}, '➒': {Wx: 788}, '➓': {Wx: 788}, '➔': {Wx: 894}, '➘': {Wx: 748}, '➙': {Wx: 924}, '➚': {Wx: 748}, '➛': {Wx: 918}, '➜': {Wx: 927}, '➝': {Wx: 928}, '➞': {Wx: 928}, '➟': {Wx: 834}, '➠': {Wx: 873}, '➡': {Wx: 828}, '➢': {Wx: 924}, '➣': {Wx: 924}, '➤': {Wx: 917}, '➥': {Wx: 930}, '➦': {Wx: 931}, '➧': {Wx: 463}, '➨': {Wx: 883}, '➩': {Wx: 836}, '➪': {Wx: 836}, '➫': {Wx: 867}, '➬': {Wx: 867}, '➭': {Wx: 696}, '➮': {Wx: 696}, '➯': {Wx: 874}, '➱': {Wx: 874}, '➲': {Wx: 760}, '➳': {Wx: 946}, '➴': {Wx: 771}, '➵': {Wx: 865}, '➶': {Wx: 771}, '➷': {Wx: 888}, '➸': {Wx: 967}, '➹': {Wx: 888}, '➺': {Wx: 831}, '➻': {Wx: 873}, '➼': {Wx: 927}, '➽': {Wx: 970}, '➾': {Wx: 918}, '\uf8d7': {Wx: 390}, '\uf8d8': {Wx: 390}, '\uf8d9': {Wx: 317}, '\uf8da': {Wx: 317}, '\uf8db': {Wx: 276}, '\uf8dc': {Wx: 276}, '\uf8dd': {Wx: 509}, '\uf8de': {Wx: 509}, '\uf8df': {Wx: 410}, '\uf8e0': {Wx: 410}, '\uf8e1': {Wx: 234}, '\uf8e2': {Wx: 234}, '\uf8e3': {Wx: 334}, '\uf8e4': {Wx: 334}}}

func (_gba *ttfParser) Seek(tag string) error {
	_bcacc, _ddbd := _gba._ggad[tag]
	if !_ddbd {
		return _g.Errorf("\u0074\u0061\u0062\u006ce \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u003a\u0020\u0025\u0073", tag)
	}
	_gba._edg.Seek(int64(_bcacc), _d.SeekStart)
	return nil
}

func (_egd StdFont) Name() string { return string(_egd._ddb.Name) }

type CharMetrics struct {
	Wx float64
	Wy float64
}

func _df() StdFont {
	_beaa.Do(_cabaa)
	_bca := Descriptor{Name: HelveticaObliqueName, Family: string(HelveticaName), Weight: FontWeightMedium, Flags: 0x0060, BBox: [4]float64{-170, -225, 1116, 931}, ItalicAngle: -12, Ascent: 718, Descent: -207, CapHeight: 718, XHeight: 523, StemV: 88, StemH: 76}
	return NewStdFont(_bca, _aeg)
}

func _edf() StdFont {
	_cgd.Do(_daba)
	_gag := Descriptor{Name: TimesBoldName, Family: _fcb, Weight: FontWeightBold, Flags: 0x0020, BBox: [4]float64{-168, -218, 1000, 935}, ItalicAngle: 0, Ascent: 683, Descent: -217, CapHeight: 676, XHeight: 461, StemV: 139, StemH: 44}
	return NewStdFont(_gag, _egdb)
}

func (_da *RuneCharSafeMap) Length() int {
	_da._fb.RLock()
	defer _da._fb.RUnlock()
	return len(_da._bb)
}

type StdFont struct {
	_ddb Descriptor
	_aga *RuneCharSafeMap
	_fcg _cc.TextEncoder
}

const (
	SymbolName       = StdFontName("\u0053\u0079\u006d\u0062\u006f\u006c")
	ZapfDingbatsName = StdFontName("\u005a\u0061\u0070f\u0044\u0069\u006e\u0067\u0062\u0061\u0074\u0073")
)

func _daba() {
	_ffgc = MakeRuneCharSafeMap(len(_fab))
	_egdb = MakeRuneCharSafeMap(len(_fab))
	_cag = MakeRuneCharSafeMap(len(_fab))
	_eecg = MakeRuneCharSafeMap(len(_fab))
	for _gcg, _ffg := range _fab {
		_ffgc.Write(_ffg, CharMetrics{Wx: float64(_cafed[_gcg])})
		_egdb.Write(_ffg, CharMetrics{Wx: float64(_dag[_gcg])})
		_cag.Write(_ffg, CharMetrics{Wx: float64(_abg[_gcg])})
		_eecg.Write(_ffg, CharMetrics{Wx: float64(_fca[_gcg])})
	}
}

func init() {
	RegisterStdFont(CourierName, _ba, "\u0043\u006f\u0075\u0072\u0069\u0065\u0072\u0043\u006f\u0075\u0072\u0069e\u0072\u004e\u0065\u0077", "\u0043\u006f\u0075\u0072\u0069\u0065\u0072\u004e\u0065\u0077")
	RegisterStdFont(CourierBoldName, _bff, "\u0043o\u0075r\u0069\u0065\u0072\u004e\u0065\u0077\u002c\u0042\u006f\u006c\u0064")
	RegisterStdFont(CourierObliqueName, _cf, "\u0043\u006f\u0075\u0072\u0069\u0065\u0072\u004e\u0065\u0077\u002c\u0049t\u0061\u006c\u0069\u0063")
	RegisterStdFont(CourierBoldObliqueName, _bg, "C\u006f\u0075\u0072\u0069er\u004ee\u0077\u002c\u0042\u006f\u006cd\u0049\u0074\u0061\u006c\u0069\u0063")
}

func _eb() StdFont {
	_beaa.Do(_cabaa)
	_beg := Descriptor{Name: HelveticaName, Family: string(HelveticaName), Weight: FontWeightMedium, Flags: 0x0020, BBox: [4]float64{-166, -225, 1000, 931}, ItalicAngle: 0, Ascent: 718, Descent: -207, CapHeight: 718, XHeight: 523, StemV: 88, StemH: 76}
	return NewStdFont(_beg, _bgd)
}

func (_eecd *ttfParser) ParsePost() error {
	if _aggg := _eecd.Seek("\u0070\u006f\u0073\u0074"); _aggg != nil {
		return _aggg
	}
	_fdedg := _eecd.Read32Fixed()
	_eecd._cgg.ItalicAngle = _eecd.Read32Fixed()
	_eecd._cgg.UnderlinePosition = _eecd.ReadShort()
	_eecd._cgg.UnderlineThickness = _eecd.ReadShort()
	_eecd._cgg.IsFixedPitch = _eecd.ReadULong() != 0
	_eecd.ReadULong()
	_eecd.ReadULong()
	_eecd.ReadULong()
	_eecd.ReadULong()
	_aba.Log.Trace("\u0050a\u0072\u0073\u0065\u0050\u006f\u0073\u0074\u003a\u0020\u0066\u006fr\u006d\u0061\u0074\u0054\u0079\u0070\u0065\u003d\u0025\u0066", _fdedg)
	switch _fdedg {
	case 1.0:
		_eecd._cgg.GlyphNames = _ffa
	case 2.0:
		_ecef := int(_eecd.ReadUShort())
		_gfc := make([]int, _ecef)
		_eecd._cgg.GlyphNames = make([]GlyphName, _ecef)
		_acc := -1
		for _bba := 0; _bba < _ecef; _bba++ {
			_fafd := int(_eecd.ReadUShort())
			_gfc[_bba] = _fafd
			if _fafd <= 0x7fff && _fafd > _acc {
				_acc = _fafd
			}
		}
		var _gedec []GlyphName
		if _acc >= len(_ffa) {
			_gedec = make([]GlyphName, _acc-len(_ffa)+1)
			for _fgfa := 0; _fgfa < _acc-len(_ffa)+1; _fgfa++ {
				_deb := int(_eecd.readByte())
				_bfgg, _ccbd := _eecd.ReadStr(_deb)
				if _ccbd != nil {
					return _ccbd
				}
				_gedec[_fgfa] = GlyphName(_bfgg)
			}
		}
		for _dga := 0; _dga < _ecef; _dga++ {
			_fag := _gfc[_dga]
			if _fag < len(_ffa) {
				_eecd._cgg.GlyphNames[_dga] = _ffa[_fag]
			} else if _fag >= len(_ffa) && _fag <= 32767 {
				_eecd._cgg.GlyphNames[_dga] = _gedec[_fag-len(_ffa)]
			} else {
				_eecd._cgg.GlyphNames[_dga] = "\u002e\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064"
			}
		}
	case 2.5:
		_dcdg := make([]int, _eecd._aab)
		for _eafb := 0; _eafb < len(_dcdg); _eafb++ {
			_gda := int(_eecd.ReadSByte())
			_dcdg[_eafb] = _eafb + 1 + _gda
		}
		_eecd._cgg.GlyphNames = make([]GlyphName, len(_dcdg))
		for _fac := 0; _fac < len(_eecd._cgg.GlyphNames); _fac++ {
			_cgdf := _ffa[_dcdg[_fac]]
			_eecd._cgg.GlyphNames[_fac] = _cgdf
		}
	case 3.0:
		_aba.Log.Debug("\u004e\u006f\u0020\u0050\u006f\u0073t\u0053\u0063\u0072i\u0070\u0074\u0020n\u0061\u006d\u0065\u0020\u0069\u006e\u0066\u006f\u0072\u006da\u0074\u0069\u006f\u006e\u0020is\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020\u0066\u006f\u006e\u0074\u002e")
	default:
		_aba.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020f\u006fr\u006d\u0061\u0074\u0054\u0079\u0070\u0065=\u0025\u0066", _fdedg)
	}
	return nil
}

var _ccee *RuneCharSafeMap

type GlyphName = _cc.GlyphName

var _ffa = []GlyphName{"\u002en\u006f\u0074\u0064\u0065\u0066", "\u002e\u006e\u0075l\u006c", "\u006e\u006fn\u006d\u0061\u0072k\u0069\u006e\u0067\u0072\u0065\u0074\u0075\u0072\u006e", "\u0073\u0070\u0061c\u0065", "\u0065\u0078\u0063\u006c\u0061\u006d", "\u0071\u0075\u006f\u0074\u0065\u0064\u0062\u006c", "\u006e\u0075\u006d\u0062\u0065\u0072\u0073\u0069\u0067\u006e", "\u0064\u006f\u006c\u006c\u0061\u0072", "\u0070e\u0072\u0063\u0065\u006e\u0074", "\u0061m\u0070\u0065\u0072\u0073\u0061\u006ed", "q\u0075\u006f\u0074\u0065\u0073\u0069\u006e\u0067\u006c\u0065", "\u0070a\u0072\u0065\u006e\u006c\u0065\u0066t", "\u0070\u0061\u0072\u0065\u006e\u0072\u0069\u0067\u0068\u0074", "\u0061\u0073\u0074\u0065\u0072\u0069\u0073\u006b", "\u0070\u006c\u0075\u0073", "\u0063\u006f\u006dm\u0061", "\u0068\u0079\u0070\u0068\u0065\u006e", "\u0070\u0065\u0072\u0069\u006f\u0064", "\u0073\u006c\u0061s\u0068", "\u007a\u0065\u0072\u006f", "\u006f\u006e\u0065", "\u0074\u0077\u006f", "\u0074\u0068\u0072e\u0065", "\u0066\u006f\u0075\u0072", "\u0066\u0069\u0076\u0065", "\u0073\u0069\u0078", "\u0073\u0065\u0076e\u006e", "\u0065\u0069\u0067h\u0074", "\u006e\u0069\u006e\u0065", "\u0063\u006f\u006co\u006e", "\u0073e\u006d\u0069\u0063\u006f\u006c\u006fn", "\u006c\u0065\u0073\u0073", "\u0065\u0071\u0075a\u006c", "\u0067r\u0065\u0061\u0074\u0065\u0072", "\u0071\u0075\u0065\u0073\u0074\u0069\u006f\u006e", "\u0061\u0074", "\u0041", "\u0042", "\u0043", "\u0044", "\u0045", "\u0046", "\u0047", "\u0048", "\u0049", "\u004a", "\u004b", "\u004c", "\u004d", "\u004e", "\u004f", "\u0050", "\u0051", "\u0052", "\u0053", "\u0054", "\u0055", "\u0056", "\u0057", "\u0058", "\u0059", "\u005a", "b\u0072\u0061\u0063\u006b\u0065\u0074\u006c\u0065\u0066\u0074", "\u0062a\u0063\u006b\u0073\u006c\u0061\u0073h", "\u0062\u0072\u0061c\u006b\u0065\u0074\u0072\u0069\u0067\u0068\u0074", "a\u0073\u0063\u0069\u0069\u0063\u0069\u0072\u0063\u0075\u006d", "\u0075\u006e\u0064\u0065\u0072\u0073\u0063\u006f\u0072\u0065", "\u0067\u0072\u0061v\u0065", "\u0061", "\u0062", "\u0063", "\u0064", "\u0065", "\u0066", "\u0067", "\u0068", "\u0069", "\u006a", "\u006b", "\u006c", "\u006d", "\u006e", "\u006f", "\u0070", "\u0071", "\u0072", "\u0073", "\u0074", "\u0075", "\u0076", "\u0077", "\u0078", "\u0079", "\u007a", "\u0062r\u0061\u0063\u0065\u006c\u0065\u0066t", "\u0062\u0061\u0072", "\u0062\u0072\u0061\u0063\u0065\u0072\u0069\u0067\u0068\u0074", "\u0061\u0073\u0063\u0069\u0069\u0074\u0069\u006c\u0064\u0065", "\u0041d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0041\u0072\u0069n\u0067", "\u0043\u0063\u0065\u0064\u0069\u006c\u006c\u0061", "\u0045\u0061\u0063\u0075\u0074\u0065", "\u004e\u0074\u0069\u006c\u0064\u0065", "\u004fd\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0055d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0061\u0061\u0063\u0075\u0074\u0065", "\u0061\u0067\u0072\u0061\u0076\u0065", "a\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0061d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0061\u0074\u0069\u006c\u0064\u0065", "\u0061\u0072\u0069n\u0067", "\u0063\u0063\u0065\u0064\u0069\u006c\u006c\u0061", "\u0065\u0061\u0063\u0075\u0074\u0065", "\u0065\u0067\u0072\u0061\u0076\u0065", "e\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0065d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0069\u0061\u0063\u0075\u0074\u0065", "\u0069\u0067\u0072\u0061\u0076\u0065", "i\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0069d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u006e\u0074\u0069\u006c\u0064\u0065", "\u006f\u0061\u0063\u0075\u0074\u0065", "\u006f\u0067\u0072\u0061\u0076\u0065", "o\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u006fd\u0069\u0065\u0072\u0065\u0073\u0069s", "\u006f\u0074\u0069\u006c\u0064\u0065", "\u0075\u0061\u0063\u0075\u0074\u0065", "\u0075\u0067\u0072\u0061\u0076\u0065", "u\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0075d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0064\u0061\u0067\u0067\u0065\u0072", "\u0064\u0065\u0067\u0072\u0065\u0065", "\u0063\u0065\u006e\u0074", "\u0073\u0074\u0065\u0072\u006c\u0069\u006e\u0067", "\u0073e\u0063\u0074\u0069\u006f\u006e", "\u0062\u0075\u006c\u006c\u0065\u0074", "\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h", "\u0067\u0065\u0072\u006d\u0061\u006e\u0064\u0062\u006c\u0073", "\u0072\u0065\u0067\u0069\u0073\u0074\u0065\u0072\u0065\u0064", "\u0063o\u0070\u0079\u0072\u0069\u0067\u0068t", "\u0074r\u0061\u0064\u0065\u006d\u0061\u0072k", "\u0061\u0063\u0075t\u0065", "\u0064\u0069\u0065\u0072\u0065\u0073\u0069\u0073", "\u006e\u006f\u0074\u0065\u0071\u0075\u0061\u006c", "\u0041\u0045", "\u004f\u0073\u006c\u0061\u0073\u0068", "\u0069\u006e\u0066\u0069\u006e\u0069\u0074\u0079", "\u0070l\u0075\u0073\u006d\u0069\u006e\u0075s", "\u006ce\u0073\u0073\u0065\u0071\u0075\u0061l", "\u0067\u0072\u0065a\u0074\u0065\u0072\u0065\u0071\u0075\u0061\u006c", "\u0079\u0065\u006e", "\u006d\u0075", "p\u0061\u0072\u0074\u0069\u0061\u006c\u0064\u0069\u0066\u0066", "\u0073u\u006d\u006d\u0061\u0074\u0069\u006fn", "\u0070r\u006f\u0064\u0075\u0063\u0074", "\u0070\u0069", "\u0069\u006e\u0074\u0065\u0067\u0072\u0061\u006c", "o\u0072\u0064\u0066\u0065\u006d\u0069\u006e\u0069\u006e\u0065", "\u006f\u0072\u0064m\u0061\u0073\u0063\u0075\u006c\u0069\u006e\u0065", "\u004f\u006d\u0065g\u0061", "\u0061\u0065", "\u006f\u0073\u006c\u0061\u0073\u0068", "\u0071\u0075\u0065s\u0074\u0069\u006f\u006e\u0064\u006f\u0077\u006e", "\u0065\u0078\u0063\u006c\u0061\u006d\u0064\u006f\u0077\u006e", "\u006c\u006f\u0067\u0069\u0063\u0061\u006c\u006e\u006f\u0074", "\u0072a\u0064\u0069\u0063\u0061\u006c", "\u0066\u006c\u006f\u0072\u0069\u006e", "a\u0070\u0070\u0072\u006f\u0078\u0065\u0071\u0075\u0061\u006c", "\u0044\u0065\u006ct\u0061", "\u0067\u0075\u0069\u006c\u006c\u0065\u006d\u006f\u0074\u006c\u0065\u0066\u0074", "\u0067\u0075\u0069\u006c\u006c\u0065\u006d\u006f\u0074r\u0069\u0067\u0068\u0074", "\u0065\u006c\u006c\u0069\u0070\u0073\u0069\u0073", "\u006e\u006fn\u0062\u0072\u0065a\u006b\u0069\u006e\u0067\u0073\u0070\u0061\u0063\u0065", "\u0041\u0067\u0072\u0061\u0076\u0065", "\u0041\u0074\u0069\u006c\u0064\u0065", "\u004f\u0074\u0069\u006c\u0064\u0065", "\u004f\u0045", "\u006f\u0065", "\u0065\u006e\u0064\u0061\u0073\u0068", "\u0065\u006d\u0064\u0061\u0073\u0068", "\u0071\u0075\u006ft\u0065\u0064\u0062\u006c\u006c\u0065\u0066\u0074", "\u0071\u0075\u006f\u0074\u0065\u0064\u0062\u006c\u0072\u0069\u0067\u0068\u0074", "\u0071u\u006f\u0074\u0065\u006c\u0065\u0066t", "\u0071\u0075\u006f\u0074\u0065\u0072\u0069\u0067\u0068\u0074", "\u0064\u0069\u0076\u0069\u0064\u0065", "\u006co\u007a\u0065\u006e\u0067\u0065", "\u0079d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0059d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e", "\u0063\u0075\u0072\u0072\u0065\u006e\u0063\u0079", "\u0067\u0075\u0069\u006c\u0073\u0069\u006e\u0067\u006c\u006c\u0065\u0066\u0074", "\u0067\u0075\u0069\u006c\u0073\u0069\u006e\u0067\u006cr\u0069\u0067\u0068\u0074", "\u0066\u0069", "\u0066\u006c", "\u0064a\u0067\u0067\u0065\u0072\u0064\u0062l", "\u0070\u0065\u0072\u0069\u006f\u0064\u0063\u0065\u006et\u0065\u0072\u0065\u0064", "\u0071\u0075\u006f\u0074\u0065\u0073\u0069\u006e\u0067l\u0062\u0061\u0073\u0065", "\u0071\u0075\u006ft\u0065\u0064\u0062\u006c\u0062\u0061\u0073\u0065", "p\u0065\u0072\u0074\u0068\u006f\u0075\u0073\u0061\u006e\u0064", "A\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "E\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0041\u0061\u0063\u0075\u0074\u0065", "\u0045d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0045\u0067\u0072\u0061\u0076\u0065", "\u0049\u0061\u0063\u0075\u0074\u0065", "I\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0049d\u0069\u0065\u0072\u0065\u0073\u0069s", "\u0049\u0067\u0072\u0061\u0076\u0065", "\u004f\u0061\u0063\u0075\u0074\u0065", "O\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0061\u0070\u0070l\u0065", "\u004f\u0067\u0072\u0061\u0076\u0065", "\u0055\u0061\u0063\u0075\u0074\u0065", "U\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0055\u0067\u0072\u0061\u0076\u0065", "\u0064\u006f\u0074\u006c\u0065\u0073\u0073\u0069", "\u0063\u0069\u0072\u0063\u0075\u006d\u0066\u006c\u0065\u0078", "\u0074\u0069\u006cd\u0065", "\u006d\u0061\u0063\u0072\u006f\u006e", "\u0062\u0072\u0065v\u0065", "\u0064o\u0074\u0061\u0063\u0063\u0065\u006et", "\u0072\u0069\u006e\u0067", "\u0063e\u0064\u0069\u006c\u006c\u0061", "\u0068\u0075\u006eg\u0061\u0072\u0075\u006d\u006c\u0061\u0075\u0074", "\u006f\u0067\u006f\u006e\u0065\u006b", "\u0063\u0061\u0072o\u006e", "\u004c\u0073\u006c\u0061\u0073\u0068", "\u006c\u0073\u006c\u0061\u0073\u0068", "\u0053\u0063\u0061\u0072\u006f\u006e", "\u0073\u0063\u0061\u0072\u006f\u006e", "\u005a\u0063\u0061\u0072\u006f\u006e", "\u007a\u0063\u0061\u0072\u006f\u006e", "\u0062r\u006f\u006b\u0065\u006e\u0062\u0061r", "\u0045\u0074\u0068", "\u0065\u0074\u0068", "\u0059\u0061\u0063\u0075\u0074\u0065", "\u0079\u0061\u0063\u0075\u0074\u0065", "\u0054\u0068\u006fr\u006e", "\u0074\u0068\u006fr\u006e", "\u006d\u0069\u006eu\u0073", "\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0079", "o\u006e\u0065\u0073\u0075\u0070\u0065\u0072\u0069\u006f\u0072", "t\u0077\u006f\u0073\u0075\u0070\u0065\u0072\u0069\u006f\u0072", "\u0074\u0068\u0072\u0065\u0065\u0073\u0075\u0070\u0065\u0072\u0069\u006f\u0072", "\u006fn\u0065\u0068\u0061\u006c\u0066", "\u006f\u006e\u0065\u0071\u0075\u0061\u0072\u0074\u0065\u0072", "\u0074\u0068\u0072\u0065\u0065\u0071\u0075\u0061\u0072\u0074\u0065\u0072\u0073", "\u0066\u0072\u0061n\u0063", "\u0047\u0062\u0072\u0065\u0076\u0065", "\u0067\u0062\u0072\u0065\u0076\u0065", "\u0049\u0064\u006f\u0074\u0061\u0063\u0063\u0065\u006e\u0074", "\u0053\u0063\u0065\u0064\u0069\u006c\u006c\u0061", "\u0073\u0063\u0065\u0064\u0069\u006c\u006c\u0061", "\u0043\u0061\u0063\u0075\u0074\u0065", "\u0063\u0061\u0063\u0075\u0074\u0065", "\u0043\u0063\u0061\u0072\u006f\u006e", "\u0063\u0063\u0061\u0072\u006f\u006e", "\u0064\u0063\u0072\u006f\u0061\u0074"}

type ttfParser struct {
	_cgg  TtfType
	_edg  _d.ReadSeeker
	_ggad map[string]uint32
	_aea  uint16
	_aab  uint16
}

func IsStdFont(name StdFontName) bool { _, _dg := _de.read(name); return _dg }

func (_agd *ttfParser) ParseOS2() error {
	if _bcac := _agd.Seek("\u004f\u0053\u002f\u0032"); _bcac != nil {
		return _bcac
	}
	_bgad := _agd.ReadUShort()
	_agd.Skip(4 * 2)
	_agd.Skip(11*2 + 10 + 4*4 + 4)
	_gdfb := _agd.ReadUShort()
	_agd._cgg.Bold = (_gdfb & 32) != 0
	_agd.Skip(2 * 2)
	_agd._cgg.TypoAscender = _agd.ReadShort()
	_agd._cgg.TypoDescender = _agd.ReadShort()
	if _bgad >= 2 {
		_agd.Skip(3*2 + 2*4 + 2)
		_agd._cgg.CapHeight = _agd.ReadShort()
	} else {
		_agd._cgg.CapHeight = 0
	}
	return nil
}

func (_gede *TtfType) MakeEncoder() (_cc.SimpleEncoder, error) {
	_begd := make(map[_cc.CharCode]GlyphName)
	for _dcg := _cc.CharCode(0); _dcg <= 256; _dcg++ {
		_bef := rune(_dcg)
		_cfd, _gbc := _gede.Chars[_bef]
		if !_gbc {
			continue
		}
		var _eff GlyphName
		if int(_cfd) >= 0 && int(_cfd) < len(_gede.GlyphNames) {
			_eff = _gede.GlyphNames[_cfd]
		} else {
			_acaa := rune(_cfd)
			if _gca, _aec := _cc.RuneToGlyph(_acaa); _aec {
				_eff = _gca
			}
		}
		if _eff != "" {
			_begd[_dcg] = _eff
		}
	}
	if len(_begd) == 0 {
		_aba.Log.Debug("WA\u0052\u004eI\u004e\u0047\u003a\u0020\u005a\u0065\u0072\u006f\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u002e\u0020\u0074\u0074\u0066=\u0025s\u0020\u0043\u0068\u0061\u0072\u0073\u003d\u005b%\u00200\u0032\u0078]", _gede, _gede.Chars)
	}
	return _cc.NewCustomSimpleTextEncoder(_begd, nil)
}

type Descriptor struct {
	Name        StdFontName
	Family      string
	Weight      FontWeight
	Flags       uint
	BBox        [4]float64
	ItalicAngle float64
	Ascent      float64
	Descent     float64
	CapHeight   float64
	XHeight     float64
	StemV       float64
	StemH       float64
}

func (_eda *ttfParser) ParseHmtx() error {
	if _gab := _eda.Seek("\u0068\u006d\u0074\u0078"); _gab != nil {
		return _gab
	}
	_eda._cgg.Widths = make([]uint16, 0, 8)
	for _ccb := uint16(0); _ccb < _eda._aea; _ccb++ {
		_eda._cgg.Widths = append(_eda._cgg.Widths, _eda.ReadUShort())
		_eda.Skip(2)
	}
	if _eda._aea < _eda._aab && _eda._aea > 0 {
		_fcaa := _eda._cgg.Widths[_eda._aea-1]
		for _gcf := _eda._aea; _gcf < _eda._aab; _gcf++ {
			_eda._cgg.Widths = append(_eda._cgg.Widths, _fcaa)
		}
	}
	return nil
}

func init() {
	RegisterStdFont(HelveticaName, _eb, "\u0041\u0072\u0069a\u006c")
	RegisterStdFont(HelveticaBoldName, _ffdd, "\u0041\u0072\u0069\u0061\u006c\u002c\u0042\u006f\u006c\u0064")
	RegisterStdFont(HelveticaObliqueName, _df, "\u0041\u0072\u0069a\u006c\u002c\u0049\u0074\u0061\u006c\u0069\u0063")
	RegisterStdFont(HelveticaBoldObliqueName, _cdf, "\u0041\u0072i\u0061\u006c\u002cB\u006f\u006c\u0064\u0049\u0074\u0061\u006c\u0069\u0063")
}

func (_ga *RuneCharSafeMap) Range(f func(_be rune, _geg CharMetrics) (_ag bool)) {
	_ga._fb.RLock()
	defer _ga._fb.RUnlock()
	for _ged, _ddc := range _ga._bb {
		if f(_ged, _ddc) {
			break
		}
	}
}

func (_fde *ttfParser) ParseCmap() error {
	var _fgb int64
	if _dcd := _fde.Seek("\u0063\u006d\u0061\u0070"); _dcd != nil {
		return _dcd
	}
	_fde.ReadUShort()
	_acab := int(_fde.ReadUShort())
	_dcde := int64(0)
	_aag := int64(0)
	_ccbb := int64(0)
	for _deab := 0; _deab < _acab; _deab++ {
		_agg := _fde.ReadUShort()
		_afd := _fde.ReadUShort()
		_fgb = int64(_fde.ReadULong())
		if _agg == 3 && _afd == 1 {
			_aag = _fgb
		} else if _agg == 3 && _afd == 10 {
			_ccbb = _fgb
		} else if _agg == 1 && _afd == 0 {
			_dcde = _fgb
		}
	}
	if _dcde != 0 {
		if _eadc := _fde.parseCmapVersion(_dcde); _eadc != nil {
			return _eadc
		}
	}
	if _aag != 0 {
		if _dff := _fde.parseCmapSubtable31(_aag); _dff != nil {
			return _dff
		}
	}
	if _ccbb != 0 {
		if _aege := _fde.parseCmapVersion(_ccbb); _aege != nil {
			return _aege
		}
	}
	if _aag == 0 && _dcde == 0 && _ccbb == 0 {
		_aba.Log.Debug("\u0074\u0074\u0066P\u0061\u0072\u0073\u0065\u0072\u002e\u0050\u0061\u0072\u0073\u0065\u0043\u006d\u0061\u0070\u002e\u0020\u004e\u006f\u0020\u0033\u0031\u002c\u0020\u0031\u0030\u002c\u0020\u00331\u0030\u0020\u0074\u0061\u0062\u006c\u0065\u002e")
	}
	return nil
}

const (
	_fcb                = "\u0054\u0069\u006de\u0073"
	TimesRomanName      = StdFontName("T\u0069\u006d\u0065\u0073\u002d\u0052\u006f\u006d\u0061\u006e")
	TimesBoldName       = StdFontName("\u0054\u0069\u006d\u0065\u0073\u002d\u0042\u006f\u006c\u0064")
	TimesItalicName     = StdFontName("\u0054\u0069\u006de\u0073\u002d\u0049\u0074\u0061\u006c\u0069\u0063")
	TimesBoldItalicName = StdFontName("\u0054\u0069m\u0065\u0073\u002dB\u006f\u006c\u0064\u0049\u0074\u0061\u006c\u0069\u0063")
)

func (_bbf *RuneCharSafeMap) Write(b rune, r CharMetrics) {
	_bbf._fb.Lock()
	defer _bbf._fb.Unlock()
	_bbf._bb[b] = r
}

type RuneCharSafeMap struct {
	_bb map[rune]CharMetrics
	_fb _fa.RWMutex
}

func (_gcfc *ttfParser) ParseName() error {
	if _cec := _gcfc.Seek("\u006e\u0061\u006d\u0065"); _cec != nil {
		return _cec
	}
	_cga, _ := _gcfc._edg.Seek(0, _d.SeekCurrent)
	_gcfc._cgg.PostScriptName = ""
	_gcfc.Skip(2)
	_bfef := _gcfc.ReadUShort()
	_agfb := _gcfc.ReadUShort()
	for _gfde := uint16(0); _gfde < _bfef && _gcfc._cgg.PostScriptName == ""; _gfde++ {
		_gcfc.Skip(3 * 2)
		_dba := _gcfc.ReadUShort()
		_ddcf := _gcfc.ReadUShort()
		_edfc := _gcfc.ReadUShort()
		if _dba == 6 {
			_gcfc._edg.Seek(_cga+int64(_agfb)+int64(_edfc), _d.SeekStart)
			_fee, _edcc := _gcfc.ReadStr(int(_ddcf))
			if _edcc != nil {
				return _edcc
			}
			_fee = _a.Replace(_fee, "\u0000", "", -1)
			_ad, _edcc := _ff.Compile("\u005b\u0028\u0029\u007b\u007d\u003c\u003e\u0020\u002f%\u005b\u005c\u005d\u005d")
			if _edcc != nil {
				return _edcc
			}
			_gcfc._cgg.PostScriptName = _ad.ReplaceAllString(_fee, "")
		}
	}
	if _gcfc._cgg.PostScriptName == "" {
		_aba.Log.Debug("\u0050a\u0072\u0073e\u004e\u0061\u006de\u003a\u0020\u0054\u0068\u0065\u0020\u006ea\u006d\u0065\u0020\u0050\u006f\u0073t\u0053\u0063\u0072\u0069\u0070\u0074\u0020\u0077\u0061\u0073\u0020n\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e")
	}
	return nil
}

func (_fff *ttfParser) parseCmapFormat6() error {
	_bfgc := int(_fff.ReadUShort())
	_fadg := int(_fff.ReadUShort())
	_aba.Log.Trace("p\u0061\u0072\u0073\u0065\u0043\u006d\u0061\u0070\u0046o\u0072\u006d\u0061\u0074\u0036\u003a\u0020%s\u0020\u0066\u0069\u0072s\u0074\u0043\u006f\u0064\u0065\u003d\u0025\u0064\u0020en\u0074\u0072y\u0043\u006f\u0075\u006e\u0074\u003d\u0025\u0064", _fff._cgg.String(), _bfgc, _fadg)
	for _aeeb := 0; _aeeb < _fadg; _aeeb++ {
		_fabc := GID(_fff.ReadUShort())
		_fff._cgg.Chars[rune(_aeeb+_bfgc)] = _fabc
	}
	return nil
}

func (_bde *ttfParser) ReadShort() (_ccfed int16) {
	_ca.Read(_bde._edg, _ca.BigEndian, &_ccfed)
	return _ccfed
}

var _de = &fontMap{_ef: make(map[StdFontName]func() StdFont)}

func (_cce StdFont) GetRuneMetrics(r rune) (CharMetrics, bool) {
	_cb, _gf := _cce._aga.Read(r)
	return _cb, _gf
}

func _ffdd() StdFont {
	_beaa.Do(_cabaa)
	_cg := Descriptor{Name: HelveticaBoldName, Family: string(HelveticaName), Weight: FontWeightBold, Flags: 0x0020, BBox: [4]float64{-170, -228, 1003, 962}, ItalicAngle: 0, Ascent: 718, Descent: -207, CapHeight: 718, XHeight: 532, StemV: 140, StemH: 118}
	return NewStdFont(_cg, _gde)
}

var _cfc = []int16{667, 1000, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 722, 722, 722, 722, 722, 722, 612, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 556, 611, 778, 778, 778, 722, 278, 278, 278, 278, 278, 278, 278, 278, 500, 667, 667, 556, 556, 556, 556, 556, 833, 722, 722, 722, 722, 722, 778, 1000, 778, 778, 778, 778, 778, 778, 778, 778, 667, 778, 722, 722, 722, 722, 667, 667, 667, 667, 667, 611, 611, 611, 667, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 944, 667, 667, 667, 667, 611, 611, 611, 611, 556, 556, 556, 556, 333, 556, 889, 556, 556, 667, 556, 556, 469, 584, 389, 1015, 556, 556, 278, 260, 334, 334, 278, 278, 333, 260, 350, 500, 500, 333, 500, 500, 333, 556, 333, 278, 278, 250, 737, 556, 556, 556, 556, 643, 556, 400, 333, 584, 556, 333, 278, 556, 556, 556, 556, 556, 556, 556, 556, 1000, 556, 1000, 556, 556, 584, 556, 278, 333, 278, 500, 556, 500, 556, 556, 167, 556, 556, 556, 611, 333, 584, 549, 556, 556, 333, 333, 556, 333, 333, 222, 278, 278, 278, 278, 278, 222, 222, 500, 500, 222, 222, 299, 222, 584, 549, 584, 471, 222, 833, 333, 584, 556, 584, 556, 556, 556, 556, 556, 549, 556, 556, 556, 556, 556, 556, 944, 333, 556, 556, 556, 556, 834, 834, 333, 370, 365, 611, 556, 556, 537, 333, 333, 476, 889, 278, 278, 1000, 584, 584, 556, 556, 611, 355, 333, 333, 333, 222, 222, 222, 191, 333, 333, 453, 333, 333, 737, 333, 500, 500, 500, 500, 500, 556, 278, 556, 556, 278, 278, 556, 600, 278, 317, 278, 556, 556, 834, 333, 333, 1000, 556, 333, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 500, 722, 500, 500, 500, 500, 556, 500, 500, 500, 500, 556}

var _fca = []int16{611, 889, 611, 611, 611, 611, 611, 611, 611, 611, 611, 611, 667, 667, 667, 667, 722, 722, 722, 612, 611, 611, 611, 611, 611, 611, 611, 611, 611, 722, 500, 611, 722, 722, 722, 722, 333, 333, 333, 333, 333, 333, 333, 333, 444, 667, 667, 556, 556, 611, 556, 556, 833, 667, 667, 667, 667, 667, 722, 944, 722, 722, 722, 722, 722, 722, 722, 722, 611, 722, 611, 611, 611, 611, 500, 500, 500, 500, 500, 556, 556, 556, 611, 722, 722, 722, 722, 722, 722, 722, 722, 722, 611, 833, 611, 556, 556, 556, 556, 556, 556, 556, 500, 500, 500, 500, 333, 500, 667, 500, 500, 778, 500, 500, 422, 541, 500, 920, 500, 500, 278, 275, 400, 400, 389, 389, 333, 275, 350, 444, 444, 333, 444, 444, 333, 500, 333, 333, 250, 250, 760, 500, 500, 500, 500, 544, 500, 400, 333, 675, 500, 333, 278, 444, 444, 444, 444, 444, 444, 444, 500, 889, 444, 889, 500, 444, 675, 500, 333, 389, 278, 500, 500, 500, 500, 500, 167, 500, 500, 500, 500, 333, 675, 549, 500, 500, 333, 333, 500, 333, 333, 278, 278, 278, 278, 278, 278, 278, 278, 444, 444, 278, 278, 300, 278, 675, 549, 675, 471, 278, 722, 333, 675, 500, 675, 500, 500, 500, 500, 500, 549, 500, 500, 500, 500, 500, 500, 667, 333, 500, 500, 500, 500, 750, 750, 300, 276, 310, 500, 500, 500, 523, 333, 333, 476, 833, 250, 250, 1000, 675, 675, 500, 500, 500, 420, 556, 556, 556, 333, 333, 333, 214, 389, 389, 453, 389, 389, 760, 333, 389, 389, 389, 389, 389, 500, 333, 500, 500, 278, 250, 500, 600, 278, 300, 278, 500, 500, 750, 300, 333, 980, 500, 300, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 444, 667, 444, 444, 444, 444, 500, 389, 389, 389, 389, 500}

func init() {
	RegisterStdFont(SymbolName, _efc, "\u0053\u0079\u006d\u0062\u006f\u006c\u002c\u0049\u0074\u0061\u006c\u0069\u0063", "S\u0079\u006d\u0062\u006f\u006c\u002c\u0042\u006f\u006c\u0064", "\u0053\u0079\u006d\u0062\u006f\u006c\u002c\u0042\u006f\u006c\u0064\u0049t\u0061\u006c\u0069\u0063")
	RegisterStdFont(ZapfDingbatsName, _aee)
}

var _cag *RuneCharSafeMap

func _gga() {
	const _bab = 600
	_ded = MakeRuneCharSafeMap(len(_fab))
	for _, _bbe := range _fab {
		_ded.Write(_bbe, CharMetrics{Wx: _bab})
	}
	_fdb = _ded.Copy()
	_caf = _ded.Copy()
	_ccee = _ded.Copy()
}

func _bae() StdFont {
	_cgd.Do(_daba)
	_abd := Descriptor{Name: TimesItalicName, Family: _fcb, Weight: FontWeightMedium, Flags: 0x0060, BBox: [4]float64{-169, -217, 1010, 883}, ItalicAngle: -15.5, Ascent: 683, Descent: -217, CapHeight: 653, XHeight: 441, StemV: 76, StemH: 32}
	return NewStdFont(_abd, _eecg)
}

func _bg() StdFont {
	_gb.Do(_gga)
	_bgb := Descriptor{Name: CourierBoldObliqueName, Family: string(CourierName), Weight: FontWeightBold, Flags: 0x0061, BBox: [4]float64{-57, -250, 869, 801}, ItalicAngle: -12, Ascent: 629, Descent: -157, CapHeight: 562, XHeight: 439, StemV: 106, StemH: 84}
	return NewStdFont(_bgb, _caf)
}

func (_gddf *ttfParser) ParseComponents() error {
	if _ece := _gddf.ParseHead(); _ece != nil {
		return _ece
	}
	if _bdg := _gddf.ParseHhea(); _bdg != nil {
		return _bdg
	}
	if _fcad := _gddf.ParseMaxp(); _fcad != nil {
		return _fcad
	}
	if _dea := _gddf.ParseHmtx(); _dea != nil {
		return _dea
	}
	if _, _abc := _gddf._ggad["\u006e\u0061\u006d\u0065"]; _abc {
		if _ceea := _gddf.ParseName(); _ceea != nil {
			return _ceea
		}
	}
	if _, _dde := _gddf._ggad["\u004f\u0053\u002f\u0032"]; _dde {
		if _ebbb := _gddf.ParseOS2(); _ebbb != nil {
			return _ebbb
		}
	}
	if _, _ddee := _gddf._ggad["\u0070\u006f\u0073\u0074"]; _ddee {
		if _fegd := _gddf.ParsePost(); _fegd != nil {
			return _fegd
		}
	}
	if _, _ffgg := _gddf._ggad["\u0063\u006d\u0061\u0070"]; _ffgg {
		if _cde := _gddf.ParseCmap(); _cde != nil {
			return _cde
		}
	}
	return nil
}

func init() {
	RegisterStdFont(TimesRomanName, _def, "\u0054\u0069\u006d\u0065\u0073\u004e\u0065\u0077\u0052\u006f\u006d\u0061\u006e", "\u0054\u0069\u006de\u0073")
	RegisterStdFont(TimesBoldName, _edf, "\u0054i\u006de\u0073\u004e\u0065\u0077\u0052o\u006d\u0061n\u002c\u0042\u006f\u006c\u0064", "\u0054\u0069\u006d\u0065\u0073\u002c\u0042\u006f\u006c\u0064")
	RegisterStdFont(TimesItalicName, _bae, "T\u0069m\u0065\u0073\u004e\u0065\u0077\u0052\u006f\u006da\u006e\u002c\u0049\u0074al\u0069\u0063", "\u0054\u0069\u006de\u0073\u002c\u0049\u0074\u0061\u006c\u0069\u0063")
	RegisterStdFont(TimesBoldItalicName, _af, "\u0054i\u006d\u0065\u0073\u004e\u0065\u0077\u0052\u006f\u006d\u0061\u006e,\u0042\u006f\u006c\u0064\u0049\u0074\u0061\u006c\u0069\u0063", "\u0054\u0069m\u0065\u0073\u002cB\u006f\u006c\u0064\u0049\u0074\u0061\u006c\u0069\u0063")
}

func NewStdFont(desc Descriptor, metrics *RuneCharSafeMap) StdFont {
	return NewStdFontWithEncoding(desc, metrics, _cc.NewStandardEncoder())
}

func _def() StdFont {
	_cgd.Do(_daba)
	_ecf := Descriptor{Name: TimesRomanName, Family: _fcb, Weight: FontWeightRoman, Flags: 0x0020, BBox: [4]float64{-168, -218, 1000, 898}, ItalicAngle: 0, Ascent: 683, Descent: -217, CapHeight: 662, XHeight: 450, StemV: 84, StemH: 28}
	return NewStdFont(_ecf, _ffgc)
}

const (
	HelveticaName            = StdFontName("\u0048e\u006c\u0076\u0065\u0074\u0069\u0063a")
	HelveticaBoldName        = StdFontName("\u0048\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0042\u006f\u006c\u0064")
	HelveticaObliqueName     = StdFontName("\u0048\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u004f\u0062l\u0069\u0071\u0075\u0065")
	HelveticaBoldObliqueName = StdFontName("H\u0065\u006c\u0076\u0065ti\u0063a\u002d\u0042\u006f\u006c\u0064O\u0062\u006c\u0069\u0071\u0075\u0065")
)

func _bff() StdFont {
	_gb.Do(_gga)
	_abe := Descriptor{Name: CourierBoldName, Family: string(CourierName), Weight: FontWeightBold, Flags: 0x0021, BBox: [4]float64{-113, -250, 749, 801}, ItalicAngle: 0, Ascent: 629, Descent: -157, CapHeight: 562, XHeight: 439, StemV: 106, StemH: 84}
	return NewStdFont(_abe, _fdb)
}

var _egdb *RuneCharSafeMap

func NewStdFontByName(name StdFontName) (StdFont, bool) {
	_fc, _gd := _de.read(name)
	if !_gd {
		return StdFont{}, false
	}
	return _fc(), true
}

func (_aff *TtfType) NewEncoder() _cc.TextEncoder { return _cc.NewTrueTypeFontEncoder(_aff.Chars) }

func (_gac *ttfParser) ParseHead() error {
	if _dgb := _gac.Seek("\u0068\u0065\u0061\u0064"); _dgb != nil {
		return _dgb
	}
	_gac.Skip(3 * 4)
	_fbe := _gac.ReadULong()
	if _fbe != 0x5F0F3CF5 {
		_aba.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0049\u006e\u0063\u006fr\u0072e\u0063\u0074\u0020\u006d\u0061\u0067\u0069\u0063\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u002e\u0020\u0046\u006fn\u0074\u0020\u006d\u0061\u0079\u0020\u006e\u006f\u0074\u0020\u0064\u0069\u0073\u0070\u006c\u0061\u0079\u0020\u0063\u006f\u0072\u0072\u0065\u0063t\u006c\u0079\u002e\u0020\u0025\u0073", _gac)
	}
	_gac.Skip(2)
	_gac._cgg.UnitsPerEm = _gac.ReadUShort()
	_gac.Skip(2 * 8)
	_gac._cgg.Xmin = _gac.ReadShort()
	_gac._cgg.Ymin = _gac.ReadShort()
	_gac._cgg.Xmax = _gac.ReadShort()
	_gac._cgg.Ymax = _gac.ReadShort()
	return nil
}

func _af() StdFont {
	_cgd.Do(_daba)
	_acg := Descriptor{Name: TimesBoldItalicName, Family: _fcb, Weight: FontWeightBold, Flags: 0x0060, BBox: [4]float64{-200, -218, 996, 921}, ItalicAngle: -15, Ascent: 683, Descent: -217, CapHeight: 669, XHeight: 462, StemV: 121, StemH: 42}
	return NewStdFont(_acg, _cag)
}

func (_cab *RuneCharSafeMap) Copy() *RuneCharSafeMap {
	_dd := MakeRuneCharSafeMap(_cab.Length())
	_cab.Range(func(_dc rune, _ccf CharMetrics) (_eeb bool) { _dd._bb[_dc] = _ccf; return false })
	return _dd
}

func (_dce *ttfParser) parseTTC() (TtfType, error) {
	_dce.Skip(2 * 2)
	_fed := _dce.ReadULong()
	if _fed < 1 {
		return TtfType{}, _fg.New("N\u006f \u0066\u006f\u006e\u0074\u0073\u0020\u0069\u006e \u0054\u0054\u0043\u0020fi\u006c\u0065")
	}
	_ebb := _dce.ReadULong()
	_, _gdf := _dce._edg.Seek(int64(_ebb), _d.SeekStart)
	if _gdf != nil {
		return TtfType{}, _gdf
	}
	return _dce.Parse()
}

type GID = _cc.GID

var _fdb *RuneCharSafeMap

func _efc() StdFont {
	_bad := _cc.NewSymbolEncoder()
	_ffc := Descriptor{Name: SymbolName, Family: string(SymbolName), Weight: FontWeightMedium, Flags: 0x0004, BBox: [4]float64{-180, -293, 1090, 1010}, ItalicAngle: 0, Ascent: 0, Descent: 0, CapHeight: 0, XHeight: 0, StemV: 85, StemH: 92}
	return NewStdFontWithEncoding(_ffc, _dgd, _bad)
}

var _aeg *RuneCharSafeMap

func (_caba StdFont) Descriptor() Descriptor { return _caba._ddb }

var _dgd = &RuneCharSafeMap{_bb: map[rune]CharMetrics{' ': {Wx: 250}, '!': {Wx: 333}, '#': {Wx: 500}, '%': {Wx: 833}, '&': {Wx: 778}, '(': {Wx: 333}, ')': {Wx: 333}, '+': {Wx: 549}, ',': {Wx: 250}, '.': {Wx: 250}, '/': {Wx: 278}, '0': {Wx: 500}, '1': {Wx: 500}, '2': {Wx: 500}, '3': {Wx: 500}, '4': {Wx: 500}, '5': {Wx: 500}, '6': {Wx: 500}, '7': {Wx: 500}, '8': {Wx: 500}, '9': {Wx: 500}, ':': {Wx: 278}, ';': {Wx: 278}, '<': {Wx: 549}, '=': {Wx: 549}, '>': {Wx: 549}, '?': {Wx: 444}, '[': {Wx: 333}, ']': {Wx: 333}, '_': {Wx: 500}, '{': {Wx: 480}, '|': {Wx: 200}, '}': {Wx: 480}, '¬': {Wx: 713}, '°': {Wx: 400}, '±': {Wx: 549}, 'µ': {Wx: 576}, '×': {Wx: 549}, '÷': {Wx: 549}, 'ƒ': {Wx: 500}, 'Α': {Wx: 722}, 'Β': {Wx: 667}, 'Γ': {Wx: 603}, 'Ε': {Wx: 611}, 'Ζ': {Wx: 611}, 'Η': {Wx: 722}, 'Θ': {Wx: 741}, 'Ι': {Wx: 333}, 'Κ': {Wx: 722}, 'Λ': {Wx: 686}, 'Μ': {Wx: 889}, 'Ν': {Wx: 722}, 'Ξ': {Wx: 645}, 'Ο': {Wx: 722}, 'Π': {Wx: 768}, 'Ρ': {Wx: 556}, 'Σ': {Wx: 592}, 'Τ': {Wx: 611}, 'Υ': {Wx: 690}, 'Φ': {Wx: 763}, 'Χ': {Wx: 722}, 'Ψ': {Wx: 795}, 'α': {Wx: 631}, 'β': {Wx: 549}, 'γ': {Wx: 411}, 'δ': {Wx: 494}, 'ε': {Wx: 439}, 'ζ': {Wx: 494}, 'η': {Wx: 603}, 'θ': {Wx: 521}, 'ι': {Wx: 329}, 'κ': {Wx: 549}, 'λ': {Wx: 549}, 'ν': {Wx: 521}, 'ξ': {Wx: 493}, 'ο': {Wx: 549}, 'π': {Wx: 549}, 'ρ': {Wx: 549}, 'ς': {Wx: 439}, 'σ': {Wx: 603}, 'τ': {Wx: 439}, 'υ': {Wx: 576}, 'φ': {Wx: 521}, 'χ': {Wx: 549}, 'ψ': {Wx: 686}, 'ω': {Wx: 686}, 'ϑ': {Wx: 631}, 'ϒ': {Wx: 620}, 'ϕ': {Wx: 603}, 'ϖ': {Wx: 713}, '•': {Wx: 460}, '…': {Wx: 1000}, '′': {Wx: 247}, '″': {Wx: 411}, '⁄': {Wx: 167}, '€': {Wx: 750}, 'ℑ': {Wx: 686}, '℘': {Wx: 987}, 'ℜ': {Wx: 795}, 'Ω': {Wx: 768}, 'ℵ': {Wx: 823}, '←': {Wx: 987}, '↑': {Wx: 603}, '→': {Wx: 987}, '↓': {Wx: 603}, '↔': {Wx: 1042}, '↵': {Wx: 658}, '⇐': {Wx: 987}, '⇑': {Wx: 603}, '⇒': {Wx: 987}, '⇓': {Wx: 603}, '⇔': {Wx: 1042}, '∀': {Wx: 713}, '∂': {Wx: 494}, '∃': {Wx: 549}, '∅': {Wx: 823}, '∆': {Wx: 612}, '∇': {Wx: 713}, '∈': {Wx: 713}, '∉': {Wx: 713}, '∋': {Wx: 439}, '∏': {Wx: 823}, '∑': {Wx: 713}, '−': {Wx: 549}, '∗': {Wx: 500}, '√': {Wx: 549}, '∝': {Wx: 713}, '∞': {Wx: 713}, '∠': {Wx: 768}, '∧': {Wx: 603}, '∨': {Wx: 603}, '∩': {Wx: 768}, '∪': {Wx: 768}, '∫': {Wx: 274}, '∴': {Wx: 863}, '∼': {Wx: 549}, '≅': {Wx: 549}, '≈': {Wx: 549}, '≠': {Wx: 549}, '≡': {Wx: 549}, '≤': {Wx: 549}, '≥': {Wx: 549}, '⊂': {Wx: 713}, '⊃': {Wx: 713}, '⊄': {Wx: 713}, '⊆': {Wx: 713}, '⊇': {Wx: 713}, '⊕': {Wx: 768}, '⊗': {Wx: 768}, '⊥': {Wx: 658}, '⋅': {Wx: 250}, '⌠': {Wx: 686}, '⌡': {Wx: 686}, '〈': {Wx: 329}, '〉': {Wx: 329}, '◊': {Wx: 494}, '♠': {Wx: 753}, '♣': {Wx: 753}, '♥': {Wx: 753}, '♦': {Wx: 753}, '\uf6d9': {Wx: 790}, '\uf6da': {Wx: 790}, '\uf6db': {Wx: 890}, '\uf8e5': {Wx: 500}, '\uf8e6': {Wx: 603}, '\uf8e7': {Wx: 1000}, '\uf8e8': {Wx: 790}, '\uf8e9': {Wx: 790}, '\uf8ea': {Wx: 786}, '\uf8eb': {Wx: 384}, '\uf8ec': {Wx: 384}, '\uf8ed': {Wx: 384}, '\uf8ee': {Wx: 384}, '\uf8ef': {Wx: 384}, '\uf8f0': {Wx: 384}, '\uf8f1': {Wx: 494}, '\uf8f2': {Wx: 494}, '\uf8f3': {Wx: 494}, '\uf8f4': {Wx: 494}, '\uf8f5': {Wx: 686}, '\uf8f6': {Wx: 384}, '\uf8f7': {Wx: 384}, '\uf8f8': {Wx: 384}, '\uf8f9': {Wx: 384}, '\uf8fa': {Wx: 384}, '\uf8fb': {Wx: 384}, '\uf8fc': {Wx: 494}, '\uf8fd': {Wx: 494}, '\uf8fe': {Wx: 494}, '\uf8ff': {Wx: 790}}}

var _beaa _fa.Once

const (
	CourierName            = StdFontName("\u0043o\u0075\u0072\u0069\u0065\u0072")
	CourierBoldName        = StdFontName("\u0043\u006f\u0075r\u0069\u0065\u0072\u002d\u0042\u006f\u006c\u0064")
	CourierObliqueName     = StdFontName("\u0043o\u0075r\u0069\u0065\u0072\u002d\u004f\u0062\u006c\u0069\u0071\u0075\u0065")
	CourierBoldObliqueName = StdFontName("\u0043\u006f\u0075\u0072ie\u0072\u002d\u0042\u006f\u006c\u0064\u004f\u0062\u006c\u0069\u0071\u0075\u0065")
)

func (_cffa *ttfParser) parseCmapFormat0() error {
	_ddbe, _fbg := _cffa.ReadStr(256)
	if _fbg != nil {
		return _fbg
	}
	_dae := []byte(_ddbe)
	_aba.Log.Trace("\u0070a\u0072\u0073e\u0043\u006d\u0061p\u0046\u006f\u0072\u006d\u0061\u0074\u0030:\u0020\u0025\u0073\u000a\u0064\u0061t\u0061\u0053\u0074\u0072\u003d\u0025\u002b\u0071\u000a\u0064\u0061t\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d", _cffa._cgg.String(), _ddbe, _dae)
	for _dbb, _cbea := range _dae {
		_cffa._cgg.Chars[rune(_dbb)] = GID(_cbea)
	}
	return nil
}

func (_eea *ttfParser) parseCmapFormat12() error {
	_bfa := _eea.ReadULong()
	_aba.Log.Trace("\u0070\u0061\u0072se\u0043\u006d\u0061\u0070\u0046\u006f\u0072\u006d\u0061t\u00312\u003a \u0025s\u0020\u006e\u0075\u006d\u0047\u0072\u006f\u0075\u0070\u0073\u003d\u0025\u0064", _eea._cgg.String(), _bfa)
	for _begf := uint32(0); _begf < _bfa; _begf++ {
		_eaf := _eea.ReadULong()
		_gbb := _eea.ReadULong()
		_edb := _eea.ReadULong()
		if _eaf > 0x0010FFFF || (0xD800 <= _eaf && _eaf <= 0xDFFF) {
			return _fg.New("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u0068\u0061\u0072\u0061c\u0074\u0065\u0072\u0073\u0020\u0063\u006f\u0064\u0065\u0073")
		}
		if _gbb < _eaf || _gbb > 0x0010FFFF || (0xD800 <= _gbb && _gbb <= 0xDFFF) {
			return _fg.New("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u0068\u0061\u0072\u0061c\u0074\u0065\u0072\u0073\u0020\u0063\u006f\u0064\u0065\u0073")
		}
		for _abacb := _eaf; _abacb <= _gbb; _abacb++ {
			if _abacb > 0x10FFFF {
				_aba.Log.Debug("\u0046\u006fr\u006d\u0061\u0074\u0020\u0031\u0032\u0020\u0063\u006d\u0061\u0070\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0073\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0062\u0065\u0079\u006f\u006e\u0064\u0020\u0055\u0043\u0053\u002d\u0034")
			}
			_eea._cgg.Chars[rune(_abacb)] = GID(_edb)
			_edb++
		}
	}
	return nil
}

func (_gcd StdFont) GetMetricsTable() *RuneCharSafeMap { return _gcd._aga }

func _cabaa() {
	_bgd = MakeRuneCharSafeMap(len(_fab))
	_gde = MakeRuneCharSafeMap(len(_fab))
	for _ddg, _gedb := range _fab {
		_bgd.Write(_gedb, CharMetrics{Wx: float64(_cfc[_ddg])})
		_gde.Write(_gedb, CharMetrics{Wx: float64(_dee[_ddg])})
	}
	_aeg = _bgd.Copy()
	_aae = _gde.Copy()
}

func (_edd *ttfParser) ReadULong() (_baed uint32) {
	_ca.Read(_edd._edg, _ca.BigEndian, &_baed)
	return _baed
}

func TtfParseFile(fileStr string) (TtfType, error) {
	_bda, _faf := _c.Open(fileStr)
	if _faf != nil {
		return TtfType{}, _faf
	}
	defer _bda.Close()
	return TtfParse(_bda)
}

var _ffgc *RuneCharSafeMap

var _gb _fa.Once

func (_abb *ttfParser) readByte() (_bed uint8) {
	_ca.Read(_abb._edg, _ca.BigEndian, &_bed)
	return _bed
}

type FontWeight int

func (_ac *fontMap) read(_cdg StdFontName) (func() StdFont, bool) {
	_ac.Lock()
	defer _ac.Unlock()
	_ae, _cdc := _ac._ef[_cdg]
	return _ae, _cdc
}

var _caf *RuneCharSafeMap

func (_ggdc *ttfParser) ParseMaxp() error {
	if _bfeb := _ggdc.Seek("\u006d\u0061\u0078\u0070"); _bfeb != nil {
		return _bfeb
	}
	_ggdc.Skip(4)
	_ggdc._aab = _ggdc.ReadUShort()
	return nil
}

func (_fcf *ttfParser) parseCmapSubtable31(_gedg int64) error {
	_efd := make([]rune, 0, 8)
	_ebaa := make([]rune, 0, 8)
	_eecc := make([]int16, 0, 8)
	_fgf := make([]uint16, 0, 8)
	_fcf._cgg.Chars = make(map[rune]GID)
	_fcf._edg.Seek(int64(_fcf._ggad["\u0063\u006d\u0061\u0070"])+_gedg, _d.SeekStart)
	_fbf := _fcf.ReadUShort()
	if _fbf != 4 {
		_aba.Log.Debug("u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0073\u0075\u0062t\u0061\u0062\u006c\u0065\u0020\u0066\u006fr\u006d\u0061\u0074\u003a\u0020\u0025\u0064\u0020\u0028\u0025w\u0029", _fbf)
		return nil
	}
	_fcf.Skip(2 * 2)
	_babc := int(_fcf.ReadUShort() / 2)
	_fcf.Skip(3 * 2)
	for _gfb := 0; _gfb < _babc; _gfb++ {
		_ebaa = append(_ebaa, rune(_fcf.ReadUShort()))
	}
	_fcf.Skip(2)
	for _fad := 0; _fad < _babc; _fad++ {
		_efd = append(_efd, rune(_fcf.ReadUShort()))
	}
	for _abac := 0; _abac < _babc; _abac++ {
		_eecc = append(_eecc, _fcf.ReadShort())
	}
	_affd, _ := _fcf._edg.Seek(int64(0), _d.SeekCurrent)
	for _edfg := 0; _edfg < _babc; _edfg++ {
		_fgf = append(_fgf, _fcf.ReadUShort())
	}
	for _gfd := 0; _gfd < _babc; _gfd++ {
		_dgc := _efd[_gfd]
		_egb := _ebaa[_gfd]
		_fadd := _eecc[_gfd]
		_bec := _fgf[_gfd]
		if _bec > 0 {
			_fcf._edg.Seek(_affd+2*int64(_gfd)+int64(_bec), _d.SeekStart)
		}
		for _edc := _dgc; _edc <= _egb; _edc++ {
			if _edc == 0xFFFF {
				break
			}
			var _ead int32
			if _bec > 0 {
				_ead = int32(_fcf.ReadUShort())
				if _ead > 0 {
					_ead += int32(_fadd)
				}
			} else {
				_ead = _edc + int32(_fadd)
			}
			if _ead >= 65536 {
				_ead -= 65536
			}
			if _ead > 0 {
				_fcf._cgg.Chars[_edc] = GID(_ead)
			}
		}
	}
	return nil
}

func (_gdae *ttfParser) Read32Fixed() float64 {
	_bfd := float64(_gdae.ReadShort())
	_fce := float64(_gdae.ReadUShort()) / 65536.0
	return _bfd + _fce
}

var _dag = []int16{722, 1000, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 722, 722, 722, 722, 722, 722, 722, 612, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 500, 611, 778, 778, 778, 778, 389, 389, 389, 389, 389, 389, 389, 389, 500, 778, 778, 667, 667, 667, 667, 667, 944, 722, 722, 722, 722, 722, 778, 1000, 778, 778, 778, 778, 778, 778, 778, 778, 611, 778, 722, 722, 722, 722, 556, 556, 556, 556, 556, 667, 667, 667, 611, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 1000, 722, 722, 722, 722, 667, 667, 667, 667, 500, 500, 500, 500, 333, 500, 722, 500, 500, 833, 500, 500, 581, 520, 500, 930, 500, 556, 278, 220, 394, 394, 333, 333, 333, 220, 350, 444, 444, 333, 444, 444, 333, 500, 333, 333, 250, 250, 747, 500, 556, 500, 500, 672, 556, 400, 333, 570, 500, 333, 278, 444, 444, 444, 444, 444, 444, 444, 500, 1000, 444, 1000, 500, 444, 570, 500, 333, 333, 333, 556, 500, 556, 500, 500, 167, 500, 500, 500, 556, 333, 570, 549, 500, 500, 333, 333, 556, 333, 333, 278, 278, 278, 278, 278, 278, 278, 333, 556, 556, 278, 278, 394, 278, 570, 549, 570, 494, 278, 833, 333, 570, 556, 570, 556, 556, 556, 556, 500, 549, 556, 500, 500, 500, 500, 500, 722, 333, 500, 500, 500, 500, 750, 750, 300, 300, 330, 500, 500, 556, 540, 333, 333, 494, 1000, 250, 250, 1000, 570, 570, 556, 500, 500, 555, 500, 500, 500, 333, 333, 333, 278, 444, 444, 549, 444, 444, 747, 333, 389, 389, 389, 389, 389, 500, 333, 500, 500, 278, 250, 500, 600, 333, 416, 333, 556, 500, 750, 300, 333, 1000, 500, 300, 556, 556, 556, 556, 556, 556, 556, 500, 556, 556, 500, 722, 500, 500, 500, 500, 500, 444, 444, 444, 444, 500}

func (_fe *fontMap) write(_gc StdFontName, _bea func() StdFont) {
	_fe.Lock()
	defer _fe.Unlock()
	_fe._ef[_gc] = _bea
}

var _ Font = StdFont{}

func _cdf() StdFont {
	_beaa.Do(_cabaa)
	_aa := Descriptor{Name: HelveticaBoldObliqueName, Family: string(HelveticaName), Weight: FontWeightBold, Flags: 0x0060, BBox: [4]float64{-174, -228, 1114, 962}, ItalicAngle: -12, Ascent: 718, Descent: -207, CapHeight: 718, XHeight: 532, StemV: 140, StemH: 118}
	return NewStdFont(_aa, _aae)
}

var _cafed = []int16{722, 889, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 667, 667, 667, 667, 722, 722, 722, 612, 611, 611, 611, 611, 611, 611, 611, 611, 611, 722, 500, 556, 722, 722, 722, 722, 333, 333, 333, 333, 333, 333, 333, 333, 389, 722, 722, 611, 611, 611, 611, 611, 889, 722, 722, 722, 722, 722, 722, 889, 722, 722, 722, 722, 722, 722, 722, 722, 556, 722, 667, 667, 667, 667, 556, 556, 556, 556, 556, 611, 611, 611, 556, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 944, 722, 722, 722, 722, 611, 611, 611, 611, 444, 444, 444, 444, 333, 444, 667, 444, 444, 778, 444, 444, 469, 541, 500, 921, 444, 500, 278, 200, 480, 480, 333, 333, 333, 200, 350, 444, 444, 333, 444, 444, 333, 500, 333, 278, 250, 250, 760, 500, 500, 500, 500, 588, 500, 400, 333, 564, 500, 333, 278, 444, 444, 444, 444, 444, 444, 444, 500, 1000, 444, 1000, 500, 444, 564, 500, 333, 333, 333, 556, 500, 556, 500, 500, 167, 500, 500, 500, 500, 333, 564, 549, 500, 500, 333, 333, 500, 333, 333, 278, 278, 278, 278, 278, 278, 278, 278, 500, 500, 278, 278, 344, 278, 564, 549, 564, 471, 278, 778, 333, 564, 500, 564, 500, 500, 500, 500, 500, 549, 500, 500, 500, 500, 500, 500, 722, 333, 500, 500, 500, 500, 750, 750, 300, 276, 310, 500, 500, 500, 453, 333, 333, 476, 833, 250, 250, 1000, 564, 564, 500, 444, 444, 408, 444, 444, 444, 333, 333, 333, 180, 333, 333, 453, 333, 333, 760, 333, 389, 389, 389, 389, 389, 500, 278, 500, 500, 278, 250, 500, 600, 278, 326, 278, 500, 500, 750, 300, 333, 980, 500, 300, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 722, 500, 500, 500, 500, 500, 444, 444, 444, 444, 500}

var _eecg *RuneCharSafeMap

func _ba() StdFont {
	_gb.Do(_gga)
	_fdf := Descriptor{Name: CourierName, Family: string(CourierName), Weight: FontWeightMedium, Flags: 0x0021, BBox: [4]float64{-23, -250, 715, 805}, ItalicAngle: 0, Ascent: 629, Descent: -157, CapHeight: 562, XHeight: 426, StemV: 51, StemH: 51}
	return NewStdFont(_fdf, _ded)
}

func (_cfg *TtfType) String() string {
	return _g.Sprintf("\u0046\u004fN\u0054\u005f\u0046\u0049\u004cE\u0032\u007b\u0025\u0023\u0071 \u0055\u006e\u0069\u0074\u0073\u0050\u0065\u0072\u0045\u006d\u003d\u0025\u0064\u0020\u0042\u006f\u006c\u0064\u003d\u0025\u0074\u0020\u0049\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065\u003d\u0025\u0066\u0020"+"\u0043\u0061pH\u0065\u0069\u0067h\u0074\u003d\u0025\u0064 Ch\u0061rs\u003d\u0025\u0064\u0020\u0047\u006c\u0079ph\u004e\u0061\u006d\u0065\u0073\u003d\u0025d\u007d", _cfg.PostScriptName, _cfg.UnitsPerEm, _cfg.Bold, _cfg.ItalicAngle, _cfg.CapHeight, len(_cfg.Chars), len(_cfg.GlyphNames))
}

func (_fec *ttfParser) Skip(n int) { _fec._edg.Seek(int64(n), _d.SeekCurrent) }

func TtfParse(r _d.ReadSeeker) (TtfType, error) {
	_bbea := &ttfParser{_edg: r}
	return _bbea.Parse()
}

var _fab = []rune{'A', 'Æ', 'Á', 'Ă', 'Â', 'Ä', 'À', 'Ā', 'Ą', 'Å', 'Ã', 'B', 'C', 'Ć', 'Č', 'Ç', 'D', 'Ď', 'Đ', '∆', 'E', 'É', 'Ě', 'Ê', 'Ë', 'Ė', 'È', 'Ē', 'Ę', 'Ð', '€', 'F', 'G', 'Ğ', 'Ģ', 'H', 'I', 'Í', 'Î', 'Ï', 'İ', 'Ì', 'Ī', 'Į', 'J', 'K', 'Ķ', 'L', 'Ĺ', 'Ľ', 'Ļ', 'Ł', 'M', 'N', 'Ń', 'Ň', 'Ņ', 'Ñ', 'O', 'Œ', 'Ó', 'Ô', 'Ö', 'Ò', 'Ő', 'Ō', 'Ø', 'Õ', 'P', 'Q', 'R', 'Ŕ', 'Ř', 'Ŗ', 'S', 'Ś', 'Š', 'Ş', 'Ș', 'T', 'Ť', 'Ţ', 'Þ', 'U', 'Ú', 'Û', 'Ü', 'Ù', 'Ű', 'Ū', 'Ų', 'Ů', 'V', 'W', 'X', 'Y', 'Ý', 'Ÿ', 'Z', 'Ź', 'Ž', 'Ż', 'a', 'á', 'ă', 'â', '´', 'ä', 'æ', 'à', 'ā', '&', 'ą', 'å', '^', '~', '*', '@', 'ã', 'b', '\\', '|', '{', '}', '[', ']', '˘', '¦', '•', 'c', 'ć', 'ˇ', 'č', 'ç', '¸', '¢', 'ˆ', ':', ',', '\uf6c3', '©', '¤', 'd', '†', '‡', 'ď', 'đ', '°', '¨', '÷', '$', '˙', 'ı', 'e', 'é', 'ě', 'ê', 'ë', 'ė', 'è', '8', '…', 'ē', '—', '–', 'ę', '=', 'ð', '!', '¡', 'f', 'ﬁ', '5', 'ﬂ', 'ƒ', '4', '⁄', 'g', 'ğ', 'ģ', 'ß', '`', '>', '≥', '«', '»', '‹', '›', 'h', '˝', '-', 'i', 'í', 'î', 'ï', 'ì', 'ī', 'į', 'j', 'k', 'ķ', 'l', 'ĺ', 'ľ', 'ļ', '<', '≤', '¬', '◊', 'ł', 'm', '¯', '−', 'µ', '×', 'n', 'ń', 'ň', 'ņ', '9', '≠', 'ñ', '#', 'o', 'ó', 'ô', 'ö', 'œ', '˛', 'ò', 'ő', 'ō', '1', '½', '¼', '¹', 'ª', 'º', 'ø', 'õ', 'p', '¶', '(', ')', '∂', '%', '.', '·', '‰', '+', '±', 'q', '?', '¿', '"', '„', '“', '”', '‘', '’', '‚', '\'', 'r', 'ŕ', '√', 'ř', 'ŗ', '®', '˚', 's', 'ś', 'š', 'ş', 'ș', '§', ';', '7', '6', '/', ' ', '£', '∑', 't', 'ť', 'ţ', 'þ', '3', '¾', '³', '˜', '™', '2', '²', 'u', 'ú', 'û', 'ü', 'ù', 'ű', 'ū', '_', 'ų', 'ů', 'v', 'w', 'x', 'y', 'ý', 'ÿ', '¥', 'z', 'ź', 'ž', 'ż', '0'}

var _dee = []int16{722, 1000, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 612, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 556, 611, 778, 778, 778, 722, 278, 278, 278, 278, 278, 278, 278, 278, 556, 722, 722, 611, 611, 611, 611, 611, 833, 722, 722, 722, 722, 722, 778, 1000, 778, 778, 778, 778, 778, 778, 778, 778, 667, 778, 722, 722, 722, 722, 667, 667, 667, 667, 667, 611, 611, 611, 667, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 944, 667, 667, 667, 667, 611, 611, 611, 611, 556, 556, 556, 556, 333, 556, 889, 556, 556, 722, 556, 556, 584, 584, 389, 975, 556, 611, 278, 280, 389, 389, 333, 333, 333, 280, 350, 556, 556, 333, 556, 556, 333, 556, 333, 333, 278, 250, 737, 556, 611, 556, 556, 743, 611, 400, 333, 584, 556, 333, 278, 556, 556, 556, 556, 556, 556, 556, 556, 1000, 556, 1000, 556, 556, 584, 611, 333, 333, 333, 611, 556, 611, 556, 556, 167, 611, 611, 611, 611, 333, 584, 549, 556, 556, 333, 333, 611, 333, 333, 278, 278, 278, 278, 278, 278, 278, 278, 556, 556, 278, 278, 400, 278, 584, 549, 584, 494, 278, 889, 333, 584, 611, 584, 611, 611, 611, 611, 556, 549, 611, 556, 611, 611, 611, 611, 944, 333, 611, 611, 611, 556, 834, 834, 333, 370, 365, 611, 611, 611, 556, 333, 333, 494, 889, 278, 278, 1000, 584, 584, 611, 611, 611, 474, 500, 500, 500, 278, 278, 278, 238, 389, 389, 549, 389, 389, 737, 333, 556, 556, 556, 556, 556, 556, 333, 556, 556, 278, 278, 556, 600, 333, 389, 333, 611, 556, 834, 333, 333, 1000, 556, 333, 611, 611, 611, 611, 611, 611, 611, 556, 611, 611, 556, 778, 556, 556, 556, 556, 556, 500, 500, 500, 500, 556}

const (
	FontWeightMedium FontWeight = iota
	FontWeightBold
	FontWeightRoman
)

var _gde *RuneCharSafeMap

type fontMap struct {
	_fa.Mutex
	_ef map[StdFontName]func() StdFont
}

func _aee() StdFont {
	_ggd := _cc.NewZapfDingbatsEncoder()
	_acd := Descriptor{Name: ZapfDingbatsName, Family: string(ZapfDingbatsName), Weight: FontWeightMedium, Flags: 0x0004, BBox: [4]float64{-1, -143, 981, 820}, ItalicAngle: 0, Ascent: 0, Descent: 0, CapHeight: 0, XHeight: 0, StemV: 90, StemH: 28}
	return NewStdFontWithEncoding(_acd, _ccc, _ggd)
}

func _cf() StdFont {
	_gb.Do(_gga)
	_cee := Descriptor{Name: CourierObliqueName, Family: string(CourierName), Weight: FontWeightMedium, Flags: 0x0061, BBox: [4]float64{-27, -250, 849, 805}, ItalicAngle: -12, Ascent: 629, Descent: -157, CapHeight: 562, XHeight: 426, StemV: 51, StemH: 51}
	return NewStdFont(_cee, _ccee)
}

func (_dgg *ttfParser) ReadUShort() (_gdg uint16) {
	_ca.Read(_dgg._edg, _ca.BigEndian, &_gdg)
	return _gdg
}

func (_bf StdFont) ToPdfObject() _b.PdfObject {
	_ce := _b.MakeDict()
	_ce.Set("\u0054\u0079\u0070\u0065", _b.MakeName("\u0046\u006f\u006e\u0074"))
	_ce.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _b.MakeName("\u0054\u0079\u0070e\u0031"))
	_ce.Set("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074", _b.MakeName(_bf.Name()))
	_ce.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bf._fcg.ToPdfObject())
	return _b.MakeIndirectObject(_ce)
}

func (_dacf *TtfType) MakeToUnicode() *_ab.CMap {
	_ggdd := make(map[_ab.CharCode]rune)
	if len(_dacf.GlyphNames) == 0 {
		for _ccfc := range _dacf.Chars {
			_ggdd[_ab.CharCode(_ccfc)] = _ccfc
		}
		return _ab.NewToUnicodeCMap(_ggdd)
	}
	for _gbca, _fgd := range _dacf.Chars {
		_bd := _ab.CharCode(_gbca)
		_acgf := _dacf.GlyphNames[_fgd]
		_cbe, _ecb := _cc.GlyphToRune(_acgf)
		if !_ecb {
			_aba.Log.Debug("\u004e\u006f \u0072\u0075\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u0020\u0067\u006c\u0079\u0070h=\u0025\u0071", _gbca, _acgf)
			_cbe = _cc.MissingCodeRune
		}
		_ggdd[_bd] = _cbe
	}
	return _ab.NewToUnicodeCMap(_ggdd)
}
