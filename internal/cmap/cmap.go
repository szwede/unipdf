//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package cmap

import (
	_cab "bufio"
	_ce "bytes"
	_ca "encoding/hex"
	_cc "errors"
	_g "fmt"
	_d "github.com/szwede/unipdf/common"
	_df "github.com/szwede/unipdf/core"
	_fg "github.com/szwede/unipdf/internal/cmap/bcmaps"
	_a "io"
	_ad "sort"
	_c "strconv"
	_f "strings"
	_e "unicode/utf16"
)

func (_bdda *cMapParser) parseObject() (cmapObject, error) {
	_bdda.skipSpaces()
	for {
		_fgdg, _ccd := _bdda._gfa.Peek(2)
		if _ccd != nil {
			return nil, _ccd
		}
		if _fgdg[0] == '%' {
			_bdda.parseComment()
			_bdda.skipSpaces()
			continue
		} else if _fgdg[0] == '/' {
			_gde, _ecb := _bdda.parseName()
			return _gde, _ecb
		} else if _fgdg[0] == '(' {
			_facb, _edc := _bdda.parseString()
			return _facb, _edc
		} else if _fgdg[0] == '[' {
			_cda, _fbgf := _bdda.parseArray()
			return _cda, _fbgf
		} else if (_fgdg[0] == '<') && (_fgdg[1] == '<') {
			_facc, _cabf := _bdda.parseDict()
			return _facc, _cabf
		} else if _fgdg[0] == '<' {
			_eaa, _afc := _bdda.parseHexString()
			return _eaa, _afc
		} else if _df.IsDecimalDigit(_fgdg[0]) || (_fgdg[0] == '-' && _df.IsDecimalDigit(_fgdg[1])) {
			_dgab, _dade := _bdda.parseNumber()
			if _dade != nil {
				return nil, _dade
			}
			return _dgab, nil
		} else {
			_bbf, _ade := _bdda.parseOperand()
			if _ade != nil {
				return nil, _ade
			}
			return _bbf, nil
		}
	}
}

type cmapDict struct{ Dict map[string]cmapObject }

func (_cgca *cMapParser) parseString() (cmapString, error) {
	_cgca._gfa.ReadByte()
	_gdce := _ce.Buffer{}
	_ecg := 1
	for {
		_bebc, _ggge := _cgca._gfa.Peek(1)
		if _ggge != nil {
			return cmapString{_gdce.String()}, _ggge
		}
		if _bebc[0] == '\\' {
			_cgca._gfa.ReadByte()
			_gcae, _gega := _cgca._gfa.ReadByte()
			if _gega != nil {
				return cmapString{_gdce.String()}, _gega
			}
			if _df.IsOctalDigit(_gcae) {
				_egb, _cfba := _cgca._gfa.Peek(2)
				if _cfba != nil {
					return cmapString{_gdce.String()}, _cfba
				}
				var _fgee []byte
				_fgee = append(_fgee, _gcae)
				for _, _efgg := range _egb {
					if _df.IsOctalDigit(_efgg) {
						_fgee = append(_fgee, _efgg)
					} else {
						break
					}
				}
				_cgca._gfa.Discard(len(_fgee) - 1)
				_d.Log.Trace("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022", _fgee)
				_eedd, _cfba := _c.ParseUint(string(_fgee), 8, 32)
				if _cfba != nil {
					return cmapString{_gdce.String()}, _cfba
				}
				_gdce.WriteByte(byte(_eedd))
				continue
			}
			switch _gcae {
			case 'n':
				_gdce.WriteByte('\n')
			case 'r':
				_gdce.WriteByte('\r')
			case 't':
				_gdce.WriteByte('\t')
			case 'b':
				_gdce.WriteByte('\b')
			case 'f':
				_gdce.WriteByte('\f')
			case '(':
				_gdce.WriteByte('(')
			case ')':
				_gdce.WriteByte(')')
			case '\\':
				_gdce.WriteByte('\\')
			}
			continue
		} else if _bebc[0] == '(' {
			_ecg++
		} else if _bebc[0] == ')' {
			_ecg--
			if _ecg == 0 {
				_cgca._gfa.ReadByte()
				break
			}
		}
		_fggb, _ := _cgca._gfa.ReadByte()
		_gdce.WriteByte(_fggb)
	}
	return cmapString{_gdce.String()}, nil
}

func LoadCmapFromData(data []byte, isSimple bool) (*CMap, error) {
	_d.Log.Trace("\u004c\u006fa\u0064\u0043\u006d\u0061\u0070\u0046\u0072\u006f\u006d\u0044\u0061\u0074\u0061\u003a\u0020\u0069\u0073\u0053\u0069\u006d\u0070\u006ce=\u0025\u0074", isSimple)
	cmap := _gbc(isSimple)
	cmap.cMapParser = _afbc(data)
	_ae := cmap.parse()
	if _ae != nil {
		return nil, _ae
	}
	if len(cmap._fa) == 0 {
		if cmap._gbe != "" {
			return cmap, nil
		}
		_d.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u002e\u0020\u0063\u006d\u0061p=\u0025\u0073", cmap)
	}
	cmap.computeInverseMappings()
	return cmap, nil
}

func (cmap *CMap) parseSystemInfo() error {
	_cca := false
	_ggfg := false
	_eee := ""
	_bcb := false
	_gaec := CIDSystemInfo{}
	for _bfgb := 0; _bfgb < 50 && !_bcb; _bfgb++ {
		_bfgbe, _fage := cmap.parseObject()
		if _fage != nil {
			return _fage
		}
		switch _eddg := _bfgbe.(type) {
		case cmapDict:
			_gdd := _eddg.Dict
			_eeba, _dae := _gdd["\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079"]
			if !_dae {
				_d.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f")
				return ErrBadCMap
			}
			_fbcc, _dae := _eeba.(cmapString)
			if !_dae {
				_d.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f")
				return ErrBadCMap
			}
			_gaec.Registry = _fbcc.String
			_eeba, _dae = _gdd["\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067"]
			if !_dae {
				_d.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f")
				return ErrBadCMap
			}
			_fbcc, _dae = _eeba.(cmapString)
			if !_dae {
				_d.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f")
				return ErrBadCMap
			}
			_gaec.Ordering = _fbcc.String
			_ffg, _dae := _gdd["\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074"]
			if !_dae {
				_d.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f")
				return ErrBadCMap
			}
			_ggdc, _dae := _ffg.(cmapInt)
			if !_dae {
				_d.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f")
				return ErrBadCMap
			}
			_gaec.Supplement = int(_ggdc._cgee)
			_bcb = true
		case cmapOperand:
			switch _eddg.Operand {
			case "\u0062\u0065\u0067i\u006e":
				_cca = true
			case "\u0065\u006e\u0064":
				_bcb = true
			case "\u0064\u0065\u0066":
				_ggfg = false
			}
		case cmapName:
			if _cca {
				_eee = _eddg.Name
				_ggfg = true
			}
		case cmapString:
			if _ggfg {
				switch _eee {
				case "\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079":
					_gaec.Registry = _eddg.String
				case "\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067":
					_gaec.Ordering = _eddg.String
				}
			}
		case cmapInt:
			if _ggfg {
				switch _eee {
				case "\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074":
					_gaec.Supplement = int(_eddg._cgee)
				}
			}
		}
	}
	if !_bcb {
		_d.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006e\u0066\u006f\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u006c\u0079")
		return ErrBadCMap
	}
	cmap._ab = _gaec
	return nil
}

const (
	_fbgg  = "\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"
	_dfcaa = "\u0062e\u0067\u0069\u006e\u0063\u006d\u0061p"
	_caeb  = "\u0065n\u0064\u0063\u006d\u0061\u0070"
	_aaa   = "\u0062\u0065\u0067\u0069nc\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0072\u0061\u006e\u0067\u0065"
	_gab   = "\u0065\u006e\u0064\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065r\u0061\u006e\u0067\u0065"
	_fab   = "b\u0065\u0067\u0069\u006e\u0062\u0066\u0063\u0068\u0061\u0072"
	_bfbd  = "\u0065n\u0064\u0062\u0066\u0063\u0068\u0061r"
	_bbde  = "\u0062\u0065\u0067i\u006e\u0062\u0066\u0072\u0061\u006e\u0067\u0065"
	_bgge  = "\u0065\u006e\u0064\u0062\u0066\u0072\u0061\u006e\u0067\u0065"
	_caf   = "\u0062\u0065\u0067\u0069\u006e\u0063\u0069\u0064\u0072\u0061\u006e\u0067\u0065"
	_ddgb  = "e\u006e\u0064\u0063\u0069\u0064\u0072\u0061\u006e\u0067\u0065"
	_gceb  = "\u0075s\u0065\u0063\u006d\u0061\u0070"
	_ebf   = "\u0057\u004d\u006fd\u0065"
	_cfff  = "\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065"
	_aef   = "\u0043\u004d\u0061\u0070\u0054\u0079\u0070\u0065"
	_ebg   = "C\u004d\u0061\u0070\u0056\u0065\u0072\u0073\u0069\u006f\u006e"
)

func NewCIDSystemInfo(obj _df.PdfObject) (_de CIDSystemInfo, _cg error) {
	_ge, _be := _df.GetDict(obj)
	if !_be {
		return CIDSystemInfo{}, _df.ErrTypeError
	}
	_cad, _be := _df.GetStringVal(_ge.Get("\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079"))
	if !_be {
		return CIDSystemInfo{}, _df.ErrTypeError
	}
	_dfg, _be := _df.GetStringVal(_ge.Get("\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067"))
	if !_be {
		return CIDSystemInfo{}, _df.ErrTypeError
	}
	_cec, _be := _df.GetIntVal(_ge.Get("\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074"))
	if !_be {
		return CIDSystemInfo{}, _df.ErrTypeError
	}
	return CIDSystemInfo{Registry: _cad, Ordering: _dfg, Supplement: _cec}, nil
}

func (cmap *CMap) NBits() int { return cmap._cbe }

func (cmap *CMap) CIDToCharcode(cid CharCode) (CharCode, bool) {
	_eea, _faf := cmap._gg[cid]
	return _eea, _faf
}

func (cmap *CMap) parseWMode() error {
	var _cge int
	_daa := false
	for _fdg := 0; _fdg < 3 && !_daa; _fdg++ {
		_geg, _gdf := cmap.parseObject()
		if _gdf != nil {
			return _gdf
		}
		switch _fca := _geg.(type) {
		case cmapOperand:
			switch _fca.Operand {
			case "\u0064\u0065\u0066":
				_daa = true
			default:
				_d.Log.Error("\u0070\u0061\u0072\u0073\u0065\u0057\u004d\u006f\u0064\u0065:\u0020\u0073\u0074\u0061\u0074\u0065\u0020e\u0072\u0072\u006f\u0072\u002e\u0020\u006f\u003d\u0025\u0023\u0076", _geg)
				return ErrBadCMap
			}
		case cmapInt:
			_cge = int(_fca._cgee)
		}
	}
	cmap._cea = integer{_acf: true, _bbdab: _cge}
	return nil
}

const (
	_bbd  = 100
	_dgg  = "\u000a\u002f\u0043\u0049\u0044\u0049\u006e\u0069\u0074\u0020\u002f\u0050\u0072\u006fc\u0053\u0065\u0074\u0020\u0066\u0069\u006e\u0064\u0072es\u006fu\u0072c\u0065 \u0062\u0065\u0067\u0069\u006e\u000a\u0031\u0032\u0020\u0064\u0069\u0063\u0074\u0020\u0062\u0065\u0067\u0069n\u000a\u0062\u0065\u0067\u0069\u006e\u0063\u006d\u0061\u0070\n\u002f\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065m\u0049\u006e\u0066\u006f\u0020\u003c\u003c\u0020\u002f\u0052\u0065\u0067\u0069\u0073t\u0072\u0079\u0020\u0028\u0041\u0064\u006f\u0062\u0065\u0029\u0020\u002f\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067\u0020\u0028\u0055\u0043\u0053)\u0020\u002f\u0053\u0075\u0070p\u006c\u0065\u006d\u0065\u006et\u0020\u0030\u0020\u003e\u003e\u0020\u0064\u0065\u0066\u000a\u002f\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065\u0020\u002f\u0041\u0064\u006f\u0062\u0065-\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0055\u0043\u0053\u0020\u0064\u0065\u0066\u000a\u002fC\u004d\u0061\u0070\u0054\u0079\u0070\u0065\u0020\u0032\u0020\u0064\u0065\u0066\u000a\u0031\u0020\u0062\u0065\u0067\u0069\u006e\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063e\u0072\u0061n\u0067\u0065\n\u003c\u0030\u0030\u0030\u0030\u003e\u0020<\u0046\u0046\u0046\u0046\u003e\u000a\u0065\u006e\u0064\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065r\u0061\u006e\u0067\u0065\u000a"
	_gaed = "\u0065\u006e\u0064\u0063\u006d\u0061\u0070\u000a\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065\u0020\u0063ur\u0072e\u006e\u0074\u0064\u0069\u0063\u0074\u0020\u002f\u0043\u004d\u0061\u0070 \u0064\u0065\u0066\u0069\u006e\u0065\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0020\u0070\u006fp\u000a\u0065\u006e\u0064\u000a\u0065\u006e\u0064\u000a"
)

func (cmap *CMap) BytesToCharcodes(data []byte) ([]CharCode, bool) {
	var _bfa []CharCode
	if cmap._cbe == 8 {
		for _, _edd := range data {
			_bfa = append(_bfa, CharCode(_edd))
		}
		return _bfa, true
	}
	for _gae := 0; _gae < len(data); {
		_bdg, _daf, _aga := cmap.matchCode(data[_gae:])
		if !_aga {
			_d.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063\u006f\u0064\u0065\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0074\u0020\u0069\u003d\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0073\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d\u003d\u0025\u0023\u0071", _gae, data, string(data))
			return _bfa, false
		}
		_bfa = append(_bfa, _bdg)
		_gae += _daf
	}
	return _bfa, true
}

type cmapObject interface{}

func (_gfag *cMapParser) parseName() (cmapName, error) {
	_bac := ""
	_cdge := false
	for {
		_bfea, _aab := _gfag._gfa.Peek(1)
		if _aab == _a.EOF {
			break
		}
		if _aab != nil {
			return cmapName{_bac}, _aab
		}
		if !_cdge {
			if _bfea[0] == '/' {
				_cdge = true
				_gfag._gfa.ReadByte()
			} else {
				_d.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u004e\u0061\u006d\u0065\u0020\u0073\u0074a\u0072t\u0069n\u0067 \u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0028\u0025\u0020\u0078\u0029", _bfea, _bfea)
				return cmapName{_bac}, _g.Errorf("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029", _bfea[0])
			}
		} else {
			if _df.IsWhiteSpace(_bfea[0]) {
				break
			} else if (_bfea[0] == '/') || (_bfea[0] == '[') || (_bfea[0] == '(') || (_bfea[0] == ']') || (_bfea[0] == '<') || (_bfea[0] == '>') {
				break
			} else if _bfea[0] == '#' {
				_bdf, _cbag := _gfag._gfa.Peek(3)
				if _cbag != nil {
					return cmapName{_bac}, _cbag
				}
				_gfag._gfa.Discard(3)
				_bbda, _cbag := _ca.DecodeString(string(_bdf[1:3]))
				if _cbag != nil {
					return cmapName{_bac}, _cbag
				}
				_bac += string(_bbda)
			} else {
				_eed, _ := _gfag._gfa.ReadByte()
				_bac += string(_eed)
			}
		}
	}
	return cmapName{_bac}, nil
}

func (cmap *CMap) CharcodeToCID(code CharCode) (CharCode, bool) {
	_bgg, _cdca := cmap._fgd[code]
	return _bgg, _cdca
}

func (cmap *CMap) Name() string { return cmap._cef }

type cmapHexString struct {
	_ffe  int
	_cefa []byte
}

func (_bcf *cMapParser) parseArray() (cmapArray, error) {
	_cag := cmapArray{}
	_cag.Array = []cmapObject{}
	_bcf._gfa.ReadByte()
	for {
		_bcf.skipSpaces()
		_fce, _deg := _bcf._gfa.Peek(1)
		if _deg != nil {
			return _cag, _deg
		}
		if _fce[0] == ']' {
			_bcf._gfa.ReadByte()
			break
		}
		_adf, _deg := _bcf.parseObject()
		if _deg != nil {
			return _cag, _deg
		}
		_cag.Array = append(_cag.Array, _adf)
	}
	return _cag, nil
}

func _ddd(_gggc string) (*CMap, error) {
	_gec, _agc := _fg.Asset(_gggc)
	if _agc != nil {
		return nil, _agc
	}
	return LoadCmapFromDataCID(_gec)
}

func (cmap *CMap) inCodespace(_efg CharCode, _ff int) bool {
	for _, _egd := range cmap._fa {
		if _egd.Low <= _efg && _efg <= _egd.High && _ff == _egd.NumBytes {
			return true
		}
	}
	return false
}

func (_aea *cMapParser) parseHexString() (cmapHexString, error) {
	_aea._gfa.ReadByte()
	_aeee := []byte("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046")
	_gddd := _ce.Buffer{}
	for {
		_aea.skipSpaces()
		_edg, _dfeb := _aea._gfa.Peek(1)
		if _dfeb != nil {
			return cmapHexString{}, _dfeb
		}
		if _edg[0] == '>' {
			_aea._gfa.ReadByte()
			break
		}
		_gbca, _ := _aea._gfa.ReadByte()
		if _ce.IndexByte(_aeee, _gbca) >= 0 {
			_gddd.WriteByte(_gbca)
		}
	}
	if _gddd.Len()%2 == 1 {
		_d.Log.Debug("\u0070\u0061rs\u0065\u0048\u0065x\u0053\u0074\u0072\u0069ng:\u0020ap\u0070\u0065\u006e\u0064\u0069\u006e\u0067 '\u0030\u0027\u0020\u0074\u006f\u0020\u0025#\u0071", _gddd.String())
		_gddd.WriteByte('0')
	}
	_adc := _gddd.Len() / 2
	_dbg, _ := _ca.DecodeString(_gddd.String())
	return cmapHexString{_ffe: _adc, _cefa: _dbg}, nil
}

func _cbca(_ecd cmapHexString) rune {
	_cgcg := _dfde(_ecd)
	if _agcc := len(_cgcg); _agcc == 0 {
		_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0068\u0065\u0078\u0054o\u0052\u0075\u006e\u0065\u002e\u0020\u0045\u0078p\u0065c\u0074\u0065\u0064\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0072u\u006e\u0065\u0020\u0073\u0068\u0065\u0078\u003d\u0025\u0023\u0076", _ecd)
		return MissingCodeRune
	}
	if len(_cgcg) > 1 {
		_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0068\u0065\u0078\u0054\u006f\u0052\u0075\u006e\u0065\u002e\u0020\u0045\u0078p\u0065\u0063\u0074\u0065\u0064\u0020\u0065\u0078\u0061\u0063\u0074\u006c\u0079\u0020\u006f\u006e\u0065\u0020\u0072\u0075\u006e\u0065\u0020\u0073\u0068\u0065\u0078\u003d\u0025\u0023v\u0020\u002d\u003e\u0020\u0025#\u0076", _ecd, _cgcg)
	}
	return _cgcg[0]
}

func (cmap *CMap) CIDSystemInfo() CIDSystemInfo { return cmap._ab }

func IsPredefinedCMap(name string) bool { return _fg.AssetExists(name) }

func (cmap *CMap) Bytes() []byte {
	_d.Log.Trace("\u0063\u006d\u0061\u0070.B\u0079\u0074\u0065\u0073\u003a\u0020\u0063\u006d\u0061\u0070\u003d\u0025\u0073", cmap.String())
	if len(cmap._cba) > 0 {
		return cmap._cba
	}
	cmap._cba = []byte(_f.Join([]string{_dgg, cmap.toBfData(), _gaed}, "\u000a"))
	return cmap._cba
}

func (cmap *CMap) StringToCID(s string) (CharCode, bool) {
	_abgb, _ga := cmap._bb[s]
	return _abgb, _ga
}

const (
	_cd               = 4
	MissingCodeRune   = '\ufffd'
	MissingCodeString = string(MissingCodeRune)
)

type integer struct {
	_acf   bool
	_bbdab int
}

func _bgb(_efb string) string {
	_egg := []rune(_efb)
	_ebb := make([]string, len(_egg))
	for _aad, _ddc := range _egg {
		_ebb[_aad] = _g.Sprintf("\u0025\u0030\u0034\u0078", _ddc)
	}
	return _g.Sprintf("\u003c\u0025\u0073\u003e", _f.Join(_ebb, ""))
}

func (cmap *CMap) Type() int { return cmap._fb }

func (cmap *CMap) parseCIDRange() error {
	for {
		_bee, _dfca := cmap.parseObject()
		if _dfca != nil {
			if _dfca == _a.EOF {
				break
			}
			return _dfca
		}
		_cdfg, _daeg := _bee.(cmapHexString)
		if !_daeg {
			if _ddg, _dfe := _bee.(cmapOperand); _dfe {
				if _ddg.Operand == _ddgb {
					return nil
				}
				return _cc.New("\u0063\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0072\u0076\u0061\u006c\u0020s\u0074\u0061\u0072\u0074\u0020\u006du\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0068\u0065\u0078\u0020\u0073t\u0072\u0069\u006e\u0067")
			}
		}
		_fbb := _dbb(_cdfg)
		_bee, _dfca = cmap.parseObject()
		if _dfca != nil {
			if _dfca == _a.EOF {
				break
			}
			return _dfca
		}
		_eda, _daeg := _bee.(cmapHexString)
		if !_daeg {
			return _cc.New("\u0063\u0069d\u0020\u0069\u006e\u0074e\u0072\u0076a\u006c\u0020\u0065\u006e\u0064\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0068\u0065\u0078\u0020\u0073t\u0072\u0069\u006e\u0067")
		}
		if len(_cdfg._cefa) != len(_eda._cefa) {
			return _cc.New("\u0075\u006e\u0065\u0071\u0075\u0061\u006c\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0062\u0079\u0074\u0065\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_bff := _dbb(_eda)
		if _fbb > _bff {
			_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0049\u0044\u0020\u0072\u0061\u006e\u0067\u0065\u002e\u0020\u0073t\u0061\u0072\u0074\u003d\u0030\u0078\u0025\u0030\u0032\u0078\u0020\u0065\u006e\u0064=\u0030x\u0025\u0030\u0032\u0078", _fbb, _bff)
			return ErrBadCMap
		}
		_bee, _dfca = cmap.parseObject()
		if _dfca != nil {
			if _dfca == _a.EOF {
				break
			}
			return _dfca
		}
		_dca, _daeg := _bee.(cmapInt)
		if !_daeg {
			return _cc.New("\u0063\u0069\u0064\u0020\u0073t\u0061\u0072\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0064\u0065\u0063\u0069\u006d\u0061\u006c\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		if _dca._cgee < 0 {
			return _cc.New("\u0069\u006e\u0076al\u0069\u0064\u0020\u0063\u0069\u0064\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0076\u0061\u006c\u0075\u0065")
		}
		_bdc := _dca._cgee
		for _ecfg := _fbb; _ecfg <= _bff; _ecfg++ {
			cmap._fgd[_ecfg] = CharCode(_bdc)
			_bdc++
		}
		_d.Log.Trace("C\u0049\u0044\u0020\u0072\u0061\u006eg\u0065\u003a\u0020\u003c\u0030\u0078\u0025\u0058\u003e \u003c\u0030\u0078%\u0058>\u0020\u0025\u0064", _fbb, _bff, _dca._cgee)
	}
	return nil
}

func (cmap *CMap) parseType() error {
	_bba := 0
	_gca := false
	for _gdc := 0; _gdc < 3 && !_gca; _gdc++ {
		_acdc, _aada := cmap.parseObject()
		if _aada != nil {
			return _aada
		}
		switch _efc := _acdc.(type) {
		case cmapOperand:
			switch _efc.Operand {
			case "\u0064\u0065\u0066":
				_gca = true
			default:
				_d.Log.Error("\u0070\u0061r\u0073\u0065\u0054\u0079\u0070\u0065\u003a\u0020\u0073\u0074\u0061\u0074\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u002e\u0020\u006f=%\u0023\u0076", _acdc)
				return ErrBadCMap
			}
		case cmapInt:
			_bba = int(_efc._cgee)
		}
	}
	cmap._fb = _bba
	return nil
}

func (cmap *CMap) CharcodeBytesToUnicode(data []byte) (string, int) {
	_dfd, _agcd := cmap.BytesToCharcodes(data)
	if !_agcd {
		_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065s\u0054\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u004e\u006f\u0074\u0020\u0069n\u0020\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u002e\u0020\u0064\u0061\u0074\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078]\u0020\u0063\u006d\u0061\u0070=\u0025\u0073", data, cmap)
		return "", 0
	}
	_bed := make([]string, len(_dfd))
	var _decb []CharCode
	for _cbc, _ba := range _dfd {
		_fc, _fd := cmap._bg[_ba]
		if !_fd {
			_decb = append(_decb, _ba)
			_fc = MissingCodeString
		}
		_bed[_cbc] = _fc
	}
	_eef := _f.Join(_bed, "")
	if len(_decb) > 0 {
		_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020C\u0068\u0061\u0072c\u006f\u0064\u0065\u0042y\u0074\u0065\u0073\u0054\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u004e\u006f\u0074\u0020\u0069\u006e\u0020\u006d\u0061\u0070\u002e\u000a"+"\u0009d\u0061t\u0061\u003d\u005b\u0025\u00200\u0032\u0078]\u003d\u0025\u0023\u0071\u000a"+"\u0009\u0063h\u0061\u0072\u0063o\u0064\u0065\u0073\u003d\u0025\u0030\u0032\u0078\u000a"+"\u0009\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u003d\u0025\u0064\u0020%\u0030\u0032\u0078\u000a"+"\u0009\u0075\u006e\u0069\u0063\u006f\u0064\u0065\u003d`\u0025\u0073\u0060\u000a"+"\u0009\u0063\u006d\u0061\u0070\u003d\u0025\u0073", data, string(data), _dfd, len(_decb), _decb, _eef, cmap)
	}
	return _eef, len(_decb)
}

func (cmap *CMap) matchCode(_ggfc []byte) (_aec CharCode, _db int, _cdf bool) {
	for _eg := 0; _eg < _cd; _eg++ {
		if _eg < len(_ggfc) {
			_aec = _aec<<8 | CharCode(_ggfc[_eg])
			_db++
		}
		_cdf = cmap.inCodespace(_aec, _eg+1)
		if _cdf {
			return _aec, _db, true
		}
	}
	_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063o\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0020m\u0061t\u0063\u0068\u0065\u0073\u0020\u0062\u0079\u0074\u0065\u0073\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d=\u0025\u0023\u0071\u0020\u0063\u006d\u0061\u0070\u003d\u0025\u0073", _ggfc, string(_ggfc), cmap)
	return 0, 0, false
}

type cmapArray struct{ Array []cmapObject }

type cmapString struct{ String string }

type Codespace struct {
	NumBytes int
	Low      CharCode
	High     CharCode
}

func _gbc(_dec bool) *CMap {
	_ed := 16
	if _dec {
		_ed = 8
	}
	return &CMap{_cbe: _ed, _fgd: make(map[CharCode]CharCode), _gg: make(map[CharCode]CharCode), _bg: make(map[CharCode]string), _bb: make(map[string]CharCode)}
}

var (
	ErrBadCMap        = _cc.New("\u0062\u0061\u0064\u0020\u0063\u006d\u0061\u0070")
	ErrBadCMapComment = _cc.New("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025")
	ErrBadCMapDict    = _cc.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074")
)

type cMapParser struct{ _gfa *_cab.Reader }

func NewToUnicodeCMap(codeToRune map[CharCode]rune) *CMap {
	_dee := make(map[CharCode]string, len(codeToRune))
	for _abg, _ag := range codeToRune {
		_dee[_abg] = string(_ag)
	}
	cmap := &CMap{_cef: "\u0041d\u006fb\u0065\u002d\u0049\u0064\u0065n\u0074\u0069t\u0079\u002d\u0055\u0043\u0053", _fb: 2, _cbe: 16, _ab: CIDSystemInfo{Registry: "\u0041\u0064\u006fb\u0065", Ordering: "\u0055\u0043\u0053", Supplement: 0}, _fa: []Codespace{{Low: 0, High: 0xffff}}, _bg: _dee, _bb: make(map[string]CharCode, len(codeToRune)), _fgd: make(map[CharCode]CharCode, len(codeToRune)), _gg: make(map[CharCode]CharCode, len(codeToRune))}
	cmap.computeInverseMappings()
	return cmap
}

type CharCode uint32

func (cmap *CMap) parseName() error {
	_bge := ""
	_acge := false
	for _aac := 0; _aac < 20 && !_acge; _aac++ {
		_cfd, _gdg := cmap.parseObject()
		if _gdg != nil {
			return _gdg
		}
		switch _dgd := _cfd.(type) {
		case cmapOperand:
			switch _dgd.Operand {
			case "\u0064\u0065\u0066":
				_acge = true
			default:
				_d.Log.Debug("\u0070\u0061\u0072\u0073\u0065\u004e\u0061\u006d\u0065\u003a\u0020\u0053\u0074\u0061\u0074\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u002e\u0020o\u003d\u0025\u0023\u0076\u0020n\u0061\u006de\u003d\u0025\u0023\u0071", _cfd, _bge)
				if _bge != "" {
					_bge = _g.Sprintf("\u0025\u0073\u0020%\u0073", _bge, _dgd.Operand)
				}
				_d.Log.Debug("\u0070\u0061\u0072\u0073\u0065\u004e\u0061\u006d\u0065\u003a \u0052\u0065\u0063\u006f\u0076\u0065\u0072e\u0064\u002e\u0020\u006e\u0061\u006d\u0065\u003d\u0025\u0023\u0071", _bge)
			}
		case cmapName:
			_bge = _dgd.Name
		}
	}
	if !_acge {
		_d.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0070\u0061\u0072\u0073\u0065N\u0061m\u0065:\u0020\u004e\u006f\u0020\u0064\u0065\u0066 ")
		return ErrBadCMap
	}
	cmap._cef = _bge
	return nil
}

func (cmap *CMap) String() string {
	_dfc := cmap._ab
	_dad := []string{_g.Sprintf("\u006e\u0062\u0069\u0074\u0073\u003a\u0025\u0064", cmap._cbe), _g.Sprintf("\u0074y\u0070\u0065\u003a\u0025\u0064", cmap._fb)}
	if cmap._gb != "" {
		_dad = append(_dad, _g.Sprintf("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u003a\u0025\u0073", cmap._gb))
	}
	if cmap._gbe != "" {
		_dad = append(_dad, _g.Sprintf("u\u0073\u0065\u0063\u006d\u0061\u0070\u003a\u0025\u0023\u0071", cmap._gbe))
	}
	_dad = append(_dad, _g.Sprintf("\u0073\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f\u003a\u0025\u0073", _dfc.String()))
	if len(cmap._fa) > 0 {
		_dad = append(_dad, _g.Sprintf("\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u003a\u0025\u0064", len(cmap._fa)))
	}
	if len(cmap._bg) > 0 {
		_dad = append(_dad, _g.Sprintf("\u0063\u006fd\u0065\u0054\u006fU\u006e\u0069\u0063\u006f\u0064\u0065\u003a\u0025\u0064", len(cmap._bg)))
	}
	return _g.Sprintf("\u0043\u004d\u0041P\u007b\u0025\u0023\u0071\u0020\u0025\u0073\u007d", cmap._cef, _f.Join(_dad, "\u0020"))
}

func (cmap *CMap) CharcodeToUnicode(code CharCode) (string, bool) {
	if _fag, _cdc := cmap._bg[code]; _cdc {
		return _fag, true
	}
	return MissingCodeString, false
}

func (cmap *CMap) parseCodespaceRange() error {
	for {
		_decg, _fac := cmap.parseObject()
		if _fac != nil {
			if _fac == _a.EOF {
				break
			}
			return _fac
		}
		_gebd, _eecc := _decg.(cmapHexString)
		if !_eecc {
			if _agf, _ccb := _decg.(cmapOperand); _ccb {
				if _agf.Operand == _gab {
					return nil
				}
				return _cc.New("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065d\u0020\u006fp\u0065\u0072\u0061\u006e\u0064")
			}
		}
		_decg, _fac = cmap.parseObject()
		if _fac != nil {
			if _fac == _a.EOF {
				break
			}
			return _fac
		}
		_bbb, _eecc := _decg.(cmapHexString)
		if !_eecc {
			return _cc.New("\u006e\u006f\u006e-\u0068\u0065\u0078\u0020\u0068\u0069\u0067\u0068")
		}
		if len(_gebd._cefa) != len(_bbb._cefa) {
			return _cc.New("\u0075\u006e\u0065\u0071\u0075\u0061\u006c\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0062\u0079\u0074\u0065\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_ceda := _dbb(_gebd)
		_abb := _dbb(_bbb)
		if _abb < _ceda {
			_d.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0042\u0061d\u0020\u0063\u006fd\u0065\u0073\u0070\u0061\u0063\u0065\u002e\u0020\u006cow\u003d\u0030\u0078%\u0030\u0032x\u0020\u0068\u0069\u0067\u0068\u003d0\u0078\u00250\u0032\u0078", _ceda, _abb)
			return ErrBadCMap
		}
		_ecc := _bbb._ffe
		_bdaa := Codespace{NumBytes: _ecc, Low: _ceda, High: _abb}
		cmap._fa = append(cmap._fa, _bdaa)
		_d.Log.Trace("\u0043\u006f\u0064e\u0073\u0070\u0061\u0063e\u0020\u006c\u006f\u0077\u003a\u0020\u0030x\u0025\u0058\u002c\u0020\u0068\u0069\u0067\u0068\u003a\u0020\u0030\u0078\u0025\u0058", _ceda, _abb)
	}
	if len(cmap._fa) == 0 {
		_d.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u0020\u0069\u006e\u0020\u0063ma\u0070\u002e")
		return ErrBadCMap
	}
	return nil
}

func (_bbff *cMapParser) parseDict() (cmapDict, error) {
	_d.Log.Trace("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021")
	_beg := _bgdc()
	_adef, _ := _bbff._gfa.ReadByte()
	if _adef != '<' {
		return _beg, ErrBadCMapDict
	}
	_adef, _ = _bbff._gfa.ReadByte()
	if _adef != '<' {
		return _beg, ErrBadCMapDict
	}
	for {
		_bbff.skipSpaces()
		_dgaa, _bdbg := _bbff._gfa.Peek(2)
		if _bdbg != nil {
			return _beg, _bdbg
		}
		if (_dgaa[0] == '>') && (_dgaa[1] == '>') {
			_bbff._gfa.ReadByte()
			_bbff._gfa.ReadByte()
			break
		}
		_bcgg, _bdbg := _bbff.parseName()
		_d.Log.Trace("\u004be\u0079\u003a\u0020\u0025\u0073", _bcgg.Name)
		if _bdbg != nil {
			_d.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0061\u006d\u0065\u002e\u0020\u0065\u0072r=\u0025\u0076", _bdbg)
			return _beg, _bdbg
		}
		_bbff.skipSpaces()
		_ccac, _bdbg := _bbff.parseObject()
		if _bdbg != nil {
			return _beg, _bdbg
		}
		_beg.Dict[_bcgg.Name] = _ccac
		_bbff.skipSpaces()
		_dgaa, _bdbg = _bbff._gfa.Peek(3)
		if _bdbg != nil {
			return _beg, _bdbg
		}
		if string(_dgaa) == "\u0064\u0065\u0066" {
			_bbff._gfa.Discard(3)
		}
	}
	return _beg, nil
}

func (_bf *CIDSystemInfo) String() string {
	return _g.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0025\u0030\u0033\u0064", _bf.Registry, _bf.Ordering, _bf.Supplement)
}

func (_bfab *cMapParser) skipSpaces() (int, error) {
	_gff := 0
	for {
		_dag, _ceb := _bfab._gfa.Peek(1)
		if _ceb != nil {
			return 0, _ceb
		}
		if _df.IsWhiteSpace(_dag[0]) {
			_bfab._gfa.ReadByte()
			_gff++
		} else {
			break
		}
	}
	return _gff, nil
}

type cmapName struct{ Name string }

func _bgdc() cmapDict { return cmapDict{Dict: map[string]cmapObject{}} }

func _afbc(_cefg []byte) *cMapParser {
	_adb := cMapParser{}
	_ccab := _ce.NewBuffer(_cefg)
	_adb._gfa = _cab.NewReader(_ccab)
	return &_adb
}

func (cmap *CMap) parseBfrange() error {
	for {
		var _gdga CharCode
		_efbc, _aace := cmap.parseObject()
		if _aace != nil {
			if _aace == _a.EOF {
				break
			}
			return _aace
		}
		switch _gcc := _efbc.(type) {
		case cmapOperand:
			if _gcc.Operand == _bgge {
				return nil
			}
			return _cc.New("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065d\u0020\u006fp\u0065\u0072\u0061\u006e\u0064")
		case cmapHexString:
			_gdga = _dbb(_gcc)
		default:
			return _cc.New("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065")
		}
		var _dde CharCode
		_efbc, _aace = cmap.parseObject()
		if _aace != nil {
			if _aace == _a.EOF {
				break
			}
			return _aace
		}
		switch _afe := _efbc.(type) {
		case cmapOperand:
			_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0063\u006f\u006d\u0070\u006c\u0065\u0074\u0065\u0020\u0062\u0066r\u0061\u006e\u0067\u0065\u0020\u0074\u0072i\u0070\u006c\u0065\u0074")
			return ErrBadCMap
		case cmapHexString:
			_dde = _dbb(_afe)
			if _dde > 0xffff {
				_dde = 0xffff
			}
		default:
			_d.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0055\u006e\u0065\u0078\u0070e\u0063t\u0065d\u0020\u0074\u0079\u0070\u0065\u0020\u0025T", _efbc)
			return ErrBadCMap
		}
		_efbc, _aace = cmap.parseObject()
		if _aace != nil {
			if _aace == _a.EOF {
				break
			}
			return _aace
		}
		switch _dbf := _efbc.(type) {
		case cmapArray:
			if len(_dbf.Array) != int(_dde-_gdga)+1 {
				_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u006f\u0066\u0020\u0069\u0074\u0065\u006d\u0073\u0020\u0069\u006e\u0020a\u0072\u0072\u0061\u0079")
				return ErrBadCMap
			}
			for _ggba := _gdga; _ggba <= _dde; _ggba++ {
				_dgda := _dbf.Array[_ggba-_gdga]
				_efe, _cfe := _dgda.(cmapHexString)
				if !_cfe {
					return _cc.New("\u006e\u006f\u006e-h\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
				}
				_fcac := _dfde(_efe)
				cmap._bg[_ggba] = string(_fcac)
			}
		case cmapHexString:
			_gegb := _dfde(_dbf)
			_ggdca := len(_gegb)
			for _bec := _gdga; _bec <= _dde; _bec++ {
				cmap._bg[_bec] = string(_gegb)
				if _ggdca > 0 {
					_gegb[_ggdca-1]++
				} else {
					_d.Log.Debug("\u004e\u006f\u0020c\u006d\u0061\u0070\u0020\u0074\u0061\u0072\u0067\u0065\u0074\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0066\u006f\u0072\u0020\u0025\u0023\u0076", _bec)
				}
				if _bec == 1<<32-1 {
					break
				}
			}
		default:
			_d.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0055\u006e\u0065\u0078\u0070e\u0063t\u0065d\u0020\u0074\u0079\u0070\u0065\u0020\u0025T", _efbc)
			return ErrBadCMap
		}
	}
	return nil
}

func (_dcab *cMapParser) parseOperand() (cmapOperand, error) {
	_aae := cmapOperand{}
	_fefc := _ce.Buffer{}
	for {
		_bcd, _eae := _dcab._gfa.Peek(1)
		if _eae != nil {
			if _eae == _a.EOF {
				break
			}
			return _aae, _eae
		}
		if _df.IsDelimiter(_bcd[0]) {
			break
		}
		if _df.IsWhiteSpace(_bcd[0]) {
			break
		}
		_abfg, _ := _dcab._gfa.ReadByte()
		_fefc.WriteByte(_abfg)
	}
	if _fefc.Len() == 0 {
		return _aae, _g.Errorf("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0070\u0065\u0072\u0061\u006e\u0064\u0020\u0028\u0065\u006d\u0070\u0074\u0079\u0029")
	}
	_aae.Operand = _fefc.String()
	return _aae, nil
}

func (cmap *CMap) parseVersion() error {
	_ccg := ""
	_cdg := false
	for _bgd := 0; _bgd < 3 && !_cdg; _bgd++ {
		_ceee, _gce := cmap.parseObject()
		if _gce != nil {
			return _gce
		}
		switch _bdba := _ceee.(type) {
		case cmapOperand:
			switch _bdba.Operand {
			case "\u0064\u0065\u0066":
				_cdg = true
			default:
				_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0070\u0061\u0072\u0073\u0065\u0056e\u0072\u0073\u0069\u006f\u006e\u003a \u0073\u0074\u0061\u0074\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u002e\u0020o\u003d\u0025\u0023\u0076", _ceee)
				return ErrBadCMap
			}
		case cmapInt:
			_ccg = _g.Sprintf("\u0025\u0064", _bdba._cgee)
		case cmapFloat:
			_ccg = _g.Sprintf("\u0025\u0066", _bdba._dbge)
		case cmapString:
			_ccg = _bdba.String
		default:
			_d.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020p\u0061\u0072\u0073\u0065Ver\u0073io\u006e\u003a\u0020\u0042\u0061\u0064\u0020ty\u0070\u0065\u002e\u0020\u006f\u003d\u0025#\u0076", _ceee)
		}
	}
	cmap._gb = _ccg
	return nil
}

func LoadCmapFromDataCID(data []byte) (*CMap, error) { return LoadCmapFromData(data, false) }

func _fad(_dge, _fdc int) int {
	if _dge < _fdc {
		return _dge
	}
	return _fdc
}

func _aa(_baa string) rune {
	_affa := []rune(_baa)
	return _affa[len(_affa)-1]
}

func (cmap *CMap) computeInverseMappings() {
	for _gba, _gef := range cmap._fgd {
		if _geb, _caa := cmap._gg[_gef]; !_caa || (_caa && _geb > _gba) {
			cmap._gg[_gef] = _gba
		}
	}
	for _dff, _agcf := range cmap._bg {
		if _aee, _ced := cmap._bb[_agcf]; !_ced || (_ced && _aee > _dff) {
			cmap._bb[_agcf] = _dff
		}
	}
	_ad.Slice(cmap._fa, func(_ebd, _ef int) bool { return cmap._fa[_ebd].Low < cmap._fa[_ef].Low })
}

func (_gga *cMapParser) parseComment() (string, error) {
	var _gdcb _ce.Buffer
	_, _bgga := _gga.skipSpaces()
	if _bgga != nil {
		return _gdcb.String(), _bgga
	}
	_efcb := true
	for {
		_gffg, _gccg := _gga._gfa.Peek(1)
		if _gccg != nil {
			_d.Log.Debug("p\u0061r\u0073\u0065\u0043\u006f\u006d\u006d\u0065\u006et\u003a\u0020\u0065\u0072r=\u0025\u0076", _gccg)
			return _gdcb.String(), _gccg
		}
		if _efcb && _gffg[0] != '%' {
			return _gdcb.String(), ErrBadCMapComment
		}
		_efcb = false
		if (_gffg[0] != '\r') && (_gffg[0] != '\n') {
			_bga, _ := _gga._gfa.ReadByte()
			_gdcb.WriteByte(_bga)
		} else {
			break
		}
	}
	return _gdcb.String(), nil
}

func LoadPredefinedCMap(name string) (*CMap, error) {
	cmap, _ggg := _ddd(name)
	if _ggg != nil {
		return nil, _ggg
	}
	if cmap._gbe == "" {
		cmap.computeInverseMappings()
		return cmap, nil
	}
	_da, _ggg := _ddd(cmap._gbe)
	if _ggg != nil {
		return nil, _ggg
	}
	for _ede, _ea := range _da._fgd {
		if _, _afb := cmap._fgd[_ede]; !_afb {
			cmap._fgd[_ede] = _ea
		}
	}
	cmap._fa = append(cmap._fa, _da._fa...)
	cmap.computeInverseMappings()
	return cmap, nil
}

func (cmap *CMap) Stream() (*_df.PdfObjectStream, error) {
	if cmap._ece != nil {
		return cmap._ece, nil
	}
	_bab, _cde := _df.MakeStream(cmap.Bytes(), _df.NewFlateEncoder())
	if _cde != nil {
		return nil, _cde
	}
	cmap._ece = _bab
	return cmap._ece, nil
}

type CIDSystemInfo struct {
	Registry   string
	Ordering   string
	Supplement int
}

type CMap struct {
	*cMapParser
	_cef string
	_cbe int
	_fb  int
	_gb  string
	_gbe string
	_ab  CIDSystemInfo
	_fa  []Codespace
	_fgd map[CharCode]CharCode
	_gg  map[CharCode]CharCode
	_bg  map[CharCode]string
	_bb  map[string]CharCode
	_cba []byte
	_ece *_df.PdfObjectStream
	_cea integer
}

type cmapOperand struct{ Operand string }

type charRange struct {
	_ec CharCode
	_ee CharCode
}

func (_edge *cMapParser) parseNumber() (cmapObject, error) {
	_eddf, _cga := _df.ParseNumber(_edge._gfa)
	if _cga != nil {
		return nil, _cga
	}
	switch _eebaf := _eddf.(type) {
	case *_df.PdfObjectFloat:
		return cmapFloat{float64(*_eebaf)}, nil
	case *_df.PdfObjectInteger:
		return cmapInt{int64(*_eebaf)}, nil
	}
	return nil, _g.Errorf("\u0075n\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0054", _eddf)
}

func (cmap *CMap) parseBfchar() error {
	for {
		_dcf, _ccgc := cmap.parseObject()
		if _ccgc != nil {
			if _ccgc == _a.EOF {
				break
			}
			return _ccgc
		}
		var _gcd CharCode
		switch _cfgc := _dcf.(type) {
		case cmapOperand:
			if _cfgc.Operand == _bfbd {
				return nil
			}
			return _cc.New("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065d\u0020\u006fp\u0065\u0072\u0061\u006e\u0064")
		case cmapHexString:
			_gcd = _dbb(_cfgc)
		default:
			return _cc.New("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065")
		}
		_dcf, _ccgc = cmap.parseObject()
		if _ccgc != nil {
			if _ccgc == _a.EOF {
				break
			}
			return _ccgc
		}
		var _bcg []rune
		switch _efgc := _dcf.(type) {
		case cmapOperand:
			if _efgc.Operand == _bfbd {
				return nil
			}
			_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020o\u0070\u0065\u0072\u0061\u006e\u0064\u002e\u0020\u0025\u0023\u0076", _efgc)
			return ErrBadCMap
		case cmapHexString:
			_bcg = _dfde(_efgc)
		case cmapName:
			_d.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0061\u006de\u002e \u0025\u0023\u0076", _efgc)
			_bcg = []rune{MissingCodeRune}
		default:
			_d.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u0074\u0079\u0070e\u002e \u0025\u0023\u0076", _dcf)
			return ErrBadCMap
		}
		cmap._bg[_gcd] = string(_bcg)
	}
	return nil
}

func _dfde(_ffa cmapHexString) []rune {
	if len(_ffa._cefa) == 1 {
		return []rune{rune(_ffa._cefa[0])}
	}
	_afed := _ffa._cefa
	if len(_afed)%2 != 0 {
		_afed = append(_afed, 0)
		_d.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0068\u0065\u0078\u0054\u006f\u0052\u0075\u006e\u0065\u0073\u002e\u0020\u0050\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0073\u0068\u0065\u0078\u003d\u0025#\u0076\u0020\u0074\u006f\u0020\u0025\u002b\u0076", _ffa, _afed)
	}
	_bcc := len(_afed) >> 1
	_agfa := make([]uint16, _bcc)
	for _cdgg := 0; _cdgg < _bcc; _cdgg++ {
		_agfa[_cdgg] = uint16(_afed[_cdgg<<1])<<8 + uint16(_afed[_cdgg<<1+1])
	}
	_cagf := _e.Decode(_agfa)
	return _cagf
}

func (cmap *CMap) parse() error {
	var _agb cmapObject
	for {
		_cgc, _fgc := cmap.parseObject()
		if _fgc != nil {
			if _fgc == _a.EOF {
				break
			}
			_d.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0043\u004d\u0061\u0070\u003a\u0020\u0025\u0076", _fgc)
			return _fgc
		}
		switch _eeb := _cgc.(type) {
		case cmapOperand:
			_efba := _eeb
			switch _efba.Operand {
			case _aaa:
				_gd := cmap.parseCodespaceRange()
				if _gd != nil {
					return _gd
				}
			case _caf:
				_gfc := cmap.parseCIDRange()
				if _gfc != nil {
					return _gfc
				}
			case _fab:
				_bfe := cmap.parseBfchar()
				if _bfe != nil {
					return _bfe
				}
			case _bbde:
				_baf := cmap.parseBfrange()
				if _baf != nil {
					return _baf
				}
			case _gceb:
				if _agb == nil {
					_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u0073\u0065\u0063m\u0061\u0070\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u006f \u0061\u0072\u0067")
					return ErrBadCMap
				}
				_bdb, _efbag := _agb.(cmapName)
				if !_efbag {
					_d.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0075\u0073\u0065\u0063\u006d\u0061\u0070\u0020\u0061\u0072\u0067\u0020\u006eo\u0074\u0020\u0061\u0020\u006e\u0061\u006de\u0020\u0025\u0023\u0076", _agb)
					return ErrBadCMap
				}
				cmap._gbe = _bdb.Name
			case _fbgg:
				_bag := cmap.parseSystemInfo()
				if _bag != nil {
					return _bag
				}
			}
		case cmapName:
			_fbg := _eeb
			switch _fbg.Name {
			case _fbgg:
				_fefg := cmap.parseSystemInfo()
				if _fefg != nil {
					return _fefg
				}
			case _cfff:
				_bfg := cmap.parseName()
				if _bfg != nil {
					return _bfg
				}
			case _aef:
				_ffb := cmap.parseType()
				if _ffb != nil {
					return _ffb
				}
			case _ebg:
				_egf := cmap.parseVersion()
				if _egf != nil {
					return _egf
				}
			case _ebf:
				if _fgc = cmap.parseWMode(); _fgc != nil {
					return _fgc
				}
			}
		}
		_agb = _cgc
	}
	return nil
}

type fbRange struct {
	_af CharCode
	_cb CharCode
	_dd string
}

type cmapInt struct{ _cgee int64 }

func _dbb(_ffd cmapHexString) CharCode {
	_gdfd := CharCode(0)
	for _, _fdb := range _ffd._cefa {
		_gdfd <<= 8
		_gdfd |= CharCode(_fdb)
	}
	return _gdfd
}

func (cmap *CMap) toBfData() string {
	if len(cmap._bg) == 0 {
		return ""
	}
	_cfg := make([]CharCode, 0, len(cmap._bg))
	for _ggb := range cmap._bg {
		_cfg = append(_cfg, _ggb)
	}
	_ad.Slice(_cfg, func(_fcb, _bbg int) bool { return _cfg[_fcb] < _cfg[_bbg] })
	var _ggd []charRange
	_aff := charRange{_cfg[0], _cfg[0]}
	_gaf := cmap._bg[_cfg[0]]
	for _, _bc := range _cfg[1:] {
		_cee := cmap._bg[_bc]
		if _bc == _aff._ee+1 && _aa(_cee) == _aa(_gaf)+1 {
			_aff._ee = _bc
		} else {
			_ggd = append(_ggd, _aff)
			_aff._ec, _aff._ee = _bc, _bc
		}
		_gaf = _cee
	}
	_ggd = append(_ggd, _aff)
	var _gc []CharCode
	var _fef []fbRange
	for _, _ead := range _ggd {
		if _ead._ec == _ead._ee {
			_gc = append(_gc, _ead._ec)
		} else {
			_fef = append(_fef, fbRange{_af: _ead._ec, _cb: _ead._ee, _dd: cmap._bg[_ead._ec]})
		}
	}
	_d.Log.Trace("\u0063\u0068ar\u0052\u0061\u006eg\u0065\u0073\u003d\u0025d f\u0062Ch\u0061\u0072\u0073\u003d\u0025\u0064\u0020fb\u0052\u0061\u006e\u0067\u0065\u0073\u003d%\u0064", len(_ggd), len(_gc), len(_fef))
	var _gaa []string
	if len(_gc) > 0 {
		_fgdf := (len(_gc) + _bbd - 1) / _bbd
		for _acg := 0; _acg < _fgdf; _acg++ {
			_dbd := _fad(len(_gc)-_acg*_bbd, _bbd)
			_gaa = append(_gaa, _g.Sprintf("\u0025\u0064\u0020\u0062\u0065\u0067\u0069\u006e\u0062f\u0063\u0068\u0061\u0072", _dbd))
			for _gbeg := 0; _gbeg < _dbd; _gbeg++ {
				_ebc := _gc[_acg*_bbd+_gbeg]
				_fgg := cmap._bg[_ebc]
				_gaa = append(_gaa, _g.Sprintf("\u003c%\u0030\u0034\u0078\u003e\u0020\u0025s", _ebc, _bgb(_fgg)))
			}
			_gaa = append(_gaa, "\u0065n\u0064\u0062\u0066\u0063\u0068\u0061r")
		}
	}
	if len(_fef) > 0 {
		_dea := (len(_fef) + _bbd - 1) / _bbd
		for _fgf := 0; _fgf < _dea; _fgf++ {
			_bdd := _fad(len(_fef)-_fgf*_bbd, _bbd)
			_gaa = append(_gaa, _g.Sprintf("\u0025d\u0020b\u0065\u0067\u0069\u006e\u0062\u0066\u0072\u0061\u006e\u0067\u0065", _bdd))
			for _eadc := 0; _eadc < _bdd; _eadc++ {
				_cae := _fef[_fgf*_bbd+_eadc]
				_gaa = append(_gaa, _g.Sprintf("\u003c%\u00304\u0078\u003e\u003c\u0025\u0030\u0034\u0078\u003e\u0020\u0025\u0073", _cae._af, _cae._cb, _bgb(_cae._dd)))
			}
			_gaa = append(_gaa, "\u0065\u006e\u0064\u0062\u0066\u0072\u0061\u006e\u0067\u0065")
		}
	}
	return _f.Join(_gaa, "\u000a")
}

func (cmap *CMap) WMode() (int, bool) { return cmap._cea._bbdab, cmap._cea._acf }

type cmapFloat struct{ _dbge float64 }
