//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler

import (
	_eb "bytes"
	_dg "crypto"
	_af "crypto/ecdsa"
	_f "crypto/rand"
	_ed "crypto/rsa"
	_cc "crypto/x509"
	_e "crypto/x509/pkix"
	_ge "encoding/asn1"
	_bc "encoding/hex"
	_a "errors"
	_ac "fmt"
	_fc "github.com/szwede/unipdf/v4/common"
	_bf "github.com/szwede/unipdf/v4/core"
	_cb "github.com/szwede/unipdf/v4/model"
	_ag "github.com/szwede/unipdf/v4/model/mdp"
	_ga "github.com/szwede/unipdf/v4/model/sigutil"
	_afb "github.com/unidoc/pkcs7"
	_ee "github.com/unidoc/timestamp"
	_b "hash"
	_d "math/big"
	_gb "strings"
	_c "time"
)

type timestampInfo struct {
	Version        int
	Policy         _ge.RawValue
	MessageImprint struct {
		HashAlgorithm _e.AlgorithmIdentifier
		HashedMessage []byte
	}
	SerialNumber    _ge.RawValue
	GeneralizedTime _c.Time
}

func (_cf *etsiPAdES) getOCSPs(_ead []*_cc.Certificate, _ded map[string]*_cc.Certificate) ([][]byte, error) {
	_cec := make([][]byte, 0, len(_ead))
	for _, _ae := range _ead {
		for _, _db := range _ae.OCSPServer {
			if _cf.CertClient.IsCA(_ae) {
				continue
			}
			_gea, _aab := _ded[_ae.Issuer.CommonName]
			if !_aab {
				_fc.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
				continue
			}
			_, _faa, _cd := _cf.OCSPClient.MakeRequest(_db, _ae, _gea)
			if _cd != nil {
				_fc.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076", _cd)
				continue
			}
			_cec = append(_cec, _faa)
		}
	}
	return _cec, nil
}

func (_beab *adobeX509RSASHA1) getHashAlgorithm(_egd *_cb.PdfSignature) (_dg.Hash, error) {
	_fcg, _cdaf := _beab.getCertificate(_egd)
	if _cdaf != nil {
		if _beab._bgd != 0 {
			return _beab._bgd, nil
		}
		return _bdf, _cdaf
	}
	if _egd.Contents != nil {
		_egde := _egd.Contents.Bytes()
		var _bgdc []byte
		if _, _abg := _ge.Unmarshal(_egde, &_bgdc); _abg == nil {
			_gfd := _dga(_fcg.PublicKey.(*_ed.PublicKey), _bgdc)
			if _gfd > 0 {
				return _gfd, nil
			}
		}
	}
	if _beab._bgd != 0 {
		return _beab._bgd, nil
	}
	return _bdf, nil
}

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct {

	// EstimateSize specifies whether the size of the signature contents
	// should be estimated based on the modulus size of the public key
	// extracted from the signing certificate. If set to false, a mock Sign
	// call is made in order to estimate the size of the signature contents.
	EstimateSize bool

	// Algorithm specifies the algorithm used for performing signing.
	// If not specified, defaults to SHA1.
	Algorithm _dg.Hash
}

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp(timestampServerURL string, hashAlgorithm _dg.Hash) (_cb.SignatureHandler, error) {
	return &docTimeStamp{_bdeb: timestampServerURL, _bdfb: hashAlgorithm}, nil
}

// NewEtsiPAdESLevelBEcdsa creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewEtsiPAdESLevelB.
func NewEtsiPAdESLevelBEcdsa(privateKey *_af.PrivateKey, certificate *_cc.Certificate, caCert *_cc.Certificate) (_cb.SignatureHandler, error) {
	return &etsiPAdES{_bea: certificate, _bec: privateKey, _dda: caCert}, nil
}

func (_acb *etsiPAdES) buildCertChain(_fbb, _aec []*_cc.Certificate) ([]*_cc.Certificate, map[string]*_cc.Certificate, error) {
	_cce := map[string]*_cc.Certificate{}
	for _, _bbg := range _fbb {
		_cce[_bbg.Subject.CommonName] = _bbg
	}
	_dcb := _fbb
	for _, _dbd := range _aec {
		_ab := _dbd.Subject.CommonName
		if _, _ebg := _cce[_ab]; _ebg {
			continue
		}
		_cce[_ab] = _dbd
		_dcb = append(_dcb, _dbd)
	}
	if len(_dcb) == 0 {
		return nil, nil, _cb.ErrSignNoCertificates
	}
	var _fd error
	for _agg := _dcb[0]; _agg != nil && !_acb.CertClient.IsCA(_agg); {
		var _bge *_cc.Certificate
		_, _ggdg := _cce[_agg.Issuer.CommonName]
		if !_ggdg {
			if _bge, _fd = _acb.CertClient.GetIssuer(_agg); _fd != nil {
				_fc.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076", _fd)
				break
			}
			_cce[_agg.Issuer.CommonName] = _bge
			_dcb = append(_dcb, _bge)
		} else {
			break
		}
		_agg = _bge
	}
	return _dcb, _cce, nil
}

// Validate validates PdfSignature.
func (_bbgd *etsiPAdES) Validate(sig *_cb.PdfSignature, digest _cb.Hasher) (_cb.SignatureValidationResult, error) {
	_ceb := sig.Contents.Bytes()
	_abf, _cddc := _afb.Parse(_ceb)
	if _cddc != nil {
		return _cb.SignatureValidationResult{}, _cddc
	}
	_efdc, _feda := digest.(*_eb.Buffer)
	if !_feda {
		return _cb.SignatureValidationResult{}, _ac.Errorf("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073")
	}
	_abf.Content = _efdc.Bytes()
	if _cddc = _abf.Verify(); _cddc != nil {
		return _cb.SignatureValidationResult{}, _cddc
	}
	_cbfa := false
	_ebac := false
	var _dfb _c.Time
	for _, _beb := range _abf.Signers {
		_cece := _beb.EncryptedDigest
		var _ebf RevocationInfoArchival
		_cddc = _abf.UnmarshalSignedAttribute(_afb.OIDAttributeAdobeRevocation, &_ebf)
		if _cddc == nil {
			if len(_ebf.Crl) > 0 {
				_ebac = true
			}
			if len(_ebf.Ocsp) > 0 {
				_cbfa = true
			}
		}
		for _, _gdd := range _beb.UnauthenticatedAttributes {
			if _gdd.Type.Equal(_afb.OIDAttributeTimeStampToken) {
				_ecg, _ceg := _ee.Parse(_gdd.Value.Bytes)
				if _ceg != nil {
					return _cb.SignatureValidationResult{}, _ceg
				}
				_dfb = _ecg.Time
				_ecb := _ecg.HashAlgorithm.New()
				_ecb.Write(_cece)
				if !_eb.Equal(_ecb.Sum(nil), _ecg.HashedMessage) {
					return _cb.SignatureValidationResult{}, _ac.Errorf("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037")
				}
				break
			}
		}
	}
	_cfe := _cb.SignatureValidationResult{IsSigned: true, IsVerified: true, IsCrlFound: _ebac, IsOcspFound: _cbfa, GeneralizedTime: _dfb}
	return _cfe, nil
}

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts(certificate *_cc.Certificate, signFunc SignFunc, opts *AdobeX509RSASHA1Opts) (_cb.SignatureHandler, error) {
	if opts == nil {
		opts = &AdobeX509RSASHA1Opts{}
	}
	return &adobeX509RSASHA1{_dgbf: certificate, _egg: signFunc, _aga: opts.EstimateSize, _bgd: opts.Algorithm}, nil
}

// InitSignature initialises the PdfSignature.
func (_adf *adobePKCS7Detached) InitSignature(sig *_cb.PdfSignature) error {
	if !_adf._bfee {
		if _adf._afbbb == nil {
			return _a.New("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c")
		}
		if _adf._gca == nil {
			return _a.New("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c")
		}
	}
	_dcc := *_adf
	sig.Handler = &_dcc
	sig.Filter = _bf.MakeName("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")
	sig.SubFilter = _bf.MakeName("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064")
	sig.Reference = nil
	_cba, _bcb := _dcc.NewDigest(sig)
	if _bcb != nil {
		return _bcb
	}
	_cba.Write([]byte("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"))
	return _dcc.Sign(sig, _cba)
}

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gfe *adobeX509RSASHA1) IsApplicable(sig *_cb.PdfSignature) bool {
	if sig == nil || sig.Filter == nil || sig.SubFilter == nil {
		return false
	}
	return (*sig.Filter == "A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053" || *sig.Filter == "\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065") && *sig.SubFilter == "\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031"
}

type adobeX509RSASHA1 struct {
	_cfgg *_ed.PrivateKey
	_dgbf *_cc.Certificate
	_egg  SignFunc
	_aga  bool
	_bgd  _dg.Hash
}

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct {

	// SignatureSize is the estimated size of the signature contents in bytes.
	// If not provided, a default signature size of 4192 is used.
	// The signing process will report the model.ErrSignNotEnoughSpace error
	// if the estimated signature size is smaller than the actual size of the
	// signature.
	SignatureSize int

	// Client is the timestamp client used to make the signature request.
	// If no client is provided, a default one is used.
	Client *_ga.TimestampClient
}

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_dba *etsiPAdES) IsApplicable(sig *_cb.PdfSignature) bool {
	if sig == nil || sig.Filter == nil || sig.SubFilter == nil {
		return false
	}
	return (*sig.Filter == "\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065") && *sig.SubFilter == "\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064"
}

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom(certificate *_cc.Certificate, signFunc SignFunc) (_cb.SignatureHandler, error) {
	return &adobeX509RSASHA1{_dgbf: certificate, _egg: signFunc}, nil
}

func (_ccf *etsiPAdES) getCRLs(_ddf []*_cc.Certificate) ([][]byte, error) {
	_cgg := make([][]byte, 0, len(_ddf))
	for _, _fef := range _ddf {
		for _, _dc := range _fef.CRLDistributionPoints {
			if _ccf.CertClient.IsCA(_fef) {
				continue
			}
			_dbe, _fbd := _ccf.CRLClient.MakeRequest(_dc, _fef)
			if _fbd != nil {
				_fc.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076", _fbd)
				continue
			}
			_cgg = append(_cgg, _dbe)
		}
	}
	return _cgg, nil
}

func (_faf *etsiPAdES) makeTimestampRequest(_df string, _de []byte) (_ge.RawValue, error) {
	_ace := _dg.SHA512.New()
	_ace.Write(_de)
	_efd := _ace.Sum(nil)
	_bfc := _ee.Request{HashAlgorithm: _dg.SHA512, HashedMessage: _efd, Certificates: true, Extensions: nil, ExtraExtensions: nil}
	_gbec := _ga.NewTimestampClient()
	_efb, _fcb := _gbec.GetEncodedToken(_df, &_bfc)
	if _fcb != nil {
		return _ge.NullRawValue, _fcb
	}
	return _ge.RawValue{FullBytes: _efb}, nil
}

// Sign adds a new reference to signature's references array.
func (_dgg *DocMDPHandler) Sign(sig *_cb.PdfSignature, digest _cb.Hasher) error {
	return _dgg._edd.Sign(sig, digest)
}

// NewDigest creates a new digest.
func (_bagg *adobeX509RSASHA1) NewDigest(sig *_cb.PdfSignature) (_cb.Hasher, error) {
	if _bebf, _gdb := _bagg.getHashAlgorithm(sig); _bebf != 0 && _gdb == nil {
		return _bebf.New(), nil
	}
	return _bdf.New(), nil
}

// NewAdobePKCS7DetachedEcdsa creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewAdobePKCS7Detached.
func NewAdobePKCS7DetachedEcdsa(privateKey *_af.PrivateKey, certificate *_cc.Certificate) (_cb.SignatureHandler, error) {
	return &adobePKCS7Detached{_afbbb: certificate, _gca: privateKey}, nil
}

// NewDigest creates a new digest.
func (_gaa *adobePKCS7Detached) NewDigest(sig *_cb.PdfSignature) (_cb.Hasher, error) {
	return _eb.NewBuffer(nil), nil
}

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct {
	_edd       _cb.SignatureHandler
	Permission _ag.DocMDPPermission
}

type adobePKCS7Detached struct {
	_gca   _dg.PrivateKey
	_afbbb *_cc.Certificate
	_bfee  bool
	_fdb   int
}

// NewDigest creates a new digest.
func (_gf *DocMDPHandler) NewDigest(sig *_cb.PdfSignature) (_cb.Hasher, error) {
	return _gf._edd.NewDigest(sig)
}

func (_fac *adobeX509RSASHA1) getCertificate(_eaac *_cb.PdfSignature) (*_cc.Certificate, error) {
	if _fac._dgbf != nil {
		return _fac._dgbf, nil
	}
	_bafd, _aff := _eaac.GetCerts()
	if _aff != nil {
		return nil, _aff
	}
	return _bafd[0], nil
}

func (_gfc *etsiPAdES) addDss(_geeb, _feg []*_cc.Certificate, _aef *RevocationInfoArchival) (int, error) {
	_ddfe, _gbb, _fec := _gfc.buildCertChain(_geeb, _feg)
	if _fec != nil {
		return 0, _fec
	}
	_afgb, _fec := _gfc.getCerts(_ddfe)
	if _fec != nil {
		return 0, _fec
	}
	var _cdf, _bac [][]byte
	if _gfc.OCSPClient != nil {
		_cdf, _fec = _gfc.getOCSPs(_ddfe, _gbb)
		if _fec != nil {
			return 0, _fec
		}
	}
	if _gfc.CRLClient != nil {
		_bac, _fec = _gfc.getCRLs(_ddfe)
		if _fec != nil {
			return 0, _fec
		}
	}
	if !_gfc._aaa {
		_, _fec = _gfc._bff.AddCerts(_afgb)
		if _fec != nil {
			return 0, _fec
		}
		_, _fec = _gfc._bff.AddOCSPs(_cdf)
		if _fec != nil {
			return 0, _fec
		}
		_, _fec = _gfc._bff.AddCRLs(_bac)
		if _fec != nil {
			return 0, _fec
		}
	}
	_becg := 0
	for _, _fcf := range _bac {
		_becg += len(_fcf)
		_aef.Crl = append(_aef.Crl, _ge.RawValue{FullBytes: _fcf})
	}
	for _, _gff := range _cdf {
		_becg += len(_gff)
		_aef.Ocsp = append(_aef.Ocsp, _ge.RawValue{FullBytes: _gff})
	}
	return _becg, nil
}

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached(privateKey *_ed.PrivateKey, certificate *_cc.Certificate) (_cb.SignatureHandler, error) {
	return &adobePKCS7Detached{_afbbb: certificate, _gca: privateKey}, nil
}

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct {
	Crl          []_ge.RawValue `asn1:"explicit,tag:0,optional"`
	Ocsp         []_ge.RawValue `asn1:"explicit,tag:1,optional"`
	OtherRevInfo []_ge.RawValue `asn1:"explicit,tag:2,optional"`
}

func _dga(_ceag *_ed.PublicKey, _cdc []byte) _dg.Hash {
	_dedb := _ceag.Size()
	if _dedb != len(_cdc) {
		return 0
	}
	_fgf := func(_deb *_d.Int, _ddaa *_ed.PublicKey, _fgb *_d.Int) *_d.Int {
		_cbc := _d.NewInt(int64(_ddaa.E))
		_deb.Exp(_fgb, _cbc, _ddaa.N)
		return _deb
	}
	_beca := new(_d.Int).SetBytes(_cdc)
	_geg := _fgf(new(_d.Int), _ceag, _beca)
	_abb := _ffg(_geg.Bytes(), _dedb)
	if _abb[0] != 0 || _abb[1] != 1 {
		return 0
	}
	_eacd := []struct {
		Hash   _dg.Hash
		Prefix []byte
	}{{Hash: _dg.SHA1, Prefix: []byte{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14}}, {Hash: _dg.SHA256, Prefix: []byte{0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20}}, {Hash: _dg.SHA384, Prefix: []byte{0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30}}, {Hash: _dg.SHA512, Prefix: []byte{0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40}}, {Hash: _dg.RIPEMD160, Prefix: []byte{0x30, 0x20, 0x30, 0x08, 0x06, 0x06, 0x28, 0xcf, 0x06, 0x03, 0x00, 0x31, 0x04, 0x14}}}
	for _, _gbc := range _eacd {
		_afa := _gbc.Hash.Size()
		_cfad := len(_gbc.Prefix) + _afa
		if _eb.Equal(_abb[_dedb-_cfad:_dedb-_afa], _gbc.Prefix) {
			return _gbc.Hash
		}
	}
	return 0
}

func _ffg(_bbgb []byte, _faab int) (_fge []byte) {
	_da := len(_bbgb)
	if _da > _faab {
		_da = _faab
	}
	_fge = make([]byte, _faab)
	copy(_fge[len(_fge)-_da:], _bbgb)
	return
}

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT(privateKey *_ed.PrivateKey, certificate *_cc.Certificate, caCert *_cc.Certificate, certificateTimestampServerURL string) (_cb.SignatureHandler, error) {
	return &etsiPAdES{_bea: certificate, _bec: privateKey, _dda: caCert, _gfb: certificateTimestampServerURL}, nil
}

// NewEtsiPAdESLevelLTEcdsa creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewEtsiPAdESLevelLT.
func NewEtsiPAdESLevelLTEcdsa(privateKey *_af.PrivateKey, certificate *_cc.Certificate, caCert *_cc.Certificate, certificateTimestampServerURL string, appender *_cb.PdfAppender) (_cb.SignatureHandler, error) {
	_baf := appender.Reader.DSS
	if _baf == nil {
		_baf = _cb.NewDSS()
	}
	if _ggg := _baf.GenerateHashMaps(); _ggg != nil {
		return nil, _ggg
	}
	return &etsiPAdES{_bea: certificate, _bec: privateKey, _dda: caCert, _gfb: certificateTimestampServerURL, CertClient: _ga.NewCertClient(), OCSPClient: _ga.NewOCSPClient(), CRLClient: _ga.NewCRLClient(), _afg: appender, _bff: _baf}, nil
}

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func(_agc *_cb.PdfSignature, _aca _cb.Hasher) ([]byte, error)

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT(privateKey *_ed.PrivateKey, certificate *_cc.Certificate, caCert *_cc.Certificate, certificateTimestampServerURL string, appender *_cb.PdfAppender) (_cb.SignatureHandler, error) {
	_bfg := appender.Reader.DSS
	if _bfg == nil {
		_bfg = _cb.NewDSS()
	}
	if _be := _bfg.GenerateHashMaps(); _be != nil {
		return nil, _be
	}
	return &etsiPAdES{_bea: certificate, _bec: privateKey, _dda: caCert, _gfb: certificateTimestampServerURL, CertClient: _ga.NewCertClient(), OCSPClient: _ga.NewOCSPClient(), CRLClient: _ga.NewCRLClient(), _afg: appender, _bff: _bfg}, nil
}

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_aba *docTimeStamp) IsApplicable(sig *_cb.PdfSignature) bool {
	if sig == nil || sig.Filter == nil || sig.SubFilter == nil {
		return false
	}
	return (*sig.Filter == "A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053" || *sig.Filter == "\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065") && *sig.SubFilter == "\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031"
}

// Sign sets the Contents fields for the PdfSignature.
func (_fca *etsiPAdES) Sign(sig *_cb.PdfSignature, digest _cb.Hasher) error {
	_bbf, _gbea := digest.(*_eb.Buffer)
	if !_gbea {
		return _ac.Errorf("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073")
	}
	_ebe, _ecf := _afb.NewSignedData(_bbf.Bytes())
	if _ecf != nil {
		return _ecf
	}
	_ebe.SetDigestAlgorithm(_afb.OIDDigestAlgorithmSHA256)
	_cbd := _afb.SignerInfoConfig{}
	_cfa := _dg.SHA256.New()
	_cfa.Write(_fca._bea.Raw)
	var _cda struct {
		Seq struct{ Seq struct{ Value []byte } }
	}
	_cda.Seq.Seq.Value = _cfa.Sum(nil)
	var _afbd []*_cc.Certificate
	var _fbdg []*_cc.Certificate
	if _fca._dda != nil {
		_fbdg = []*_cc.Certificate{_fca._dda}
	}
	_fed := RevocationInfoArchival{Crl: []_ge.RawValue{}, Ocsp: []_ge.RawValue{}, OtherRevInfo: []_ge.RawValue{}}
	_cgb := 0
	if _fca._afg != nil && len(_fca._gfb) > 0 {
		_fbdf, _cdd := _fca.makeTimestampRequest(_fca._gfb, ([]byte)(""))
		if _cdd != nil {
			return _cdd
		}
		_eab, _cdd := _ee.Parse(_fbdf.FullBytes)
		if _cdd != nil {
			return _cdd
		}
		_afbd = append(_afbd, _eab.Certificates...)
	}
	if _fca._afg != nil {
		_eabd, _gdg := _fca.addDss([]*_cc.Certificate{_fca._bea}, _fbdg, &_fed)
		if _gdg != nil {
			return _gdg
		}
		_cgb += _eabd
		if len(_afbd) > 0 {
			_eabd, _gdg = _fca.addDss(_afbd, nil, &_fed)
			if _gdg != nil {
				return _gdg
			}
			_cgb += _eabd
		}
		if !_fca._aaa {
			_fca._afg.SetDSS(_fca._bff)
		}
	}
	_cbd.ExtraSignedAttributes = append(_cbd.ExtraSignedAttributes, _afb.Attribute{Type: _afb.OIDAttributeSigningCertificateV2, Value: _cda}, _afb.Attribute{Type: _afb.OIDAttributeAdobeRevocation, Value: _fed})
	if _cfg := _ebe.AddSignerChainPAdES(_fca._bea, _fca._bec, _fbdg, _cbd); _cfg != nil {
		return _cfg
	}
	_ebe.Detach()
	if len(_fca._gfb) > 0 {
		_bab := _ebe.GetSignedData().SignerInfos[0].EncryptedDigest
		_bfe, _bde := _fca.makeTimestampRequest(_fca._gfb, _bab)
		if _bde != nil {
			return _bde
		}
		_bde = _ebe.AddTimestampTokenToSigner(0, _bfe.FullBytes)
		if _bde != nil {
			return _bde
		}
	}
	_ddc, _ecf := _ebe.Finish()
	if _ecf != nil {
		return _ecf
	}
	const _ccfe = 1024
	_dec := (len(_ddc) / _ccfe) + 2
	_edf := make([]byte, _ccfe*_dec+_cgb)
	copy(_edf, _ddc)
	sig.Contents = _bf.MakeHexString(string(_edf))
	if !_fca._aaa && _fca._bff != nil {
		_cfa = _dg.SHA1.New()
		_cfa.Write(_edf)
		_bbgc := _gb.ToUpper(_bc.EncodeToString(_cfa.Sum(nil)))
		if _bbgc != "" {
			_fca._bff.VRI[_bbgc] = &_cb.VRI{Cert: _fca._bff.Certs, OCSP: _fca._bff.OCSPs, CRL: _fca._bff.CRLs}
		}
		_fca._afg.SetDSS(_fca._bff)
	}
	return nil
}

func (_fdd *adobeX509RSASHA1) sign(_efde *_cb.PdfSignature, _caa _cb.Hasher, _aeg bool) error {
	if !_aeg {
		return _fdd.Sign(_efde, _caa)
	}
	_agea, _fade := _fdd._dgbf.PublicKey.(*_ed.PublicKey)
	if !_fade {
		return _ac.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054", _agea)
	}
	_bagc, _egf := _ge.Marshal(make([]byte, _agea.Size()))
	if _egf != nil {
		return _egf
	}
	_efde.Contents = _bf.MakeHexString(string(_bagc))
	return nil
}

// NewEtsiPAdESLevelTEcdsa creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
// ECDSA keys are supported by PDF version >= 2.0, for earlier versions use NewEtsiPAdESLevelT.
func NewEtsiPAdESLevelTEcdsa(privateKey *_af.PrivateKey, certificate *_cc.Certificate, caCert *_cc.Certificate, certificateTimestampServerURL string) (_cb.SignatureHandler, error) {
	return &etsiPAdES{_bea: certificate, _bec: privateKey, _dda: caCert, _gfb: certificateTimestampServerURL}, nil
}

// Validate validates PdfSignature.
func (_cea *adobeX509RSASHA1) Validate(sig *_cb.PdfSignature, digest _cb.Hasher) (_cb.SignatureValidationResult, error) {
	_gab, _ddab := _cea.getCertificate(sig)
	if _ddab != nil {
		return _cb.SignatureValidationResult{}, _ddab
	}
	_gdc := sig.Contents.Bytes()
	var _edfe []byte
	if _, _cfc := _ge.Unmarshal(_gdc, &_edfe); _cfc != nil {
		return _cb.SignatureValidationResult{}, _cfc
	}
	_fab, _cde := digest.(_b.Hash)
	if !_cde {
		return _cb.SignatureValidationResult{}, _a.New("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_dgf, _ := _cea.getHashAlgorithm(sig)
	if _dgf == 0 {
		_dgf = _bdf
	}
	if _bbd := _ed.VerifyPKCS1v15(_gab.PublicKey.(*_ed.PublicKey), _dgf, _fab.Sum(nil), _edfe); _bbd != nil {
		return _cb.SignatureValidationResult{}, _bbd
	}
	return _cb.SignatureValidationResult{IsSigned: true, IsVerified: true}, nil
}

// Validate validates PdfSignature.
func (_fafc *adobePKCS7Detached) Validate(sig *_cb.PdfSignature, digest _cb.Hasher) (_cb.SignatureValidationResult, error) {
	_cgbe := sig.Contents.Bytes()
	_dgde, _gag := _afb.Parse(_cgbe)
	if _gag != nil {
		return _cb.SignatureValidationResult{}, _gag
	}
	_adc, _bee := digest.(*_eb.Buffer)
	if !_bee {
		return _cb.SignatureValidationResult{}, _ac.Errorf("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073")
	}
	_dgde.Content = _adc.Bytes()
	if _gag = _dgde.Verify(); _gag != nil {
		return _cb.SignatureValidationResult{}, _gag
	}
	return _cb.SignatureValidationResult{IsSigned: true, IsVerified: true}, nil
}

// Validate validates PdfSignature.
func (_ecd *docTimeStamp) Validate(sig *_cb.PdfSignature, digest _cb.Hasher) (_cb.SignatureValidationResult, error) {
	_bad := sig.Contents.Bytes()
	_cdea, _abe := _afb.Parse(_bad)
	if _abe != nil {
		return _cb.SignatureValidationResult{}, _abe
	}
	if _abe = _cdea.Verify(); _abe != nil {
		return _cb.SignatureValidationResult{}, _abe
	}
	var _fbdfg timestampInfo
	_, _abe = _ge.Unmarshal(_cdea.Content, &_fbdfg)
	if _abe != nil {
		return _cb.SignatureValidationResult{}, _abe
	}
	_eae, _abe := _ccb(_fbdfg.MessageImprint.HashAlgorithm.Algorithm)
	if _abe != nil {
		return _cb.SignatureValidationResult{}, _abe
	}
	_daa := _eae.New()
	_eca, _cee := digest.(*_eb.Buffer)
	if !_cee {
		return _cb.SignatureValidationResult{}, _ac.Errorf("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073")
	}
	_daa.Write(_eca.Bytes())
	_ffc := _daa.Sum(nil)
	_beagd := _cb.SignatureValidationResult{IsSigned: true, IsVerified: _eb.Equal(_ffc, _fbdfg.MessageImprint.HashedMessage), GeneralizedTime: _fbdfg.GeneralizedTime}
	return _beagd, nil
}

// Sign sets the Contents fields for the PdfSignature.
func (_bbc *adobeX509RSASHA1) Sign(sig *_cb.PdfSignature, digest _cb.Hasher) error {
	var _ddfa []byte
	var _faff error
	if _bbc._egg != nil {
		_ddfa, _faff = _bbc._egg(sig, digest)
		if _faff != nil {
			return _faff
		}
	} else {
		_eddf, _gdf := digest.(_b.Hash)
		if !_gdf {
			return _a.New("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_dcd := _bdf
		if _bbc._bgd != 0 {
			_dcd = _bbc._bgd
		}
		_ddfa, _faff = _ed.SignPKCS1v15(_f.Reader, _bbc._cfgg, _dcd, _eddf.Sum(nil))
		if _faff != nil {
			return _faff
		}
	}
	_ddfa, _faff = _ge.Marshal(_ddfa)
	if _faff != nil {
		return _faff
	}
	sig.Contents = _bf.MakeHexString(string(_ddfa))
	return nil
}

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_dd *DocMDPHandler) ValidateWithOpts(sig *_cb.PdfSignature, digest _cb.Hasher, params _cb.SignatureHandlerDocMDPParams) (_cb.SignatureValidationResult, error) {
	_ec, _bd := _dd._edd.Validate(sig, digest)
	if _bd != nil {
		return _ec, _bd
	}
	_ba := params.Parser
	if _ba == nil {
		return _cb.SignatureValidationResult{}, _a.New("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c")
	}
	if !_ec.IsVerified {
		return _ec, nil
	}
	_adb := params.DiffPolicy
	if _adb == nil {
		_adb = _ag.NewDefaultDiffPolicy()
	}
	for _gad := 0; _gad <= _ba.GetRevisionNumber(); _gad++ {
		_bb, _fe := _ba.GetRevision(_gad)
		if _fe != nil {
			return _cb.SignatureValidationResult{}, _fe
		}
		_dge := _bb.GetTrailer()
		if _dge == nil {
			return _cb.SignatureValidationResult{}, _a.New("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074")
		}
		_age, _fbe := _bf.GetDict(_dge.Get("\u0052\u006f\u006f\u0074"))
		if !_fbe {
			return _cb.SignatureValidationResult{}, _a.New("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t")
		}
		_cbf, _fbe := _bf.GetDict(_age.Get("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"))
		if !_fbe {
			continue
		}
		_bbb, _fbe := _bf.GetArray(_cbf.Get("\u0046\u0069\u0065\u006c\u0064\u0073"))
		if !_fbe {
			continue
		}
		for _, _ca := range _bbb.Elements() {
			_ea, _gd := _bf.GetDict(_ca)
			if !_gd {
				continue
			}
			_gce, _gd := _bf.GetDict(_ea.Get("\u0056"))
			if !_gd {
				continue
			}
			if _bf.EqualObjects(_gce.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"), sig.Contents) {
				_ec.DiffResults, _fe = _adb.ReviewFile(_bb, _ba, &_ag.MDPParameters{DocMDPLevel: _dd.Permission})
				if _fe != nil {
					return _cb.SignatureValidationResult{}, _fe
				}
				_ec.IsVerified = _ec.DiffResults.IsPermitted()
				return _ec, nil
			}
		}
	}
	return _cb.SignatureValidationResult{}, _a.New("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073")
}

// InitSignature initialises the PdfSignature.
func (_dgba *docTimeStamp) InitSignature(sig *_cb.PdfSignature) error {
	_dfd := *_dgba
	sig.Type = _bf.MakeName("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070")
	sig.Handler = &_dfd
	sig.Filter = _bf.MakeName("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")
	sig.SubFilter = _bf.MakeName("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031")
	sig.Reference = nil
	if _dgba._acbg > 0 {
		sig.Contents = _bf.MakeHexString(string(make([]byte, _dgba._acbg)))
	} else {
		_dcbf, _fag := _dgba.NewDigest(sig)
		if _fag != nil {
			return _fag
		}
		_dcbf.Write([]byte("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"))
		if _fag = _dfd.Sign(sig, _dcbf); _fag != nil {
			return _fag
		}
		_dgba._acbg = _dfd._acbg
	}
	return nil
}

type docTimeStamp struct {
	_bdeb string
	_bdfb _dg.Hash
	_acbg int
	_adef *_ga.TimestampClient
}

// InitSignature initialization of the DocMDP signature.
func (_ce *DocMDPHandler) InitSignature(sig *_cb.PdfSignature) error {
	_acc := _ce._edd.InitSignature(sig)
	if _acc != nil {
		return _acc
	}
	sig.Handler = _ce
	if sig.Reference == nil {
		sig.Reference = _bf.MakeArray()
	}
	sig.Reference.Append(_cb.NewPdfSignatureReferenceDocMDP(_cb.NewPdfTransformParamsDocMDP(_ce.Permission)).ToPdfObject())
	return nil
}

// NewDigest creates a new digest.
func (_fdc *etsiPAdES) NewDigest(_ *_cb.PdfSignature) (_cb.Hasher, error) {
	return _eb.NewBuffer(nil), nil
}

const _bdf = _dg.SHA1

// InitSignature initialises the PdfSignature.
func (_eg *etsiPAdES) InitSignature(sig *_cb.PdfSignature) error {
	if !_eg._afbb {
		if _eg._bea == nil {
			return _a.New("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c")
		}
		if _eg._bec == nil {
			return _a.New("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c")
		}
	}
	_eaa := *_eg
	sig.Handler = &_eaa
	sig.Filter = _bf.MakeName("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")
	sig.SubFilter = _bf.MakeName("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064")
	sig.Reference = nil
	_gbd, _ced := _eaa.NewDigest(sig)
	if _ced != nil {
		return _ced
	}
	_, _ced = _gbd.Write([]byte("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"))
	if _ced != nil {
		return _ced
	}
	_eaa._aaa = true
	_ced = _eaa.Sign(sig, _gbd)
	_eaa._aaa = false
	return _ced
}

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fa *DocMDPHandler) IsApplicable(sig *_cb.PdfSignature) bool {
	_fad := false
	for _, _bg := range sig.Reference.Elements() {
		if _gbe, _ad := _bf.GetDict(_bg); _ad {
			if _aa, _ef := _bf.GetNameVal(_gbe.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064")); _ef {
				if _aa != "\u0044\u006f\u0063\u004d\u0044\u0050" {
					return false
				}
				if _gc, _cg := _bf.GetDict(_gbe.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073")); _cg {
					_, _fg := _bf.GetNumberAsInt64(_gc.Get("\u0050"))
					if _fg != nil {
						return false
					}
					_fad = true
					break
				}
			}
		}
	}
	return _fad && _fa._edd.IsApplicable(sig)
}

// Sign sets the Contents fields.
func (_dfbc *adobePKCS7Detached) Sign(sig *_cb.PdfSignature, digest _cb.Hasher) error {
	if _dfbc._bfee {
		_fegg := _dfbc._fdb
		if _fegg <= 0 {
			_fegg = 8192
		}
		sig.Contents = _bf.MakeHexString(string(make([]byte, _fegg)))
		return nil
	}
	_beag, _fcae := digest.(*_eb.Buffer)
	if !_fcae {
		return _ac.Errorf("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073")
	}
	_agga, _cag := _afb.NewSignedData(_beag.Bytes())
	if _cag != nil {
		return _cag
	}
	if _eac := _agga.AddSigner(_dfbc._afbbb, _dfbc._gca, _afb.SignerInfoConfig{}); _eac != nil {
		return _eac
	}
	_agga.Detach()
	_aebd, _cag := _agga.Finish()
	if _cag != nil {
		return _cag
	}
	_ged := make([]byte, 8192)
	copy(_ged, _aebd)
	sig.Contents = _bf.MakeHexString(string(_ged))
	return nil
}

func (_bfge *etsiPAdES) getCerts(_eba []*_cc.Certificate) ([][]byte, error) {
	_fgc := make([][]byte, 0, len(_eba))
	for _, _dgd := range _eba {
		_fgc = append(_fgc, _dgd.Raw)
	}
	return _fgc, nil
}

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_efe *adobePKCS7Detached) IsApplicable(sig *_cb.PdfSignature) bool {
	if sig == nil || sig.Filter == nil || sig.SubFilter == nil {
		return false
	}
	return (*sig.Filter == "A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053" || *sig.Filter == "\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065") && *sig.SubFilter == "\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064"
}

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB(privateKey *_ed.PrivateKey, certificate *_cc.Certificate, caCert *_cc.Certificate) (_cb.SignatureHandler, error) {
	return &etsiPAdES{_bea: certificate, _bec: privateKey, _dda: caCert}, nil
}

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts(timestampServerURL string, hashAlgorithm _dg.Hash, opts *DocTimeStampOpts) (_cb.SignatureHandler, error) {
	if opts == nil {
		opts = &DocTimeStampOpts{}
	}
	if opts.SignatureSize <= 0 {
		opts.SignatureSize = 4192
	}
	return &docTimeStamp{_bdeb: timestampServerURL, _bdfb: hashAlgorithm, _acbg: opts.SignatureSize, _adef: opts.Client}, nil
}

// Sign sets the Contents fields for the PdfSignature.
func (_ecdf *docTimeStamp) Sign(sig *_cb.PdfSignature, digest _cb.Hasher) error {
	_dbaf, _egb := _ga.NewTimestampRequest(digest.(*_eb.Buffer), &_ee.RequestOptions{Hash: _ecdf._bdfb, Certificates: true})
	if _egb != nil {
		return _egb
	}
	_becf := _ecdf._adef
	if _becf == nil {
		_becf = _ga.NewTimestampClient()
	}
	_bce, _egb := _becf.GetEncodedToken(_ecdf._bdeb, _dbaf)
	if _egb != nil {
		return _egb
	}
	_eacb := len(_bce)
	if _ecdf._acbg > 0 && _eacb > _ecdf._acbg {
		return _cb.ErrSignNotEnoughSpace
	}
	if _eacb > 0 {
		_ecdf._acbg = _eacb + 128
	}
	if sig.Contents != nil {
		_acf := sig.Contents.Bytes()
		copy(_acf, _bce)
		_bce = _acf
	}
	sig.Contents = _bf.MakeHexString(string(_bce))
	return nil
}

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler(handler _cb.SignatureHandler, permission _ag.DocMDPPermission) (_cb.SignatureHandler, error) {
	return &DocMDPHandler{_edd: handler, Permission: permission}, nil
}

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_eaf *DocMDPHandler) Validate(sig *_cb.PdfSignature, digest _cb.Hasher) (_cb.SignatureValidationResult, error) {
	return _cb.SignatureValidationResult{}, _a.New("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065")
}

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached(signatureLen int) (_cb.SignatureHandler, error) {
	return &adobePKCS7Detached{_bfee: true, _fdb: signatureLen}, nil
}

type etsiPAdES struct {
	_bec  _dg.PrivateKey
	_bea  *_cc.Certificate
	_afbb bool
	_aaa  bool
	_dda  *_cc.Certificate
	_gfb  string

	// CertClient is the client used to retrieve certificates.
	CertClient *_ga.CertClient

	// OCSPClient is the client used to retrieve OCSP validation information.
	OCSPClient *_ga.OCSPClient

	// CRLClient is the client used to retrieve CRL validation information.
	CRLClient *_ga.CRLClient
	_afg      *_cb.PdfAppender
	_bff      *_cb.DSS
}

// NewDigest creates a new digest.
func (_dfc *docTimeStamp) NewDigest(sig *_cb.PdfSignature) (_cb.Hasher, error) {
	return _eb.NewBuffer(nil), nil
}

func _ccb(_dea _ge.ObjectIdentifier) (_dg.Hash, error) {
	switch {
	case _dea.Equal(_afb.OIDDigestAlgorithmSHA1), _dea.Equal(_afb.OIDDigestAlgorithmECDSASHA1), _dea.Equal(_afb.OIDDigestAlgorithmDSA), _dea.Equal(_afb.OIDDigestAlgorithmDSASHA1), _dea.Equal(_afb.OIDEncryptionAlgorithmRSA):
		return _dg.SHA1, nil
	case _dea.Equal(_afb.OIDDigestAlgorithmSHA256), _dea.Equal(_afb.OIDDigestAlgorithmECDSASHA256):
		return _dg.SHA256, nil
	case _dea.Equal(_afb.OIDDigestAlgorithmSHA384), _dea.Equal(_afb.OIDDigestAlgorithmECDSASHA384):
		return _dg.SHA384, nil
	case _dea.Equal(_afb.OIDDigestAlgorithmSHA512), _dea.Equal(_afb.OIDDigestAlgorithmECDSASHA512):
		return _dg.SHA512, nil
	}
	return _dg.Hash(0), _afb.ErrUnsupportedAlgorithm
}

func (_geec *docTimeStamp) getCertificate(_gae *_cb.PdfSignature) (*_cc.Certificate, error) {
	_gdfc, _ecef := _gae.GetCerts()
	if _ecef != nil {
		return nil, _ecef
	}
	return _gdfc[0], nil
}

// InitSignature initialises the PdfSignature.
func (_fbf *adobeX509RSASHA1) InitSignature(sig *_cb.PdfSignature) error {
	if _fbf._dgbf == nil {
		return _a.New("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c")
	}
	if _fbf._cfgg == nil && _fbf._egg == nil {
		return _a.New("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	}
	_dbb := *_fbf
	sig.Handler = &_dbb
	sig.Filter = _bf.MakeName("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")
	sig.SubFilter = _bf.MakeName("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031")
	sig.Cert = _bf.MakeString(string(_dbb._dgbf.Raw))
	sig.Reference = nil
	_bcc, _bbe := _dbb.NewDigest(sig)
	if _bbe != nil {
		return _bbe
	}
	_bcc.Write([]byte("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"))
	return _dbb.sign(sig, _bcc, _fbf._aga)
}

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1(privateKey *_ed.PrivateKey, certificate *_cc.Certificate) (_cb.SignatureHandler, error) {
	return &adobeX509RSASHA1{_dgbf: certificate, _cfgg: privateKey}, nil
}
