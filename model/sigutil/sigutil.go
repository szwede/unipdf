//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sigutil

import (
	_e "bytes"
	_ee "crypto"
	_df "crypto/x509"
	_g "encoding/asn1"
	_a "encoding/pem"
	_c "errors"
	_cb "fmt"
	_ac "github.com/szwede/unipdf/common"
	_acb "github.com/unidoc/timestamp"
	_cd "golang.org/x/crypto/ocsp"
	_d "io"
	_f "net/http"
	_bf "time"
)

// MakeRequest makes a CRL request to the specified server and returns the
// response. If a server URL is not provided, it is extracted from the certificate.
func (_gg *CRLClient) MakeRequest(serverURL string, cert *_df.Certificate) ([]byte, error) {
	if _gg.HTTPClient == nil {
		_gg.HTTPClient = _fde()
	}
	if serverURL == "" {
		if len(cert.CRLDistributionPoints) == 0 {
			return nil, _c.New("\u0063e\u0072\u0074i\u0066\u0069\u0063\u0061t\u0065\u0020\u0064o\u0065\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070ec\u0069\u0066\u0079 \u0061\u006ey\u0020\u0043\u0052\u004c\u0020\u0073e\u0072\u0076e\u0072\u0073")
		}
		serverURL = cert.CRLDistributionPoints[0]
	}
	_aaf, _dfg := _gg.HTTPClient.Get(serverURL)
	if _dfg != nil {
		return nil, _dfg
	}
	defer _aaf.Body.Close()
	_gde, _dfg := _d.ReadAll(_aaf.Body)
	if _dfg != nil {
		return nil, _dfg
	}
	if _ccg, _ := _a.Decode(_gde); _ccg != nil {
		_gde = _ccg.Bytes
	}
	return _gde, nil
}

// NewTimestampClient returns a new timestamp client.
func NewTimestampClient() *TimestampClient { return &TimestampClient{HTTPClient: _fde()} }

// GetIssuer retrieves the issuer of the provided certificate.
func (_aa *CertClient) GetIssuer(cert *_df.Certificate) (*_df.Certificate, error) {
	for _, _ec := range cert.IssuingCertificateURL {
		_ecb, _eba := _aa.Get(_ec)
		if _eba != nil {
			_ac.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0064\u006f\u0077\u006e\u006c\u006f\u0061\u0064\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0066\u006f\u0072\u0020\u0063\u0065\u0072\u0074\u0069\u0066ic\u0061\u0074\u0065\u0020\u0025\u0076\u003a\u0020\u0025\u0076", cert.Subject.CommonName, _eba)
			continue
		}
		return _ecb, nil
	}
	return nil, _cb.Errorf("\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063a\u0074e\u0020\u006e\u006f\u0074\u0020\u0066\u006fu\u006e\u0064")
}

// MakeRequest makes a OCSP request to the specified server and returns
// the parsed and raw responses. If a server URL is not provided, it is
// extracted from the certificate.
func (_dfb *OCSPClient) MakeRequest(serverURL string, cert, issuer *_df.Certificate) (*_cd.Response, []byte, error) {
	if _dfb.HTTPClient == nil {
		_dfb.HTTPClient = _fde()
	}
	if serverURL == "" {
		if len(cert.OCSPServer) == 0 {
			return nil, nil, _c.New("\u0063e\u0072\u0074i\u0066\u0069\u0063a\u0074\u0065\u0020\u0064\u006f\u0065\u0073 \u006e\u006f\u0074\u0020\u0073\u0070e\u0063\u0069\u0066\u0079\u0020\u0061\u006e\u0079\u0020\u004f\u0043S\u0050\u0020\u0073\u0065\u0072\u0076\u0065\u0072\u0073")
		}
		serverURL = cert.OCSPServer[0]
	}
	_ccgb, _eg := _cd.CreateRequest(cert, issuer, &_cd.RequestOptions{Hash: _dfb.Hash})
	if _eg != nil {
		return nil, nil, _eg
	}
	_gb, _eg := _dfb.HTTPClient.Post(serverURL, "\u0061p\u0070\u006c\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u006fc\u0073\u0070\u002d\u0072\u0065\u0071\u0075\u0065\u0073\u0074", _e.NewReader(_ccgb))
	if _eg != nil {
		return nil, nil, _eg
	}
	defer _gb.Body.Close()
	_eea, _eg := _d.ReadAll(_gb.Body)
	if _eg != nil {
		return nil, nil, _eg
	}
	if _cg, _ := _a.Decode(_eea); _cg != nil {
		_eea = _cg.Bytes
	}
	_ggf, _eg := _cd.ParseResponseForCert(_eea, cert, issuer)
	if _eg != nil {
		return nil, nil, _eg
	}
	return _ggf, _eea, nil
}

// GetEncodedToken executes the timestamp request and returns the DER encoded
// timestamp token bytes.
func (_dgd *TimestampClient) GetEncodedToken(serverURL string, req *_acb.Request) ([]byte, error) {
	if serverURL == "" {
		return nil, _cb.Errorf("\u006d\u0075\u0073\u0074\u0020\u0070r\u006f\u0076\u0069\u0064\u0065\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061m\u0070\u0020\u0073\u0065\u0072\u0076\u0065r\u0020\u0055\u0052\u004c")
	}
	if req == nil {
		return nil, _cb.Errorf("\u0074\u0069\u006de\u0073\u0074\u0061\u006dp\u0020\u0072\u0065\u0071\u0075\u0065\u0073t\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	_aafe, _ae := req.Marshal()
	if _ae != nil {
		return nil, _ae
	}
	_ebg, _ae := _f.NewRequest("\u0050\u004f\u0053\u0054", serverURL, _e.NewBuffer(_aafe))
	if _ae != nil {
		return nil, _ae
	}
	_ebg.Header.Set("\u0043\u006f\u006et\u0065\u006e\u0074\u002d\u0054\u0079\u0070\u0065", "a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079")
	if _dgd.BeforeHTTPRequest != nil {
		if _acd := _dgd.BeforeHTTPRequest(_ebg); _acd != nil {
			return nil, _acd
		}
	}
	_fbb := _dgd.HTTPClient
	if _fbb == nil {
		_fbb = _fde()
	}
	_dd, _ae := _fbb.Do(_ebg)
	if _ae != nil {
		return nil, _ae
	}
	defer _dd.Body.Close()
	_gc, _ae := _d.ReadAll(_dd.Body)
	if _ae != nil {
		return nil, _ae
	}
	if _dd.StatusCode != _f.StatusOK {
		return nil, _cb.Errorf("\u0075\u006e\u0065x\u0070\u0065\u0063\u0074e\u0064\u0020\u0048\u0054\u0054\u0050\u0020s\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0064", _dd.StatusCode)
	}
	var _ge struct {
		Version _g.RawValue
		Content _g.RawValue
	}
	if _, _ae = _g.Unmarshal(_gc, &_ge); _ae != nil {
		return nil, _ae
	}
	return _ge.Content.FullBytes, nil
}

// NewOCSPClient returns a new OCSP client.
func NewOCSPClient() *OCSPClient { return &OCSPClient{HTTPClient: _fde(), Hash: _ee.SHA1} }

// CRLClient represents a CRL (Certificate revocation list) client.
// It is used to request revocation data from CRL servers.
type CRLClient struct {

	// HTTPClient is the HTTP client used to make CRL requests.
	// By default, an HTTP client with a 5 second timeout per request is used.
	HTTPClient *_f.Client
}

// NewTimestampRequest returns a new timestamp request based
// on the specified options.
func NewTimestampRequest(body _d.Reader, opts *_acb.RequestOptions) (*_acb.Request, error) {
	if opts == nil {
		opts = &_acb.RequestOptions{}
	}
	if opts.Hash == 0 {
		opts.Hash = _ee.SHA256
	}
	if !opts.Hash.Available() {
		return nil, _df.ErrUnsupportedAlgorithm
	}
	_fd := opts.Hash.New()
	if _, _gdb := _d.Copy(_fd, body); _gdb != nil {
		return nil, _gdb
	}
	return &_acb.Request{HashAlgorithm: opts.Hash, HashedMessage: _fd.Sum(nil), Certificates: opts.Certificates, TSAPolicyOID: opts.TSAPolicyOID, Nonce: opts.Nonce}, nil
}

// CertClient represents a X.509 certificate client. Its primary purpose
// is to download certificates.
type CertClient struct {

	// HTTPClient is the HTTP client used to make certificate requests.
	// By default, an HTTP client with a 5 second timeout per request is used.
	HTTPClient *_f.Client
}

// Get retrieves the certificate at the specified URL.
func (_bd *CertClient) Get(url string) (*_df.Certificate, error) {
	if _bd.HTTPClient == nil {
		_bd.HTTPClient = _fde()
	}
	_gd, _fb := _bd.HTTPClient.Get(url)
	if _fb != nil {
		return nil, _fb
	}
	defer _gd.Body.Close()
	_cc, _fb := _d.ReadAll(_gd.Body)
	if _fb != nil {
		return nil, _fb
	}
	if _ff, _ := _a.Decode(_cc); _ff != nil {
		_cc = _ff.Bytes
	}
	_eb, _fb := _df.ParseCertificate(_cc)
	if _fb != nil {
		return nil, _fb
	}
	return _eb, nil
}

// IsCA returns true if the provided certificate appears to be a CA certificate.
func (_ecc *CertClient) IsCA(cert *_df.Certificate) bool {
	return cert.IsCA && _e.Equal(cert.RawIssuer, cert.RawSubject)
}

func _fde() *_f.Client { return &_f.Client{Timeout: 5 * _bf.Second} }

// OCSPClient represents a OCSP (Online Certificate Status Protocol) client.
// It is used to request revocation data from OCSP servers.
type OCSPClient struct {

	// HTTPClient is the HTTP client used to make OCSP requests.
	// By default, an HTTP client with a 5 second timeout per request is used.
	HTTPClient *_f.Client

	// Hash is the hash function  used when constructing the OCSP
	// requests. If zero, SHA-1 will be used.
	Hash _ee.Hash
}

// TimestampClient represents a RFC 3161 timestamp client.
// It is used to obtain signed tokens from timestamp authority servers.
type TimestampClient struct {

	// HTTPClient is the HTTP client used to make timestamp requests.
	// By default, an HTTP client with a 5 second timeout per request is used.
	HTTPClient *_f.Client

	// Callbacks.
	BeforeHTTPRequest func(_ag *_f.Request) error
}

// NewCRLClient returns a new CRL client.
func NewCRLClient() *CRLClient { return &CRLClient{HTTPClient: _fde()} }

// NewCertClient returns a new certificate client.
func NewCertClient() *CertClient { return &CertClient{HTTPClient: _fde()} }
