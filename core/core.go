//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core

import (
	_ge "bufio"
	_e "bytes"
	_df "compress/lzw"
	_deg "compress/zlib"
	_da "crypto/md5"
	_ed "crypto/rand"
	_fd "encoding/hex"
	_b "errors"
	_dg "fmt"
	_fdb "github.com/szwede/unipdf/common"
	_ad "github.com/szwede/unipdf/core/security"
	_bc "github.com/szwede/unipdf/core/security/crypt"
	_ac "github.com/szwede/unipdf/internal/ccittfax"
	_dfa "github.com/szwede/unipdf/internal/imageutil"
	_bb "github.com/szwede/unipdf/internal/jbig2"
	_gf "github.com/szwede/unipdf/internal/jbig2/bitmap"
	_ba "github.com/szwede/unipdf/internal/jbig2/decoder"
	_edc "github.com/szwede/unipdf/internal/jbig2/document"
	_fag "github.com/szwede/unipdf/internal/jbig2/errors"
	_fdf "github.com/szwede/unipdf/internal/precision"
	_fb "github.com/szwede/unipdf/internal/strutils"
	_ag "golang.org/x/image/tiff/lzw"
	_be "golang.org/x/text/unicode/bidi"
	_faf "golang.org/x/xerrors"
	_ff "image"
	_g "image/color"
	_fc "image/jpeg"
	_eed "io"
	_ee "os"
	_ef "reflect"
	_a "regexp"
	_de "sort"
	_d "strconv"
	_fa "strings"
	_bf "sync"
	_dd "time"
	_ea "unicode"
)

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder() *ASCII85Encoder { _cabff := &ASCII85Encoder{}; return _cabff }

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_egfg *PdfParser) ParseIndirectObject() (PdfObject, error) {
	_gcb := PdfIndirectObject{}
	_gcb._agfgc = _egfg
	_fdb.Log.Trace("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a")
	_beagcf, _dafd := _egfg._gggee.Peek(20)
	if _dafd != nil {
		if _dafd != _eed.EOF {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a")
			return &_gcb, _dafd
		}
	}
	_fdb.Log.Trace("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022", string(_beagcf))
	_fcab := _bgbge.FindStringSubmatchIndex(string(_beagcf))
	if len(_fcab) < 6 {
		if _dafd == _eed.EOF {
			return nil, _dafd
		}
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029", string(_beagcf))
		return &_gcb, _b.New("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065")
	}
	_egfg._gggee.Discard(_fcab[0])
	_fdb.Log.Trace("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064", _fcab)
	_bebf := _fcab[1] - _fcab[0]
	_dcdb := make([]byte, _bebf)
	_, _dafd = _egfg.ReadAtLeast(_dcdb, _bebf)
	if _dafd != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073", _dafd)
		return nil, _dafd
	}
	_fdb.Log.Trace("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073", _dcdb)
	_acga := _bgbge.FindStringSubmatch(string(_dcdb))
	if len(_acga) < 3 {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029", string(_dcdb))
		return &_gcb, _b.New("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065")
	}
	_afcf, _ := _d.Atoi(_acga[1])
	_gaee, _ := _d.Atoi(_acga[2])
	_gcb.ObjectNumber = int64(_afcf)
	_gcb.GenerationNumber = int64(_gaee)
	for {
		_bbed, _fgdf := _egfg._gggee.Peek(2)
		if _fgdf != nil {
			return &_gcb, _fgdf
		}
		_fdb.Log.Trace("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021", string(_bbed), string(_bbed))
		if IsWhiteSpace(_bbed[0]) {
			_egfg.skipSpaces()
		} else if _bbed[0] == '%' {
			_egfg.skipComments()
		} else if (_bbed[0] == '<') && (_bbed[1] == '<') {
			_fdb.Log.Trace("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074")
			_gcb.PdfObject, _fgdf = _egfg.ParseDict()
			_fdb.Log.Trace("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076", _fgdf)
			if _fgdf != nil {
				return &_gcb, _fgdf
			}
			_fdb.Log.Trace("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e")
		} else if (_bbed[0] == '/') || (_bbed[0] == '(') || (_bbed[0] == '[') || (_bbed[0] == '<') {
			_gcb.PdfObject, _fgdf = _egfg.parseObject()
			if _fgdf != nil {
				return &_gcb, _fgdf
			}
			_fdb.Log.Trace("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e")
		} else if _bbed[0] == ']' {
			_fdb.Log.Debug("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			_egfg._gggee.Discard(1)
		} else {
			if _bbed[0] == 'e' {
				_abffg, _aege := _egfg.readTextLine()
				if _aege != nil {
					return nil, _aege
				}
				if len(_abffg) >= 6 && _abffg[0:6] == "\u0065\u006e\u0064\u006f\u0062\u006a" {
					break
				}
			} else if _bbed[0] == 's' {
				_bbed, _ = _egfg._gggee.Peek(10)
				if string(_bbed[:6]) == "\u0073\u0074\u0072\u0065\u0061\u006d" {
					_dceab := 6
					if len(_bbed) > 6 {
						if IsWhiteSpace(_bbed[_dceab]) && _bbed[_dceab] != '\r' && _bbed[_dceab] != '\n' {
							_fdb.Log.Debug("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072")
							_egfg._afcb._fac = true
							_dceab++
						}
						switch _bbed[_dceab] {
						case '\r':
							_dceab++
							if _bbed[_dceab] == '\n' {
								_dceab++
							}
						case '\n':
							_dceab++
						default:
							_egfg._afcb._fac = true
						}
					}
					_egfg._gggee.Discard(_dceab)
					_bafd, _fcgbb := _gcb.PdfObject.(*PdfObjectDictionary)
					if !_fcgbb {
						return nil, _b.New("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
					}
					_fdb.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073", _bafd)
					_cecgg, _aecg := _egfg.traceStreamLength(_bafd.Get("\u004c\u0065\u006e\u0067\u0074\u0068"))
					if _aecg != nil {
						_fdb.Log.Debug("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076", _aecg)
						return nil, _aecg
					}
					_fdb.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073", _cecgg)
					_afec, _efeeae := _cecgg.(*PdfObjectInteger)
					if !_efeeae {
						return nil, _b.New("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072")
					}
					_cdcde := *_afec
					if _cdcde < 0 {
						return nil, _b.New("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
					}
					_bgbe := _egfg.GetFileOffset()
					_aedcf := _egfg.xrefNextObjectOffset(_bgbe)
					if _bgbe+int64(_cdcde) > _aedcf && _aedcf > _bgbe {
						_fdb.Log.Debug("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064", _bgbe+int64(_cdcde))
						_fdb.Log.Debug("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064", _aedcf)
						_baeb := _aedcf - _bgbe - 17
						if _baeb < 0 {
							return nil, _b.New("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073")
						}
						_fdb.Log.Debug("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e", _baeb)
						_cdcde = PdfObjectInteger(_baeb)
						_bafd.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(_baeb))
					}
					if int64(_cdcde) > _egfg._dbed {
						_fdb.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065")
						return nil, _b.New("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065")
					}
					_degea := make([]byte, _cdcde)
					_, _aecg = _egfg.ReadAtLeast(_degea, int(_cdcde))
					if _aecg != nil {
						_fdb.Log.Debug("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058", len(_degea), _degea)
						_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _aecg)
						return nil, _aecg
					}
					_gcffd := PdfObjectStream{}
					_gcffd.Stream = _degea
					_gcffd.PdfObjectDictionary = _gcb.PdfObject.(*PdfObjectDictionary)
					_gcffd.ObjectNumber = _gcb.ObjectNumber
					_gcffd.GenerationNumber = _gcb.GenerationNumber
					_gcffd.PdfObjectReference._agfgc = _egfg
					_egfg.skipSpaces()
					_egfg._gggee.Discard(9)
					_egfg.skipSpaces()
					return &_gcffd, nil
				}
			}
			_gcb.PdfObject, _fgdf = _egfg.parseObject()
			if _gcb.PdfObject == nil {
				_fdb.Log.Debug("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074")
				_gcb.PdfObject = MakeNull()
			}
			return &_gcb, _fgdf
		}
	}
	if _gcb.PdfObject == nil {
		_fdb.Log.Debug("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074")
		_gcb.PdfObject = MakeNull()
	}
	_fdb.Log.Trace("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021")
	return &_gcb, nil
}

func _ffbcg(_abbe *PdfObjectDictionary) (_deee *_dfa.ImageBase) {
	var (
		_ddcfa *PdfObjectInteger
		_aacaf bool
	)
	if _ddcfa, _aacaf = _abbe.Get("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger); _aacaf {
		_deee = &_dfa.ImageBase{Width: int(*_ddcfa)}
	} else {
		return nil
	}
	if _ddcfa, _aacaf = _abbe.Get("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger); _aacaf {
		_deee.Height = int(*_ddcfa)
	}
	if _ddcfa, _aacaf = _abbe.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger); _aacaf {
		_deee.BitsPerComponent = int(*_ddcfa)
	}
	if _ddcfa, _aacaf = _abbe.Get("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger); _aacaf {
		_deee.ColorComponents = int(*_ddcfa)
	}
	return _deee
}

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream(streamObj *PdfObjectStream) error {
	_fdb.Log.Trace("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
	_aaeg, _eage := NewEncoderFromStream(streamObj)
	if _eage != nil {
		_fdb.Log.Debug("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076", _eage)
		return _eage
	}
	if _efdd, _bdge := _aaeg.(*LZWEncoder); _bdge {
		_efdd.EarlyChange = 0
		streamObj.Set("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065", MakeInteger(0))
	}
	_fdb.Log.Trace("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a", _aaeg)
	_dcegc, _eage := _aaeg.EncodeBytes(streamObj.Stream)
	if _eage != nil {
		_fdb.Log.Debug("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076", _eage)
		return _eage
	}
	streamObj.Stream = _dcegc
	streamObj.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(int64(len(_dcegc))))
	return nil
}

// DecodeStream implements ASCII hex decoding.
func (_ebfc *ASCIIHexEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _ebfc.DecodeBytes(streamObj.Stream)
}

// UpdateParams updates the parameter values of the encoder.
func (_cbbd *RunLengthEncoder) UpdateParams(params *PdfObjectDictionary) {}

// UpdateParams updates the parameter values of the encoder.
func (_efdgb *DCTEncoder) UpdateParams(params *PdfObjectDictionary) {
	_dgfa, _dfab := GetNumberAsInt64(params.Get("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"))
	if _dfab == nil {
		_efdgb.ColorComponents = int(_dgfa)
	}
	_bfgg, _dfab := GetNumberAsInt64(params.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"))
	if _dfab == nil {
		_efdgb.BitsPerComponent = int(_bfgg)
	}
	_ccdbb, _dfab := GetNumberAsInt64(params.Get("\u0057\u0069\u0064t\u0068"))
	if _dfab == nil {
		_efdgb.Width = int(_ccdbb)
	}
	_gcff, _dfab := GetNumberAsInt64(params.Get("\u0048\u0065\u0069\u0067\u0068\u0074"))
	if _dfab == nil {
		_efdgb.Height = int(_gcff)
	}
	_gcaf, _dfab := GetNumberAsInt64(params.Get("\u0051u\u0061\u006c\u0069\u0074\u0079"))
	if _dfab == nil {
		_efdgb.Quality = int(_gcaf)
	}
	_eefc, _gada := GetArray(params.Get("\u0044\u0065\u0063\u006f\u0064\u0065"))
	if _gada {
		_efdgb.Decode, _dfab = _eefc.ToFloat64Array()
		if _dfab != nil {
			_fdb.Log.Error("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076", _dfab)
		}
	}
}

func _bdded(_fbbg string) (PdfObjectReference, error) {
	_bgff := PdfObjectReference{}
	_bbabd := _gbbc.FindStringSubmatch(_fbbg)
	if len(_bbabd) < 3 {
		_fdb.Log.Debug("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
		return _bgff, _b.New("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e")
	}
	_ffee, _ := _d.Atoi(_bbabd[1])
	_afcd, _ := _d.Atoi(_bbabd[2])
	_bgff.ObjectNumber = int64(_ffee)
	_bgff.GenerationNumber = int64(_afcd)
	return _bgff, nil
}

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_ddff *DCTEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_bfac := _e.NewReader(encoded)
	_aae, _gecf := _fc.Decode(_bfac)
	if _gecf != nil {
		_fdb.Log.Debug("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073", _gecf)
		return nil, _gecf
	}
	_gadab := _aae.Bounds()
	var _gbbg = make([]byte, _gadab.Dx()*_gadab.Dy()*_ddff.ColorComponents*_ddff.BitsPerComponent/8)
	_fgfaf := 0
	switch _ddff.ColorComponents {
	case 1:
		_agcb := []float64{_ddff.Decode[0], _ddff.Decode[1]}
		for _ffcc := _gadab.Min.Y; _ffcc < _gadab.Max.Y; _ffcc++ {
			for _gdbg := _gadab.Min.X; _gdbg < _gadab.Max.X; _gdbg++ {
				_caag := _aae.At(_gdbg, _ffcc)
				if _ddff.BitsPerComponent == 16 {
					_abcd, _cbe := _caag.(_g.Gray16)
					if !_cbe {
						return nil, _b.New("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
					}
					_fgde := _gbff(uint(_abcd.Y>>8), _agcb[0], _agcb[1])
					_acec := _gbff(uint(_abcd.Y), _agcb[0], _agcb[1])
					_gbbg[_fgfaf] = byte(_fgde)
					_fgfaf++
					_gbbg[_fgfaf] = byte(_acec)
					_fgfaf++
				} else {
					_fdfd, _gead := _caag.(_g.Gray)
					if !_gead {
						return nil, _b.New("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
					}
					_gbbg[_fgfaf] = byte(_gbff(uint(_fdfd.Y), _agcb[0], _agcb[1]))
					_fgfaf++
				}
			}
		}
	case 3:
		_aece := []float64{_ddff.Decode[0], _ddff.Decode[1]}
		_ecbe := []float64{_ddff.Decode[2], _ddff.Decode[3]}
		_cfeb := []float64{_ddff.Decode[4], _ddff.Decode[5]}
		for _cadg := _gadab.Min.Y; _cadg < _gadab.Max.Y; _cadg++ {
			for _ggaa := _gadab.Min.X; _ggaa < _gadab.Max.X; _ggaa++ {
				_eedb := _aae.At(_ggaa, _cadg)
				if _ddff.BitsPerComponent == 16 {
					_fbba, _efabc := _eedb.(_g.RGBA64)
					if !_efabc {
						return nil, _b.New("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
					}
					_gbbf := _gbff(uint(_fbba.R>>8), _aece[0], _aece[1])
					_abff := _gbff(uint(_fbba.R), _aece[0], _aece[1])
					_bfdg := _gbff(uint(_fbba.G>>8), _ecbe[0], _ecbe[1])
					_fcgb := _gbff(uint(_fbba.G), _ecbe[0], _ecbe[1])
					_gaca := _gbff(uint(_fbba.B>>8), _cfeb[0], _cfeb[1])
					_eaab := _gbff(uint(_fbba.B), _cfeb[0], _cfeb[1])
					_gbbg[_fgfaf] = byte(_gbbf)
					_fgfaf++
					_gbbg[_fgfaf] = byte(_abff)
					_fgfaf++
					_gbbg[_fgfaf] = byte(_bfdg)
					_fgfaf++
					_gbbg[_fgfaf] = byte(_fcgb)
					_fgfaf++
					_gbbg[_fgfaf] = byte(_gaca)
					_fgfaf++
					_gbbg[_fgfaf] = byte(_eaab)
					_fgfaf++
				} else {
					_dbba, _gacb := _eedb.(_g.RGBA)
					if _gacb {
						_bbgg := _gbff(uint(_dbba.R), _aece[0], _aece[1])
						_cfcf := _gbff(uint(_dbba.G), _ecbe[0], _ecbe[1])
						_aebb := _gbff(uint(_dbba.B), _cfeb[0], _cfeb[1])
						_gbbg[_fgfaf] = byte(_bbgg)
						_fgfaf++
						_gbbg[_fgfaf] = byte(_cfcf)
						_fgfaf++
						_gbbg[_fgfaf] = byte(_aebb)
						_fgfaf++
					} else {
						_efbb, _bebd := _eedb.(_g.YCbCr)
						if !_bebd {
							return nil, _b.New("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
						}
						_fec, _befe, _cbaa, _ := _efbb.RGBA()
						_cged := _gbff(uint(_fec>>8), _aece[0], _aece[1])
						_cdaa := _gbff(uint(_befe>>8), _ecbe[0], _ecbe[1])
						_cdaaa := _gbff(uint(_cbaa>>8), _cfeb[0], _cfeb[1])
						_gbbg[_fgfaf] = byte(_cged)
						_fgfaf++
						_gbbg[_fgfaf] = byte(_cdaa)
						_fgfaf++
						_gbbg[_fgfaf] = byte(_cdaaa)
						_fgfaf++
					}
				}
			}
		}
	case 4:
		_dabg := []float64{_ddff.Decode[0], _ddff.Decode[1]}
		_dcdf := []float64{_ddff.Decode[2], _ddff.Decode[3]}
		_cgca := []float64{_ddff.Decode[4], _ddff.Decode[5]}
		_acgf := []float64{_ddff.Decode[6], _ddff.Decode[7]}
		for _def := _gadab.Min.Y; _def < _gadab.Max.Y; _def++ {
			for _ceac := _gadab.Min.X; _ceac < _gadab.Max.X; _ceac++ {
				_bdde := _aae.At(_ceac, _def)
				_abd, _bdg := _bdde.(_g.CMYK)
				if !_bdg {
					return nil, _b.New("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
				}
				_ccdd := 255 - _gbff(uint(_abd.C), _dabg[0], _dabg[1])
				_gfca := 255 - _gbff(uint(_abd.M), _dcdf[0], _dcdf[1])
				_aaea := 255 - _gbff(uint(_abd.Y), _cgca[0], _cgca[1])
				_aag := 255 - _gbff(uint(_abd.K), _acgf[0], _acgf[1])
				_gbbg[_fgfaf] = byte(_ccdd)
				_fgfaf++
				_gbbg[_fgfaf] = byte(_gfca)
				_fgfaf++
				_gbbg[_fgfaf] = byte(_aaea)
				_fgfaf++
				_gbbg[_fgfaf] = byte(_aag)
				_fgfaf++
			}
		}
	}
	return _gbbg, nil
}

func (_ggf *PdfParser) lookupObjectViaOS(_dgf int, _gb int) (PdfObject, error) {
	var _dc *_e.Reader
	var _adb objectStream
	var _ece bool
	_adb, _ece = _ggf._bcdd[_dgf]
	if !_ece {
		_ddc, _gebg := _ggf.LookupByNumber(_dgf)
		if _gebg != nil {
			_fdb.Log.Debug("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064", _dgf)
			return nil, _gebg
		}
		_ebd, _cca := _ddc.(*PdfObjectStream)
		if !_cca {
			return nil, _b.New("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d")
		}
		if _ggf._dccfc != nil && !_ggf._dccfc.isDecrypted(_ebd) {
			return nil, _b.New("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d")
		}
		_gaf := _ebd.PdfObjectDictionary
		_fdb.Log.Trace("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n", _gaf.String())
		_baa, _cca := _gaf.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName)
		if !_cca {
			_fdb.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065")
			return nil, _b.New("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065")
		}
		if _fa.ToLower(string(*_baa)) != "\u006f\u0062\u006a\u0073\u0074\u006d" {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021")
			return nil, _b.New("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d")
		}
		N, _cca := _gaf.Get("\u004e").(*PdfObjectInteger)
		if !_cca {
			return nil, _b.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		}
		_gebd, _cca := _gaf.Get("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger)
		if !_cca {
			return nil, _b.New("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		}
		_fdb.Log.Trace("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064", _baa, *N)
		_agf, _gebg := DecodeStream(_ebd)
		if _gebg != nil {
			return nil, _gebg
		}
		_fdb.Log.Trace("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073", _agf)
		_eab := _ggf.GetFileOffset()
		defer func() { _ggf.SetFileOffset(_eab) }()
		_dc = _e.NewReader(_agf)
		_ggf._gggee._ffb = _ge.NewReader(_dc)
		_fdb.Log.Trace("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070")
		_gae := map[int]int64{}
		for _cee := 0; _cee < int(*N); _cee++ {
			_ggf.skipSpaces()
			_gafe, _gec := _ggf.parseNumber()
			if _gec != nil {
				return nil, _gec
			}
			_gdb, _dgb := _gafe.(*PdfObjectInteger)
			if !_dgb {
				return nil, _b.New("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065")
			}
			_ggf.skipSpaces()
			_gafe, _gec = _ggf.parseNumber()
			if _gec != nil {
				return nil, _gec
			}
			_gbc, _dgb := _gafe.(*PdfObjectInteger)
			if !_dgb {
				return nil, _b.New("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065")
			}
			_fdb.Log.Trace("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064", *_gdb, *_gbc)
			_gae[int(*_gdb)] = int64(*_gebd + *_gbc)
		}
		_adb = objectStream{N: int(*N), _eedf: _agf, _cae: _gae}
		_ggf._bcdd[_dgf] = _adb
	} else {
		_faa := _ggf.GetFileOffset()
		defer func() { _ggf.SetFileOffset(_faa) }()
		_dc = _e.NewReader(_adb._eedf)
		_ggf._gggee._ffb = _ge.NewReader(_dc)
	}
	_bbb := _adb._cae[_gb]
	_fdb.Log.Trace("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064", _gb, _bbb)
	_dc.Seek(_bbb, _eed.SeekStart)
	_ggf._gggee._ffb = _ge.NewReader(_dc)
	_ced, _ := _ggf._gggee._ffb.Peek(100)
	_fdb.Log.Trace("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022", string(_ced))
	_fgd, _dae := _ggf.parseObject()
	if _dae != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029", _dae)
		return nil, _dae
	}
	if _fgd == nil {
		return nil, _b.New("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c")
	}
	_eaba := PdfIndirectObject{}
	_eaba.ObjectNumber = int64(_gb)
	_eaba.PdfObject = _fgd
	_eaba._agfgc = _ggf
	return &_eaba, nil
}

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_gbgg *PdfParser) Decrypt(password []byte) (bool, error) {
	if _gbgg._dccfc == nil {
		return false, _b.New("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074")
	}
	_ebga, _gaae := _gbgg._dccfc.authenticate(password)
	if _gaae != nil {
		return false, _gaae
	}
	if !_ebga {
		_ebga, _gaae = _gbgg._dccfc.authenticate([]byte(""))
	}
	return _ebga, _gaae
}

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_aefd ParserMetadata) HasEOLAfterHeader() bool { return _aefd._edcbb }

func _gbfff(_ffcca PdfObject) (*float64, error) {
	switch _eebde := _ffcca.(type) {
	case *PdfObjectFloat:
		_cebe := float64(*_eebde)
		return &_cebe, nil
	case *PdfObjectInteger:
		_fbaa := float64(*_eebde)
		return &_fbaa, nil
	case *PdfObjectNull:
		return nil, nil
	}
	return nil, ErrNotANumber
}

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_baefb *MultiEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _baefb.DecodeBytes(streamObj.Stream)
}

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString(s string) *PdfObjectString { _egce := PdfObjectString{_gdea: s}; return &_egce }

// String returns a string describing `d`.
func (_fgdg *PdfObjectDictionary) String() string {
	var _egbg _fa.Builder
	_egbg.WriteString("\u0044\u0069\u0063t\u0028")
	for _, _efad := range _fgdg._faaee {
		_feefg := _fgdg._bgfg[_efad]
		_egbg.WriteString("\u0022" + _efad.String() + "\u0022\u003a\u0020")
		_egbg.WriteString(_feefg.String())
		_egbg.WriteString("\u002c\u0020")
	}
	_egbg.WriteString("\u0029")
	return _egbg.String()
}

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bgge Version) String() string {
	return _dg.Sprintf("\u00250\u0064\u002e\u0025\u0030\u0064", _bgge.Major, _bgge.Minor)
}

var _cbgd = _b.New("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats(vals []float64) *PdfObjectArray {
	_eeeg := MakeArray()
	for _, _cdgf := range vals {
		_eeeg.Append(MakeFloat(_cdgf))
	}
	return _eeeg
}

func (_caf *PdfCrypt) makeKey(_ddf string, _caa, _dfaf uint32, _bbf []byte) ([]byte, error) {
	_egc, _gfe := _caf._fca[_ddf]
	if !_gfe {
		return nil, _dg.Errorf("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)", _ddf)
	}
	return _egc.MakeKey(_caa, _dfaf, _bbf)
}

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray(objects ...PdfObject) *PdfObjectArray { return &PdfObjectArray{_abad: objects} }

func _faba(_aabc _eed.ReadSeeker, _deff int64) (*limitedReadSeeker, error) {
	_, _bddgf := _aabc.Seek(0, _eed.SeekStart)
	if _bddgf != nil {
		return nil, _bddgf
	}
	return &limitedReadSeeker{_fafde: _aabc, _fabbd: _deff}, nil
}

// Seek implementation of Seek interface.
func (_aagf *limitedReadSeeker) Seek(offset int64, whence int) (int64, error) {
	var _beaae int64
	switch whence {
	case _eed.SeekStart:
		_beaae = offset
	case _eed.SeekCurrent:
		_agbe, _eeff := _aagf._fafde.Seek(0, _eed.SeekCurrent)
		if _eeff != nil {
			return 0, _eeff
		}
		_beaae = _agbe + offset
	case _eed.SeekEnd:
		_beaae = _aagf._fabbd + offset
	}
	if _ffbf := _aagf.getError(_beaae); _ffbf != nil {
		return 0, _ffbf
	}
	if _, _aagb := _aagf._fafde.Seek(_beaae, _eed.SeekStart); _aagb != nil {
		return 0, _aagb
	}
	return _beaae, nil
}

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct {
	_gdea string
	_gdgf bool
}

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bbcc *DCTEncoder) MakeDecodeParams() PdfObject { return nil }

func (_aec *PdfCrypt) newEncryptDict() *PdfObjectDictionary {
	_add := MakeDict()
	_add.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"))
	_add.Set("\u0056", MakeInteger(int64(_aec._cabf.V)))
	_add.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(int64(_aec._cabf.Length)))
	return _add
}

// String returns a string representation of `name`.
func (_bagdd *PdfObjectName) String() string { return string(*_bagdd) }

// HeaderPosition gets the file header position.
func (_bfee ParserMetadata) HeaderPosition() int { return _bfee._cad }

// Clear resets the dictionary to an empty state.
func (_eeege *PdfObjectDictionary) Clear() {
	_eeege._faaee = []PdfObjectName{}
	_eeege._bgfg = map[PdfObjectName]PdfObject{}
	_eeege._dcge = &_bf.Mutex{}
}

var _dbbbf = _a.MustCompile("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a")

// UpdateParams updates the parameter values of the encoder.
func (_bfcb *FlateEncoder) UpdateParams(params *PdfObjectDictionary) {
	_gdad, _acf := GetNumberAsInt64(params.Get("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"))
	if _acf == nil {
		_bfcb.Predictor = int(_gdad)
	}
	_ccc, _acf := GetNumberAsInt64(params.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"))
	if _acf == nil {
		_bfcb.BitsPerComponent = int(_ccc)
	}
	_aca, _acf := GetNumberAsInt64(params.Get("\u0057\u0069\u0064t\u0068"))
	if _acf == nil {
		_bfcb.Columns = int(_aca)
	}
	_eff, _acf := GetNumberAsInt64(params.Get("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"))
	if _acf == nil {
		_bfcb.Colors = int(_eff)
	}
}

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
// renamed to String() as a pretty string to use in debugging etc.
func (_egfdc *MultiEncoder) GetFilterName() string {
	_gadc := ""
	for _fdfb, _beee := range _egfdc._bdfea {
		_gadc += _beee.GetFilterName()
		if _fdfb < len(_egfdc._bdfea)-1 {
			_gadc += "\u0020"
		}
	}
	return _gadc
}

// NewParserFromString is used for testing purposes.
func NewParserFromString(txt string) *PdfParser {
	_eeefe := _e.NewReader([]byte(txt))
	_bebb := &PdfParser{ObjCache: objectCache{}, _gggee: _gcc(_eeefe), _dbed: int64(len(txt)), _effa: map[int64]bool{}, _bcgf: make(map[*PdfParser]*PdfParser)}
	_bebb._fabaa.ObjectMap = make(map[int]XrefObject)
	return _bebb
}

func _cea(_bbgb _bc.Filter, _aeb _ad.AuthEvent) *PdfObjectDictionary {
	if _aeb == "" {
		_aeb = _ad.EventDocOpen
	}
	_gda := MakeDict()
	_gda.Set("\u0054\u0079\u0070\u0065", MakeName("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"))
	_gda.Set("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et", MakeName(string(_aeb)))
	_gda.Set("\u0043\u0046\u004d", MakeName(_bbgb.Name()))
	_gda.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(int64(_bbgb.KeyLength())))
	return _gda
}

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_faaf *PdfParser) GetPreviousRevisionParser() (*PdfParser, error) {
	if _faaf._agdg == 0 {
		return nil, _b.New("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e")
	}
	if _dfcbg, _cefb := _faaf._bcgf[_faaf]; _cefb {
		return _dfcbg, nil
	}
	_gaef, _bgcbe := _faaf.GetPreviousRevisionReadSeeker()
	if _bgcbe != nil {
		return nil, _bgcbe
	}
	_ccggg, _bgcbe := NewParser(_gaef)
	_ccggg._bcgf = _faaf._bcgf
	if _bgcbe != nil {
		return nil, _bgcbe
	}
	_faaf._bcgf[_faaf] = _ccggg
	return _ccggg, nil
}

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fcgg *PdfCrypt) Decrypt(obj PdfObject, parentObjNum, parentGenNum int64) error {
	if _fcgg.isDecrypted(obj) {
		return nil
	}
	switch _acg := obj.(type) {
	case *PdfIndirectObject:
		_fcgg._fbe[_acg] = true
		_fdb.Log.Trace("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021", _acg.ObjectNumber, _acg.GenerationNumber)
		_fed := _acg.ObjectNumber
		_aef := _acg.GenerationNumber
		_ebbf := _fcgg.Decrypt(_acg.PdfObject, _fed, _aef)
		if _ebbf != nil {
			return _ebbf
		}
		return nil
	case *PdfObjectStream:
		_fcgg._fbe[_acg] = true
		_cgcb := _acg.PdfObjectDictionary
		if _fcgg._ecf.R != 5 {
			if _fggee, _dcde := _cgcb.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName); _dcde && *_fggee == "\u0058\u0052\u0065\u0066" {
				return nil
			}
		}
		_gbfa := _acg.ObjectNumber
		_cbab := _acg.GenerationNumber
		_fdb.Log.Trace("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!", _gbfa, _cbab)
		_cfbb := _bdc
		if _fcgg._cabf.V >= 4 {
			_cfbb = _fcgg._cef
			_fdb.Log.Trace("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073", _fcgg._cef)
			if _bgcb, _eece := _cgcb.Get("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray); _eece {
				if _ebdd, _gbeg := GetName(_bgcb.Get(0)); _gbeg {
					if *_ebdd == "\u0043\u0072\u0079p\u0074" {
						_cfbb = "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"
						if _dbf, _fcd := _cgcb.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary); _fcd {
							if _faac, _afca := _dbf.Get("\u004e\u0061\u006d\u0065").(*PdfObjectName); _afca {
								if _, _bgbb := _fcgg._fca[string(*_faac)]; _bgbb {
									_fdb.Log.Trace("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073", *_faac)
									_cfbb = string(*_faac)
								}
							}
						}
					}
				}
			}
			_fdb.Log.Trace("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072", _cfbb)
			if _cfbb == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079" {
				return nil
			}
		}
		_efab := _fcgg.Decrypt(_cgcb, _gbfa, _cbab)
		if _efab != nil {
			return _efab
		}
		_bfef, _efab := _fcgg.makeKey(_cfbb, uint32(_gbfa), uint32(_cbab), _fcgg._bae)
		if _efab != nil {
			return _efab
		}
		_acg.Stream, _efab = _fcgg.decryptBytes(_acg.Stream, _cfbb, _bfef)
		if _efab != nil {
			return _efab
		}
		_cgcb.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(int64(len(_acg.Stream))))
		return nil
	case *PdfObjectString:
		_fdb.Log.Trace("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021")
		_aee := _bdc
		if _fcgg._cabf.V >= 4 {
			_fdb.Log.Trace("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072", _fcgg._cfd)
			if _fcgg._cfd == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079" {
				return nil
			}
			_aee = _fcgg._cfd
		}
		_aeda, _fgb := _fcgg.makeKey(_aee, uint32(parentObjNum), uint32(parentGenNum), _fcgg._bae)
		if _fgb != nil {
			return _fgb
		}
		_eba := _acg.Str()
		_fbf := make([]byte, len(_eba))
		for _bdfe := 0; _bdfe < len(_eba); _bdfe++ {
			_fbf[_bdfe] = _eba[_bdfe]
		}
		if len(_fbf) > 0 {
			_fdb.Log.Trace("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078", _fbf, _fbf)
			_fbf, _fgb = _fcgg.decryptBytes(_fbf, _aee, _aeda)
			if _fgb != nil {
				return _fgb
			}
		}
		_acg._gdea = string(_fbf)
		return nil
	case *PdfObjectArray:
		for _, _gcea := range _acg.Elements() {
			_agda := _fcgg.Decrypt(_gcea, parentObjNum, parentGenNum)
			if _agda != nil {
				return _agda
			}
		}
		return nil
	case *PdfObjectDictionary:
		_fdbd := false
		if _baaa := _acg.Get("\u0054\u0079\u0070\u0065"); _baaa != nil {
			_cbf, _cbcc := _baaa.(*PdfObjectName)
			if _cbcc && *_cbf == "\u0053\u0069\u0067" {
				_fdbd = true
			}
		}
		for _, _cgf := range _acg.Keys() {
			_bee := _acg.Get(_cgf)
			if _fdbd && string(_cgf) == "\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073" {
				continue
			}
			if string(_cgf) != "\u0050\u0061\u0072\u0065\u006e\u0074" && string(_cgf) != "\u0050\u0072\u0065\u0076" && string(_cgf) != "\u004c\u0061\u0073\u0074" {
				_fff := _fcgg.Decrypt(_bee, parentObjNum, parentGenNum)
				if _fff != nil {
					return _fff
				}
			}
		}
		return nil
	}
	return nil
}

// String returns a string describing `ind`.
func (_bdee *PdfIndirectObject) String() string {
	return _dg.Sprintf("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064", (*_bdee).ObjectNumber)
}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_abeg *LZWEncoder) MakeStreamDict() *PdfObjectDictionary {
	_gece := MakeDict()
	_gece.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_abeg.GetFilterName()))
	_fdeg := _abeg.MakeDecodeParams()
	if _fdeg != nil {
		_gece.Set("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073", _fdeg)
	}
	_gece.Set("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065", MakeInteger(int64(_abeg.EarlyChange)))
	return _gece
}

const _cefd = 10

// UpdateParams updates the parameter values of the encoder.
func (_fcf *CCITTFaxEncoder) UpdateParams(params *PdfObjectDictionary) {
	if _cfece, _caae := GetNumberAsInt64(params.Get("\u004b")); _caae == nil {
		_fcf.K = int(_cfece)
	}
	if _cfbe, _gcaffb := GetNumberAsInt64(params.Get("\u0043o\u006c\u0075\u006d\u006e\u0073")); _gcaffb == nil {
		_fcf.Columns = int(_cfbe)
	} else if _cfbe, _gcaffb = GetNumberAsInt64(params.Get("\u0057\u0069\u0064t\u0068")); _gcaffb == nil {
		_fcf.Columns = int(_cfbe)
	}
	if _ccfc, _fddd := GetNumberAsInt64(params.Get("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031")); _fddd == nil {
		_fcf.BlackIs1 = _ccfc > 0
	} else {
		if _ceecc, _dddgg := GetBoolVal(params.Get("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031")); _dddgg {
			_fcf.BlackIs1 = _ceecc
		} else {
			if _agfg, _eda := GetArray(params.Get("\u0044\u0065\u0063\u006f\u0064\u0065")); _eda {
				_gfcab, _fcb := _agfg.ToIntegerArray()
				if _fcb == nil {
					_fcf.BlackIs1 = _gfcab[0] == 1 && _gfcab[1] == 0
				}
			}
		}
	}
	if _ceacg, _dfec := GetNumberAsInt64(params.Get("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e")); _dfec == nil {
		_fcf.EncodedByteAlign = _ceacg > 0
	} else {
		if _bbe, _bcg := GetBoolVal(params.Get("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e")); _bcg {
			_fcf.EncodedByteAlign = _bbe
		}
	}
	if _cacc, _gdgd := GetNumberAsInt64(params.Get("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee")); _gdgd == nil {
		_fcf.EndOfLine = _cacc > 0
	} else {
		if _faee, _dfeda := GetBoolVal(params.Get("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee")); _dfeda {
			_fcf.EndOfLine = _faee
		}
	}
	if _ffgf, _efff := GetNumberAsInt64(params.Get("\u0052\u006f\u0077\u0073")); _efff == nil {
		_fcf.Rows = int(_ffgf)
	} else if _ffgf, _efff = GetNumberAsInt64(params.Get("\u0048\u0065\u0069\u0067\u0068\u0074")); _efff == nil {
		_fcf.Rows = int(_ffgf)
	}
	if _ebca, _cadf := GetNumberAsInt64(params.Get("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b")); _cadf == nil {
		_fcf.EndOfBlock = _ebca > 0
	} else {
		if _dbbb, _bfdc := GetBoolVal(params.Get("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b")); _bfdc {
			_fcf.EndOfBlock = _dbbb
		}
	}
	if _ffde, _eeeb := GetNumberAsInt64(params.Get("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072")); _eeeb != nil {
		_fcf.DamagedRowsBeforeError = int(_ffde)
	}
}

func (_ccdbd *PdfParser) resolveReference(_eefb *PdfObjectReference) (PdfObject, bool, error) {
	_badgb, _cafd := _ccdbd.ObjCache[int(_eefb.ObjectNumber)]
	if _cafd {
		return _badgb, true, nil
	}
	_gedb, _deccb := _ccdbd.LookupByReference(*_eefb)
	if _deccb != nil {
		return nil, false, _deccb
	}
	_ccdbd.ObjCache[int(_eefb.ObjectNumber)] = _gedb
	return _gedb, false, nil
}

// GetFilterName returns the name of the encoding filter.
func (_aff *RawEncoder) GetFilterName() string { return StreamEncodingFilterNameRaw }

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cfdee *RawEncoder) DecodeBytes(encoded []byte) ([]byte, error) { return encoded, nil }

// UpdateParams updates the parameter values of the encoder.
func (_bbbb *MultiEncoder) UpdateParams(params *PdfObjectDictionary) {
	for _, _cdfg := range _bbbb._bdfea {
		_cdfg.UpdateParams(params)
	}
}

func _dcac(_ddac int) cryptFilters { return cryptFilters{_bdc: _bc.NewFilterV2(_ddac)} }

const (
	StreamEncodingFilterNameFlate     = "F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065"
	StreamEncodingFilterNameLZW       = "\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e"
	StreamEncodingFilterNameDCT       = "\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e"
	StreamEncodingFilterNameRunLength = "\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065"
	StreamEncodingFilterNameASCIIHex  = "\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065"
	StreamEncodingFilterNameASCII85   = "\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065"
	StreamEncodingFilterNameCCITTFax  = "\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065"
	StreamEncodingFilterNameJBIG2     = "J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065"
	StreamEncodingFilterNameJPX       = "\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e"
	StreamEncodingFilterNameRaw       = "\u0052\u0061\u0077"
)

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_bcbg *CCITTFaxEncoder) EncodeBytes(data []byte) ([]byte, error) {
	var _agee _dfa.Gray
	switch len(data) {
	case _bcbg.Rows * _bcbg.Columns:
		_gbfb, _acba := _dfa.NewImage(_bcbg.Columns, _bcbg.Rows, 8, 1, data, nil, nil)
		if _acba != nil {
			return nil, _acba
		}
		_agee = _gbfb.(_dfa.Gray)
	case (_bcbg.Columns * _bcbg.Rows) + 7>>3:
		_afdf, _dgcd := _dfa.NewImage(_bcbg.Columns, _bcbg.Rows, 1, 1, data, nil, nil)
		if _dgcd != nil {
			return nil, _dgcd
		}
		_ggaaf := _afdf.(*_dfa.Monochrome)
		if _dgcd = _ggaaf.AddPadding(); _dgcd != nil {
			return nil, _dgcd
		}
		_agee = _ggaaf
	default:
		if len(data) < _dfa.BytesPerLine(_bcbg.Columns, 1, 1)*_bcbg.Rows {
			return nil, _b.New("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061")
		}
		_gfce, _aadec := _dfa.NewImage(_bcbg.Columns, _bcbg.Rows, 1, 1, data, nil, nil)
		if _aadec != nil {
			return nil, _aadec
		}
		_gbcc := _gfce.(*_dfa.Monochrome)
		_agee = _gbcc
	}
	_gdde := make([][]byte, _bcbg.Rows)
	for _bbce := 0; _bbce < _bcbg.Rows; _bbce++ {
		_eccfa := make([]byte, _bcbg.Columns)
		for _dgcde := 0; _dgcde < _bcbg.Columns; _dgcde++ {
			_dadg := _agee.GrayAt(_dgcde, _bbce)
			_eccfa[_dgcde] = _dadg.Y >> 7
		}
		_gdde[_bbce] = _eccfa
	}
	_dccag := &_ac.Encoder{K: _bcbg.K, Columns: _bcbg.Columns, EndOfLine: _bcbg.EndOfLine, EndOfBlock: _bcbg.EndOfBlock, BlackIs1: _bcbg.BlackIs1, DamagedRowsBeforeError: _bcbg.DamagedRowsBeforeError, Rows: _bcbg.Rows, EncodedByteAlign: _bcbg.EncodedByteAlign}
	return _dccag.Encode(_gdde), nil
}

func (_gafc *PdfObjectInteger) String() string { return _dg.Sprintf("\u0025\u0064", *_gafc) }

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect(obj PdfObject) (_acbc *PdfIndirectObject, _feae bool) {
	obj = ResolveReference(obj)
	_acbc, _feae = obj.(*PdfIndirectObject)
	return _acbc, _feae
}

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_egcee *PdfObjectDictionary) Update(objmap map[string]PdfObject) *PdfObjectDictionary {
	_egcee._dcge.Lock()
	defer _egcee._dcge.Unlock()
	for _dcba, _efbgf := range objmap {
		_egcee.setWithLock(PdfObjectName(_dcba), _efbgf, false)
	}
	return _egcee
}

// FormatWriteDirectionLTR formats a string for left-to-right rendering, handling bidirectional runs.
func FormatWriteDirectionLTR(str string, isLTR bool) string {
	_dadfa := str
	if _dadfa == "" {
		return ""
	}
	_ceede := _be.Paragraph{}
	_, _eacgf := _ceede.SetString(str)
	if _eacgf != nil {
		return _dadfa
	}
	_gaacf, _eacgf := _ceede.Order()
	if _eacgf != nil {
		return _dadfa
	}
	_bcbbag := _gaacf.NumRuns()
	_ceagb := make([]string, _bcbbag)
	for _gbaad := 0; _gbaad < _gaacf.NumRuns(); _gbaad++ {
		_beaaa := _gaacf.Run(_gbaad)
		_ccgag := _beaaa.String()
		if _beaaa.Direction() == _be.RightToLeft {
			_ccgag = _be.ReverseString(_ccgag)
		}
		if isLTR {
			_ceagb[_gbaad] = _ccgag
		} else {
			_ceagb[_bcbbag-1] = _ccgag
		}
		_bcbbag--
	}
	if len(_ceagb) != _gaacf.NumRuns() {
		return str
	}
	_dadfa = _fa.Join(_ceagb, "")
	return _dadfa
}

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject(obj PdfObject) PdfObject {
	if _ffeeg, _ecbebe := obj.(*PdfObjectReference); _ecbebe {
		obj = _ffeeg.Resolve()
	}
	_abbb, _gfaf := obj.(*PdfIndirectObject)
	_bfadd := 0
	for _gfaf {
		obj = _abbb.PdfObject
		_abbb, _gfaf = GetIndirect(obj)
		_bfadd++
		if _bfadd > _cefd {
			_fdb.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021", _cefd)
			return nil
		}
	}
	return obj
}

var _edbdf = _a.MustCompile("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024")

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_ccaf *PdfParser) GetUpdatedObjects(prevParser *PdfParser) (map[int64]PdfObject, error) {
	if prevParser == nil {
		return nil, _b.New("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c")
	}
	_bgbac, _bbbd := _ccaf.getNumbersOfUpdatedObjects(prevParser)
	if _bbbd != nil {
		return nil, _bbbd
	}
	_addbf := make(map[int64]PdfObject)
	for _, _adeg := range _bgbac {
		if _aggbc, _bebaa := _ccaf.LookupByNumber(_adeg); _bebaa == nil {
			_addbf[int64(_adeg)] = _aggbc
		} else {
			return nil, _bebaa
		}
	}
	return _addbf, nil
}

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_cceec *PdfObjectDictionary) Get(key PdfObjectName) PdfObject {
	_cceec._dcge.Lock()
	defer _cceec._dcge.Unlock()
	_cbef, _acda := _cceec._bgfg[key]
	if !_acda {
		return nil
	}
	return _cbef
}

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct {
	XType        xrefType
	ObjectNumber int
	Generation   int

	// For normal xrefs (defined by OFFSET)
	Offset int64

	// For xrefs to object streams.
	OsObjNumber int
	OsObjIndex  int
}

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct {
	_agfgc           *PdfParser
	ObjectNumber     int64
	GenerationNumber int64
}

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gfcfa *JBIG2Encoder) EncodeJBIG2Image(img *JBIG2Image) ([]byte, error) {
	const _aada = "c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065"
	if _ebfg := _gfcfa.AddPageImage(img, &_gfcfa.DefaultPageSettings); _ebfg != nil {
		return nil, _fag.Wrap(_ebfg, _aada, "")
	}
	return _gfcfa.Encode()
}

func _dbeg(_bdgf *PdfObjectStream, _bfcce *PdfObjectDictionary) (*JBIG2Encoder, error) {
	const _egaa = "\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m"
	_dffg := NewJBIG2Encoder()
	_gbbgf := _bdgf.PdfObjectDictionary
	if _gbbgf == nil {
		return _dffg, nil
	}
	if _bfcce == nil {
		_ffacd := _gbbgf.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073")
		if _ffacd != nil {
			switch _bccc := _ffacd.(type) {
			case *PdfObjectDictionary:
				_bfcce = _bccc
			case *PdfObjectArray:
				if _bccc.Len() == 1 {
					if _cbcb, _fdfg := GetDict(_bccc.Get(0)); _fdfg {
						_bfcce = _cbcb
					}
				}
			default:
				_fdb.Log.Error("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076", _ffacd)
				return nil, _fag.Errorf(_egaa, "\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054", _bccc)
			}
		}
	}
	if _bfcce == nil {
		return _dffg, nil
	}
	_dffg.UpdateParams(_bfcce)
	_fgag, _bgfa := GetStream(_bfcce.Get("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"))
	if !_bgfa {
		return _dffg, nil
	}
	var _acbae error
	_dffg.Globals, _acbae = _bb.DecodeGlobals(_fgag.Stream)
	if _acbae != nil {
		_acbae = _fag.Wrap(_acbae, _egaa, "\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061")
		_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _acbae)
		return nil, _acbae
	}
	return _dffg, nil
}

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder() *CCITTFaxEncoder { return &CCITTFaxEncoder{Columns: 1728, EndOfBlock: true} }

func (_bfbd *PdfParser) parseArray() (*PdfObjectArray, error) {
	_bbec := MakeArray()
	_bfbd._gggee.ReadByte()
	for {
		_bfbd.skipSpaces()
		_cafcg, _gcdc := _bfbd._gggee.Peek(1)
		if _gcdc != nil {
			return _bbec, _gcdc
		}
		if _cafcg[0] == ']' {
			_bfbd._gggee.ReadByte()
			break
		}
		_bbag, _gcdc := _bfbd.parseObject()
		if _gcdc != nil {
			return _bbec, _gcdc
		}
		_bbec.Append(_bbag)
	}
	return _bbec, nil
}

func (_adcdf *PdfParser) skipComments() error {
	if _, _bgfd := _adcdf.skipSpaces(); _bgfd != nil {
		return _bgfd
	}
	_bcbba := true
	for {
		_ecfb, _gccdc := _adcdf._gggee.Peek(1)
		if _gccdc != nil {
			_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _gccdc.Error())
			return _gccdc
		}
		if _bcbba && _ecfb[0] != '%' {
			return nil
		}
		_bcbba = false
		if (_ecfb[0] != '\r') && (_ecfb[0] != '\n') {
			_adcdf._gggee.ReadByte()
		} else {
			break
		}
	}
	return _adcdf.skipComments()
}

// Discard discards the next n bytes from the buffered reader.
func (_adc *bufferedReadSeeker) Discard(n int) (int, error) { return _adc._ffb.Discard(n) }

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter(c byte) bool {
	return c == '(' || c == ')' || c == '<' || c == '>' || c == '[' || c == ']' || c == '{' || c == '}' || c == '/' || c == '%'
}

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_ecfe *PdfParser) ReadBytesAt(offset, len int64) ([]byte, error) {
	_edfdb := _ecfe.GetFileOffset()
	_, _fbafa := _ecfe._gggee.Seek(offset, _eed.SeekStart)
	if _fbafa != nil {
		return nil, _fbafa
	}
	_gbge := make([]byte, len)
	_, _fbafa = _eed.ReadAtLeast(_ecfe._gggee, _gbge, int(len))
	if _fbafa != nil {
		return nil, _fbafa
	}
	_ecfe.SetFileOffset(_edfdb)
	return _gbge, nil
}

func (_dcbf *PdfParser) getNumbersOfUpdatedObjects(_dcbdf *PdfParser) ([]int, error) {
	if _dcbdf == nil {
		return nil, _b.New("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c")
	}
	_agea := _dcbdf._dbed
	_gfga := make([]int, 0)
	_eadb := make(map[int]interface{})
	_ccae := make(map[int]int64)
	for _aggb, _ecaaa := range _dcbf._fabaa.ObjectMap {
		if _ecaaa.Offset == 0 {
			if _ecaaa.OsObjNumber != 0 {
				if _abea, _dceaf := _dcbf._fabaa.ObjectMap[_ecaaa.OsObjNumber]; _dceaf {
					_eadb[_ecaaa.OsObjNumber] = struct{}{}
					_ccae[_aggb] = _abea.Offset
				} else {
					return nil, _b.New("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065")
				}
			}
		} else {
			_ccae[_aggb] = _ecaaa.Offset
		}
	}
	for _fbc, _cgdb := range _ccae {
		if _, _dcg := _eadb[_fbc]; _dcg {
			continue
		}
		if _cgdb > _agea {
			_gfga = append(_gfga, _fbc)
		}
	}
	return _gfga, nil
}

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ebefe *ASCII85Encoder) MakeDecodeParams() PdfObject { return nil }

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct {
	_baefa   Version
	_gggee   *bufferedReadSeeker
	_dbed    int64
	_fabaa   XrefTable
	_gecfg   int64
	_defc    *xrefType
	_bcdd    objectStreams
	_fce     *PdfObjectDictionary
	_dccfc   *PdfCrypt
	_afad    *PdfIndirectObject
	_bagd    bool
	ObjCache objectCache
	_bagc    map[int]bool
	_effa    map[int64]bool
	_afcb    ParserMetadata
	_baga    bool
	_aedf    []int64
	_agdg    int
	_fdfba   bool
	_ddea    int64
	_bcgf    map[*PdfParser]*PdfParser
	_ebaaa   []*PdfParser

	// Opts holds different parsing options.
	Opts *ParserOpts
}

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_bcag ParserMetadata) HasOddLengthHexStrings() bool { return _bcag._bcf }

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_gebc *LZWEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	var _debe _e.Buffer
	_dccf := _e.NewReader(encoded)
	var _fbbd _eed.ReadCloser
	if _gebc.EarlyChange == 1 {
		_fbbd = _ag.NewReader(_dccf, _ag.MSB, 8)
	} else {
		_fbbd = _df.NewReader(_dccf, _df.MSB, 8)
	}
	defer _fbbd.Close()
	if _, _bfec := _debe.ReadFrom(_fbbd); _bfec != nil {
		if _bfec != _eed.ErrUnexpectedEOF || _debe.Len() == 0 {
			return nil, _bfec
		}
		_fdb.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e", _bfec)
	}
	return _debe.Bytes(), nil
}

// UnreadByte unreads the last byte read from the buffered reader.
func (_daa *bufferedReadSeeker) UnreadByte() error { return _daa._ffb.UnreadByte() }

var _gbbc = _a.MustCompile("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR")

var _efae = _a.MustCompile("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029")

// LookupByReference looks up a PdfObject by a reference.
func (_feg *PdfParser) LookupByReference(ref PdfObjectReference) (PdfObject, error) {
	_fdb.Log.Trace("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073", ref.String())
	return _feg.LookupByNumber(int(ref.ObjectNumber))
}

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{}

// Write outputs the object as it is to be written to file.
func (_acegd *PdfIndirectObject) Write() []byte {
	return _edb(func(_fbff *_e.Buffer) {
		_fbff.WriteString(_d.FormatInt(_acegd.ObjectNumber, 10))
		_fbff.WriteString("\u0020\u0030\u0020\u0052")
	})
}

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gbed *PdfObjectArray) Get(i int) PdfObject {
	if _gbed == nil || i >= len(_gbed._abad) || i < 0 {
		return nil
	}
	return _gbed._abad[i]
}

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface {
	GetFilterName() string
	MakeDecodeParams() PdfObject
	MakeStreamDict() *PdfObjectDictionary
	UpdateParams(_bdcc *PdfObjectDictionary)
	EncodeBytes(_eef []byte) ([]byte, error)
	DecodeBytes(_cfde []byte) ([]byte, error)
	DecodeStream(_bcef *PdfObjectStream) ([]byte, error)
}

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject(obj PdfObject) *PdfIndirectObject {
	_ecbee := &PdfIndirectObject{}
	_ecbee.PdfObject = obj
	return _ecbee
}

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream(obj PdfObject) (_gdaag *PdfObjectStream, _egcd bool) {
	obj = ResolveReference(obj)
	_gdaag, _egcd = obj.(*PdfObjectStream)
	return _gdaag, _egcd
}

// Write outputs the object as it is to be written to file.
func (_egec *PdfObjectBool) Write() []byte {
	if *_egec {
		return []byte("\u0074\u0072\u0075\u0065")
	}
	return []byte("\u0066\u0061\u006cs\u0065")
}

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_aaggg *PdfParser) GetPreviousRevisionReadSeeker() (_eed.ReadSeeker, error) {
	if _afbg := _aaggg.seekToEOFMarker(_aaggg._dbed - _eabc); _afbg != nil {
		return nil, _afbg
	}
	_gbbd, _eagb := _aaggg._gggee.Seek(0, _eed.SeekCurrent)
	if _eagb != nil {
		return nil, _eagb
	}
	_gbbd += _eabc
	return _faba(_aaggg._gggee, _gbbd)
}

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_gdba *JBIG2Encoder) DecodeGlobals(encoded []byte) (_bb.Globals, error) {
	return _bb.DecodeGlobals(encoded)
}

// Write outputs the object as it is to be written to file.
func (_gacad *PdfObjectInteger) Write() []byte { return []byte(_d.FormatInt(int64(*_gacad), 10)) }

// FlateEncoder represents Flate encoding.
type FlateEncoder struct {
	Predictor        int
	BitsPerComponent int

	// For predictors
	Columns int
	Rows    int
	Colors  int
	_gfg    *_dfa.ImageBase
}

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64(obj PdfObject) (int64, error) {
	switch _ceca := obj.(type) {
	case *PdfObjectFloat:
		_fdb.Log.Debug("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029")
		return int64(*_ceca), nil
	case *PdfObjectInteger:
		return int64(*_ceca), nil
	case *PdfObjectReference:
		_acccf := TraceToDirectObject(obj)
		return GetNumberAsInt64(_acccf)
	case *PdfIndirectObject:
		return GetNumberAsInt64(_ceca.PdfObject)
	}
	return 0, ErrNotANumber
}

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_bfag ParserMetadata) HasInvalidSubsectionHeader() bool { return _bfag._gcfg }

// UpdateParams updates the parameter values of the encoder.
func (_dgd *RawEncoder) UpdateParams(params *PdfObjectDictionary) {}

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_ccba *PdfObjectArray) GetAsFloat64Slice() ([]float64, error) {
	var _ecdg []float64
	for _, _bgfe := range _ccba.Elements() {
		_eege, _fdeab := GetNumberAsFloat(TraceToDirectObject(_bgfe))
		if _fdeab != nil {
			return nil, _dg.Errorf("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072")
		}
		_ecdg = append(_ecdg, _eege)
	}
	return _ecdg, nil
}

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat(val float64) *PdfObjectFloat {
	val = _fdf.RoundDefault(val)
	_ggbb := PdfObjectFloat(val)
	return &_ggbb
}

func (_ebbcd *PdfParser) repairRebuildXrefsTopDown() (*XrefTable, error) {
	if _ebbcd._bagd {
		return nil, _dg.Errorf("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064")
	}
	_ebbcd._bagd = true
	_ebbcd._gggee.Seek(0, _eed.SeekStart)
	_ecdb := 20
	_aabde := make([]byte, _ecdb)
	_cfac := XrefTable{}
	_cfac.ObjectMap = make(map[int]XrefObject)
	for {
		_gbdgf, _edgba := _ebbcd._gggee.ReadByte()
		if _edgba != nil {
			if _edgba == _eed.EOF {
				break
			} else {
				return nil, _edgba
			}
		}
		if _gbdgf == 'j' && _aabde[_ecdb-1] == 'b' && _aabde[_ecdb-2] == 'o' && IsWhiteSpace(_aabde[_ecdb-3]) {
			_ecaed := _ecdb - 4
			for IsWhiteSpace(_aabde[_ecaed]) && _ecaed > 0 {
				_ecaed--
			}
			if _ecaed == 0 || !IsDecimalDigit(_aabde[_ecaed]) {
				continue
			}
			for IsDecimalDigit(_aabde[_ecaed]) && _ecaed > 0 {
				_ecaed--
			}
			if _ecaed == 0 || !IsWhiteSpace(_aabde[_ecaed]) {
				continue
			}
			for IsWhiteSpace(_aabde[_ecaed]) && _ecaed > 0 {
				_ecaed--
			}
			if _ecaed == 0 || !IsDecimalDigit(_aabde[_ecaed]) {
				continue
			}
			for IsDecimalDigit(_aabde[_ecaed]) && _ecaed > 0 {
				_ecaed--
			}
			if _ecaed == 0 {
				continue
			}
			_dcgg := _ebbcd.GetFileOffset() - int64(_ecdb-_ecaed)
			_dede := append(_aabde[_ecaed+1:], _gbdgf)
			_bdddc, _dadga, _daef := _dgdc(string(_dede))
			if _daef != nil {
				_fdb.Log.Debug("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076", _daef)
				return nil, _daef
			}
			if _bbbba, _ffeg := _cfac.ObjectMap[_bdddc]; !_ffeg || _bbbba.Generation <= _dadga {
				_bbcd := XrefObject{}
				_bbcd.XType = XrefTypeTableEntry
				_bbcd.ObjectNumber = _bdddc
				_bbcd.Generation = _dadga
				_bbcd.Offset = _dcgg
				_cfac.ObjectMap[_bdddc] = _bbcd
			}
		}
		_aabde = append(_aabde[1:_ecdb], _gbdgf)
	}
	_ebbcd._bagc = nil
	return &_cfac, nil
}

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_bff *RunLengthEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _bff.DecodeBytes(streamObj.Stream)
}

func (_dfbg *PdfCrypt) generateParams(_fbd, _fffcc []byte) error {
	_dbe := _dfbg.securityHandler()
	_aac, _agcd := _dbe.GenerateParams(&_dfbg._ecf, _fffcc, _fbd)
	if _agcd != nil {
		return _agcd
	}
	_dfbg._bae = _aac
	return nil
}

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct {
	_cabf encryptDict
	_ecf  _ad.StdEncryptDict
	_fda  string
	_bae  []byte
	_fbe  map[PdfObject]bool
	_egb  map[PdfObject]bool
	_ffa  bool
	_fca  cryptFilters
	_cef  string
	_cfd  string
	_gfd  *PdfParser
	_cfe  map[int]struct{}
}

// String returns a string representation of the *PdfObjectString.
func (_fegf *PdfObjectString) String() string { return _fegf._gdea }

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_fdfa *PdfObjectDictionary) SetIfNotNil(key PdfObjectName, val PdfObject) {
	if val != nil {
		switch _dffb := val.(type) {
		case *PdfObjectName:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectDictionary:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectStream:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectString:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectNull:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectInteger:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectArray:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectBool:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectFloat:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfObjectReference:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		case *PdfIndirectObject:
			if _dffb != nil {
				_fdfa.Set(key, val)
			}
		default:
			_fdb.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021", val)
		}
	}
}

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool

func _ggfb(_bbaf int) int { _ddcd := _bbaf >> (_cgcd - 1); return (_bbaf ^ _ddcd) - _ddcd }

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams(obj PdfObject) (_gbaed *PdfObjectStreams, _dge bool) {
	_gbaed, _dge = obj.(*PdfObjectStreams)
	return _gbaed, _dge
}

func _beab(_fcgbd *PdfObjectStream, _cdae *PdfObjectDictionary) (*CCITTFaxEncoder, error) {
	_gdff := NewCCITTFaxEncoder()
	_ceabc := _fcgbd.PdfObjectDictionary
	if _ceabc == nil {
		return _gdff, nil
	}
	if _cdae == nil {
		_bbgfb := TraceToDirectObject(_ceabc.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"))
		if _bbgfb != nil {
			switch _aaga := _bbgfb.(type) {
			case *PdfObjectDictionary:
				_cdae = _aaga
			case *PdfObjectArray:
				if _aaga.Len() == 1 {
					if _cgg, _aabg := GetDict(_aaga.Get(0)); _aabg {
						_cdae = _cgg
					}
				}
			default:
				_fdb.Log.Error("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076", _bbgfb)
				return nil, _b.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073")
			}
		}
		if _cdae == nil {
			_fdb.Log.Error("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076", _bbgfb)
			return nil, _b.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073")
		}
	}
	if _acb, _bfgf := GetNumberAsInt64(_cdae.Get("\u004b")); _bfgf == nil {
		_gdff.K = int(_acb)
	}
	if _fgbg, _ddfe := GetNumberAsInt64(_cdae.Get("\u0043o\u006c\u0075\u006d\u006e\u0073")); _ddfe == nil {
		_gdff.Columns = int(_fgbg)
	} else {
		_gdff.Columns = 1728
	}
	if _fdbc, _fdcc := GetNumberAsInt64(_cdae.Get("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031")); _fdcc == nil {
		_gdff.BlackIs1 = _fdbc > 0
	} else {
		if _fdegd, _dfge := GetBoolVal(_cdae.Get("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031")); _dfge {
			_gdff.BlackIs1 = _fdegd
		} else {
			if _cacf, _cbga := GetArray(_cdae.Get("\u0044\u0065\u0063\u006f\u0064\u0065")); _cbga {
				_caeb, _debb := _cacf.ToIntegerArray()
				if _debb == nil {
					_gdff.BlackIs1 = _caeb[0] == 1 && _caeb[1] == 0
				}
			}
		}
	}
	if _ebdg, _efgb := GetNumberAsInt64(_cdae.Get("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e")); _efgb == nil {
		_gdff.EncodedByteAlign = _ebdg > 0
	} else {
		if _dddg, _bdaa := GetBoolVal(_cdae.Get("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e")); _bdaa {
			_gdff.EncodedByteAlign = _dddg
		}
	}
	if _dfgd, _gabf := GetNumberAsInt64(_cdae.Get("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee")); _gabf == nil {
		_gdff.EndOfLine = _dfgd > 0
	} else {
		if _fcca, _fadb := GetBoolVal(_cdae.Get("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee")); _fadb {
			_gdff.EndOfLine = _fcca
		}
	}
	if _faeb, _acee := GetNumberAsInt64(_cdae.Get("\u0052\u006f\u0077\u0073")); _acee == nil {
		_gdff.Rows = int(_faeb)
	}
	_gdff.EndOfBlock = true
	if _fdea, _gfcf := GetNumberAsInt64(_cdae.Get("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b")); _gfcf == nil {
		_gdff.EndOfBlock = _fdea > 0
	} else {
		if _cffe, _cfbaa := GetBoolVal(_cdae.Get("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b")); _cfbaa {
			_gdff.EndOfBlock = _cffe
		}
	}
	if _dbd, _fbacc := GetNumberAsInt64(_cdae.Get("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072")); _fbacc != nil {
		_gdff.DamagedRowsBeforeError = int(_dbd)
	}
	_fdb.Log.Trace("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073", _cdae.String())
	return _gdff, nil
}

// Remove removes an element specified by key.
func (_dbdg *PdfObjectDictionary) Remove(key PdfObjectName) {
	_gafd := -1
	for _cggag, _bgde := range _dbdg._faaee {
		if _bgde == key {
			_gafd = _cggag
			break
		}
	}
	if _gafd >= 0 {
		_dbdg._faaee = append(_dbdg._faaee[:_gafd], _dbdg._faaee[_gafd+1:]...)
		delete(_dbdg._bgfg, key)
	}
}

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_deda *PdfObjectDictionary) Keys() []PdfObjectName {
	if _deda == nil {
		return nil
	}
	return _deda._faaee
}

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_gcag *PdfParser) Inspect() (map[string]int, error) { return _gcag.inspect() }

var _abee = _a.MustCompile("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024")

func (_bfaf *PdfCrypt) encryptBytes(_dbg []byte, _gfed string, _ebeb []byte) ([]byte, error) {
	_fdb.Log.Trace("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073")
	_fgf, _fffc := _bfaf._fca[_gfed]
	if !_fffc {
		return nil, _dg.Errorf("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)", _gfed)
	}
	return _fgf.EncryptBytes(_dbg, _ebeb)
}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ccfa *JPXEncoder) MakeStreamDict() *PdfObjectDictionary { return MakeDict() }

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal(obj PdfObject) (_bead string, _fgfce bool) {
	_beeeb, _fgfce := TraceToDirectObject(obj).(*PdfObjectString)
	if _fgfce {
		return _beeeb.Str(), true
	}
	return
}

func (_dff *PdfCrypt) isDecrypted(_becc PdfObject) bool {
	_, _eagc := _dff._fbe[_becc]
	if _eagc {
		_fdb.Log.Trace("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064")
		return true
	}
	switch _egae := _becc.(type) {
	case *PdfObjectStream:
		if _dff._ecf.R != 5 {
			if _dfb, _fefa := _egae.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName); _fefa && *_dfb == "\u0058\u0052\u0065\u0066" {
				return true
			}
		}
	case *PdfIndirectObject:
		if _, _eagc = _dff._cfe[int(_egae.ObjectNumber)]; _eagc {
			return true
		}
		switch _bcbf := _egae.PdfObject.(type) {
		case *PdfObjectDictionary:
			_ffcb := true
			for _, _cafc := range _gfdf {
				if _bcbf.Get(_cafc) == nil {
					_ffcb = false
					break
				}
			}
			if _ffcb {
				return true
			}
		}
	}
	_fdb.Log.Trace("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074")
	return false
}

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString(s string) *PdfObjectString {
	_debea := PdfObjectString{_gdea: s, _gdgf: true}
	return &_debea
}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_agdb *CCITTFaxEncoder) MakeStreamDict() *PdfObjectDictionary {
	_baf := MakeDict()
	_baf.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_agdb.GetFilterName()))
	_baf.SetIfNotNil("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073", _agdb.MakeDecodeParams())
	return _baf
}

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64

func (_fegb *PdfCrypt) checkAccessRights(_fdaf []byte) (bool, _ad.Permissions, error) {
	_fae := _fegb.securityHandler()
	_eca, _bfe, _fea := _fae.Authenticate(&_fegb._ecf, _fdaf)
	if _fea != nil {
		return false, 0, _fea
	} else if _bfe == 0 || len(_eca) == 0 {
		return false, 0, nil
	}
	return true, _bfe, nil
}

func _gbff(_fcad uint, _dgbfa, _ebaa float64) float64 {
	_aedag := _fdf.RoundFloat((float64(_fcad) / 255.0), 6)
	_ddee := _fdf.RoundFloat((_ebaa-_dgbfa)*_aedag, 6)
	return _fdf.RoundFloat((_dgbfa+_ddee)*255.0, 6)
}

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ebfgb *PdfObjectStreams) Elements() []PdfObject {
	if _ebfgb == nil {
		return nil
	}
	return _ebfgb._bedg
}

func (_ceab *ASCII85Encoder) base256Tobase85(_aedad uint32) [5]byte {
	_abab := [5]byte{0, 0, 0, 0, 0}
	_dbbd := _aedad
	for _ecgd := 0; _ecgd < 5; _ecgd++ {
		_bfad := uint32(1)
		for _ggge := 0; _ggge < 4-_ecgd; _ggge++ {
			_bfad *= 85
		}
		_ceec := _dbbd / _bfad
		_dbbd = _dbbd % _bfad
		_abab[_ecgd] = byte(_ceec)
	}
	return _abab
}

type xrefType int

func _cbaab(_afegb PdfObject, _cbfd int, _eacec map[PdfObject]struct{}) error {
	_fdb.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029", _cbfd)
	if _, _gecee := _eacec[_afegb]; _gecee {
		_fdb.Log.Trace("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e")
		return nil
	}
	_eacec[_afegb] = struct{}{}
	switch _eagf := _afegb.(type) {
	case *PdfIndirectObject:
		_dgaf := _eagf
		_fdb.Log.Trace("\u0069\u006f\u003a\u0020\u0025\u0073", _dgaf)
		_fdb.Log.Trace("\u002d\u0020\u0025\u0073", _dgaf.PdfObject)
		return _cbaab(_dgaf.PdfObject, _cbfd+1, _eacec)
	case *PdfObjectStream:
		_caab := _eagf
		return _cbaab(_caab.PdfObjectDictionary, _cbfd+1, _eacec)
	case *PdfObjectDictionary:
		_dddd := _eagf
		_fdb.Log.Trace("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073", _dddd)
		for _, _bcdfa := range _dddd.Keys() {
			_gaac := _dddd.Get(_bcdfa)
			if _cbgae, _cdag := _gaac.(*PdfObjectReference); _cdag {
				_bbad := _cbgae.Resolve()
				_dddd.Set(_bcdfa, _bbad)
				_ccbb := _cbaab(_bbad, _cbfd+1, _eacec)
				if _ccbb != nil {
					return _ccbb
				}
			} else {
				_dgcgf := _cbaab(_gaac, _cbfd+1, _eacec)
				if _dgcgf != nil {
					return _dgcgf
				}
			}
		}
		return nil
	case *PdfObjectArray:
		_cfgb := _eagf
		_fdb.Log.Trace("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073", _cfgb)
		for _eae, _ddcfe := range _cfgb.Elements() {
			if _dbede, _eagg := _ddcfe.(*PdfObjectReference); _eagg {
				_dgea := _dbede.Resolve()
				_cfgb.Set(_eae, _dgea)
				_baae := _cbaab(_dgea, _cbfd+1, _eacec)
				if _baae != nil {
					return _baae
				}
			} else {
				_cbgdf := _cbaab(_ddcfe, _cbfd+1, _eacec)
				if _cbgdf != nil {
					return _cbgdf
				}
			}
		}
		return nil
	case *PdfObjectReference:
		_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021")
		return _b.New("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e")
	}
	return nil
}

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject(obj PdfObject) bool {
	_, _accg := TraceToDirectObject(obj).(*PdfObjectNull)
	return _accg
}

func (_bdac *PdfCrypt) decryptBytes(_agaf []byte, _bgb string, _eec []byte) ([]byte, error) {
	_fdb.Log.Trace("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073")
	_afg, _gfa := _bdac._fca[_bgb]
	if !_gfa {
		return nil, _dg.Errorf("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)", _bgb)
	}
	return _afg.DecryptBytes(_agaf, _eec)
}

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat(obj PdfObject) (float64, error) {
	switch _dgaa := obj.(type) {
	case *PdfObjectFloat:
		return float64(*_dgaa), nil
	case *PdfObjectInteger:
		return float64(*_dgaa), nil
	case *PdfObjectReference:
		_bgegg := TraceToDirectObject(obj)
		return GetNumberAsFloat(_bgegg)
	case *PdfIndirectObject:
		return GetNumberAsFloat(_dgaa.PdfObject)
	}
	return 0, ErrNotANumber
}

// EncodeBytes encodes data into ASCII85 encoded format.
func (_egbc *ASCII85Encoder) EncodeBytes(data []byte) ([]byte, error) {
	var _gebcf _e.Buffer
	for _gdda := 0; _gdda < len(data); _gdda += 4 {
		_dade := data[_gdda]
		_dceb := 1
		_eeag := byte(0)
		if _gdda+1 < len(data) {
			_eeag = data[_gdda+1]
			_dceb++
		}
		_fedd := byte(0)
		if _gdda+2 < len(data) {
			_fedd = data[_gdda+2]
			_dceb++
		}
		_efea := byte(0)
		if _gdda+3 < len(data) {
			_efea = data[_gdda+3]
			_dceb++
		}
		_efbd := (uint32(_dade) << 24) | (uint32(_eeag) << 16) | (uint32(_fedd) << 8) | uint32(_efea)
		if _efbd == 0 {
			_gebcf.WriteByte('z')
		} else {
			_gced := _egbc.base256Tobase85(_efbd)
			for _, _cddg := range _gced[:_dceb+1] {
				_gebcf.WriteByte(_cddg + '!')
			}
		}
	}
	_gebcf.WriteString("\u007e\u003e")
	return _gebcf.Bytes(), nil
}

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_ede *bufferedReadSeeker) ReadAtLeast(p []byte, n int) (int, error) {
	_af := n
	_gd := 0
	for _af > 0 {
		_gea, _bg := _ede.Read(p[n-_gd:])
		if _bg != nil {
			return _gd, _bg
		}
		_gd++
		_af -= _gea
	}
	return _gd, nil
}

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct {
	_bgfg  map[PdfObjectName]PdfObject
	_faaee []PdfObjectName
	_dcge  *_bf.Mutex
	_febb  *PdfParser
}

// UpdateParams updates the parameter values of the encoder.
func (_cgdg *ASCII85Encoder) UpdateParams(params *PdfObjectDictionary) {}

const _bdc = "\u0053\u0074\u0064C\u0046"

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt(obj PdfObject) (_bfbba *PdfObjectInteger, _faca bool) {
	_bfbba, _faca = TraceToDirectObject(obj).(*PdfObjectInteger)
	return _bfbba, _faca
}

// Write outputs the object as it is to be written to file.
func (_daca *PdfObjectString) Write() []byte {
	return _edb(func(_dbaf *_e.Buffer) {
		if _daca._gdgf {
			_agdgb := _fd.EncodeToString(_daca.Bytes())
			_dbaf.Grow(len(_agdgb) + 2)
			_dbaf.WriteString("\u003c")
			_dbaf.WriteString(_agdgb)
			_dbaf.WriteString("\u003e")
			return
		}
		_dbaf.Grow(len(_daca._gdea) + len(_daca._gdea)/5 + 2)
		_dbaf.WriteString("\u0028")
		for _eefba := 0; _eefba < len(_daca._gdea); _eefba++ {
			_agfa := _daca._gdea[_eefba]
			if _ggfg, _bbfgc := _gcebe[_agfa]; _bbfgc {
				_dbaf.Write(_ggfg)
			} else {
				_dbaf.WriteByte(_agfa)
			}
		}
		_dbaf.WriteString("\u0029")
	})
}

// String returns a string describing `ref`.
func (_adde *PdfObjectReference) String() string {
	return _dg.Sprintf("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029", _adde.ObjectNumber, _adde.GenerationNumber)
}

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_daff *PdfCrypt) GetAccessPermissions() _ad.Permissions { return _daff._ecf.P }

func (_bgdf *PdfParser) parseString() (*PdfObjectString, error) {
	_bgdf._gggee.ReadByte()
	var _begb _e.Buffer
	_dbgb := 1
	for {
		_afdd, _ddgd := _bgdf._gggee.Peek(1)
		if _ddgd != nil {
			return MakeString(_begb.String()), _ddgd
		}
		if _afdd[0] == '\\' {
			_bgdf._gggee.ReadByte()
			_gbbcd, _geag := _bgdf._gggee.ReadByte()
			if _geag != nil {
				return MakeString(_begb.String()), _geag
			}
			if IsOctalDigit(_gbbcd) {
				_aagg, _cdff := _bgdf._gggee.Peek(2)
				if _cdff != nil {
					return MakeString(_begb.String()), _cdff
				}
				var _ead []byte
				_ead = append(_ead, _gbbcd)
				for _, _cdbd := range _aagg {
					if IsOctalDigit(_cdbd) {
						_ead = append(_ead, _cdbd)
					} else {
						break
					}
				}
				_bgdf._gggee.Discard(len(_ead) - 1)
				_fdb.Log.Trace("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022", _ead)
				_gecg, _cdff := _d.ParseUint(string(_ead), 8, 32)
				if _cdff != nil {
					return MakeString(_begb.String()), _cdff
				}
				_begb.WriteByte(byte(_gecg))
				continue
			}
			switch _gbbcd {
			case 'n':
				_begb.WriteRune('\n')
			case 'r':
				_begb.WriteRune('\r')
			case 't':
				_begb.WriteRune('\t')
			case 'b':
				_begb.WriteRune('\b')
			case 'f':
				_begb.WriteRune('\f')
			case '(':
				_begb.WriteRune('(')
			case ')':
				_begb.WriteRune(')')
			case '\\':
				_begb.WriteRune('\\')
			}
			continue
		} else if _afdd[0] == '(' {
			_dbgb++
		} else if _afdd[0] == ')' {
			_dbgb--
			if _dbgb == 0 {
				_bgdf._gggee.ReadByte()
				break
			}
		}
		_cgcf, _ := _bgdf._gggee.ReadByte()
		_begb.WriteByte(_cgcf)
	}
	return MakeString(_begb.String()), nil
}

func (_dfgc *PdfParser) parsePdfVersion() (int, int, error) {
	var _gceb int64 = 20
	_ggcf := make([]byte, _gceb)
	_dfgc._gggee.Seek(0, _eed.SeekStart)
	_dfgc._gggee.Read(_ggcf)
	var _gdbga error
	var _dgcg, _fgaf int
	if _gbae := _gaaf.FindStringSubmatch(string(_ggcf)); len(_gbae) < 3 {
		if _dgcg, _fgaf, _gdbga = _dfgc.seekPdfVersionTopDown(); _gdbga != nil {
			_fdb.Log.Debug("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e")
			return 0, 0, _gdbga
		}
		_dfgc._gggee._bca, _gdbga = _ebff(_dfgc._gggee._bca, _dfgc.GetFileOffset()-8)
		if _gdbga != nil {
			return 0, 0, _gdbga
		}
	} else {
		if _dgcg, _gdbga = _d.Atoi(_gbae[1]); _gdbga != nil {
			return 0, 0, _gdbga
		}
		if _fgaf, _gdbga = _d.Atoi(_gbae[2]); _gdbga != nil {
			return 0, 0, _gdbga
		}
		_dfgc.SetFileOffset(0)
	}
	_dfgc._gggee._ffb = _ge.NewReader(_dfgc._gggee._bca)
	_fdb.Log.Debug("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064", _dgcg, _fgaf)
	return _dgcg, _fgaf, nil
}

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_dafa *PdfParser) GetRevision(revisionNumber int) (*PdfParser, error) {
	_bddee := _dafa._agdg
	if _bddee == revisionNumber {
		return _dafa, nil
	}
	if _bddee < revisionNumber {
		return nil, _b.New("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e")
	}
	if _dafa._ebaaa[revisionNumber] != nil {
		return _dafa._ebaaa[revisionNumber], nil
	}
	_dfgec := _dafa
	for ; _bddee > revisionNumber; _bddee-- {
		_accf, _bfddb := _dfgec.GetPreviousRevisionParser()
		if _bfddb != nil {
			return nil, _bfddb
		}
		_dafa._ebaaa[_bddee-1] = _accf
		_dafa._bcgf[_dfgec] = _accf
		_dfgec = _accf
	}
	return _dfgec, nil
}

func (_cgfdg *PdfParser) parseLinearizedDictionary() (*PdfObjectDictionary, error) {
	_geff, _dee := _cgfdg._gggee.Seek(0, _eed.SeekEnd)
	if _dee != nil {
		return nil, _dee
	}
	var _cabe int64
	var _fadbc int64 = 2048
	for _cabe < _geff-4 {
		if _geff <= (_fadbc + _cabe) {
			_fadbc = _geff - _cabe
		}
		_, _dfcf := _cgfdg._gggee.Seek(_cabe, _eed.SeekStart)
		if _dfcf != nil {
			return nil, _dfcf
		}
		_fagadc := make([]byte, _fadbc)
		_, _dfcf = _cgfdg._gggee.Read(_fagadc)
		if _dfcf != nil {
			return nil, _dfcf
		}
		_fdb.Log.Trace("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022", string(_fagadc))
		_eaaf := _bgbge.FindAllStringIndex(string(_fagadc), -1)
		if _eaaf != nil {
			_agbb := _eaaf[0]
			_fdb.Log.Trace("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064", _eaaf)
			_, _deca := _cgfdg._gggee.Seek(int64(_agbb[0]), _eed.SeekStart)
			if _deca != nil {
				return nil, _deca
			}
			_cgfdg._gggee._ffb = _ge.NewReader(_cgfdg._gggee._bca)
			_aadg, _deca := _cgfdg.ParseIndirectObject()
			if _deca != nil {
				return nil, nil
			}
			if _defg, _egbec := GetIndirect(_aadg); _egbec {
				if _dbbf, _ddae := GetDict(_defg.PdfObject); _ddae {
					if _bcdea := _dbbf.Get("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064"); _bcdea != nil {
						return _dbbf, nil
					}
					return nil, nil
				}
			}
			return nil, nil
		}
		_cabe += _fadbc - 4
	}
	return nil, _b.New("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064")
}

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_cddgf *MultiEncoder) EncodeBytes(data []byte) ([]byte, error) {
	_bddd := data
	var _adae error
	for _debbg := len(_cddgf._bdfea) - 1; _debbg >= 0; _debbg-- {
		_aecc := _cddgf._bdfea[_debbg]
		_bddd, _adae = _aecc.EncodeBytes(_bddd)
		if _adae != nil {
			return nil, _adae
		}
	}
	return _bddd, nil
}

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap(objmap map[string]PdfObject) *PdfObjectDictionary {
	_cbdbf := MakeDict()
	return _cbdbf.Update(objmap)
}

const _eabc = 6

var _bec = _bf.Pool{New: func() interface{} { return new(_e.Buffer) }}

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct {
	ColorComponents  int
	BitsPerComponent int
	Width            int
	Height           int
	Quality          int
	Decode           []float64
}

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString(s string, utf16BE bool) *PdfObjectString {
	if utf16BE {
		var _cfcbc _e.Buffer
		_cfcbc.Write([]byte{0xFE, 0xFF})
		_cfcbc.WriteString(_fb.StringToUTF16(s))
		return &PdfObjectString{_gdea: _cfcbc.String(), _gdgf: true}
	}
	return &PdfObjectString{_gdea: string(_fb.StringToPDFDocEncoding(s)), _gdgf: false}
}

const (
	_ebcg = 0
	_efee = 1
	_ggae = 2
	_aade = 3
	_fead = 4
)

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_geda *FlateEncoder) MakeDecodeParams() PdfObject {
	if _geda.Predictor > 1 {
		_cceb := MakeDict()
		_cceb.Set("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr", MakeInteger(int64(_geda.Predictor)))
		if _geda.BitsPerComponent != 8 {
			_cceb.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", MakeInteger(int64(_geda.BitsPerComponent)))
		}
		if _geda.Columns != 1 {
			_cceb.Set("\u0043o\u006c\u0075\u006d\u006e\u0073", MakeInteger(int64(_geda.Columns)))
		}
		if _geda.Colors != 1 {
			_cceb.Set("\u0043\u006f\u006c\u006f\u0072\u0073", MakeInteger(int64(_geda.Colors)))
		}
		return _cceb
	}
	return nil
}

type objectStreams map[int]objectStream

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_acab *LZWEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	_fdb.Log.Trace("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067")
	_fdb.Log.Trace("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064", _acab.Predictor)
	_gag, _dea := _acab.DecodeBytes(streamObj.Stream)
	if _dea != nil {
		return nil, _dea
	}
	_fdb.Log.Trace("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078", len(streamObj.Stream), streamObj.Stream)
	_fdb.Log.Trace("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078", len(_gag), _gag)
	if _acab.Predictor > 1 {
		if _acab.Predictor == 2 {
			_fdb.Log.Trace("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
			_afab := _acab.Columns * _acab.Colors
			if _afab < 1 {
				return []byte{}, nil
			}
			_efbe := len(_gag) / _afab
			if len(_gag)%_afab != 0 {
				_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e")
				return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029", len(_gag), _afab)
			}
			if _afab%_acab.Colors != 0 {
				return nil, _dg.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064", _afab, _acab.Colors)
			}
			if _afab > len(_gag) {
				_fdb.Log.Debug("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029", _afab, len(_gag))
				return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
			}
			_fdb.Log.Trace("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078", len(_gag), _gag)
			_gddb := _e.NewBuffer(nil)
			for _fabb := 0; _fabb < _efbe; _fabb++ {
				_afef := _gag[_afab*_fabb : _afab*(_fabb+1)]
				for _efdg := _acab.Colors; _efdg < _afab; _efdg++ {
					_afef[_efdg] = byte(int(_afef[_efdg]+_afef[_efdg-_acab.Colors]) % 256)
				}
				_gddb.Write(_afef)
			}
			_eede := _gddb.Bytes()
			_fdb.Log.Trace("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078", len(_eede), _eede)
			return _eede, nil
		} else if _acab.Predictor >= 10 && _acab.Predictor <= 15 {
			_fdb.Log.Trace("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
			_baec := _acab.Columns*_acab.Colors + 1
			if _baec < 1 {
				return []byte{}, nil
			}
			_bgf := len(_gag) / _baec
			if len(_gag)%_baec != 0 {
				return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029", len(_gag), _baec)
			}
			if _baec > len(_gag) {
				_fdb.Log.Debug("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029", _baec, len(_gag))
				return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
			}
			_gebdg := _e.NewBuffer(nil)
			_fdb.Log.Trace("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064", _acab.Columns)
			_fdb.Log.Trace("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s", len(_gag), _baec, _bgf)
			_ddg := make([]byte, _baec)
			for _ceg := 0; _ceg < _baec; _ceg++ {
				_ddg[_ceg] = 0
			}
			for _gdf := 0; _gdf < _bgf; _gdf++ {
				_edcad := _gag[_baec*_gdf : _baec*(_gdf+1)]
				_abaf := _edcad[0]
				switch _abaf {
				case 0:
				case 1:
					for _cgea := 2; _cgea < _baec; _cgea++ {
						_edcad[_cgea] = byte(int(_edcad[_cgea]+_edcad[_cgea-1]) % 256)
					}
				case 2:
					for _bcbd := 1; _bcbd < _baec; _bcbd++ {
						_edcad[_bcbd] = byte(int(_edcad[_bcbd]+_ddg[_bcbd]) % 256)
					}
				default:
					_fdb.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029", _abaf)
					return nil, _dg.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029", _abaf)
				}
				for _egef := 0; _egef < _baec; _egef++ {
					_ddg[_egef] = _edcad[_egef]
				}
				_gebdg.Write(_edcad[1:])
			}
			_gccd := _gebdg.Bytes()
			return _gccd, nil
		} else {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029", _acab.Predictor)
			return nil, _dg.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029", _acab.Predictor)
		}
	}
	return _gag, nil
}

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger(val int64) *PdfObjectInteger { _cabdb := PdfObjectInteger(val); return &_cabdb }

func (_dca *PdfParser) lookupByNumberWrapper(_gdc int, _cd bool) (PdfObject, bool, error) {
	_gbf, _cb, _cg := _dca.lookupByNumber(_gdc, _cd)
	if _cg != nil {
		return nil, _cb, _cg
	}
	if !_cb && _dca._dccfc != nil && _dca._dccfc._ffa && !_dca._dccfc.isDecrypted(_gbf) {
		_bgg := _dca._dccfc.Decrypt(_gbf, 0, 0)
		if _bgg != nil {
			return nil, _cb, _bgg
		}
	}
	return _gbf, _cb, nil
}

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_ggff *JBIG2Encoder) UpdateParams(params *PdfObjectDictionary) {
	_gfgf, _afbbb := GetNumberAsInt64(params.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"))
	if _afbbb == nil {
		_ggff.BitsPerComponent = int(_gfgf)
	}
	_cdcdg, _afbbb := GetNumberAsInt64(params.Get("\u0057\u0069\u0064t\u0068"))
	if _afbbb == nil {
		_ggff.Width = int(_cdcdg)
	}
	_daae, _afbbb := GetNumberAsInt64(params.Get("\u0048\u0065\u0069\u0067\u0068\u0074"))
	if _afbbb == nil {
		_ggff.Height = int(_daae)
	}
	_eecb, _afbbb := GetNumberAsInt64(params.Get("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"))
	if _afbbb == nil {
		_ggff.ColorComponents = int(_eecb)
	}
}

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_ddgb *PdfObjectString) Str() string { return _ddgb._gdea }

func (_degfa *PdfParser) parseName() (PdfObjectName, error) {
	var _adfab _e.Buffer
	_badg := false
	for {
		_bcca, _eccb := _degfa._gggee.Peek(1)
		if _eccb == _eed.EOF {
			break
		}
		if _eccb != nil {
			return PdfObjectName(_adfab.String()), _eccb
		}
		if !_badg {
			switch _bcca[0] {
			case '/':
				_badg = true
				_degfa._gggee.ReadByte()
			case '%':
				_degfa.readComment()
				_degfa.skipSpaces()
			default:
				_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029", _bcca, _bcca)
				return PdfObjectName(_adfab.String()), _dg.Errorf("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029", _bcca[0])
			}
		} else {
			if IsWhiteSpace(_bcca[0]) {
				break
			} else if (_bcca[0] == '/') || (_bcca[0] == '[') || (_bcca[0] == '(') || (_bcca[0] == ']') || (_bcca[0] == '<') || (_bcca[0] == '>') {
				break
			} else if _bcca[0] == '#' {
				_bfbbf, _cdga := _degfa._gggee.Peek(3)
				if _cdga != nil {
					return PdfObjectName(_adfab.String()), _cdga
				}
				_effad, _cdga := _fd.DecodeString(string(_bfbbf[1:3]))
				if _cdga != nil {
					_fdb.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074")
					_adfab.WriteByte('#')
					_degfa._gggee.Discard(1)
					continue
				}
				_degfa._gggee.Discard(3)
				_adfab.Write(_effad)
			} else {
				_eagcd, _ := _degfa._gggee.ReadByte()
				_adfab.WriteByte(_eagcd)
			}
		}
	}
	return PdfObjectName(_adfab.String()), nil
}

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{}

func (_cdaf *PdfParser) traceStreamLength(_bebc PdfObject) (PdfObject, error) {
	_ecab, _faag := _bebc.(*PdfObjectReference)
	if _faag {
		_fdcdd, _bbde := _cdaf._effa[_ecab.ObjectNumber]
		if _bbde && _fdcdd {
			_fdb.Log.Debug("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029")
			return nil, _b.New("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070")
		}
		_cdaf._effa[_ecab.ObjectNumber] = true
	}
	_cedg, _bbaa := _cdaf.Resolve(_bebc)
	if _bbaa != nil {
		return nil, _bbaa
	}
	_fdb.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073", _cedg)
	if _faag {
		_cdaf._effa[_ecab.ObjectNumber] = false
	}
	return _cedg, nil
}

func (_feeg *PdfParser) parseHexString() (*PdfObjectString, error) {
	_feeg._gggee.ReadByte()
	var _dafb _e.Buffer
	for {
		_egdg, _bcde := _feeg._gggee.Peek(1)
		if _bcde != nil {
			return MakeString(""), _bcde
		}
		if _egdg[0] == '>' {
			_feeg._gggee.ReadByte()
			break
		}
		_ceeb, _ := _feeg._gggee.ReadByte()
		if _feeg._baga {
			if _e.IndexByte(_cgbb, _ceeb) == -1 {
				_feeg._afcb._afb = true
			}
		}
		if !IsWhiteSpace(_ceeb) {
			_dafb.WriteByte(_ceeb)
		}
	}
	if _dafb.Len()%2 == 1 {
		_feeg._afcb._bcf = true
		_dafb.WriteRune('0')
	}
	_cbffb, _ := _fd.DecodeString(_dafb.String())
	return MakeHexString(string(_cbffb)), nil
}

func _fagd(_fbee, _acef PdfObject, _cdbf int) bool {
	if _cdbf > _cefd {
		_fdb.Log.Error("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021", _cefd)
		return false
	}
	if _fbee == nil && _acef == nil {
		return true
	} else if _fbee == nil || _acef == nil {
		return false
	}
	if _ef.TypeOf(_fbee) != _ef.TypeOf(_acef) {
		return false
	}
	switch _efcaf := _fbee.(type) {
	case *PdfObjectNull, *PdfObjectReference:
		return true
	case *PdfObjectName:
		return *_efcaf == *(_acef.(*PdfObjectName))
	case *PdfObjectString:
		return *_efcaf == *(_acef.(*PdfObjectString))
	case *PdfObjectInteger:
		return *_efcaf == *(_acef.(*PdfObjectInteger))
	case *PdfObjectBool:
		return *_efcaf == *(_acef.(*PdfObjectBool))
	case *PdfObjectFloat:
		return *_efcaf == *(_acef.(*PdfObjectFloat))
	case *PdfIndirectObject:
		return _fagd(TraceToDirectObject(_fbee), TraceToDirectObject(_acef), _cdbf+1)
	case *PdfObjectArray:
		_gbgb := _acef.(*PdfObjectArray)
		if len((*_efcaf)._abad) != len((*_gbgb)._abad) {
			return false
		}
		for _efade, _gafa := range (*_efcaf)._abad {
			if !_fagd(_gafa, (*_gbgb)._abad[_efade], _cdbf+1) {
				return false
			}
		}
		return true
	case *PdfObjectDictionary:
		_bffb := _acef.(*PdfObjectDictionary)
		_gded, _feffb := (*_efcaf)._bgfg, (*_bffb)._bgfg
		if len(_gded) != len(_feffb) {
			return false
		}
		for _afeb, _cecf := range _gded {
			_cebcg, _cbdf := _feffb[_afeb]
			if !_cbdf || !_fagd(_cecf, _cebcg, _cdbf+1) {
				return false
			}
		}
		return true
	case *PdfObjectStream:
		_fefge := _acef.(*PdfObjectStream)
		return _fagd((*_efcaf).PdfObjectDictionary, (*_fefge).PdfObjectDictionary, _cdbf+1)
	default:
		_fdb.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021", _fbee)
	}
	return false
}

func (_bfg *PdfParser) lookupByNumber(_gdg int, _ggd bool) (PdfObject, bool, error) {
	_efb, _fdfc := _bfg.ObjCache[_gdg]
	if _fdfc {
		_fdb.Log.Trace("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064", _gdg)
		return _efb, false, nil
	}
	if _bfg._bagc == nil {
		_bfg._bagc = map[int]bool{}
	}
	if _bfg._bagc[_gdg] {
		_fdb.Log.Debug("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064", _gdg)
		return nil, false, _b.New("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064")
	}
	_bfg._bagc[_gdg] = true
	defer delete(_bfg._bagc, _gdg)
	_bfa, _fdfc := _bfg._fabaa.ObjectMap[_gdg]
	if !_fdfc {
		_fdb.Log.Trace("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		var _aa PdfObjectNull
		return &_aa, false, nil
	}
	_fdb.Log.Trace("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064", _gdg)
	switch _bfa.XType {
	case XrefTypeTableEntry:
		_fdb.Log.Trace("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064", _bfa.ObjectNumber)
		_fdb.Log.Trace("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064", _bfa.Generation)
		_fdb.Log.Trace("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064", _bfa.Offset)
		_bfg._gggee.Seek(_bfa.Offset, _eed.SeekStart)
		_fab, _edg := _bfg.ParseIndirectObject()
		if _edg != nil {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029", _edg)
			if _ggd {
				_fdb.Log.Debug("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029")
				_fba, _eee := _bfg.repairRebuildXrefsTopDown()
				if _eee != nil {
					_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029", _eee)
					return nil, false, _eee
				}
				_bfg._fabaa = *_fba
				return _bfg.lookupByNumber(_gdg, false)
			}
			return nil, false, _edg
		}
		if _ggd {
			_bbge, _, _ := _ae(_fab)
			if int(_bbge) != _gdg {
				_fdb.Log.Debug("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg")
				_cf := _bfg.rebuildXrefTable()
				if _cf != nil {
					return nil, false, _cf
				}
				_bfg.ObjCache = objectCache{}
				return _bfg.lookupByNumberWrapper(_gdg, false)
			}
		}
		_fdb.Log.Trace("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a")
		_bfg.ObjCache[_gdg] = _fab
		return _fab, false, nil
	case XrefTypeObjectStream:
		_fdb.Log.Trace("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021")
		_fdb.Log.Trace("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021")
		_fdb.Log.Trace("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064", _bfa.OsObjNumber, _bfa.OsObjIndex)
		if _bfa.OsObjNumber == _gdg {
			_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021")
			return nil, true, _b.New("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
		}
		if _, _bbba := _bfg._fabaa.ObjectMap[_bfa.OsObjNumber]; _bbba {
			_db, _eag := _bfg.lookupObjectViaOS(_bfa.OsObjNumber, _gdg)
			if _eag != nil {
				_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029", _eag)
				return nil, true, _eag
			}
			_fdb.Log.Trace("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053")
			_bfg.ObjCache[_gdg] = _db
			if _bfg._dccfc != nil {
				_bfg._dccfc._fbe[_db] = true
			}
			return _db, true, nil
		}
		_fdb.Log.Debug("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021")
		return nil, true, _b.New("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	return nil, false, _b.New("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065")
}

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_dfeb *DCTEncoder) EncodeBytes(data []byte) ([]byte, error) {
	var _bbac _ff.Image
	if _dfeb.ColorComponents == 1 && _dfeb.BitsPerComponent == 8 {
		_bbac = &_ff.Gray{Rect: _ff.Rect(0, 0, _dfeb.Width, _dfeb.Height), Pix: data, Stride: _dfa.BytesPerLine(_dfeb.Width, _dfeb.BitsPerComponent, _dfeb.ColorComponents)}
	} else {
		var _deag error
		_bbac, _deag = _dfa.NewImage(_dfeb.Width, _dfeb.Height, _dfeb.BitsPerComponent, _dfeb.ColorComponents, data, nil, nil)
		if _deag != nil {
			return nil, _deag
		}
	}
	_gcaff := _fc.Options{}
	_gcaff.Quality = _dfeb.Quality
	var _ggc _e.Buffer
	if _ggb := _fc.Encode(&_ggc, _bbac, &_gcaff); _ggb != nil {
		return nil, _ggb
	}
	return _ggc.Bytes(), nil
}

// GetFilterName returns the name of the encoding filter.
func (_cace *JPXEncoder) GetFilterName() string { return StreamEncodingFilterNameJPX }

func (_gfceg *PdfParser) skipSpaces() (int, error) {
	_cga := 0
	for {
		_cdbg, _cedf := _gfceg._gggee.ReadByte()
		if _cedf != nil {
			return 0, _cedf
		}
		if IsWhiteSpace(_cdbg) {
			_cga++
		} else {
			_gfceg._gggee.UnreadByte()
			break
		}
	}
	return _cga, nil
}

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_eaac *PdfParser) ParseDict() (*PdfObjectDictionary, error) {
	_fdb.Log.Trace("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021")
	_faab := MakeDict()
	_faab._febb = _eaac
	_bcfc, _ := _eaac._gggee.ReadByte()
	if _bcfc != '<' {
		return nil, _b.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074")
	}
	_bcfc, _ = _eaac._gggee.ReadByte()
	if _bcfc != '<' {
		return nil, _b.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074")
	}
	for {
		_eaac.skipSpaces()
		_eaac.skipComments()
		_bfecb, _egff := _eaac._gggee.Peek(2)
		if _egff != nil {
			return nil, _egff
		}
		_fdb.Log.Trace("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021", string(_bfecb), string(_bfecb))
		if (_bfecb[0] == '>') && (_bfecb[1] == '>') {
			_fdb.Log.Trace("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
			_eaac._gggee.ReadByte()
			_eaac._gggee.ReadByte()
			break
		}
		_fdb.Log.Trace("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021")
		_ecdca, _egff := _eaac.parseName()
		_fdb.Log.Trace("\u004be\u0079\u003a\u0020\u0025\u0073", _ecdca)
		if _egff != nil {
			_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073", _egff)
			return nil, _egff
		}
		if len(_ecdca) > 4 && _ecdca[len(_ecdca)-4:] == "\u006e\u0075\u006c\u006c" {
			_afeg := _ecdca[0 : len(_ecdca)-4]
			_fdb.Log.Debug("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029", _ecdca)
			_fdb.Log.Debug("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c", _afeg)
			_eaac.skipSpaces()
			_gbbgg, _ := _eaac._gggee.Peek(1)
			if _gbbgg[0] == '/' {
				_faab.Set(_afeg, MakeNull())
				continue
			}
		}
		_eaac.skipSpaces()
		_gcaaf, _egff := _eaac.parseObject()
		if _egff != nil {
			return nil, _egff
		}
		_faab.Set(_ecdca, _gcaaf)
		if _fdb.Log.IsLogLevel(_fdb.LogLevelTrace) {
			_fdb.Log.Trace("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073", _ecdca, _gcaaf.String())
		}
	}
	_fdb.Log.Trace("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021")
	return _faab, nil
}

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt(parser *PdfParser, ed, trailer *PdfObjectDictionary) (*PdfCrypt, error) {
	_dbb := &PdfCrypt{_ffa: false, _fbe: make(map[PdfObject]bool), _egb: make(map[PdfObject]bool), _cfe: make(map[int]struct{}), _gfd: parser}
	_fef, _dccg := ed.Get("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName)
	if !_dccg {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021")
		return _dbb, _b.New("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067")
	}
	if *_fef != "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064" {
		_fdb.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029", *_fef)
		return _dbb, _b.New("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072")
	}
	_dbb._cabf.Filter = string(*_fef)
	if _cgc, _cffa := ed.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString); _cffa {
		_dbb._cabf.SubFilter = _cgc.Str()
		_fdb.Log.Debug("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073", _cgc)
	}
	if L, _bcdbg := ed.Get("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger); _bcdbg {
		if (*L % 8) != 0 {
			_fdb.Log.Debug("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
			return _dbb, _b.New("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h")
		}
		_dbb._cabf.Length = int(*L)
	} else {
		_dbb._cabf.Length = 40
	}
	_dbb._cabf.V = 0
	if _cdb, _bbgc := ed.Get("\u0056").(*PdfObjectInteger); _bbgc {
		V := int(*_cdb)
		_dbb._cabf.V = V
		if V >= 1 && V <= 2 {
			_dbb._fca = _dcac(_dbb._cabf.Length)
		} else if V >= 4 && V <= 5 {
			if _cce := _dbb.loadCryptFilters(ed); _cce != nil {
				return _dbb, _cce
			}
		} else {
			_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064", V)
			return _dbb, _b.New("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d")
		}
	}
	if _bfcc := _bbc(&_dbb._ecf, ed); _bfcc != nil {
		return _dbb, _bfcc
	}
	_gef := ""
	if _bad, _aedc := trailer.Get("\u0049\u0044").(*PdfObjectArray); _aedc && _bad.Len() >= 1 {
		_aeg, _adcd := GetString(_bad.Get(0))
		if !_adcd {
			return _dbb, _b.New("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044")
		}
		_gef = _aeg.Str()
	} else {
		_fdb.Log.Debug("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021")
	}
	_dbb._fda = _gef
	return _dbb, nil
}

func (_gcg *FlateEncoder) postDecodePredict(_abe []byte) ([]byte, error) {
	if _gcg.Predictor > 1 {
		if _gcg.Predictor == 2 {
			_fdb.Log.Trace("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
			_fdb.Log.Trace("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064", _gcg.Colors)
			_ebaf := _gcg.Columns * _gcg.Colors
			if _ebaf < 1 {
				return []byte{}, nil
			}
			_efgd := len(_abe) / _ebaf
			if len(_abe)%_ebaf != 0 {
				_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e")
				return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029", len(_abe), _ebaf)
			}
			if _ebaf%_gcg.Colors != 0 {
				return nil, _dg.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064", _ebaf, _gcg.Colors)
			}
			if _ebaf > len(_abe) {
				_fdb.Log.Debug("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029", _ebaf, len(_abe))
				return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
			}
			_fdb.Log.Trace("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078", len(_abe), _abe)
			_bde := _e.NewBuffer(nil)
			for _gadf := 0; _gadf < _efgd; _gadf++ {
				_eefd := _abe[_ebaf*_gadf : _ebaf*(_gadf+1)]
				for _fcge := _gcg.Colors; _fcge < _ebaf; _fcge++ {
					_eefd[_fcge] += _eefd[_fcge-_gcg.Colors]
				}
				_bde.Write(_eefd)
			}
			_ggdf := _bde.Bytes()
			_fdb.Log.Trace("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078", len(_ggdf), _ggdf)
			return _ggdf, nil
		} else if _gcg.Predictor >= 10 && _gcg.Predictor <= 15 {
			_fdb.Log.Trace("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
			_bge := _gcg.Columns*_gcg.Colors + 1
			_fbbb := len(_abe) / _bge
			if len(_abe)%_bge != 0 {
				return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029", len(_abe), _bge)
			}
			if _bge > len(_abe) {
				_fdb.Log.Debug("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029", _bge, len(_abe))
				return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
			}
			_dce := _e.NewBuffer(nil)
			_fdb.Log.Trace("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064", _gcg.Columns)
			_fdb.Log.Trace("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s", len(_abe), _bge, _fbbb)
			_beg := make([]byte, _bge)
			for _ace := 0; _ace < _bge; _ace++ {
				_beg[_ace] = 0
			}
			_bfae := _gcg.Colors
			for _acgd := 0; _acgd < _fbbb; _acgd++ {
				_edbd := _abe[_bge*_acgd : _bge*(_acgd+1)]
				_gbca := _edbd[0]
				switch _gbca {
				case _ebcg:
				case _efee:
					for _bfded := 1 + _bfae; _bfded < _bge; _bfded++ {
						_edbd[_bfded] += _edbd[_bfded-_bfae]
					}
				case _ggae:
					for _gbd := 1; _gbd < _bge; _gbd++ {
						_edbd[_gbd] += _beg[_gbd]
					}
				case _aade:
					for _cced := 1; _cced < _bfae+1; _cced++ {
						_edbd[_cced] += _beg[_cced] / 2
					}
					for _gee := _bfae + 1; _gee < _bge; _gee++ {
						_edbd[_gee] += byte((int(_edbd[_gee-_bfae]) + int(_beg[_gee])) / 2)
					}
				case _fead:
					for _ffcd := 1; _ffcd < _bge; _ffcd++ {
						var _ccf, _afe, _gfbb byte
						_afe = _beg[_ffcd]
						if _ffcd >= _bfae+1 {
							_ccf = _edbd[_ffcd-_bfae]
							_gfbb = _beg[_ffcd-_bfae]
						}
						_edbd[_ffcd] += _ebbg(_ccf, _afe, _gfbb)
					}
				default:
					_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064", _gbca, _acgd)
					return nil, _dg.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029", _gbca)
				}
				copy(_beg, _edbd)
				_dce.Write(_edbd[1:])
			}
			_cfbd := _dce.Bytes()
			return _cfbd, nil
		} else {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029", _gcg.Predictor)
			return nil, _dg.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029", _gcg.Predictor)
		}
	}
	return _abe, nil
}

func (_fad *PdfParser) checkPostEOFData() error {
	const _gfb = "\u0025\u0025\u0045O\u0046"
	_, _ecac := _fad._gggee.Seek(-int64(len([]byte(_gfb)))-1, _eed.SeekEnd)
	if _ecac != nil {
		return _ecac
	}
	_eedff := make([]byte, len([]byte(_gfb))+1)
	_, _ecac = _fad._gggee.Read(_eedff)
	if _ecac != nil {
		if _ecac != _eed.EOF {
			return _ecac
		}
	}
	if string(_eedff) == _gfb || string(_eedff) == _gfb+"\u000a" {
		_fad._afcb._degd = true
	}
	return nil
}

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_edfd *PdfCrypt) Encrypt(obj PdfObject, parentObjNum, parentGenNum int64) error {
	if _edfd.isEncrypted(obj) {
		return nil
	}
	switch _cbaf := obj.(type) {
	case *PdfIndirectObject:
		_edfd._egb[_cbaf] = true
		_fdb.Log.Trace("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021", _cbaf.ObjectNumber, _cbaf.GenerationNumber)
		_bdfc := _cbaf.ObjectNumber
		_bab := _cbaf.GenerationNumber
		_decea := _edfd.Encrypt(_cbaf.PdfObject, _bdfc, _bab)
		if _decea != nil {
			return _decea
		}
		return nil
	case *PdfObjectStream:
		_edfd._egb[_cbaf] = true
		_ffg := _cbaf.PdfObjectDictionary
		if _gcdg, _bdag := _ffg.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName); _bdag && *_gcdg == "\u0058\u0052\u0065\u0066" {
			return nil
		}
		_gccg := _cbaf.ObjectNumber
		_dfgf := _cbaf.GenerationNumber
		_fdb.Log.Trace("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!", _gccg, _dfgf)
		_bgd := _bdc
		if _edfd._cabf.V >= 4 {
			_bgd = _edfd._cef
			_fdb.Log.Trace("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073", _edfd._cef)
			if _dfafb, _beb := _ffg.Get("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray); _beb {
				if _gdbd, _fcdd := GetName(_dfafb.Get(0)); _fcdd {
					if *_gdbd == "\u0043\u0072\u0079p\u0074" {
						_bgd = "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"
						if _fbea, _fgfd := _ffg.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary); _fgfd {
							if _bfd, _dfed := _fbea.Get("\u004e\u0061\u006d\u0065").(*PdfObjectName); _dfed {
								if _, _aaae := _edfd._fca[string(*_bfd)]; _aaae {
									_fdb.Log.Trace("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073", *_bfd)
									_bgd = string(*_bfd)
								}
							}
						}
					}
				}
			}
			_fdb.Log.Trace("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072", _bgd)
			if _bgd == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079" {
				return nil
			}
		}
		_agcc := _edfd.Encrypt(_cbaf.PdfObjectDictionary, _gccg, _dfgf)
		if _agcc != nil {
			return _agcc
		}
		_cdf, _agcc := _edfd.makeKey(_bgd, uint32(_gccg), uint32(_dfgf), _edfd._bae)
		if _agcc != nil {
			return _agcc
		}
		_cbaf.Stream, _agcc = _edfd.encryptBytes(_cbaf.Stream, _bgd, _cdf)
		if _agcc != nil {
			return _agcc
		}
		_ffg.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(int64(len(_cbaf.Stream))))
		return nil
	case *PdfObjectString:
		_fdb.Log.Trace("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021")
		_fggea := _bdc
		if _edfd._cabf.V >= 4 {
			_fdb.Log.Trace("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072", _edfd._cfd)
			if _edfd._cfd == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079" {
				return nil
			}
			_fggea = _edfd._cfd
		}
		_age, _cbb := _edfd.makeKey(_fggea, uint32(parentObjNum), uint32(parentGenNum), _edfd._bae)
		if _cbb != nil {
			return _cbb
		}
		_faae := _cbaf.Str()
		_ebcc := make([]byte, len(_faae))
		for _fee := 0; _fee < len(_faae); _fee++ {
			_ebcc[_fee] = _faae[_fee]
		}
		_fdb.Log.Trace("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078", _ebcc, _ebcc)
		_ebcc, _cbb = _edfd.encryptBytes(_ebcc, _fggea, _age)
		if _cbb != nil {
			return _cbb
		}
		_cbaf._gdea = string(_ebcc)
		return nil
	case *PdfObjectArray:
		for _, _ebddc := range _cbaf.Elements() {
			_gdd := _edfd.Encrypt(_ebddc, parentObjNum, parentGenNum)
			if _gdd != nil {
				return _gdd
			}
		}
		return nil
	case *PdfObjectDictionary:
		_eaf := false
		if _dabe := _cbaf.Get("\u0054\u0079\u0070\u0065"); _dabe != nil {
			_beag, _ccee := _dabe.(*PdfObjectName)
			if _ccee && *_beag == "\u0053\u0069\u0067" {
				_eaf = true
			}
		}
		for _, _beaa := range _cbaf.Keys() {
			_fege := _cbaf.Get(_beaa)
			if _eaf && string(_beaa) == "\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073" {
				continue
			}
			if string(_beaa) != "\u0050\u0061\u0072\u0065\u006e\u0074" && string(_beaa) != "\u0050\u0072\u0065\u0076" && string(_beaa) != "\u004c\u0061\u0073\u0074" {
				_gcf := _edfd.Encrypt(_fege, parentObjNum, parentGenNum)
				if _gcf != nil {
					return _gcf
				}
			}
		}
		return nil
	}
	return nil
}

func (_acbf *PdfObjectDictionary) setWithLock(_gbggb PdfObjectName, _eggc PdfObject, _cgdf bool) {
	if _cgdf {
		_acbf._dcge.Lock()
		defer _acbf._dcge.Unlock()
	}
	_, _dcdbd := _acbf._bgfg[_gbggb]
	if !_dcdbd {
		_acbf._faaee = append(_acbf._faaee, _gbggb)
	}
	_acbf._bgfg[_gbggb] = _eggc
}

// MultiEncoder supports serial encoding.
type MultiEncoder struct{ _bdfea []StreamEncoder }

func (_aeee *PdfParser) parseNull() (PdfObjectNull, error) {
	_, _adee := _aeee._gggee.Discard(4)
	return PdfObjectNull{}, _adee
}

// Validate validates the page settings for the JBIG2 encoder.
func (_fadg JBIG2EncoderSettings) Validate() error {
	const _dfca = "\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072"
	if _fadg.Threshold < 0 || _fadg.Threshold > 1.0 {
		return _fag.Errorf(_dfca, "\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d", _fadg.Threshold)
	}
	if _fadg.ResolutionX < 0 {
		return _fag.Errorf(_dfca, "\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065", _fadg.ResolutionX)
	}
	if _fadg.ResolutionY < 0 {
		return _fag.Errorf(_dfca, "\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065", _fadg.ResolutionY)
	}
	if _fadg.DefaultPixelValue != 0 && _fadg.DefaultPixelValue != 1 {
		return _fag.Errorf(_dfca, "de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}", _fadg.DefaultPixelValue)
	}
	if _fadg.Compression != JB2Generic {
		return _fag.Errorf(_dfca, "\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
	}
	return nil
}

// GetFilterName returns the name of the encoding filter.
func (_bfge *DCTEncoder) GetFilterName() string { return StreamEncodingFilterNameDCT }

func (_gce *PdfCrypt) saveCryptFilters(_dcd *PdfObjectDictionary) error {
	if _gce._cabf.V < 4 {
		return _b.New("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034")
	}
	_dabb := MakeDict()
	_dcd.Set("\u0043\u0046", _dabb)
	for _fgc, _ebde := range _gce._fca {
		if _fgc == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079" {
			continue
		}
		_dac := _cea(_ebde, "")
		_dabb.Set(PdfObjectName(_fgc), _dac)
	}
	_dcd.Set("\u0053\u0074\u0072\u0046", MakeName(_gce._cfd))
	_dcd.Set("\u0053\u0074\u006d\u0046", MakeName(_gce._cef))
	return nil
}

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_dddf *PdfParser) GetFileOffset() int64 { return _dddf._gggee.GetFileOffset() }

// Elements returns a slice of the PdfObject elements in the array.
func (_dffa *PdfObjectArray) Elements() []PdfObject {
	if _dffa == nil {
		return nil
	}
	return _dffa._abad
}

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dacf *PdfObjectArray) ToInt64Slice() ([]int64, error) {
	var _fdade []int64
	for _, _ebbff := range _dacf.Elements() {
		if _aedg, _cedgf := _ebbff.(*PdfObjectInteger); _cedgf {
			_fdade = append(_fdade, int64(*_aedg))
		} else {
			return nil, ErrTypeError
		}
	}
	return _fdade, nil
}

func (_bgfgc *PdfParser) rebuildXrefTable() error {
	_addbfe := XrefTable{}
	_addbfe.ObjectMap = map[int]XrefObject{}
	_gdeag := make([]int, 0, len(_bgfgc._fabaa.ObjectMap))
	for _gdecc := range _bgfgc._fabaa.ObjectMap {
		_gdeag = append(_gdeag, _gdecc)
	}
	_de.Ints(_gdeag)
	for _, _bbbg := range _gdeag {
		_daga := _bgfgc._fabaa.ObjectMap[_bbbg]
		_baff, _, _bcdf := _bgfgc.lookupByNumberWrapper(_bbbg, false)
		if _bcdf != nil {
			_fdb.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029", _bcdf)
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020")
			_gdbc, _babe := _bgfgc.repairRebuildXrefsTopDown()
			if _babe != nil {
				_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029", _babe)
				return _babe
			}
			_bgfgc._fabaa = *_gdbc
			_fdb.Log.Debug("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct")
			return nil
		}
		_ebebd, _dbbaf, _bcdf := _ae(_baff)
		if _bcdf != nil {
			return _bcdf
		}
		_daga.ObjectNumber = int(_ebebd)
		_daga.Generation = int(_dbbaf)
		_addbfe.ObjectMap[int(_ebebd)] = _daga
	}
	_bgfgc._fabaa = _addbfe
	_fdb.Log.Debug("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074")
	_dbc(_bgfgc._fabaa)
	return nil
}

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct {

	// Width and Height defines the image boundaries.
	Width, Height int

	// Data is the byte slice data for the input image
	Data []byte

	// HasPadding is the attribute that defines if the last byte of the data in the row contains
	// 0 bits padding.
	HasPadding bool
}

var _gfgb = _a.MustCompile("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d")

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{}

// Write outputs the object as it is to be written to file.
func (_fbfe *PdfObjectReference) Write() []byte {
	return _edb(func(_dgce *_e.Buffer) {
		_dgce.WriteString(_d.FormatInt(_fbfe.ObjectNumber, 10))
		_dgce.WriteString("\u0020")
		_dgce.WriteString(_d.FormatInt(_fbfe.GenerationNumber, 10))
		_dgce.WriteString("\u0020\u0052")
	})
}

func (_dcbad *PdfParser) repairSeekXrefMarker() error {
	_daaaf, _efbf := _dcbad._gggee.Seek(0, _eed.SeekEnd)
	if _efbf != nil {
		return _efbf
	}
	_ddba := _a.MustCompile("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*")
	var _gbfbd int64
	var _ffecd int64 = 1000
	for _gbfbd < _daaaf {
		if _daaaf <= (_ffecd + _gbfbd) {
			_ffecd = _daaaf - _gbfbd
		}
		_, _gbcf := _dcbad._gggee.Seek(-_gbfbd-_ffecd, _eed.SeekEnd)
		if _gbcf != nil {
			return _gbcf
		}
		_fcbe := make([]byte, _ffecd)
		_dcbad._gggee.Read(_fcbe)
		_fdb.Log.Trace("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022", string(_fcbe))
		_aedaf := _ddba.FindAllStringIndex(string(_fcbe), -1)
		if _aedaf != nil {
			_fedfc := _aedaf[len(_aedaf)-1]
			_fdb.Log.Trace("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064", _aedaf)
			_dcbad._gggee.Seek(-_gbfbd-_ffecd+int64(_fedfc[0]), _eed.SeekEnd)
			for {
				_bebda, _acag := _dcbad._gggee.Peek(1)
				if _acag != nil {
					return _acag
				}
				_fdb.Log.Trace("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063", _bebda[0], _bebda[0])
				if !IsWhiteSpace(_bebda[0]) {
					break
				}
				_dcbad._gggee.Discard(1)
			}
			return nil
		}
		_fdb.Log.Debug("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067")
		_gbfbd += _ffecd
	}
	_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e")
	return _b.New("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020")
}

func (_ddeb *PdfParser) repairLocateXref() (int64, error) {
	_ccbf := int64(1000)
	_ddeb._gggee.Seek(-_ccbf, _eed.SeekCurrent)
	_cadfb, _edggd := _ddeb._gggee.Seek(0, _eed.SeekCurrent)
	if _edggd != nil {
		return 0, _edggd
	}
	_edafc := make([]byte, _ccbf)
	_ddeb._gggee.Read(_edafc)
	_dggf := _gfgb.FindAllStringIndex(string(_edafc), -1)
	if len(_dggf) < 1 {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021")
		return 0, _b.New("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	_fggf := int64(_dggf[len(_dggf)-1][0])
	_gddef := _cadfb + _fggf
	return _gddef, nil
}

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_gba *LZWEncoder) EncodeBytes(data []byte) ([]byte, error) {
	if _gba.Predictor != 1 {
		return nil, _dg.Errorf("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074")
	}
	if _gba.EarlyChange == 1 {
		return nil, _dg.Errorf("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074")
	}
	var _bba _e.Buffer
	_cac := _df.NewWriter(&_bba, _df.MSB, 8)
	_cac.Write(data)
	_cac.Close()
	return _bba.Bytes(), nil
}

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_abcf *PdfObjectString) IsHexadecimal() bool { return _abcf._gdgf }

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct {

	// These values are required to be set for the 'EncodeBytes' method.
	// ColorComponents defines the number of color components for provided image.
	ColorComponents int

	// BitsPerComponent is the number of bits that stores per color component
	BitsPerComponent int

	// Width is the width of the image to encode
	Width int

	// Height is the height of the image to encode.
	Height int
	_cabc  *_edc.Document

	// Globals are the JBIG2 global segments.
	Globals _bb.Globals

	// IsChocolateData defines if the data is encoded such that
	// binary data '1' means black and '0' white.
	// otherwise the data is called vanilla.
	// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
	IsChocolateData bool

	// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
	DefaultPageSettings JBIG2EncoderSettings
}

// Implement the Read and Seek methods.
func (_ade *bufferedReadSeeker) Read(p []byte) (int, error) { return _ade._ffb.Read(p) }

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_bfeee *MultiEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_gfdg := encoded
	var _dcdfb error
	for _, _dcfb := range _bfeee._bdfea {
		_fdb.Log.Trace("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054", _dcfb, _dcfb)
		_gfdg, _dcdfb = _dcfb.DecodeBytes(_gfdg)
		if _dcdfb != nil {
			return nil, _dcdfb
		}
	}
	return _gfdg, nil
}

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_dacb ParserMetadata) HasInvalidSeparationAfterXRef() bool { return _dacb._egf }

func (_eegg *PdfParser) parseObject() (PdfObject, error) {
	_fdb.Log.Trace("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074")
	_eegg.skipSpaces()
	for {
		_ecbb, _gddee := _eegg._gggee.Peek(2)
		if _gddee != nil {
			if _gddee != _eed.EOF || len(_ecbb) == 0 {
				return nil, _gddee
			}
			if len(_ecbb) == 1 {
				_ecbb = append(_ecbb, ' ')
			}
		}
		_fdb.Log.Trace("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073", string(_ecbb))
		if _ecbb[0] == '/' {
			_fadd, _acaf := _eegg.parseName()
			_fdb.Log.Trace("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027", _fadd)
			return &_fadd, _acaf
		} else if _ecbb[0] == '(' {
			_fdb.Log.Trace("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!")
			_gbeag, _fedgc := _eegg.parseString()
			return _gbeag, _fedgc
		} else if _ecbb[0] == '[' {
			_fdb.Log.Trace("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021")
			_cgcfb, _fge := _eegg.parseArray()
			return _cgcfb, _fge
		} else if (_ecbb[0] == '<') && (_ecbb[1] == '<') {
			_fdb.Log.Trace("\u002d>\u0044\u0069\u0063\u0074\u0021")
			_aea, _cegc := _eegg.ParseDict()
			return _aea, _cegc
		} else if _ecbb[0] == '<' {
			_fdb.Log.Trace("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021")
			_gddc, _fdbdd := _eegg.parseHexString()
			return _gddc, _fdbdd
		} else if _ecbb[0] == '%' {
			_eegg.readComment()
			_eegg.skipSpaces()
		} else {
			_fdb.Log.Trace("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f")
			_ecbb, _ = _eegg._gggee.Peek(15)
			_ddcf := string(_ecbb)
			_fdb.Log.Trace("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073", _ddcf)
			if (len(_ddcf) > 3) && (_ddcf[:4] == "\u006e\u0075\u006c\u006c") {
				_ceb, _ebag := _eegg.parseNull()
				return &_ceb, _ebag
			} else if (len(_ddcf) > 4) && (_ddcf[:5] == "\u0066\u0061\u006cs\u0065") {
				_fccf, _edfdf := _eegg.parseBool()
				return &_fccf, _edfdf
			} else if (len(_ddcf) > 3) && (_ddcf[:4] == "\u0074\u0072\u0075\u0065") {
				_ccfd, _bebg := _eegg.parseBool()
				return &_ccfd, _bebg
			}
			_gecb := _gbbc.FindStringSubmatch(_ddcf)
			if len(_gecb) > 1 {
				_ecbb, _ = _eegg._gggee.ReadBytes('R')
				_fdb.Log.Trace("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027", string(_ecbb[:]))
				_bgffc, _eabb := _bdded(string(_ecbb))
				_bgffc._agfgc = _eegg
				return &_bgffc, _eabb
			}
			_gddd := _cbcbg.FindStringSubmatch(_ddcf)
			if len(_gddd) > 1 {
				_fdb.Log.Trace("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021")
				_efgdf, _abef := _eegg.parseNumber()
				return _efgdf, _abef
			}
			_gddd = _aagag.FindStringSubmatch(_ddcf)
			if len(_gddd) > 1 {
				_fdb.Log.Trace("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021")
				_fdb.Log.Trace("\u0025\u0020\u0073", _gddd)
				_aegf, _gadfb := _eegg.parseNumber()
				return _aegf, _gadfb
			}
			_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)", _ddcf)
			return nil, _b.New("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e")
		}
	}
}

// Append appends PdfObject(s) to the array.
func (_ccfg *PdfObjectArray) Append(objects ...PdfObject) {
	if _ccfg == nil {
		_fdb.Log.Debug("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079")
		return
	}
	_ccfg._abad = append(_ccfg._abad, objects...)
}

func (_dbdf *PdfParser) seekPdfVersionTopDown() (int, int, error) {
	_dbdf._gggee.Seek(0, _eed.SeekStart)
	_bbcee := 20
	_afaa := make([]byte, _bbcee)
	for {
		_bebfa, _geffe := _dbdf._gggee.ReadByte()
		if _geffe != nil {
			if _geffe == _eed.EOF {
				break
			} else {
				return 0, 0, _geffe
			}
		}
		if IsDecimalDigit(_bebfa) && _afaa[_bbcee-1] == '.' && IsDecimalDigit(_afaa[_bbcee-2]) && _afaa[_bbcee-3] == '-' && _afaa[_bbcee-4] == 'F' && _afaa[_bbcee-5] == 'D' && _afaa[_bbcee-6] == 'P' {
			_deaa := int(_afaa[_bbcee-2] - '0')
			_ddeae := int(_bebfa - '0')
			return _deaa, _ddeae, nil
		}
		_afaa = append(_afaa[1:_bbcee], _bebfa)
	}
	return 0, 0, _b.New("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder() *JBIG2Encoder { return &JBIG2Encoder{_cabc: _edc.InitEncodeDocument(false)} }

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_egdf *JBIG2Encoder) EncodeImage(img _ff.Image) ([]byte, error) {
	return _egdf.encodeImage(img)
}

type offsetReader struct {
	_ebfac _eed.ReadSeeker
	_aadaa int64
}

var _bcbb = _a.MustCompile("\u0025\u0025\u0045\u004f\u0046\u003f")

func _ebff(_edfe _eed.ReadSeeker, _afdc int64) (*offsetReader, error) {
	_agdbf := &offsetReader{_ebfac: _edfe, _aadaa: _afdc}
	_, _efgbd := _agdbf.Seek(0, _eed.SeekStart)
	return _agdbf, _efgbd
}

// GetParser returns the parser for lazy-loading or compare references.
func (_cdda *PdfObjectReference) GetParser() *PdfParser { return _cdda._agfgc }

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface {

	// String outputs a string representation of the primitive (for debugging).
	String() string

	// Write outputs the PDF primitive as written to file as expected by the standard.
	Write() []byte
}

func (_ceag *PdfParser) readComment() (string, error) {
	var _fcaa _e.Buffer
	_, _gbgee := _ceag.skipSpaces()
	if _gbgee != nil {
		return _fcaa.String(), _gbgee
	}
	_cfg := true
	for {
		_ebgg, _fdgg := _ceag._gggee.Peek(1)
		if _fdgg != nil {
			_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _fdgg.Error())
			return _fcaa.String(), _fdgg
		}
		if _cfg && _ebgg[0] != '%' {
			return _fcaa.String(), _b.New("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025")
		}
		_cfg = false
		if (_ebgg[0] != '\r') && (_ebgg[0] != '\n') {
			_adgg, _ := _ceag._gggee.ReadByte()
			_fcaa.WriteByte(_adgg)
		} else {
			break
		}
	}
	return _fcaa.String(), nil
}

// UpdateParams updates the parameter values of the encoder.
func (_caad *LZWEncoder) UpdateParams(params *PdfObjectDictionary) {
	_gbb, _gccb := GetNumberAsInt64(params.Get("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"))
	if _gccb == nil {
		_caad.Predictor = int(_gbb)
	}
	_ebcf, _gccb := GetNumberAsInt64(params.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"))
	if _gccb == nil {
		_caad.BitsPerComponent = int(_ebcf)
	}
	_fgcf, _gccb := GetNumberAsInt64(params.Get("\u0057\u0069\u0064t\u0068"))
	if _gccb == nil {
		_caad.Columns = int(_fgcf)
	}
	_bdd, _gccb := GetNumberAsInt64(params.Get("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"))
	if _gccb == nil {
		_caad.Colors = int(_bdd)
	}
	_dfde, _gccb := GetNumberAsInt64(params.Get("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"))
	if _gccb == nil {
		_caad.EarlyChange = int(_dfde)
	}
}

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal(obj PdfObject) (_eddd float64, _aggge bool) {
	_bfgcd, _aggge := TraceToDirectObject(obj).(*PdfObjectFloat)
	if _aggge {
		return float64(*_bfgcd), true
	}
	return 0, false
}

var _bgbge = _a.MustCompile("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a")

const (
	XrefTypeTableEntry   xrefType = iota
	XrefTypeObjectStream xrefType = iota
)

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder() *MultiEncoder {
	_ccag := MultiEncoder{}
	_ccag._bdfea = []StreamEncoder{}
	return &_ccag
}

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit(c byte) bool { return ('0' <= c && c <= '9') || c == '.' }

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fggd *RunLengthEncoder) MakeDecodeParams() PdfObject { return nil }

func _edb(_adf func(*_e.Buffer)) []byte {
	_c := _bcc()
	defer _bd(_c)
	_adf(_c)
	_fg := _c.Bytes()
	_ga := make([]byte, len(_fg))
	copy(_ga, _fg)
	return _ga
}

// GetXrefTable returns the PDFs xref table.
func (_bcbga *PdfParser) GetXrefTable() XrefTable { return _bcbga._fabaa }

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct {
	PdfObjectReference
	PdfObject
}

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cdg *FlateEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	_fdb.Log.Trace("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d")
	_fdb.Log.Trace("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064", _cdg.Predictor)
	if _cdg.BitsPerComponent != 8 {
		return nil, _dg.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029", _cdg.BitsPerComponent)
	}
	_cge, _ecdf := _cdg.DecodeBytes(streamObj.Stream)
	if _ecdf != nil {
		return nil, _ecdf
	}
	_cge, _ecdf = _cdg.postDecodePredict(_cge)
	if _ecdf != nil {
		return nil, _ecdf
	}
	return _cge, nil
}

var _gaaf = _a.MustCompile("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029")

// HeaderCommentBytes gets the header comment bytes.
func (_gbfd ParserMetadata) HeaderCommentBytes() [4]byte { return _gbfd._gegc }

func (_cda *PdfParser) parseDetailedHeader() (_bdb error) {
	_cda._gggee.Seek(0, _eed.SeekStart)
	_bef := 20
	_feab := make([]byte, _bef)
	var (
		_bebe bool
		_cbg  int
	)
	for {
		_edeb, _bfde := _cda._gggee.ReadByte()
		if _bfde != nil {
			if _bfde == _eed.EOF {
				break
			} else {
				return _bfde
			}
		}
		if IsDecimalDigit(_edeb) && _feab[_bef-1] == '.' && IsDecimalDigit(_feab[_bef-2]) && _feab[_bef-3] == '-' && _feab[_bef-4] == 'F' && _feab[_bef-5] == 'D' && _feab[_bef-6] == 'P' && _feab[_bef-7] == '%' {
			_cda._baefa = Version{Major: int(_feab[_bef-2] - '0'), Minor: int(_edeb - '0')}
			_cda._afcb._cad = _cbg - 7
			_bebe = true
			break
		}
		_cbg++
		_feab = append(_feab[1:_bef], _edeb)
	}
	if !_bebe {
		return _dg.Errorf("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064")
	}
	_afce, _bdb := _cda._gggee.ReadByte()
	if _bdb == _eed.EOF {
		return _dg.Errorf("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074")
	}
	if _bdb != nil {
		return _bdb
	}
	_cda._afcb._edcbb = _afce == '\n'
	_afce, _bdb = _cda._gggee.ReadByte()
	if _bdb != nil {
		return _dg.Errorf("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077", _bdb)
	}
	if _afce != '%' {
		return nil
	}
	_bdage := make([]byte, 4)
	_, _bdb = _cda._gggee.Read(_bdage)
	if _bdb != nil {
		return _dg.Errorf("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077", _bdb)
	}
	_cda._afcb._gegc = [4]byte{_bdage[0], _bdage[1], _bdage[2], _bdage[3]}
	return nil
}

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray(obj PdfObject) (_ggbbc *PdfObjectArray, _eefgd bool) {
	_ggbbc, _eefgd = TraceToDirectObject(obj).(*PdfObjectArray)
	return _ggbbc, _eefgd
}

type encryptDict struct {
	Filter    string
	V         int
	SubFilter string
	Length    int
	StmF      string
	StrF      string
	EFF       string
	CF        map[string]_bc.FilterDict
}

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_aaag *RunLengthEncoder) EncodeBytes(data []byte) ([]byte, error) {
	_afcee := _e.NewReader(data)
	var _ebf []byte
	var _ffec []byte
	_dbfc, _bbgf := _afcee.ReadByte()
	if _bbgf == _eed.EOF {
		return []byte{}, nil
	} else if _bbgf != nil {
		return nil, _bbgf
	}
	_cbdb := 1
	for {
		_baaae, _dcb := _afcee.ReadByte()
		if _dcb == _eed.EOF {
			break
		} else if _dcb != nil {
			return nil, _dcb
		}
		if _baaae == _dbfc {
			if len(_ffec) > 0 {
				_ffec = _ffec[:len(_ffec)-1]
				if len(_ffec) > 0 {
					_ebf = append(_ebf, byte(len(_ffec)-1))
					_ebf = append(_ebf, _ffec...)
				}
				_cbdb = 1
				_ffec = []byte{}
			}
			_cbdb++
			if _cbdb >= 127 {
				_ebf = append(_ebf, byte(257-_cbdb), _dbfc)
				_cbdb = 0
			}
		} else {
			if _cbdb > 0 {
				if _cbdb == 1 {
					_ffec = []byte{_dbfc}
				} else {
					_ebf = append(_ebf, byte(257-_cbdb), _dbfc)
				}
				_cbdb = 0
			}
			_ffec = append(_ffec, _baaae)
			if len(_ffec) >= 127 {
				_ebf = append(_ebf, byte(len(_ffec)-1))
				_ebf = append(_ebf, _ffec...)
				_ffec = []byte{}
			}
		}
		_dbfc = _baaae
	}
	if len(_ffec) > 0 {
		_ebf = append(_ebf, byte(len(_ffec)-1))
		_ebf = append(_ebf, _ffec...)
	} else if _cbdb > 0 {
		_ebf = append(_ebf, byte(257-_cbdb), _dbfc)
	}
	_ebf = append(_ebf, 128)
	return _ebf, nil
}

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_ecde *PdfParser) ReadAtLeast(p []byte, n int) (int, error) {
	_fedg := n
	_addb := 0
	_eeec := 0
	for _fedg > 0 {
		_eeaeg, _ceed := _ecde._gggee.Read(p[_addb:])
		if _ceed != nil {
			_fdb.Log.Debug("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073", _eeaeg, _eeec, _ceed.Error())
			return _addb, _b.New("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067")
		}
		_eeec++
		_addb += _eeaeg
		_fedg -= _eeaeg
	}
	return _addb, nil
}

func (_bcee *PdfParser) xrefNextObjectOffset(_gccgg int64) int64 {
	_edcfa := int64(0)
	if len(_bcee._fabaa.ObjectMap) == 0 {
		return 0
	}
	if len(_bcee._fabaa._ce) == 0 {
		_aceab := 0
		for _, _cdcf := range _bcee._fabaa.ObjectMap {
			if _cdcf.Offset > 0 {
				_aceab++
			}
		}
		if _aceab == 0 {
			return 0
		}
		_bcee._fabaa._ce = make([]XrefObject, _aceab)
		_gffd := 0
		for _, _fecb := range _bcee._fabaa.ObjectMap {
			if _fecb.Offset > 0 {
				_bcee._fabaa._ce[_gffd] = _fecb
				_gffd++
			}
		}
		_de.Slice(_bcee._fabaa._ce, func(_egga, _efca int) bool { return _bcee._fabaa._ce[_egga].Offset < _bcee._fabaa._ce[_efca].Offset })
	}
	_eegcb := _de.Search(len(_bcee._fabaa._ce), func(_gbaa int) bool { return _bcee._fabaa._ce[_gbaa].Offset >= _gccgg })
	if _eegcb < len(_bcee._fabaa._ce) {
		_edcfa = _bcee._fabaa._ce[_eegcb].Offset
	}
	return _edcfa
}

// UpdateParams updates the parameter values of the encoder.
func (_cbffd *ASCIIHexEncoder) UpdateParams(params *PdfObjectDictionary) {}

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat(objects []PdfObject) (_ccda []float64, _ebfcf error) {
	for _, _gfdbc := range objects {
		_aceg, _agab := GetNumberAsFloat(_gfdbc)
		if _agab != nil {
			return nil, _agab
		}
		_ccda = append(_ccda, _aceg)
	}
	return _ccda, nil
}

type cryptFilters map[string]_bc.Filter

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_beae *ASCIIHexEncoder) EncodeBytes(data []byte) ([]byte, error) {
	var _afcab _e.Buffer
	for _, _ddfg := range data {
		_afcab.WriteString(_dg.Sprintf("\u0025\u002e\u0032X\u0020", _ddfg))
	}
	_afcab.WriteByte('>')
	return _afcab.Bytes(), nil
}

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_eead *JPXEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073", _eead.GetFilterName())
	return streamObj.Stream, ErrNoJPXDecode
}

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject(obj PdfObject) PdfObject { return _aeaa(obj, 0) }

// String returns a string describing `streams`.
func (_edbgc *PdfObjectStreams) String() string {
	return _dg.Sprintf("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064", _edbgc.ObjectNumber)
}

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64(vals []int64) *PdfObjectArray {
	_aggae := MakeArray()
	for _, _eaag := range vals {
		_aggae.Append(MakeInteger(_eaag))
	}
	return _aggae
}

func (_cbfa *limitedReadSeeker) getError(_fegd int64) error {
	switch {
	case _fegd < 0:
		return _dg.Errorf("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064", _fegd)
	case _fegd > _cbfa._fabbd:
		return _dg.Errorf("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064", _fegd)
	}
	return nil
}

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_adg *PdfParser) LookupByNumber(objNumber int) (PdfObject, error) {
	_bcd, _, _bfc := _adg.lookupByNumberWrapper(objNumber, true)
	return _bcd, _bfc
}

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_ebef *DCTEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _ebef.DecodeBytes(streamObj.Stream)
}

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_ecfca *PdfObjectDictionary) Merge(another *PdfObjectDictionary) *PdfObjectDictionary {
	if another != nil {
		for _, _ffgg := range another.Keys() {
			_eagbc := another.Get(_ffgg)
			_ecfca.Set(_ffgg, _eagbc)
		}
	}
	return _ecfca
}

func (_aefc *PdfParser) readTextLine() (string, error) {
	var _bbcf _e.Buffer
	for {
		_fdegdd, _gccf := _aefc._gggee.Peek(1)
		if _gccf != nil {
			_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _gccf.Error())
			return _bbcf.String(), _gccf
		}
		if (_fdegdd[0] != '\r') && (_fdegdd[0] != '\n') {
			_dcdc, _ := _aefc._gggee.ReadByte()
			_bbcf.WriteByte(_dcdc)
		} else {
			break
		}
	}
	return _bbcf.String(), nil
}

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_daadg *PdfParser) GetCrypter() *PdfCrypt { return _daadg._dccfc }

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_bedf *PdfParser) CheckAccessRights(password []byte) (bool, _ad.Permissions, error) {
	if _bedf._dccfc == nil {
		return true, _ad.PermOwner, nil
	}
	return _bedf._dccfc.checkAccessRights(password)
}

func _fagc(_acgb *PdfObjectStream) (*MultiEncoder, error) {
	_caee := NewMultiEncoder()
	_ecdc := _acgb.PdfObjectDictionary
	if _ecdc == nil {
		return _caee, nil
	}
	var _cefc *PdfObjectDictionary
	var _dfea []PdfObject
	_edgfc := _ecdc.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073")
	if _edgfc != nil {
		_ffedb, _cdcd := _edgfc.(*PdfObjectDictionary)
		if _cdcd {
			_cefc = _ffedb
		}
		_dfgfg, _afbb := _edgfc.(*PdfObjectArray)
		if _afbb {
			for _, _dadfd := range _dfgfg.Elements() {
				_dadfd = TraceToDirectObject(_dadfd)
				if _fgbe, _dcea := _dadfd.(*PdfObjectDictionary); _dcea {
					_dfea = append(_dfea, _fgbe)
				} else {
					_dfea = append(_dfea, MakeDict())
				}
			}
		}
	}
	_edgfc = _ecdc.Get("\u0046\u0069\u006c\u0074\u0065\u0072")
	if _edgfc == nil {
		return nil, _dg.Errorf("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
	}
	_afge, _gaeg := _edgfc.(*PdfObjectArray)
	if !_gaeg {
		return nil, _dg.Errorf("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079")
	}
	for _aabb, _ffac := range _afge.Elements() {
		_dfggb, _abcdd := _ffac.(*PdfObjectName)
		if !_abcdd {
			return nil, _dg.Errorf("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065")
		}
		var _aacb PdfObject
		if _cefc != nil {
			_aacb = _cefc
		} else {
			if len(_dfea) > 0 {
				if _aabb >= len(_dfea) {
					return nil, _dg.Errorf("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079")
				}
				_aacb = _dfea[_aabb]
			}
		}
		var _fade *PdfObjectDictionary
		if _gegf, _fbge := _aacb.(*PdfObjectDictionary); _fbge {
			_fade = _gegf
		}
		_fdb.Log.Trace("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076", *_dfggb, _aacb, _fade)
		switch *_dfggb {
		case StreamEncodingFilterNameFlate:
			_cbdd, _ebfa := _cdd(_acgb, _fade)
			if _ebfa != nil {
				return nil, _ebfa
			}
			_caee.AddEncoder(_cbdd)
		case StreamEncodingFilterNameLZW:
			_adfg, _dba := _ecb(_acgb, _fade)
			if _dba != nil {
				return nil, _dba
			}
			_caee.AddEncoder(_adfg)
		case StreamEncodingFilterNameASCIIHex:
			_aabd := NewASCIIHexEncoder()
			_caee.AddEncoder(_aabd)
		case StreamEncodingFilterNameASCII85:
			_ffgff := NewASCII85Encoder()
			_caee.AddEncoder(_ffgff)
		case StreamEncodingFilterNameDCT:
			_gcdf, _abag := _cdge(_acgb, _caee)
			if _abag != nil {
				return nil, _abag
			}
			_caee.AddEncoder(_gcdf)
			_fdb.Log.Trace("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e")
			_fdb.Log.Trace("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076", _caee)
		case StreamEncodingFilterNameCCITTFax:
			_ecba, _abgd := _beab(_acgb, _fade)
			if _abgd != nil {
				return nil, _abgd
			}
			_caee.AddEncoder(_ecba)
		default:
			_fdb.Log.Error("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073", *_dfggb)
			return nil, _dg.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079")
		}
	}
	return _caee, nil
}

// MakeNull creates an PdfObjectNull.
func MakeNull() *PdfObjectNull { _bfed := PdfObjectNull{}; return &_bfed }

// Seek sets the offset for the next Read to offset, interpreted according to whence:
// 0 means relative to the start of the file,
// 1 means relative to the current offset, and 2 means relative to the end.
func (_gff *bufferedReadSeeker) Seek(offset int64, whence int) (int64, error) {
	_ffc, _gc := _gff._bca.Seek(offset, whence)
	if _gc != nil {
		return _ffc, _gc
	}
	_gff._ffb = _ge.NewReader(_gff._bca)
	return _ffc, nil
}

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fafdd *JBIG2Encoder) AddPageImage(img *JBIG2Image, settings *JBIG2EncoderSettings) (_efeag error) {
	const _egefe = "\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065"
	if _fafdd == nil {
		return _fag.Error(_egefe, "J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c")
	}
	if settings == nil {
		settings = &_fafdd.DefaultPageSettings
	}
	if _fafdd._cabc == nil {
		_fafdd._cabc = _edc.InitEncodeDocument(settings.FileMode)
	}
	if _efeag = settings.Validate(); _efeag != nil {
		return _fag.Wrap(_efeag, _egefe, "")
	}
	_degf, _efeag := img.toBitmap()
	if _efeag != nil {
		return _fag.Wrap(_efeag, _egefe, "")
	}
	switch settings.Compression {
	case JB2Generic:
		if _efeag = _fafdd._cabc.AddGenericPage(_degf, settings.DuplicatedLinesRemoval); _efeag != nil {
			return _fag.Wrap(_efeag, _egefe, "")
		}
	case JB2SymbolCorrelation:
		return _fag.Error(_egefe, "s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
	case JB2SymbolRankHaus:
		return _fag.Error(_egefe, "\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
	default:
		return _fag.Error(_egefe, "\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e")
	}
	return nil
}

func (_cedeg *offsetReader) Read(p []byte) (_bddc int, _bgba error) {
	return _cedeg._ebfac.Read(p)
}

func _ae(_bbg PdfObject) (int64, int64, error) {
	if _agd, _dcc := _bbg.(*PdfIndirectObject); _dcc {
		return _agd.ObjectNumber, _agd.GenerationNumber, nil
	}
	if _bda, _gad := _bbg.(*PdfObjectStream); _gad {
		return _bda.ObjectNumber, _bda.GenerationNumber, nil
	}
	return 0, 0, _b.New("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074")
}

func (_dabee *offsetReader) Seek(offset int64, whence int) (int64, error) {
	if whence == _eed.SeekStart {
		offset += _dabee._aadaa
	}
	_gcdbd, _bfcgb := _dabee._ebfac.Seek(offset, whence)
	if _bfcgb != nil {
		return _gcdbd, _bfcgb
	}
	if whence == _eed.SeekCurrent {
		_gcdbd -= _dabee._aadaa
	}
	if _gcdbd < 0 {
		return 0, _b.New("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e")
	}
	return _gcdbd, nil
}

// NewParserWithOpts creates and initializes a new PdfParser using the provided options.
// It creates a parser that tolerates certain non-critical PDF errors.
// Returns a PdfParser or an error if initialization fails.
func NewParserWithOpts(rs _eed.ReadSeeker, opts ParserOpts) (*PdfParser, error) {
	_aaac := &PdfParser{_gggee: _gcc(rs), ObjCache: make(objectCache), _effa: map[int64]bool{}, _aedf: make([]int64, 0), _bcgf: make(map[*PdfParser]*PdfParser), Opts: &opts}
	_cbabe := _aaac.initParser()
	if _cbabe != nil {
		return nil, _cbabe
	}
	return _aaac, nil
}

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_gcdb *JPXEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073", _gcdb.GetFilterName())
	return encoded, ErrNoJPXDecode
}

// String returns a string describing `array`.
func (_fbeg *PdfObjectArray) String() string {
	_gadcg := "\u005b"
	for _abcb, _dagc := range _fbeg.Elements() {
		_gadcg += _dagc.String()
		if _abcb < (_fbeg.Len() - 1) {
			_gadcg += "\u002c\u0020"
		}
	}
	_gadcg += "\u005d"
	return _gadcg
}

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2(i _ff.Image, bwThreshold float64) (*JBIG2Image, error) {
	const _beea = "\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032"
	if i == nil {
		return nil, _fag.Error(_beea, "i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064")
	}
	var (
		_ebee  uint8
		_gdbgf _dfa.Image
		_agecf error
	)
	if bwThreshold == JB2ImageAutoThreshold {
		_gdbgf, _agecf = _dfa.MonochromeConverter.Convert(i)
	} else if bwThreshold > 1.0 || bwThreshold < 0.0 {
		return nil, _fag.Error(_beea, "p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d")
	} else {
		_ebee = uint8(255 * bwThreshold)
		_gdbgf, _agecf = _dfa.MonochromeThresholdConverter(_ebee).Convert(i)
	}
	if _agecf != nil {
		return nil, _agecf
	}
	return _abfa(_gdbgf), nil
}

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict() *PdfObjectDictionary {
	_eged := &PdfObjectDictionary{}
	_eged._bgfg = map[PdfObjectName]PdfObject{}
	_eged._faaee = []PdfObjectName{}
	_eged._dcge = &_bf.Mutex{}
	return _eged
}

// DecodeStream implements ASCII85 stream decoding.
func (_fecd *ASCII85Encoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _fecd.DecodeBytes(streamObj.Stream)
}

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_cabcg *JBIG2Encoder) EncodeBytes(data []byte) ([]byte, error) {
	const _feafd = "\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073"
	if _cabcg.ColorComponents != 1 || _cabcg.BitsPerComponent != 1 {
		return nil, _fag.Errorf(_feafd, "\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061")
	}
	var (
		_egaeg *_gf.Bitmap
		_ecee  error
	)
	_fbab := (_cabcg.Width * _cabcg.Height) == len(data)
	if _fbab {
		_egaeg, _ecee = _gf.NewWithUnpaddedData(_cabcg.Width, _cabcg.Height, data)
	} else {
		_egaeg, _ecee = _gf.NewWithData(_cabcg.Width, _cabcg.Height, data)
	}
	if _ecee != nil {
		return nil, _ecee
	}
	_dfdeb := _cabcg.DefaultPageSettings
	if _ecee = _dfdeb.Validate(); _ecee != nil {
		return nil, _fag.Wrap(_ecee, _feafd, "")
	}
	if _cabcg._cabc == nil {
		_cabcg._cabc = _edc.InitEncodeDocument(_dfdeb.FileMode)
	}
	switch _dfdeb.Compression {
	case JB2Generic:
		if _ecee = _cabcg._cabc.AddGenericPage(_egaeg, _dfdeb.DuplicatedLinesRemoval); _ecee != nil {
			return nil, _fag.Wrap(_ecee, _feafd, "")
		}
	case JB2SymbolCorrelation:
		return nil, _fag.Error(_feafd, "s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
	case JB2SymbolRankHaus:
		return nil, _fag.Error(_feafd, "\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
	default:
		return nil, _fag.Error(_feafd, "\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e")
	}
	return _cabcg.Encode()
}

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder() *FlateEncoder {
	_ddfbb := &FlateEncoder{}
	_ddfbb.Predictor = 1
	_ddfbb.BitsPerComponent = 8
	_ddfbb.Colors = 1
	_ddfbb.Columns = 1
	return _ddfbb
}

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_agg *FlateEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_fdb.Log.Trace("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073")
	if len(encoded) == 0 {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e")
		return []byte{}, nil
	}
	_ffe := _e.NewReader(encoded)
	_agb, _gabc := _deg.NewReader(_ffe)
	if _gabc != nil {
		_fdb.Log.Debug("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a", _gabc)
		_fdb.Log.Debug("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078", len(encoded), encoded)
		return nil, _gabc
	}
	defer _agb.Close()
	var _gcccb _e.Buffer
	_gcccb.ReadFrom(_agb)
	return _gcccb.Bytes(), nil
}

func (_cabfe *PdfParser) seekToEOFMarker(_eegc int64) error {
	var _cecc int64
	var _ddbf int64 = 2048
	for _cecc < _eegc-4 {
		if _eegc <= (_ddbf + _cecc) {
			_ddbf = _eegc - _cecc
		}
		_, _gdec := _cabfe._gggee.Seek(_eegc-_cecc-_ddbf, _eed.SeekStart)
		if _gdec != nil {
			return _gdec
		}
		_bcfa := make([]byte, _ddbf)
		_cabfe._gggee.Read(_bcfa)
		_fdb.Log.Trace("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022", string(_bcfa))
		_geee := _bcbb.FindAllStringIndex(string(_bcfa), -1)
		if _geee != nil {
			_bafb := _geee[len(_geee)-1]
			_fdb.Log.Trace("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064", _geee)
			_cgfe := _eegc - _cecc - _ddbf + int64(_bafb[0])
			_cabfe._gggee.Seek(_cgfe, _eed.SeekStart)
			return nil
		}
		_fdb.Log.Debug("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067")
		_cecc += _ddbf - 4
	}
	_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e")
	return _cbgd
}

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_eb *bufferedReadSeeker) GetFileOffset() int64 {
	_gg, _ := _eb._bca.Seek(0, _eed.SeekCurrent)
	_gg -= int64(_eb._ffb.Buffered())
	return _gg
}

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_dceg *MultiEncoder) AddEncoder(encoder StreamEncoder) {
	_dceg._bdfea = append(_dceg._bdfea, encoder)
}

// ReadByte reads a single byte from the buffered reader.
func (_fe *bufferedReadSeeker) ReadByte() (byte, error) {
	_dege, _ebb := _fe._ffb.ReadByte()
	if _ebb != nil {
		return 0, _ebb
	}
	return _dege, nil
}

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{}

// Write outputs the object as it is to be written to file.
func (_edaf *PdfObjectDictionary) Write() []byte {
	var _gaba _e.Buffer
	_gaba.WriteString("\u003c\u003c")
	for _, _ebdga := range _edaf._faaee {
		_eefe := _edaf._bgfg[_ebdga]
		_gaba.Write(_ebdga.Write())
		_gaba.WriteString("\u0020")
		_gaba.Write(_eefe.Write())
	}
	_gaba.WriteString("\u003e\u003e")
	return _gaba.Bytes()
}

func (_egcf *PdfParser) parseBool() (PdfObjectBool, error) {
	_bfcd, _ddced := _egcf._gggee.Peek(4)
	if _ddced != nil {
		return PdfObjectBool(false), _ddced
	}
	if (len(_bfcd) >= 4) && (string(_bfcd[:4]) == "\u0074\u0072\u0075\u0065") {
		_egcf._gggee.Discard(4)
		return PdfObjectBool(true), nil
	}
	_bfcd, _ddced = _egcf._gggee.Peek(5)
	if _ddced != nil {
		return PdfObjectBool(false), _ddced
	}
	if (len(_bfcd) >= 5) && (string(_bfcd[:5]) == "\u0066\u0061\u006cs\u0065") {
		_egcf._gggee.Discard(5)
		return PdfObjectBool(false), nil
	}
	return PdfObjectBool(false), _b.New("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg")
}

const JB2ImageAutoThreshold = -1.0

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber(buf *_ge.Reader) (PdfObject, error) {
	_gbdf := false
	_cbbb := true
	var _abdd _e.Buffer
	for {
		if _fdb.Log.IsLogLevel(_fdb.LogLevelTrace) {
			_fdb.Log.Trace("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022", _abdd.String())
		}
		_abdb, _gdge := buf.Peek(1)
		if _gdge == _eed.EOF {
			break
		}
		if _gdge != nil {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073", _gdge)
			return nil, _gdge
		}
		if _cbbb && (_abdb[0] == '-' || _abdb[0] == '+') {
			_ggcd, _ := buf.ReadByte()
			_abdd.WriteByte(_ggcd)
			_cbbb = false
		} else if IsDecimalDigit(_abdb[0]) {
			_cbccd, _ := buf.ReadByte()
			_abdd.WriteByte(_cbccd)
		} else if _abdb[0] == '.' {
			_cabed, _ := buf.ReadByte()
			_abdd.WriteByte(_cabed)
			_gbdf = true
		} else if _abdb[0] == 'e' || _abdb[0] == 'E' {
			_eefff, _ := buf.ReadByte()
			_abdd.WriteByte(_eefff)
			_gbdf = true
			_cbbb = true
		} else {
			break
		}
	}
	var _gcgc PdfObject
	if _gbdf {
		_dcbcbd, _afda := _d.ParseFloat(_abdd.String(), 64)
		if _afda != nil {
			_fdb.Log.Debug("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074", _abdd.String(), _afda)
			_dcbcbd = 0.0
		}
		_fccaf := PdfObjectFloat(_dcbcbd)
		_gcgc = &_fccaf
	} else {
		_cgcfg, _gcfc := _d.ParseInt(_abdd.String(), 10, 64)
		if _gcfc != nil {
			_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074", _abdd.String(), _gcfc)
			_cgcfg = 0
		}
		_bacf := PdfObjectInteger(_cgcfg)
		_gcgc = &_bacf
	}
	return _gcgc, nil
}

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_gbg *ASCII85Encoder) DecodeBytes(encoded []byte) ([]byte, error) {
	var _afd []byte
	_fdb.Log.Trace("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065")
	_ada := 0
	_ebafa := false
	for _ada < len(encoded) && !_ebafa {
		_fcc := [5]byte{0, 0, 0, 0, 0}
		_bfece := 0
		_cdc := 0
		_fdg := 4
		for _cdc < 5+_bfece {
			if _ada+_cdc == len(encoded) {
				break
			}
			_ccgd := encoded[_ada+_cdc]
			if IsWhiteSpace(_ccgd) {
				_bfece++
				_cdc++
				continue
			} else if _ccgd == '~' && _ada+_cdc+1 < len(encoded) && encoded[_ada+_cdc+1] == '>' {
				_fdg = (_cdc - _bfece) - 1
				if _fdg < 0 {
					_fdg = 0
				}
				_ebafa = true
				break
			} else if _ccgd >= '!' && _ccgd <= 'u' {
				_ccgd -= '!'
			} else if _ccgd == 'z' && _cdc-_bfece == 0 {
				_fdg = 4
				_cdc++
				break
			} else {
				_fdb.Log.Error("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065")
				return nil, _b.New("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064")
			}
			_fcc[_cdc-_bfece] = _ccgd
			_cdc++
		}
		_ada += _cdc
		for _edbg := _fdg + 1; _edbg < 5; _edbg++ {
			_fcc[_edbg] = 84
		}
		_edcadb := uint32(_fcc[0])*85*85*85*85 + uint32(_fcc[1])*85*85*85 + uint32(_fcc[2])*85*85 + uint32(_fcc[3])*85 + uint32(_fcc[4])
		_degg := []byte{byte((_edcadb >> 24) & 0xff), byte((_edcadb >> 16) & 0xff), byte((_edcadb >> 8) & 0xff), byte(_edcadb & 0xff)}
		_afd = append(_afd, _degg[:_fdg]...)
	}
	_fdb.Log.Trace("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058", encoded)
	_fdb.Log.Trace("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058", _afd)
	return _afd, nil
}

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct {
	Version

	// Encrypt is an encryption dictionary that contains all necessary parameters.
	// It should be stored in all copies of the document trailer.
	Encrypt *PdfObjectDictionary

	// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
	ID0, ID1 string
}

// PdfVersion returns version of the PDF file.
func (_affa *PdfParser) PdfVersion() Version { return _affa._baefa }

func _ebbg(_gaab, _ccgg, _ccef uint8) uint8 {
	_fbde := int(_ccef)
	_ddfd := int(_ccgg) - _fbde
	_dbegf := int(_gaab) - _fbde
	_fbde = _ggfb(_ddfd + _dbegf)
	_ddfd = _ggfb(_ddfd)
	_dbegf = _ggfb(_dbegf)
	if _ddfd <= _dbegf && _ddfd <= _fbde {
		return _gaab
	} else if _dbegf <= _fbde {
		return _ccgg
	}
	return _ccef
}

func (_bcdb *PdfCrypt) loadCryptFilters(_cfec *PdfObjectDictionary) error {
	_bcdb._fca = cryptFilters{}
	_edcb := _cfec.Get("\u0043\u0046")
	_edcb = TraceToDirectObject(_edcb)
	if _ega, _adge := _edcb.(*PdfObjectReference); _adge {
		_gbea, _cfff := _bcdb._gfd.LookupByReference(*_ega)
		if _cfff != nil {
			_fdb.Log.Debug("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065")
			return _cfff
		}
		_edcb = TraceToDirectObject(_gbea)
	}
	_gbef, _edbe := _edcb.(*PdfObjectDictionary)
	if !_edbe {
		_fdb.Log.Debug("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054", _edcb)
		return _b.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046")
	}
	for _, _fbaf := range _gbef.Keys() {
		_ebe := _gbef.Get(_fbaf)
		if _bdf, _cfee := _ebe.(*PdfObjectReference); _cfee {
			_fgg, _bcba := _bcdb._gfd.LookupByReference(*_bdf)
			if _bcba != nil {
				_fdb.Log.Debug("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065")
				return _bcba
			}
			_ebe = TraceToDirectObject(_fgg)
		}
		_fbbe, _deba := _ebe.(*PdfObjectDictionary)
		if !_deba {
			return _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054", _fbaf, _ebe)
		}
		if _fbaf == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079" {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074")
			continue
		}
		var _bceg _bc.FilterDict
		if _dcf := _cgd(&_bceg, _fbbe); _dcf != nil {
			return _dcf
		}
		_ggg, _baag := _bc.NewFilter(_bceg)
		if _baag != nil {
			return _baag
		}
		_bcdb._fca[string(_fbaf)] = _ggg
	}
	_bcdb._fca["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"] = _bc.NewIdentity()
	_bcdb._cfd = "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"
	if _edca, _afc := _cfec.Get("\u0053\u0074\u0072\u0046").(*PdfObjectName); _afc {
		if _, _fgge := _bcdb._fca[string(*_edca)]; !_fgge {
			return _dg.Errorf("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029", *_edca)
		}
		_bcdb._cfd = string(*_edca)
	}
	_bcdb._cef = "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"
	if _bfaa, _gadba := _cfec.Get("\u0053\u0074\u006d\u0046").(*PdfObjectName); _gadba {
		if _, _dab := _bcdb._fca[string(*_bfaa)]; !_dab {
			return _dg.Errorf("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029", *_bfaa)
		}
		_bcdb._cef = string(*_bfaa)
	}
	return nil
}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcga *RunLengthEncoder) MakeStreamDict() *PdfObjectDictionary {
	_beagc := MakeDict()
	_beagc.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_fcga.GetFilterName()))
	return _beagc
}

var _gcebe = map[byte][]byte{'\n': []byte("\u005c\u006e"), '\r': []byte("\u005c\u0072"), '\t': []byte("\u005c\u0074"), '\b': []byte("\u005c\u0062"), '\f': []byte("\u005c\u0066"), '(': []byte("\u005c\u0028"), ')': []byte("\u005c\u0029"), '\\': []byte("\u005c\u005c")}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_effd *DCTEncoder) MakeStreamDict() *PdfObjectDictionary {
	_bfdd := MakeDict()
	_bfdd.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_effd.GetFilterName()))
	return _bfdd
}

// HasNonConformantStream implements core.ParserMetadata.
func (_eded ParserMetadata) HasNonConformantStream() bool { return _eded._fac }

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_adeecc *PdfObjectArray) Set(i int, obj PdfObject) error {
	if i < 0 || i >= len(_adeecc._abad) {
		return _b.New("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073")
	}
	_adeecc._abad[i] = obj
	return nil
}

// MakeName creates a PdfObjectName from a string.
func MakeName(s string) *PdfObjectName { _bdcd := PdfObjectName(s); return &_bdcd }

func _bbc(_cfc *_ad.StdEncryptDict, _bgc *PdfObjectDictionary) error {
	R, _dec := _bgc.Get("\u0052").(*PdfObjectInteger)
	if !_dec {
		return _b.New("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052")
	}
	if *R < 2 || *R > 6 {
		return _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029", *R)
	}
	_cfc.R = int(*R)
	O, _dec := _bgc.GetString("\u004f")
	if !_dec {
		return _b.New("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f")
	}
	if _cfc.R == 5 || _cfc.R == 6 {
		if len(O) < 48 {
			return _dg.Errorf("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029", len(O))
		}
	} else if len(O) != 32 {
		return _dg.Errorf("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029", len(O))
	}
	_cfc.O = []byte(O)
	U, _dec := _bgc.GetString("\u0055")
	if !_dec {
		return _b.New("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055")
	}
	if _cfc.R == 5 || _cfc.R == 6 {
		if len(U) < 48 {
			return _dg.Errorf("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029", len(U))
		}
	} else if len(U) != 32 {
		_fdb.Log.Debug("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029", len(U))
	}
	_cfc.U = []byte(U)
	if _cfc.R >= 5 {
		OE, _daed := _bgc.GetString("\u004f\u0045")
		if !_daed {
			return _b.New("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045")
		} else if len(OE) != 32 {
			return _dg.Errorf("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029", len(OE))
		}
		_cfc.OE = []byte(OE)
		UE, _daed := _bgc.GetString("\u0055\u0045")
		if !_daed {
			return _b.New("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045")
		} else if len(UE) != 32 {
			return _dg.Errorf("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029", len(UE))
		}
		_cfc.UE = []byte(UE)
	}
	P, _dec := _bgc.Get("\u0050").(*PdfObjectInteger)
	if !_dec {
		return _b.New("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072")
	}
	_cfc.P = _ad.Permissions(*P)
	if _cfc.R == 6 {
		Perms, _cba := _bgc.GetString("\u0050\u0065\u0072m\u0073")
		if !_cba {
			return _b.New("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073")
		} else if len(Perms) != 16 {
			return _dg.Errorf("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029", len(Perms))
		}
		_cfc.Perms = []byte(Perms)
	}
	if _ab, _ddb := _bgc.Get("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool); _ddb {
		_cfc.EncryptMetadata = bool(*_ab)
	} else {
		_cfc.EncryptMetadata = true
	}
	return nil
}

func (_bgcc *JBIG2Image) toBitmap() (_ccff *_gf.Bitmap, _babdc error) {
	const _gfee = "\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070"
	if _bgcc.Data == nil {
		return nil, _fag.Error(_gfee, "\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064")
	}
	if _bgcc.Width == 0 || _bgcc.Height == 0 {
		return nil, _fag.Error(_gfee, "\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	if _bgcc.HasPadding {
		_ccff, _babdc = _gf.NewWithData(_bgcc.Width, _bgcc.Height, _bgcc.Data)
	} else {
		_ccff, _babdc = _gf.NewWithUnpaddedData(_bgcc.Width, _bgcc.Height, _bgcc.Data)
	}
	if _babdc != nil {
		return nil, _fag.Wrap(_babdc, _gfee, "")
	}
	return _ccff, nil
}

var _gfdf = []PdfObjectName{"\u0056", "\u0052", "\u004f", "\u0055", "\u0050"}

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_bddcc *PdfObjectArray) ToFloat64Array() ([]float64, error) {
	var _aggbe []float64
	for _, _gcbf := range _bddcc.Elements() {
		switch _cgga := _gcbf.(type) {
		case *PdfObjectInteger:
			_aggbe = append(_aggbe, float64(*_cgga))
		case *PdfObjectFloat:
			_aggbe = append(_aggbe, float64(*_cgga))
		default:
			return nil, ErrTypeError
		}
	}
	return _aggbe, nil
}

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{ _abad []PdfObject }

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_adgf *JBIG2Encoder) MakeDecodeParams() PdfObject { return MakeDict() }

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct {
	PdfObjectReference
	_bedg []PdfObject
}

// GetFilterName returns the name of the encoding filter.
func (_fbac *ASCII85Encoder) GetFilterName() string { return StreamEncodingFilterNameASCII85 }

func _cdge(_gaad *PdfObjectStream, _dfgg *MultiEncoder) (*DCTEncoder, error) {
	_dcdg := NewDCTEncoder()
	_facb := _gaad.PdfObjectDictionary
	if _facb == nil {
		return _dcdg, nil
	}
	_eac := _gaad.Stream
	if _dfgg != nil {
		_eccf, _aggg := _dfgg.DecodeBytes(_eac)
		if _aggg != nil {
			return nil, _aggg
		}
		_eac = _eccf
	}
	_eccg := _e.NewReader(_eac)
	_eacg, _cegb := _fc.DecodeConfig(_eccg)
	if _cegb != nil {
		_fdb.Log.Debug("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _cegb)
		return nil, _cegb
	}
	switch _eacg.ColorModel {
	case _g.RGBAModel:
		_dcdg.BitsPerComponent = 8
		_dcdg.ColorComponents = 3
		_dcdg.Decode = []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
	case _g.RGBA64Model:
		_dcdg.BitsPerComponent = 16
		_dcdg.ColorComponents = 3
		_dcdg.Decode = []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
	case _g.GrayModel:
		_dcdg.BitsPerComponent = 8
		_dcdg.ColorComponents = 1
		_dcdg.Decode = []float64{0.0, 1.0}
	case _g.Gray16Model:
		_dcdg.BitsPerComponent = 16
		_dcdg.ColorComponents = 1
		_dcdg.Decode = []float64{0.0, 1.0}
	case _g.CMYKModel:
		_dcdg.BitsPerComponent = 8
		_dcdg.ColorComponents = 4
		_dcdg.Decode = []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
	case _g.YCbCrModel:
		_dcdg.BitsPerComponent = 8
		_dcdg.ColorComponents = 3
		_dcdg.Decode = []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
	default:
		return nil, _b.New("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c")
	}
	_dcdg.Width = _eacg.Width
	_dcdg.Height = _eacg.Height
	_fdb.Log.Trace("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076", _dcdg)
	_dcdg.Quality = DefaultJPEGQuality
	_gega, _dbgd := GetArray(_facb.Get("\u0044\u0065\u0063\u006f\u0064\u0065"))
	if _dbgd {
		_ddce, _bgdg := _gega.ToFloat64Array()
		if _bgdg != nil {
			return _dcdg, _bgdg
		}
		_dcdg.Decode = _ddce
	}
	return _dcdg, nil
}

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes(obj PdfObject) (_agff []byte, _bffa bool) {
	_eggad, _bffa := TraceToDirectObject(obj).(*PdfObjectString)
	if _bffa {
		return _eggad.Bytes(), true
	}
	return
}

// Read implementation of Read interface.
func (_bbbab *limitedReadSeeker) Read(p []byte) (_cdce int, _dcbd error) {
	_bfbca, _dcbd := _bbbab._fafde.Seek(0, _eed.SeekCurrent)
	if _dcbd != nil {
		return 0, _dcbd
	}
	_bgfab := _bbbab._fabbd - _bfbca
	if _bgfab == 0 {
		return 0, _eed.EOF
	}
	if _bfccf := int64(len(p)); _bfccf < _bgfab {
		_bgfab = _bfccf
	}
	_fdde := make([]byte, _bgfab)
	_cdce, _dcbd = _bbbab._fafde.Read(_fdde)
	copy(p, _fdde)
	return _cdce, _dcbd
}

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_agbd *CCITTFaxEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _agbd.DecodeBytes(streamObj.Stream)
}

// UpdateParams updates the parameter values of the encoder.
func (_acdd *JPXEncoder) UpdateParams(params *PdfObjectDictionary) {}

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_feca *PdfParser) IsEncrypted() (bool, error) {
	if _feca._dccfc != nil {
		return true, nil
	} else if _feca._fce == nil {
		return false, nil
	}
	_fdb.Log.Trace("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021")
	_gbdg := _feca._fce.Get("\u0045n\u0063\u0072\u0079\u0070\u0074")
	if _gbdg == nil {
		return false, nil
	}
	_fdb.Log.Trace("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021")
	var (
		_bdeb *PdfObjectDictionary
	)
	switch _cbbda := _gbdg.(type) {
	case *PdfObjectDictionary:
		_bdeb = _cbbda
	case *PdfObjectReference:
		_fdb.Log.Trace("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071", _cbbda)
		_bccb, _cadc := _feca.LookupByReference(*_cbbda)
		_fdb.Log.Trace("\u0031\u003a\u0020%\u0071", _bccb)
		if _cadc != nil {
			return false, _cadc
		}
		_edae, _baca := _bccb.(*PdfIndirectObject)
		if !_baca {
			_fdb.Log.Debug("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074")
			return false, _b.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_bgdfb, _baca := _edae.PdfObject.(*PdfObjectDictionary)
		_feca._afad = _edae
		_fdb.Log.Trace("\u0032\u003a\u0020%\u0071", _bgdfb)
		if !_baca {
			return false, _b.New("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		_bdeb = _bgdfb
	case *PdfObjectNull:
		_fdb.Log.Debug("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e")
		return false, nil
	default:
		return false, _dg.Errorf("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054", _cbbda)
	}
	_ffca, _eaca := PdfCryptNewDecrypt(_feca, _bdeb, _feca._fce)
	if _eaca != nil {
		return false, _eaca
	}
	for _, _beeee := range []string{"\u0045n\u0063\u0072\u0079\u0070\u0074"} {
		_efeab := _feca._fce.Get(PdfObjectName(_beeee))
		if _efeab == nil {
			continue
		}
		switch _badf := _efeab.(type) {
		case *PdfObjectReference:
			_ffca._cfe[int(_badf.ObjectNumber)] = struct{}{}
		case *PdfIndirectObject:
			_ffca._fbe[_badf] = true
			_ffca._cfe[int(_badf.ObjectNumber)] = struct{}{}
		}
	}
	_feca._dccfc = _ffca
	_fdb.Log.Trace("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062", _ffca)
	return true, nil
}

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct {
	PdfObjectReference
	*PdfObjectDictionary
	Stream   []byte
	Lazy     bool
	TempFile string
}

// String returns a string describing `stream`.
func (_cdbb *PdfObjectStream) String() string {
	return _dg.Sprintf("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073", _cdbb.ObjectNumber, _cdbb.PdfObjectDictionary)
}

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ec *bufferedReadSeeker) SetFileOffset(offset int64) {
	if offset < 0 {
		offset = 0
	}
	_ec.Seek(offset, _eed.SeekStart)
}

var _aagag = _a.MustCompile("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029")

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict(obj PdfObject) (_gffa *PdfObjectDictionary, _gcec bool) {
	_gffa, _gcec = TraceToDirectObject(obj).(*PdfObjectDictionary)
	return _gffa, _gcec
}

// GetFilterName returns the name of the encoding filter.
func (_gfaa *JBIG2Encoder) GetFilterName() string { return StreamEncodingFilterNameJBIG2 }

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_cbeg *PdfParser) GetTrailer() *PdfObjectDictionary { return _cbeg._fce }

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dgbf *ASCIIHexEncoder) MakeDecodeParams() PdfObject { return nil }

func _dbc(_bcdc XrefTable) {
	_fdb.Log.Debug("\u003dX\u003d\u0058\u003d\u0058\u003d")
	_fdb.Log.Debug("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a")
	_gbe := 0
	for _, _agde := range _bcdc.ObjectMap {
		_fdb.Log.Debug("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064", _gbe+1, _agde.ObjectNumber, _agde.Generation, _agde.Offset)
		_gbe++
	}
}

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_baaf *JBIG2Encoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return _baaf.DecodeBytes(streamObj.Stream)
}

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_dgeb *PdfObjectStreams) Set(i int, obj PdfObject) error {
	if i < 0 || i >= len(_dgeb._bedg) {
		return _b.New("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073")
	}
	_dgeb._bedg[i] = obj
	return nil
}

func (_adca *PdfParser) initParser() error {
	_bdcca, _aaca, _bccf := _adca.parsePdfVersion()
	if _bccf != nil {
		_fdb.Log.Error("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076", _bccf)
		return _bccf
	}
	_adca._baefa.Major = _bdcca
	_adca._baefa.Minor = _aaca
	if _adca._fce, _bccf = _adca.loadXrefs(); _bccf != nil {
		_fdb.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073", _bccf)
		return _bccf
	}
	_fdb.Log.Trace("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073", _adca._fce)
	_bbef, _bccf := _adca.parseLinearizedDictionary()
	if _bccf != nil {
		return _bccf
	}
	if _bbef != nil {
		_adca._fdfba, _bccf = _adca.checkLinearizedInformation(_bbef)
		if _bccf != nil {
			return _bccf
		}
	}
	if len(_adca._fabaa.ObjectMap) == 0 {
		return _dg.Errorf("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064")
	}
	_adca._agdg = len(_adca._aedf)
	if _adca._fdfba && _adca._agdg != 0 {
		_adca._agdg--
	}
	_adca._ebaaa = make([]*PdfParser, _adca._agdg)
	return nil
}

// Append appends PdfObject(s) to the streams.
func (_cdeg *PdfObjectStreams) Append(objects ...PdfObject) {
	if _cdeg == nil {
		_fdb.Log.Debug("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073")
		return
	}
	_cdeg._bedg = append(_cdeg._bedg, objects...)
}

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ecgf *PdfObjectDictionary) Set(key PdfObjectName, val PdfObject) {
	_ecgf.setWithLock(key, val, true)
}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbab *MultiEncoder) MakeStreamDict() *PdfObjectDictionary {
	_feef := MakeDict()
	_feef.Set("\u0046\u0069\u006c\u0074\u0065\u0072", _bbab.GetFilterArray())
	for _, _gfdb := range _bbab._bdfea {
		_cag := _gfdb.MakeStreamDict()
		for _, _gfeg := range _cag.Keys() {
			_dabf := _cag.Get(_gfeg)
			if _gfeg != "\u0046\u0069\u006c\u0074\u0065\u0072" && _gfeg != "D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073" {
				_feef.Set(_gfeg, _dabf)
			}
		}
	}
	_bed := _bbab.MakeDecodeParams()
	if _bed != nil {
		_feef.Set("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073", _bed)
	}
	return _feef
}

func _gcc(_dde _eed.ReadSeeker) *bufferedReadSeeker {
	return &bufferedReadSeeker{_bca: _dde, _ffb: _ge.NewReader(_dde)}
}

var (
	ErrUnsupportedEncodingParameters = _b.New("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073")
	ErrNoCCITTFaxDecode              = _b.New("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064")
	ErrNoJBIG2Decode                 = _b.New("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064")
	ErrNoJPXDecode                   = _b.New("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064")
	ErrNoPdfVersion                  = _b.New("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
	ErrTypeError                     = _b.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	ErrRangeError                    = _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	ErrNotSupported                  = _faf.New("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064")
	ErrNotANumber                    = _b.New("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
)

// GetFilterName returns the name of the encoding filter.
func (_cdfb *RunLengthEncoder) GetFilterName() string { return StreamEncodingFilterNameRunLength }

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64

func _cgd(_gaeb *_bc.FilterDict, _aab *PdfObjectDictionary) error {
	if _aaa, _edf := _aab.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName); _edf {
		if _ged := string(*_aaa); _ged != "C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072" {
			_fdb.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029", _ged)
		}
	}
	_fgdd, _agc := _aab.Get("\u0043\u0046\u004d").(*PdfObjectName)
	if !_agc {
		return _dg.Errorf("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029")
	}
	_gaeb.CFM = string(*_fgdd)
	if _cfb, _dfg := _aab.Get("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName); _dfg {
		_gaeb.AuthEvent = _ad.AuthEvent(*_cfb)
	} else {
		_gaeb.AuthEvent = _ad.EventDocOpen
	}
	if _geaf, _bfb := _aab.Get("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger); _bfb {
		_gaeb.Length = int(*_geaf)
	}
	return nil
}

// GetRevisionNumber returns the current version of the Pdf document.
func (_gefb *PdfParser) GetRevisionNumber() int { return _gefb._agdg }

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers(vals []int) *PdfObjectArray {
	_fgff := MakeArray()
	for _, _fccc := range vals {
		_fgff.Append(MakeInteger(int64(_fccc)))
	}
	return _fgff
}

// DecodeBytes decodes the CCITTFax encoded image data.
func (_adcbc *CCITTFaxEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_fggg, _bggf := _ac.NewDecoder(encoded, _ac.DecodeOptions{Columns: _adcbc.Columns, Rows: _adcbc.Rows, K: _adcbc.K, EncodedByteAligned: _adcbc.EncodedByteAlign, BlackIsOne: _adcbc.BlackIs1, EndOfBlock: _adcbc.EndOfBlock, EndOfLine: _adcbc.EndOfLine, DamagedRowsBeforeError: _adcbc.DamagedRowsBeforeError})
	if _bggf != nil {
		return nil, _bggf
	}
	_ffbca, _bggf := _eed.ReadAll(_fggg)
	if _bggf != nil {
		return nil, _bggf
	}
	return _ffbca, nil
}

const (
	DefaultJPEGQuality = 75
)

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_eaad *JBIG2Encoder) Encode() (_bcgc []byte, _bccg error) {
	const _debfe = "J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065"
	if _eaad._cabc == nil {
		return nil, _fag.Errorf(_debfe, "\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	}
	_eaad._cabc.FullHeaders = _eaad.DefaultPageSettings.FileMode
	_bcgc, _bccg = _eaad._cabc.Encode()
	if _bccg != nil {
		return nil, _fag.Wrap(_bccg, _debfe, "")
	}
	return _bcgc, nil
}

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_agec *RunLengthEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_ffbc := _e.NewReader(encoded)
	var _ebdf []byte
	for {
		_cead, _cbff := _ffbc.ReadByte()
		if _cbff != nil {
			return nil, _cbff
		}
		if _cead > 128 {
			_dfc, _fga := _ffbc.ReadByte()
			if _fga != nil {
				return nil, _fga
			}
			for _ecgc := 0; _ecgc < 257-int(_cead); _ecgc++ {
				_ebdf = append(_ebdf, _dfc)
			}
		} else if _cead < 128 {
			for _acfd := 0; _acfd < int(_cead)+1; _acfd++ {
				_gcfb, _dfcb := _ffbc.ReadByte()
				if _dfcb != nil {
					return nil, _dfcb
				}
				_ebdf = append(_ebdf, _gcfb)
			}
		} else {
			break
		}
	}
	return _ebdf, nil
}

// ParserOpts defines configuration options for Parser.
// These options allow setting customization flags to control parsing behaviors.
type ParserOpts struct {

	// RelaxedMode enables tolerant parsing by ignoring certain non-critical PDF errors.
	// When set to true, the parser will attempt to continue processing despite certain
	// structural errors such as:
	// - Missing or invalid /XRefStm entries
	// - Non-/Page or non-/Pages objects found in the page tree (/Kids array)
	RelaxedMode bool
}

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_bga *RawEncoder) EncodeBytes(data []byte) ([]byte, error) { return data, nil }

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_degfe *PdfObjectDictionary) GetString(key PdfObjectName) (string, bool) {
	_eagca := _degfe.Get(key)
	if _eagca == nil {
		return "", false
	}
	_ccddg, _dfebb := _eagca.(*PdfObjectString)
	if !_dfebb {
		return "", false
	}
	return _ccddg.Str(), true
}

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder() *JPXEncoder { return &JPXEncoder{} }

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_dagg ParserMetadata) HasDataAfterEOF() bool { return _dagg._degd }

// Write outputs the object as it is to be written to file.
func (_fdbf *PdfObjectNull) Write() []byte { return []byte("\u006e\u0075\u006c\u006c") }

func (_cgb *PdfCrypt) authenticate(_gaa []byte) (bool, error) {
	_cgb._ffa = false
	_fcae := _cgb.securityHandler()
	_accc, _ecd, _dgff := _fcae.Authenticate(&_cgb._ecf, _gaa)
	if _dgff != nil {
		return false, _dgff
	} else if _ecd == 0 || len(_accc) == 0 {
		return false, nil
	}
	_cgb._ffa = true
	_cgb._bae = _accc
	return true, nil
}

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dgc *LZWEncoder) MakeDecodeParams() PdfObject {
	if _dgc.Predictor > 1 {
		_bfba := MakeDict()
		_bfba.Set("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr", MakeInteger(int64(_dgc.Predictor)))
		if _dgc.BitsPerComponent != 8 {
			_bfba.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", MakeInteger(int64(_dgc.BitsPerComponent)))
		}
		if _dgc.Columns != 1 {
			_bfba.Set("\u0043o\u006c\u0075\u006d\u006e\u0073", MakeInteger(int64(_dgc.Columns)))
		}
		if _dgc.Colors != 1 {
			_bfba.Set("\u0043\u006f\u006c\u006f\u0072\u0073", MakeInteger(int64(_dgc.Colors)))
		}
		return _bfba
	}
	return nil
}

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes(data []byte) *PdfObjectString { return MakeString(string(data)) }

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_abfg *PdfParser) IsAuthenticated() bool { return _abfg._dccfc._ffa }

type limitedReadSeeker struct {
	_fafde _eed.ReadSeeker
	_fabbd int64
}

func (_gdfe *PdfParser) loadXrefs() (*PdfObjectDictionary, error) {
	_gdfe._fabaa.ObjectMap = make(map[int]XrefObject)
	_gdfe._bcdd = make(objectStreams)
	_cbfe, _cbgac := _gdfe._gggee.Seek(0, _eed.SeekEnd)
	if _cbgac != nil {
		return nil, _cbgac
	}
	_fdb.Log.Trace("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d", _cbfe)
	_gdfe._dbed = _cbfe
	_cbgac = _gdfe.seekToEOFMarker(_cbfe)
	if _cbgac != nil {
		_fdb.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076", _cbgac)
		return nil, _cbgac
	}
	_dadgb, _cbgac := _gdfe._gggee.Seek(0, _eed.SeekCurrent)
	if _cbgac != nil {
		return nil, _cbgac
	}
	var _dffgf int64 = 64
	_bbee := _dadgb - _dffgf
	if _bbee < 0 {
		_bbee = 0
	}
	_, _cbgac = _gdfe._gggee.Seek(_bbee, _eed.SeekStart)
	if _cbgac != nil {
		return nil, _cbgac
	}
	_ccfdf := make([]byte, _dffgf)
	_, _cbgac = _gdfe._gggee.Read(_ccfdf)
	if _cbgac != nil {
		_fdb.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076", _cbgac)
		return nil, _cbgac
	}
	_dgcf := _efae.FindStringSubmatch(string(_ccfdf))
	if len(_dgcf) < 2 {
		_fdb.Log.Debug("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021")
		return nil, _b.New("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	if len(_dgcf) > 2 {
		_fdb.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021", _ccfdf)
		return nil, _b.New("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f")
	}
	_dedf, _ := _d.ParseInt(_dgcf[1], 10, 64)
	_fdb.Log.Trace("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064", _dedf)
	if _dedf > _cbfe {
		_fdb.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065")
		_fdb.Log.Debug("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072")
		_dedf, _cbgac = _gdfe.repairLocateXref()
		if _cbgac != nil {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029")
			return nil, _cbgac
		}
	}
	_gdfe._gggee.Seek(_dedf, _eed.SeekStart)
	_eeef, _cbgac := _gdfe.parseXref()
	if _cbgac != nil {
		return nil, _cbgac
	}
	_cagb := _eeef.Get("\u0058R\u0065\u0066\u0053\u0074\u006d")
	if _cagb != nil {
		_efdb, _gbad := _cagb.(*PdfObjectInteger)
		if !_gbad {
			return nil, _b.New("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074")
		}
		_, _cbgac = _gdfe.parseXrefStream(_efdb)
		if _cbgac != nil && _gdfe.Opts != nil && !_gdfe.Opts.RelaxedMode {
			return nil, _cbgac
		}
	}
	var _cbda []int64
	_bdda := func(_caba int64, _bcbgf []int64) bool {
		for _, _ebbd := range _bcbgf {
			if _ebbd == _caba {
				return true
			}
		}
		return false
	}
	_cagb = _eeef.Get("\u0050\u0072\u0065\u0076")
	for _cagb != nil {
		_aabdg, _feeec := _cagb.(*PdfObjectInteger)
		if !_feeec {
			_fdb.Log.Debug("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029", _cagb)
			return _eeef, nil
		}
		_gbfda := *_aabdg
		_fdb.Log.Trace("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064", _gbfda)
		_gdfe._gggee.Seek(int64(_gbfda), _eed.SeekStart)
		_cggc, _bbbc := _gdfe.parseXref()
		if _bbbc != nil {
			_fdb.Log.Debug("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
			_fdb.Log.Debug("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074")
			break
		}
		_gdfe._aedf = append(_gdfe._aedf, int64(_gbfda))
		_cagb = _cggc.Get("\u0050\u0072\u0065\u0076")
		if _cagb != nil {
			_aecec := *(_cagb.(*PdfObjectInteger))
			if _bdda(int64(_aecec), _cbda) {
				_fdb.Log.Debug("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067")
				break
			}
			_cbda = append(_cbda, int64(_aecec))
		}
	}
	return _eeef, nil
}

func _gadb(_gga *_ad.StdEncryptDict, _fdc *PdfObjectDictionary) {
	_fdc.Set("\u0052", MakeInteger(int64(_gga.R)))
	_fdc.Set("\u0050", MakeInteger(int64(_gga.P)))
	_fdc.Set("\u004f", MakeStringFromBytes(_gga.O))
	_fdc.Set("\u0055", MakeStringFromBytes(_gga.U))
	if _gga.R >= 5 {
		_fdc.Set("\u004f\u0045", MakeStringFromBytes(_gga.OE))
		_fdc.Set("\u0055\u0045", MakeStringFromBytes(_gga.UE))
		_fdc.Set("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", MakeBool(_gga.EncryptMetadata))
		if _gga.R > 5 {
			_fdc.Set("\u0050\u0065\u0072m\u0073", MakeStringFromBytes(_gga.Perms))
		}
	}
}

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ecc *FlateEncoder) EncodeBytes(data []byte) ([]byte, error) {
	if _ecc.Predictor != 1 && _ecc.Predictor != 11 {
		_fdb.Log.Debug("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064")
		return nil, ErrUnsupportedEncodingParameters
	}
	if _ecc.Predictor == 11 {
		_gfcd := _ecc.Columns
		_gfgg := len(data) / _gfcd
		if len(data)%_gfcd != 0 {
			_fdb.Log.Error("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068")
			return nil, _b.New("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068")
		}
		_eeb := _e.NewBuffer(nil)
		_agafb := make([]byte, _gfcd)
		for _faga := 0; _faga < _gfgg; _faga++ {
			_fdcf := data[_gfcd*_faga : _gfcd*(_faga+1)]
			_agafb[0] = _fdcf[0]
			for _debf := 1; _debf < _gfcd; _debf++ {
				_agafb[_debf] = byte(int(_fdcf[_debf]-_fdcf[_debf-1]) % 256)
			}
			_eeb.WriteByte(1)
			_eeb.Write(_agafb)
		}
		data = _eeb.Bytes()
	}
	var _gffg _e.Buffer
	_bfeb := _deg.NewWriter(&_gffg)
	_bfeb.Write(data)
	_bfeb.Close()
	return _gffg.Bytes(), nil
}

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder(filterName string, customStreamEncoder StreamEncoder) {
	_cbgc.Store(filterName, customStreamEncoder)
}

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_bfcdd *PdfObjectReference) Resolve() PdfObject {
	if _bfcdd._agfgc == nil {
		return MakeNull()
	}
	_beecd, _, _fbeb := _bfcdd._agfgc.resolveReference(_bfcdd)
	if _fbeb != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074", _fbeb)
		return MakeNull()
	}
	if _beecd == nil {
		_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074")
		return MakeNull()
	}
	return _beecd
}

func _bd(_bce *_e.Buffer) { _bce.Reset(); _bec.Put(_bce) }

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder() *LZWEncoder {
	_edgf := &LZWEncoder{}
	_edgf.Predictor = 1
	_edgf.BitsPerComponent = 8
	_edgf.Colors = 1
	_edgf.Columns = 1
	_edgf.EarlyChange = 1
	return _edgf
}

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat(obj PdfObject) (_fbdg *PdfObjectFloat, _fedgd bool) {
	_fbdg, _fedgd = TraceToDirectObject(obj).(*PdfObjectFloat)
	return _fbdg, _fedgd
}

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName(obj PdfObject) (_ddfge *PdfObjectName, _bfedc bool) {
	_ddfge, _bfedc = TraceToDirectObject(obj).(*PdfObjectName)
	return _ddfge, _bfedc
}

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct {
	K                      int
	EndOfLine              bool
	EncodedByteAlign       bool
	Columns                int
	Rows                   int
	EndOfBlock             bool
	BlackIs1               bool
	DamagedRowsBeforeError int
}

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_bfadb *RawEncoder) DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	return streamObj.Stream, nil
}

const (
	JB2Generic JBIG2CompressionType = iota
	JB2SymbolCorrelation
	JB2SymbolRankHaus
)

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_edd *ASCIIHexEncoder) DecodeBytes(encoded []byte) ([]byte, error) {
	_eebd := _e.NewReader(encoded)
	var _bcaa []byte
	for {
		_bggd, _cabfg := _eebd.ReadByte()
		if _cabfg != nil {
			return nil, _cabfg
		}
		if _bggd == '>' {
			break
		}
		if IsWhiteSpace(_bggd) {
			continue
		}
		if (_bggd >= 'a' && _bggd <= 'f') || (_bggd >= 'A' && _bggd <= 'F') || (_bggd >= '0' && _bggd <= '9') {
			_bcaa = append(_bcaa, _bggd)
		} else {
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029", _bggd)
			return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029", _bggd)
		}
	}
	if len(_bcaa)%2 == 1 {
		_bcaa = append(_bcaa, '0')
	}
	_fdb.Log.Trace("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073", _bcaa)
	_bfbc := make([]byte, _fd.DecodedLen(len(_bcaa)))
	_, _edfb := _fd.Decode(_bfbc, _bcaa)
	if _edfb != nil {
		return nil, _edfb
	}
	return _bfbc, nil
}

type objectStream struct {
	N     int
	_eedf []byte
	_cae  map[int]int64
}

// Write outputs the object as it is to be written to file.
func (_egab *PdfObjectStreams) Write() []byte {
	return _edb(func(_bddf *_e.Buffer) {
		_bddf.WriteString(_d.FormatInt(_egab.ObjectNumber, 10))
		_bddf.WriteString("\u0020\u0030\u0020\u0052")
	})
}

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct {
	Predictor        int
	BitsPerComponent int

	// For predictors
	Columns int
	Colors  int

	// LZW algorithm setting.
	EarlyChange int
}

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afea *CCITTFaxEncoder) MakeDecodeParams() PdfObject {
	_adac := MakeDict()
	_adac.Set("\u004b", MakeInteger(int64(_afea.K)))
	_adac.Set("\u0043o\u006c\u0075\u006d\u006e\u0073", MakeInteger(int64(_afea.Columns)))
	if _afea.BlackIs1 {
		_adac.Set("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031", MakeBool(_afea.BlackIs1))
	}
	if _afea.EncodedByteAlign {
		_adac.Set("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e", MakeBool(_afea.EncodedByteAlign))
	}
	if _afea.EndOfLine && _afea.K >= 0 {
		_adac.Set("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee", MakeBool(_afea.EndOfLine))
	}
	if _afea.Rows != 0 && !_afea.EndOfBlock {
		_adac.Set("\u0052\u006f\u0077\u0073", MakeInteger(int64(_afea.Rows)))
	}
	if !_afea.EndOfBlock {
		_adac.Set("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b", MakeBool(_afea.EndOfBlock))
	}
	if _afea.DamagedRowsBeforeError != 0 {
		_adac.Set("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072", MakeInteger(int64(_afea.DamagedRowsBeforeError)))
	}
	return _adac
}

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_dadgg *JBIG2Image) ToGoImage() (_ff.Image, error) {
	const _ecbf = "J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065"
	if _dadgg.Data == nil {
		return nil, _fag.Error(_ecbf, "\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064")
	}
	if _dadgg.Width == 0 || _dadgg.Height == 0 {
		return nil, _fag.Error(_ecbf, "\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	_gbbgd, _gdcg := _dfa.NewImage(_dadgg.Width, _dadgg.Height, 1, 1, _dadgg.Data, nil, nil)
	if _gdcg != nil {
		return nil, _gdcg
	}
	return _gbbgd, nil
}

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_acbg *JBIG2Encoder) DecodeImages(encoded []byte) ([]_ff.Image, error) {
	const _aaf = "\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s"
	_adba, _cdca := _ba.Decode(encoded, _ba.Parameters{}, _acbg.Globals.ToDocumentGlobals())
	if _cdca != nil {
		return nil, _fag.Wrap(_cdca, _aaf, "")
	}
	_cacb, _cdca := _adba.PageNumber()
	if _cdca != nil {
		return nil, _fag.Wrap(_cdca, _aaf, "")
	}
	_bdaf := []_ff.Image{}
	var _cfa _ff.Image
	for _ffeda := 1; _ffeda <= _cacb; _ffeda++ {
		_cfa, _cdca = _adba.DecodePageImage(_ffeda)
		if _cdca != nil {
			return nil, _fag.Wrapf(_cdca, _aaf, "\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027", _ffeda)
		}
		_bdaf = append(_bdaf, _cfa)
	}
	return _bdaf, nil
}

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cde *JPXEncoder) MakeDecodeParams() PdfObject { return nil }

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_cbbdc *PdfObjectArray) ToIntegerArray() ([]int, error) {
	var _eacab []int
	for _, _dedb := range _cbbdc.Elements() {
		if _fbcc, _dggg := _dedb.(*PdfObjectInteger); _dggg {
			_eacab = append(_eacab, int(*_fbcc))
		} else {
			return nil, ErrTypeError
		}
	}
	return _eacab, nil
}

// ReadBytes reads until the first occurrence of delim in the buffered reader.
func (_fbg *bufferedReadSeeker) ReadBytes(delim byte) ([]byte, error) {
	_efg, _geb := _fbg._ffb.ReadBytes(delim)
	if _geb != nil {
		return nil, _geb
	}
	return _efg, nil
}

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal(obj PdfObject) (_fadef string, _gfea bool) {
	_ecgge, _gfea := TraceToDirectObject(obj).(*PdfObjectName)
	if _gfea {
		return string(*_ecgge), true
	}
	return
}

const _cgcd = 32 << (^uint(0) >> 63)

// ParserMetadata gets the pdf parser metadata.
func (_ccdb *PdfParser) ParserMetadata() (ParserMetadata, error) {
	if !_ccdb._baga {
		return ParserMetadata{}, _dg.Errorf("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a")
	}
	return _ccdb._afcb, nil
}

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface {
	ColorModel() _g.Model
	Bounds() _ff.Rectangle
	At(_abb, _ecae int) _g.Color
	Set(_ffed, _gabb int, _bgeg _g.Color)
}

// Peek returns the next n bytes from the buffered reader without advancing the reader.
func (_cc *bufferedReadSeeker) Peek(n int) ([]byte, error) { return _cc._ffb.Peek(n) }

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aaee *ASCIIHexEncoder) MakeStreamDict() *PdfObjectDictionary {
	_bgee := MakeDict()
	_bgee.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_aaee.GetFilterName()))
	return _bgee
}

// String returns a string describing `null`.
func (_adag *PdfObjectNull) String() string { return "\u006e\u0075\u006c\u006c" }

func _bdaaf(_bdfgd int) int {
	if _bdfgd < 0 {
		return -_bdfgd
	}
	return _bdfgd
}

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_egfd *FlateEncoder) MakeStreamDict() *PdfObjectDictionary {
	_bfcg := MakeDict()
	_bfcg.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_egfd.GetFilterName()))
	_dfd := _egfd.MakeDecodeParams()
	if _dfd != nil {
		_bfcg.Set("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073", _dfd)
	}
	return _bfcg
}

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct {

	// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
	// shortened pdf mode. This adds the file header to the jbig2 definition.
	FileMode bool

	// Compression is the setting that defines the compression type used for encoding the page.
	Compression JBIG2CompressionType

	// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
	// doesn't store it twice.
	DuplicatedLinesRemoval bool

	// DefaultPixelValue is the bit value initial for every pixel in the page.
	DefaultPixelValue uint8

	// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
	ResolutionX int

	// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
	ResolutionY int

	// Threshold defines the threshold of the image correlation for
	// non Generic compression.
	// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
	// Best results in range [0.7 - 0.98] - the less the better the compression would be
	// but the more lossy.
	// Default value: 0.95
	Threshold float64
}

// GetXrefOffset returns the offset of the xref table.
func (_ecgg *PdfParser) GetXrefOffset() int64 { return _ecgg._gecfg }

// Bytes returns the PdfObjectString content as a []byte array.
func (_cedea *PdfObjectString) Bytes() []byte { return []byte(_cedea._gdea) }

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder() *DCTEncoder {
	_eaaa := &DCTEncoder{}
	_eaaa.ColorComponents = 3
	_eaaa.BitsPerComponent = 8
	_eaaa.Quality = DefaultJPEGQuality
	_eaaa.Decode = []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
	return _eaaa
}

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects(obj1, obj2 PdfObject) bool { return _fagd(obj1, obj2, 0) }

// Write outputs the object as it is to be written to file.
func (_ecda *PdfObjectStream) Write() []byte {
	return _edb(func(_bbcb *_e.Buffer) {
		_bbcb.WriteString(_d.FormatInt(_ecda.ObjectNumber, 10))
		_bbcb.WriteString("\u0020\u0030\u0020\u0052")
	})
}

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool(obj PdfObject) (_bgcd *PdfObjectBool, _fgfc bool) {
	_bgcd, _fgfc = TraceToDirectObject(obj).(*PdfObjectBool)
	return _bgcd, _fgfc
}

// String returns a descriptive information string about the encryption method used.
func (_dag *PdfCrypt) String() string {
	if _dag == nil {
		return ""
	}
	_aba := _dag._cabf.Filter + "\u0020\u002d\u0020"
	if _dag._cabf.V == 0 {
		_aba += "\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d"
	} else if _dag._cabf.V == 1 {
		_aba += "\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073"
	} else if _dag._cabf.V == 2 {
		_aba += _dg.Sprintf("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073", _dag._cabf.Length)
	} else if _dag._cabf.V == 3 {
		_aba += "U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d"
	} else if _dag._cabf.V >= 4 {
		_aba += _dg.Sprintf("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073", _dag._cef, _dag._cfd)
		_aba += "\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a"
		for _bcb, _fcg := range _dag._fca {
			_aba += _dg.Sprintf("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029", _bcb, _fcg.Name(), _fcg.KeyLength())
		}
	}
	_fbb := _dag.GetAccessPermissions()
	_aba += _dg.Sprintf("\u0020\u002d\u0020\u0025\u0023\u0076", _fbb)
	return _aba
}

func _dfgdf(_edga, _fecde, _eabag int) error {
	if _fecde < 0 || _fecde > _edga {
		return _b.New("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073")
	}
	if _eabag < _fecde {
		return _b.New("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a")
	}
	if _eabag > _edga {
		return _b.New("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073")
	}
	return nil
}

// Clear resets the array to an empty state.
func (_adec *PdfObjectArray) Clear() { _adec._abad = []PdfObject{} }

func _aeaa(_aeff PdfObject, _badgba int) PdfObject {
	if _badgba > _cefd {
		_fdb.Log.Error("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021", _cefd)
		return MakeNull()
	}
	switch _aede := _aeff.(type) {
	case *PdfIndirectObject:
		_aeff = _aeaa((*_aede).PdfObject, _badgba+1)
	case *PdfObjectArray:
		for _dfgeg, _edbdd := range (*_aede)._abad {
			(*_aede)._abad[_dfgeg] = _aeaa(_edbdd, _badgba+1)
		}
	case *PdfObjectDictionary:
		for _eefbc, _ddcdc := range (*_aede)._bgfg {
			(*_aede)._bgfg[_eefbc] = _aeaa(_ddcdc, _badgba+1)
		}
		_de.Slice((*_aede)._faaee, func(_adggg, _bcfd int) bool { return (*_aede)._faaee[_adggg] < (*_aede)._faaee[_bcfd] })
	}
	return _aeff
}

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_gccbg *PdfParser) GetEncryptObj() *PdfIndirectObject { return _gccbg._afad }

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egfb *MultiEncoder) MakeDecodeParams() PdfObject {
	if len(_egfb._bdfea) == 0 {
		return nil
	}
	if len(_egfb._bdfea) == 1 {
		return _egfb._bdfea[0].MakeDecodeParams()
	}
	_dfaa := MakeArray()
	_fdcd := true
	for _, _aeeg := range _egfb._bdfea {
		_babd := _aeeg.MakeDecodeParams()
		if _babd == nil {
			_dfaa.Append(MakeNull())
		} else {
			_fdcd = false
			_dfaa.Append(_babd)
		}
	}
	if _fdcd {
		return nil
	}
	return _dfaa
}

type bufferedReadSeeker struct {
	_bca _eed.ReadSeeker
	_ffb *_ge.Reader
}

func (_efaeb *PdfParser) checkLinearizedInformation(_gffdg *PdfObjectDictionary) (bool, error) {
	var _abgdc error
	_efaeb._ddea, _abgdc = GetNumberAsInt64(_gffdg.Get("\u004c"))
	if _abgdc != nil {
		return false, _abgdc
	}
	_abgdc = _efaeb.seekToEOFMarker(_efaeb._ddea)
	switch _abgdc {
	case nil:
		return true, nil
	case _cbgd:
		return false, nil
	default:
		return false, _abgdc
	}
}

// SetFileOffset sets the file to an offset position and resets buffer.
func (_bag *PdfParser) SetFileOffset(offset int64) { _bag._gggee.SetFileOffset(offset) }

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit(c byte) bool { return '0' <= c && c <= '7' }

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_ggbf *PdfObjectString) Decoded() string {
	if _ggbf == nil {
		return ""
	}
	_fbed := []byte(_ggbf._gdea)
	if len(_fbed) >= 2 && _fbed[0] == 0xFE && _fbed[1] == 0xFF {
		return _fb.UTF16ToString(_fbed[2:])
	}
	return _fb.PDFDocEncodingToString(_fbed)
}

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct {
	_cad   int
	_edcbb bool
	_gegc  [4]byte
	_degd  bool
	_bcf   bool
	_afb   bool
	_fac   bool
	_gcfg  bool
	_egf   bool
}

func (_ecg *PdfCrypt) isEncrypted(_cbfc PdfObject) bool {
	_, _dcae := _ecg._egb[_cbfc]
	if _dcae {
		_fdb.Log.Trace("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064")
		return true
	}
	_fdb.Log.Trace("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074")
	return false
}

func (_ecggd *PdfParser) parseXrefTable() (*PdfObjectDictionary, error) {
	var _adgc *PdfObjectDictionary
	_bfeec, _fcdf := _ecggd.readTextLine()
	if _fcdf != nil {
		return nil, _fcdf
	}
	if _ecggd._baga && _fa.Count(_fa.TrimPrefix(_bfeec, "\u0078\u0072\u0065\u0066"), "\u0020") > 0 {
		_ecggd._afcb._egf = true
	}
	_fdb.Log.Trace("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073", _bfeec)
	_gbcd := -1
	_egad := 0
	_cec := false
	_bfddg := ""
	for {
		_ecggd.skipSpaces()
		_, _dfafd := _ecggd._gggee.Peek(1)
		if _dfafd != nil {
			return nil, _dfafd
		}
		_bfeec, _dfafd = _ecggd.readTextLine()
		if _dfafd != nil {
			return nil, _dfafd
		}
		_gaafa := _abee.FindStringSubmatch(_bfeec)
		if len(_gaafa) == 0 {
			_dabff := len(_bfddg) > 0
			_bfddg += _bfeec + "\u000a"
			if _dabff {
				_gaafa = _abee.FindStringSubmatch(_bfddg)
			}
		}
		if len(_gaafa) == 3 {
			if _ecggd._baga && !_ecggd._afcb._gcfg {
				var (
					_dcdgc bool
					_dbfb  int
				)
				for _, _agga := range _bfeec {
					if _ea.IsDigit(_agga) {
						if _dcdgc {
							break
						}
						continue
					}
					if !_dcdgc {
						_dcdgc = true
					}
					_dbfb++
				}
				if _dbfb > 1 {
					_ecggd._afcb._gcfg = true
				}
			}
			_feba, _ := _d.Atoi(_gaafa[1])
			_gegb, _ := _d.Atoi(_gaafa[2])
			_gbcd = _feba
			_egad = _gegb
			_cec = true
			_bfddg = ""
			_fdb.Log.Trace("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064", _gbcd, _egad)
			continue
		}
		_beaf := _edbdf.FindStringSubmatch(_bfeec)
		if len(_beaf) == 4 {
			if !_cec {
				_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a")
				return nil, _b.New("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
			}
			_bgad, _ := _d.ParseInt(_beaf[1], 10, 64)
			_gbgc, _ := _d.Atoi(_beaf[2])
			_cebf := _beaf[3]
			_bfddg = ""
			if _fa.ToLower(_cebf) == "\u006e" && _bgad > 1 {
				_cgda, _bdce := _ecggd._fabaa.ObjectMap[_gbcd]
				if !_bdce || _gbgc > _cgda.Generation {
					_dafg := XrefObject{ObjectNumber: _gbcd, XType: XrefTypeTableEntry, Offset: _bgad, Generation: _gbgc}
					_ecggd._fabaa.ObjectMap[_gbcd] = _dafg
				}
			}
			_gbcd++
			continue
		}
		if (len(_bfeec) > 6) && (_bfeec[:7] == "\u0074r\u0061\u0069\u006c\u0065\u0072") {
			_fdb.Log.Trace("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073", _bfeec)
			if len(_bfeec) > 9 {
				_gcaab := _ecggd.GetFileOffset()
				_ecggd.SetFileOffset(_gcaab - int64(len(_bfeec)) + 7)
			}
			_ecggd.skipSpaces()
			_ecggd.skipComments()
			_fdb.Log.Trace("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021")
			_fdb.Log.Trace("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022", _bfeec)
			_adgc, _dfafd = _ecggd.ParseDict()
			_fdb.Log.Trace("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!")
			if _dfafd != nil {
				_fdb.Log.Debug("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029", _dfafd)
				return nil, _dfafd
			}
			break
		}
		if _bfeec == "\u0025\u0025\u0045O\u0046" {
			_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021")
			return nil, _b.New("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
		}
		_fdb.Log.Trace("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073", _bfeec)
	}
	_fdb.Log.Trace("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021")
	if _ecggd._defc == nil {
		_fagad := XrefTypeTableEntry
		_ecggd._defc = &_fagad
	}
	return _adgc, nil
}

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{}

// Len returns the number of elements in the streams.
func (_ddcb *PdfObjectStreams) Len() int {
	if _ddcb == nil {
		return 0
	}
	return len(_ddcb._bedg)
}

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder() *ASCIIHexEncoder { _egda := &ASCIIHexEncoder{}; return _egda }

// Len returns the number of elements in the array.
func (_cegf *PdfObjectArray) Len() int {
	if _cegf == nil {
		return 0
	}
	return len(_cegf._abad)
}

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal(obj PdfObject) (_dcfa bool, _cfbad bool) {
	_bdae, _cfbad := TraceToDirectObject(obj).(*PdfObjectBool)
	if _cfbad {
		return bool(*_bdae), true
	}
	return false, false
}

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt(cf _bc.Filter, userPass, ownerPass []byte, perm _ad.Permissions) (*PdfCrypt, *EncryptInfo, error) {
	_gace := &PdfCrypt{_egb: make(map[PdfObject]bool), _fca: make(cryptFilters), _ecf: _ad.StdEncryptDict{P: perm, EncryptMetadata: true}}
	var _fde Version
	if cf != nil {
		_cff := cf.PDFVersion()
		_fde.Major, _fde.Minor = _cff[0], _cff[1]
		V, R := cf.HandlerVersion()
		_gace._cabf.V = V
		_gace._ecf.R = R
		_gace._cabf.Length = cf.KeyLength() * 8
	}
	const (
		_dfe = _bdc
	)
	_gace._fca[_dfe] = cf
	if _gace._cabf.V >= 4 {
		_gace._cef = _dfe
		_gace._cfd = _dfe
	}
	_cbc := _gace.newEncryptDict()
	_daf := _da.Sum([]byte(_dd.Now().Format(_dd.RFC850)))
	_dadf := string(_daf[:])
	_cab := make([]byte, 100)
	_ed.Read(_cab)
	_daf = _da.Sum(_cab)
	_ccd := string(_daf[:])
	_fdb.Log.Trace("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078", _cab)
	_fdb.Log.Trace("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078", _dadf)
	_gace._fda = _dadf
	_dga := _gace.generateParams(userPass, ownerPass)
	if _dga != nil {
		return nil, nil, _dga
	}
	_gadb(&_gace._ecf, _cbc)
	if _gace._cabf.V >= 4 {
		if _bea := _gace.saveCryptFilters(_cbc); _bea != nil {
			return nil, nil, _bea
		}
	}
	return _gace, &EncryptInfo{Version: _fde, Encrypt: _cbc, ID0: _dadf, ID1: _ccd}, nil
}

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit(c byte) bool { return '0' <= c && c <= '9' }

// GetXrefType returns the type of the first xref object (table or stream).
func (_bcfg *PdfParser) GetXrefType() *xrefType { return _bcfg._defc }

func (_cabb *PdfParser) parseNumber() (PdfObject, error) { return ParseNumber(_cabb._gggee._ffb) }

var _cbgc _bf.Map

// GetFilterName returns the name of the encoding filter.
func (_egd *FlateEncoder) GetFilterName() string { return StreamEncodingFilterNameFlate }

// RGBToGrayscale converts RGB color values to grayscale using the standard luminance formula.
//
// Parameters r, g, b are expected to be integers in the range [0, 255].
//
// The coefficient used in the formula to convert RGB values to grayscale.
// This formula is based on the luminance perception of the human eye,
// which is more sensitive to green light and less sensitive to blue light.
// The full formula is:  [ gray = 0.299 * R + 0.587 * G + 0.114 * B ]
//
// This implementation uses integer arithmetic for better performance by using
// scaled coefficients: 299, 587, 114 (scaled by 1000).
func RGBToGrayscale(r, g, b int) int { _dfgge := 299*r + 587*g + 114*b; return _dfgge / 1000 }

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference(obj PdfObject) PdfObject {
	if _aceeg, _cgede := obj.(*PdfObjectReference); _cgede {
		return _aceeg.Resolve()
	}
	return obj
}

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{}

func _agac(_ *PdfObjectStream, _ *PdfObjectDictionary) (*RunLengthEncoder, error) {
	return NewRunLengthEncoder(), nil
}

func (_gcde *PdfParser) inspect() (map[string]int, error) {
	_fdb.Log.Trace("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d")
	_fdb.Log.Trace("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a")
	_cgac := map[string]int{}
	_gdac := 0
	_deccbc := 0
	var _dbdd []int
	for _agbdg := range _gcde._fabaa.ObjectMap {
		_dbdd = append(_dbdd, _agbdg)
	}
	_de.Ints(_dbdd)
	_gdfg := 0
	for _, _gcda := range _dbdd {
		_dfcc := _gcde._fabaa.ObjectMap[_gcda]
		if _dfcc.ObjectNumber == 0 {
			continue
		}
		_gdac++
		_fdb.Log.Trace("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d")
		_fdb.Log.Trace("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064", _dfcc.ObjectNumber)
		_ggaea, _defcb := _gcde.LookupByNumber(_dfcc.ObjectNumber)
		if _defcb != nil {
			_fdb.Log.Trace("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029", _dfcc.ObjectNumber, _defcb)
			_deccbc++
			continue
		}
		_fdb.Log.Trace("\u006fb\u006a\u003a\u0020\u0025\u0073", _ggaea)
		_bgbf, _bbbae := _ggaea.(*PdfIndirectObject)
		if _bbbae {
			_fdb.Log.Trace("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073", _dfcc.ObjectNumber, _bgbf)
			_cddf, _cfbbd := _bgbf.PdfObject.(*PdfObjectDictionary)
			if _cfbbd {
				if _geab, _fdba := _cddf.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName); _fdba {
					_adcg := string(*_geab)
					_fdb.Log.Trace("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073", _adcg)
					_, _dedc := _cgac[_adcg]
					if _dedc {
						_cgac[_adcg]++
					} else {
						_cgac[_adcg] = 1
					}
				} else if _dafbg, _eeab := _cddf.Get("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName); _eeab {
					_ddaee := string(*_dafbg)
					_fdb.Log.Trace("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073", _ddaee)
					_, _cegbc := _cgac[_ddaee]
					if _cegbc {
						_cgac[_ddaee]++
					} else {
						_cgac[_ddaee] = 1
					}
				}
				if _decf, _ggcba := _cddf.Get("\u0053").(*PdfObjectName); _ggcba && *_decf == "\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074" {
					_, _dffaf := _cgac["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]
					if _dffaf {
						_cgac["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++
					} else {
						_cgac["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"] = 1
					}
				}
			}
		} else if _gcce, _bcbbb := _ggaea.(*PdfObjectStream); _bcbbb {
			if _ecef, _fgcd := _gcce.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName); _fgcd {
				_fdb.Log.Trace("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073", *_ecef)
				_ceadc := string(*_ecef)
				_cgac[_ceadc]++
			}
		} else {
			_egdfd, _ffcdd := _ggaea.(*PdfObjectDictionary)
			if _ffcdd {
				_acae, _bffd := _egdfd.Get("\u0054\u0079\u0070\u0065").(*PdfObjectName)
				if _bffd {
					_adeecg := string(*_acae)
					_fdb.Log.Trace("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _adeecg)
					_cgac[_adeecg]++
				}
			}
			_fdb.Log.Trace("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073", _dfcc.ObjectNumber, _ggaea)
		}
		_gdfg++
	}
	_fdb.Log.Trace("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d")
	_fdb.Log.Trace("\u003d=\u003d\u003d\u003d\u003d\u003d")
	_fdb.Log.Trace("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064", _gdac)
	_fdb.Log.Trace("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064", _deccbc)
	for _gaaa, _ccdac := range _cgac {
		_fdb.Log.Trace("\u0025\u0073\u003a\u0020\u0025\u0064", _gaaa, _ccdac)
	}
	_fdb.Log.Trace("\u003d=\u003d\u003d\u003d\u003d\u003d")
	if len(_gcde._fabaa.ObjectMap) < 1 {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029")
		return nil, _dg.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029")
	}
	_gbbda, _edff := _cgac["\u0046\u006f\u006e\u0074"]
	if !_edff || _gbbda < 2 {
		_fdb.Log.Trace("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021")
	} else {
		_fdb.Log.Trace("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021")
	}
	return _cgac, nil
}

func _cdd(_caaf *PdfObjectStream, _gceg *PdfObjectDictionary) (*FlateEncoder, error) {
	_aacc := NewFlateEncoder()
	_bada := _caaf.PdfObjectDictionary
	if _bada == nil {
		return _aacc, nil
	}
	_aacc._gfg = _ffbcg(_bada)
	if _gceg == nil {
		_efcf := TraceToDirectObject(_bada.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"))
		switch _bbfg := _efcf.(type) {
		case *PdfObjectArray:
			if _bbfg.Len() != 1 {
				_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029", _bbfg.Len())
				return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
			}
			if _dfae, _ccg := GetDict(_bbfg.Get(0)); _ccg {
				_gceg = _dfae
			}
		case *PdfObjectDictionary:
			_gceg = _bbfg
		case *PdfObjectNull, nil:
		default:
			_fdb.Log.Debug("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029", _efcf)
			return nil, _dg.Errorf("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073")
		}
	}
	if _gceg == nil {
		return _aacc, nil
	}
	_fdb.Log.Trace("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073", _gceg.String())
	_fdag := _gceg.Get("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr")
	if _fdag == nil {
		_fdb.Log.Debug("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029")
	} else {
		_aegc, _dcca := _fdag.(*PdfObjectInteger)
		if !_dcca {
			_fdb.Log.Debug("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029", _fdag)
			return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072")
		}
		_aacc.Predictor = int(*_aegc)
	}
	_fdag = _gceg.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _fdag != nil {
		_bgcg, _dadd := _fdag.(*PdfObjectInteger)
		if !_dadd {
			_fdb.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
			return nil, _dg.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
		}
		_aacc.BitsPerComponent = int(*_bgcg)
		if _aacc.BitsPerComponent != _aacc._gfg.BitsPerComponent {
			_fdb.Log.Debug("\u0057A\u0052\u004e\u0049\u004eG\u003a \u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006di\u0073\u006d\u0061\u0074\u0063\u0068\u0020\u0077\u0069\u0074\u0068 \u0069\u006d\u0061\u0067\u0065\u0020\u0028\u0025\u0064\u002f%\u0064\u0029\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020i\u006da\u0067\u0065", _aacc.BitsPerComponent, _aacc._gfg.BitsPerComponent)
			_aacc.BitsPerComponent = _aacc._gfg.BitsPerComponent
		}
	}
	if _aacc.Predictor > 1 {
		_aacc.Columns = 1
		_fdag = _gceg.Get("\u0043o\u006c\u0075\u006d\u006e\u0073")
		if _fdag != nil {
			_abc, _gcegc := _fdag.(*PdfObjectInteger)
			if !_gcegc {
				return nil, _dg.Errorf("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
			}
			_aacc.Columns = int(*_abc)
		}
		_aacc.Colors = 1
		_fdag = _gceg.Get("\u0043\u006f\u006c\u006f\u0072\u0073")
		if _fdag != nil {
			_ffcg, _efe := _fdag.(*PdfObjectInteger)
			if !_efe {
				return nil, _dg.Errorf("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072")
			}
			_aacc.Colors = int(*_ffcg)
		}
	}
	return _aacc, nil
}

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_gdab *MultiEncoder) GetFilterArray() *PdfObjectArray {
	_fbgd := make([]PdfObject, len(_gdab._bdfea))
	for _efdf, _gcaa := range _gdab._bdfea {
		_fbgd[_efdf] = MakeName(_gcaa.GetFilterName())
	}
	return MakeArray(_fbgd...)
}

// Close closes the bufferedReadSeeker.
func (_ca *bufferedReadSeeker) Close() error {
	if _dda, _dad := _ca._bca.(_eed.Closer); _dad {
		return _dda.Close()
	}
	return nil
}

// Reset resets the buffered reader with a new io.Reader.
func (_gccc *bufferedReadSeeker) Reset(r _eed.Reader) { _gccc._ffb.Reset(r) }

func _dgdc(_ebbfe string) (int, int, error) {
	_fcfb := _bgbge.FindStringSubmatch(_ebbfe)
	if len(_fcfb) < 3 {
		return 0, 0, _b.New("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065")
	}
	_beda, _ := _d.Atoi(_fcfb[1])
	_gdegc, _ := _d.Atoi(_fcfb[2])
	return _beda, _gdegc, nil
}

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream(streamObj *PdfObjectStream) ([]byte, error) {
	_fdb.Log.Trace("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
	_abcdf, _eaff := NewEncoderFromStream(streamObj)
	if _eaff != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076", _eaff)
		return nil, _eaff
	}
	_fdb.Log.Trace("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a", _abcdf)
	_ffedg, _eaff := _abcdf.DecodeStream(streamObj)
	if _eaff != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076", _eaff)
		return nil, _eaff
	}
	return _ffedg, nil
}

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fgfa *FlateEncoder) SetPredictor(columns int) { _fgfa.Predictor = 11; _fgfa.Columns = columns }

// GetFilterName returns the name of the encoding filter.
func (_cbd *LZWEncoder) GetFilterName() string { return StreamEncodingFilterNameLZW }

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bfgc *PdfParser) Resolve(obj PdfObject) (PdfObject, error) {
	_ffd, _aad := obj.(*PdfObjectReference)
	if !_aad {
		return obj, nil
	}
	_efa := _bfgc.GetFileOffset()
	defer func() { _bfgc.SetFileOffset(_efa) }()
	_gadg, _ebc := _bfgc.LookupByReference(*_ffd)
	if _ebc != nil {
		return nil, _ebc
	}
	_gac, _geg := _gadg.(*PdfIndirectObject)
	if !_geg {
		return _gadg, nil
	}
	_gadg = _gac.PdfObject
	_, _aad = _gadg.(*PdfObjectReference)
	if _aad {
		return _gac, _b.New("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072")
	}
	return _gadg, nil
}

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable(c byte) bool { return 0x21 <= c && c <= 0x7E }

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_efbef *JPXEncoder) EncodeBytes(data []byte) ([]byte, error) {
	_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073", _efbef.GetFilterName())
	return data, ErrNoJPXDecode
}

func _begbe() string { return _fdb.Version }

func (_abf *PdfCrypt) securityHandler() _ad.StdHandler {
	if _abf._ecf.R >= 5 {
		return _ad.NewHandlerR6()
	}
	return _ad.NewHandlerR4(_abf._fda, _abf._cabf.Length)
}

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser(rs _eed.ReadSeeker) (_cafcd *PdfParser, _afa error) {
	_cafcd = &PdfParser{_gggee: _gcc(rs), ObjCache: make(objectCache), _effa: map[int64]bool{}, _baga: true, _bcgf: make(map[*PdfParser]*PdfParser)}
	if _afa = _cafcd.parseDetailedHeader(); _afa != nil {
		return nil, _afa
	}
	if _cafcd._fce, _afa = _cafcd.loadXrefs(); _afa != nil {
		_fdb.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073", _afa)
		return nil, _afa
	}
	_fdb.Log.Trace("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073", _cafcd._fce)
	if len(_cafcd._fabaa.ObjectMap) == 0 {
		return nil, _dg.Errorf("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064")
	}
	return _cafcd, nil
}

// Version represents a version of a PDF standard.
type Version struct {
	Major int
	Minor int
}

// Buffered returns the number of bytes currently buffered.
func (_acc *bufferedReadSeeker) Buffered() int { return _acc._ffb.Buffered() }

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams(objects ...PdfObject) *PdfObjectStreams {
	return &PdfObjectStreams{_bedg: objects}
}

func _bcc() *_e.Buffer { return _bec.Get().(*_e.Buffer) }

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_ddd ParserMetadata) HasInvalidHexRunes() bool { return _ddd._afb }

// GetFilterName returns the name of the encoding filter.
func (_decc *ASCIIHexEncoder) GetFilterName() string { return StreamEncodingFilterNameASCIIHex }

func _ecb(_abg *PdfObjectStream, _eeg *PdfObjectDictionary) (*LZWEncoder, error) {
	_ddbe := NewLZWEncoder()
	_cffcf := _abg.PdfObjectDictionary
	if _cffcf == nil {
		return _ddbe, nil
	}
	if _eeg == nil {
		_agae := TraceToDirectObject(_cffcf.Get("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"))
		if _agae != nil {
			if _ege, _daad := _agae.(*PdfObjectDictionary); _daad {
				_eeg = _ege
			} else if _cfcb, _gbega := _agae.(*PdfObjectArray); _gbega {
				if _cfcb.Len() == 1 {
					if _gfcg, _cfba := GetDict(_cfcb.Get(0)); _cfba {
						_eeg = _gfcg
					}
				}
			}
			if _eeg == nil {
				_fdb.Log.Error("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076", _agae)
				return nil, _dg.Errorf("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073")
			}
		}
	}
	_adfaa := _cffcf.Get("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065")
	if _adfaa != nil {
		_acd, _cade := _adfaa.(*PdfObjectInteger)
		if !_cade {
			_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029", _adfaa)
			return nil, _dg.Errorf("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065")
		}
		if *_acd != 0 && *_acd != 1 {
			return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029")
		}
		_ddbe.EarlyChange = int(*_acd)
	} else {
		_ddbe.EarlyChange = 1
	}
	if _eeg == nil {
		return _ddbe, nil
	}
	if _acce, _bfbb := GetIntVal(_eeg.Get("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065")); _bfbb {
		if _acce == 0 || _acce == 1 {
			_ddbe.EarlyChange = _acce
		} else {
			_fdb.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064", _acce)
		}
	}
	_adfaa = _eeg.Get("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr")
	if _adfaa != nil {
		_cgce, _bddg := _adfaa.(*PdfObjectInteger)
		if !_bddg {
			_fdb.Log.Debug("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029", _adfaa)
			return nil, _dg.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072")
		}
		_ddbe.Predictor = int(*_cgce)
	}
	_adfaa = _eeg.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _adfaa != nil {
		_ccb, _cede := _adfaa.(*PdfObjectInteger)
		if !_cede {
			_fdb.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
			return nil, _dg.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
		}
		_ddbe.BitsPerComponent = int(*_ccb)
	}
	if _ddbe.Predictor > 1 {
		_ddbe.Columns = 1
		_adfaa = _eeg.Get("\u0043o\u006c\u0075\u006d\u006e\u0073")
		if _adfaa != nil {
			_dbff, _gabe := _adfaa.(*PdfObjectInteger)
			if !_gabe {
				return nil, _dg.Errorf("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
			}
			_ddbe.Columns = int(*_dbff)
		}
		_ddbe.Colors = 1
		_adfaa = _eeg.Get("\u0043\u006f\u006c\u006f\u0072\u0073")
		if _adfaa != nil {
			_bgbg, _fdad := _adfaa.(*PdfObjectInteger)
			if !_fdad {
				return nil, _dg.Errorf("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072")
			}
			_ddbe.Colors = int(*_bgbg)
		}
	}
	_fdb.Log.Trace("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073", _eeg.String())
	return _ddbe, nil
}

// GetFilterName returns the name of the encoding filter.
func (_ggca *CCITTFaxEncoder) GetFilterName() string { return StreamEncodingFilterNameCCITTFax }

// Write outputs the object as it is to be written to file.
func (_bfgfd *PdfObjectFloat) Write() []byte {
	return []byte(_d.FormatFloat(float64(*_bfgfd), 'f', -1, 64))
}

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep(o PdfObject, traversed map[PdfObject]struct{}) error {
	if traversed == nil {
		traversed = map[PdfObject]struct{}{}
	}
	return _cbaab(o, 0, traversed)
}

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct {
	ObjectMap map[int]XrefObject
	_ce       []XrefObject
}

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal(obj PdfObject) (_gdaa int, _gfbf bool) {
	_bgfdd, _gfbf := TraceToDirectObject(obj).(*PdfObjectInteger)
	if _gfbf && _bgfdd != nil {
		return int(*_bgfdd), true
	}
	return 0, false
}

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_dcbc *ASCII85Encoder) MakeStreamDict() *PdfObjectDictionary {
	_bcac := MakeDict()
	_bcac.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_dcbc.GetFilterName()))
	return _bcac
}

func _abfa(_dfbd _dfa.Image) *JBIG2Image {
	_cfdc := _dfbd.Base()
	return &JBIG2Image{Data: _cfdc.Data, Width: _cfdc.Width, Height: _cfdc.Height, HasPadding: true}
}

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eeae *RawEncoder) MakeDecodeParams() PdfObject { return nil }

var _cbcbg = _a.MustCompile("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029")

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString(obj PdfObject) (_gbeae *PdfObjectString, _dbafb bool) {
	_gbeae, _dbafb = TraceToDirectObject(obj).(*PdfObjectString)
	return _gbeae, _dbafb
}

func (_fdce *PdfParser) parseXrefStream(_gfde *PdfObjectInteger) (*PdfObjectDictionary, error) {
	if _gfde != nil {
		_fdb.Log.Trace("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064", _gfde)
		_fdce._gggee.Seek(int64(*_gfde), _eed.SeekStart)
	}
	_ddbd := _fdce.GetFileOffset()
	_ecbeb, _dfaaa := _fdce.ParseIndirectObject()
	if _dfaaa != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074")
		return nil, _b.New("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	_fdb.Log.Trace("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073", _ecbeb)
	_abae, _bdfg := _ecbeb.(*PdfObjectStream)
	if !_bdfg {
		_fdb.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021")
		return nil, _b.New("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_fggdd := _abae.PdfObjectDictionary
	_eabcg, _bdfg := _abae.Get("\u0053\u0069\u007a\u0065").(*PdfObjectInteger)
	if !_bdfg {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d")
		return nil, _b.New("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d")
	}
	if int64(*_eabcg) > 8388607 {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029", *_eabcg)
		return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	}
	_gdeg := _abae.Get("\u0057")
	_dgfb, _bdfg := _gdeg.(*PdfObjectArray)
	if !_bdfg {
		return nil, _b.New("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
	}
	_dbgf := _dgfb.Len()
	if _dbgf != 3 {
		_fdb.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029", _dbgf)
		return nil, _b.New("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033")
	}
	var _cecg []int64
	for _babdcd := 0; _babdcd < 3; _babdcd++ {
		_edaa, _gecc := GetInt(_dgfb.Get(_babdcd))
		if !_gecc {
			return nil, _b.New("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065")
		}
		_cecg = append(_cecg, int64(*_edaa))
	}
	_fgfdc, _dfaaa := DecodeStream(_abae)
	if _dfaaa != nil {
		_fdb.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _dfaaa)
		return nil, _dfaaa
	}
	_ecfc := int(_cecg[0])
	_ebfb := int(_cecg[0] + _cecg[1])
	_efeea := int(_cecg[0] + _cecg[1] + _cecg[2])
	_dgg := int(_cecg[0] + _cecg[1] + _cecg[2])
	if _ecfc < 0 || _ebfb < 0 || _efeea < 0 {
		_fdb.Log.Debug("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029", _ecfc, _ebfb, _efeea)
		return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	}
	if _dgg == 0 {
		_fdb.Log.Debug("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029")
		return _fggdd, nil
	}
	_fadc := len(_fgfdc) / _dgg
	_gaag := 0
	_dadb := _abae.Get("\u0049\u006e\u0064e\u0078")
	var _bgffd []int
	if _dadb != nil {
		_fdb.Log.Trace("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b", _dadb)
		_abed, _cegg := _dadb.(*PdfObjectArray)
		if !_cegg {
			_fdb.Log.Debug("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029")
			return nil, _b.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074")
		}
		if _abed.Len()%2 != 0 {
			_fdb.Log.Debug("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e")
			return nil, _b.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
		}
		_gaag = 0
		_gcae, _gfcdb := _abed.ToIntegerArray()
		if _gfcdb != nil {
			_fdb.Log.Debug("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076", _gfcdb)
			return nil, _gfcdb
		}
		for _eace := 0; _eace < len(_gcae); _eace += 2 {
			_fcgac := _gcae[_eace]
			_acge := _gcae[_eace+1]
			for _ddeag := 0; _ddeag < _acge; _ddeag++ {
				_bgffd = append(_bgffd, _fcgac+_ddeag)
			}
			_gaag += _acge
		}
	} else {
		for _feff := 0; _feff < int(*_eabcg); _feff++ {
			_bgffd = append(_bgffd, _feff)
		}
		_gaag = int(*_eabcg)
	}
	if _fadc == _gaag+1 {
		_fdb.Log.Debug("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073")
		_fcfa := _gaag - 1
		for _, _gge := range _bgffd {
			if _gge > _fcfa {
				_fcfa = _gge
			}
		}
		_bgffd = append(_bgffd, _fcfa+1)
		_gaag++
	}
	if _fadc != len(_bgffd) {
		_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029", _fadc, len(_bgffd))
		return nil, _b.New("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029")
	}
	_fdb.Log.Trace("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064", _gaag)
	_fdb.Log.Trace("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064", _bgffd)
	_edec := func(_aecd []byte) int64 {
		var _ebcd int64
		for _afbbg := 0; _afbbg < len(_aecd); _afbbg++ {
			_ebcd += int64(_aecd[_afbbg]) * (1 << uint(8*(len(_aecd)-_afbbg-1)))
		}
		return _ebcd
	}
	_fdb.Log.Trace("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d", len(_fgfdc))
	_afgd := 0
	for _bgged := 0; _bgged < len(_fgfdc); _bgged += _dgg {
		_edgg := _dfgdf(len(_fgfdc), _bgged, _bgged+_ecfc)
		if _edgg != nil {
			_fdb.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076", _edgg)
			return nil, _edgg
		}
		_cbbf := _fgfdc[_bgged : _bgged+_ecfc]
		_edgg = _dfgdf(len(_fgfdc), _bgged+_ecfc, _bgged+_ebfb)
		if _edgg != nil {
			_fdb.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076", _edgg)
			return nil, _edgg
		}
		_affc := _fgfdc[_bgged+_ecfc : _bgged+_ebfb]
		_edgg = _dfgdf(len(_fgfdc), _bgged+_ebfb, _bgged+_efeea)
		if _edgg != nil {
			_fdb.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076", _edgg)
			return nil, _edgg
		}
		_edab := _fgfdc[_bgged+_ebfb : _bgged+_efeea]
		_becdf := _edec(_cbbf)
		_ffcf := _edec(_affc)
		_cdfgc := _edec(_edab)
		if _cecg[0] == 0 {
			_becdf = 1
		}
		if _afgd >= len(_bgffd) {
			_fdb.Log.Debug("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067")
			break
		}
		_efga := _bgffd[_afgd]
		_afgd++
		_fdb.Log.Trace("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078", _efga, _cbbf)
		_fdb.Log.Trace("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078", _efga, _affc)
		_fdb.Log.Trace("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078", _efga, _edab)
		_fdb.Log.Trace("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064", _efga, _becdf, _ffcf, _cdfgc)
		switch _becdf {
		case 0:
			_fdb.Log.Trace("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065")
		case 1:
			_fdb.Log.Trace("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062", _affc)
			if _ffcf == _ddbd {
				_fdb.Log.Debug("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064", _efga, _abae.ObjectNumber)
				_efga = int(_abae.ObjectNumber)
			}
			if _bgbc, _efaf := _fdce._fabaa.ObjectMap[_efga]; !_efaf || int(_cdfgc) > _bgbc.Generation {
				_deffa := XrefObject{ObjectNumber: _efga, XType: XrefTypeTableEntry, Offset: _ffcf, Generation: int(_cdfgc)}
				_fdce._fabaa.ObjectMap[_efga] = _deffa
			}
		case 2:
			_fdb.Log.Trace("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074")
			if _, _fggdb := _fdce._fabaa.ObjectMap[_efga]; !_fggdb {
				_cecb := XrefObject{ObjectNumber: _efga, XType: XrefTypeObjectStream, OsObjNumber: int(_ffcf), OsObjIndex: int(_cdfgc)}
				_fdce._fabaa.ObjectMap[_efga] = _cecb
				_fdb.Log.Trace("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076", _cecb)
			}
		default:
			_fdb.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-")
			continue
		}
	}
	if _fdce._defc == nil {
		_bccab := XrefTypeObjectStream
		_fdce._defc = &_bccab
	}
	return _fggdd, nil
}

var _cgbb = []byte("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046")

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream(streamObj *PdfObjectStream) (StreamEncoder, error) {
	_ddacb := TraceToDirectObject(streamObj.Get("\u0046\u0069\u006c\u0074\u0065\u0072"))
	if _ddacb == nil {
		return NewRawEncoder(), nil
	}
	if _, _dccd := _ddacb.(*PdfObjectNull); _dccd {
		return NewRawEncoder(), nil
	}
	_becdg, _bdgb := _ddacb.(*PdfObjectName)
	if !_bdgb {
		_bdebg, _cagc := _ddacb.(*PdfObjectArray)
		if !_cagc {
			return nil, _dg.Errorf("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074")
		}
		if _bdebg.Len() == 0 {
			return NewRawEncoder(), nil
		}
		if _bdebg.Len() != 1 {
			_caac, _ffcbg := _fagc(streamObj)
			if _ffcbg != nil {
				_fdb.Log.Error("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076", _ffcbg)
				return nil, _ffcbg
			}
			_fdb.Log.Trace("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a", _caac)
			return _caac, nil
		}
		_ddacb = _bdebg.Get(0)
		_becdg, _cagc = _ddacb.(*PdfObjectName)
		if !_cagc {
			return nil, _dg.Errorf("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074")
		}
	}
	if _agdc, _cbba := _cbgc.Load(_becdg.String()); _cbba {
		return _agdc.(StreamEncoder), nil
	}
	switch *_becdg {
	case StreamEncodingFilterNameFlate:
		return _cdd(streamObj, nil)
	case StreamEncodingFilterNameLZW:
		return _ecb(streamObj, nil)
	case StreamEncodingFilterNameDCT:
		return _cdge(streamObj, nil)
	case StreamEncodingFilterNameRunLength:
		return _agac(streamObj, nil)
	case StreamEncodingFilterNameASCIIHex:
		return NewASCIIHexEncoder(), nil
	case StreamEncodingFilterNameASCII85, "\u0041\u0038\u0035":
		return NewASCII85Encoder(), nil
	case StreamEncodingFilterNameCCITTFax:
		return _beab(streamObj, nil)
	case StreamEncodingFilterNameJBIG2:
		return _dbeg(streamObj, nil)
	case StreamEncodingFilterNameJPX:
		return NewJPXEncoder(), nil
	}
	_fdb.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021")
	return nil, _dg.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029", *_becdg)
}

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_egeb *PdfObjectStream) MakeLazy() error {
	if _egeb.Lazy {
		return nil
	}
	_eegf, _dbgba := _ee.CreateTemp("", "\u0078o\u0062\u006a\u0065\u0063\u0074")
	if _dbgba != nil {
		return _dbgba
	}
	defer _eegf.Close()
	_, _dbgba = _eegf.Write(_egeb.Stream)
	if _dbgba != nil {
		return _dbgba
	}
	_egeb.Lazy = true
	_egeb.Stream = nil
	_egeb.TempFile = _eegf.Name()
	return nil
}

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream(contents []byte, encoder StreamEncoder) (*PdfObjectStream, error) {
	_ffbcc := &PdfObjectStream{}
	if encoder == nil {
		encoder = NewRawEncoder()
	}
	_ffbcc.PdfObjectDictionary = encoder.MakeStreamDict()
	_adfgd, _bdbf := encoder.EncodeBytes(contents)
	if _bdbf != nil {
		return nil, _bdbf
	}
	_ffbcc.Set("\u004c\u0065\u006e\u0067\u0074\u0068", MakeInteger(int64(len(_adfgd))))
	_ffbcc.Stream = _adfgd
	return _ffbcc, nil
}

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_cgag *PdfParser) GetObjectNums() []int {
	var _bgbd []int
	for _, _agfe := range _cgag._fabaa.ObjectMap {
		_bgbd = append(_bgbd, _agfe.ObjectNumber)
	}
	_de.Ints(_bgbd)
	return _bgbd
}

// Write outputs the object as it is to be written to file.
func (_efbg *PdfObjectArray) Write() []byte {
	return _edb(func(_ccga *_e.Buffer) {
		_ccga.WriteString("\u005b")
		for _ddgde, _edgbd := range _efbg.Elements() {
			_ccga.Write(_edgbd.Write())
			if _ddgde < (_efbg.Len() - 1) {
				_ccga.WriteString("\u0020")
			}
		}
		_ccga.WriteString("\u005d")
	})
}

// Write outputs the object as it is to be written to file.
func (_dfgcb *PdfObjectName) Write() []byte {
	return _edb(func(_gfad *_e.Buffer) {
		if len(*_dfgcb) > 127 {
			_fdb.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)", *_dfgcb)
		}
		_gfad.WriteString("\u002f")
		for _aafe := 0; _aafe < len(*_dfgcb); _aafe++ {
			_aggga := (*_dfgcb)[_aafe]
			if !IsPrintable(_aggga) || _aggga == '#' || IsDelimiter(_aggga) {
				_dg.Fprintf(_gfad, "\u0023\u0025\u002e2\u0078", _aggga)
			} else {
				_gfad.WriteByte(_aggga)
			}
		}
	})
}

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace(ch byte) bool {
	if (ch == 0x00) || (ch == 0x09) || (ch == 0x0A) || (ch == 0x0C) || (ch == 0x0D) || (ch == 0x20) {
		return true
	}
	return false
}

func (_gege *PdfParser) parseXref() (*PdfObjectDictionary, error) {
	_gege.skipSpaces()
	const _dfag = 20
	_ggda, _ := _gege._gggee.Peek(_dfag)
	for _gdce := 0; _gdce < 2; _gdce++ {
		if _gege._gecfg == 0 {
			_gege._gecfg = _gege.GetFileOffset()
		}
		if _bgbge.Match(_ggda) {
			_fdb.Log.Trace("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
			_fdb.Log.Debug("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022", string(_ggda))
			return _gege.parseXrefStream(nil)
		}
		if _dbbbf.Match(_ggda) {
			_fdb.Log.Trace("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021")
			return _gege.parseXrefTable()
		}
		_cabd := _gege.GetFileOffset()
		if _gege._gecfg == 0 {
			_gege._gecfg = _cabd
		}
		_gege.SetFileOffset(_cabd - _dfag)
		defer _gege.SetFileOffset(_cabd)
		_egadf, _ := _gege._gggee.Peek(_dfag)
		_ggda = append(_egadf, _ggda...)
	}
	_fdb.Log.Debug("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e")
	if _aebg := _gege.repairSeekXrefMarker(); _aebg != nil {
		_fdb.Log.Debug("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076", _aebg)
		return nil, _aebg
	}
	return _gege.parseXrefTable()
}

// SetImage sets the image base for given flate encoder.
func (_edgd *FlateEncoder) SetImage(img *_dfa.ImageBase) { _edgd._gfg = img }

func (_eefbg *PdfObjectFloat) String() string { return _dg.Sprintf("\u0025\u0066", *_eefbg) }

// IsTextWriteDirectionLTR returns `true` if string write direction Left To Right.
// detect string write direction using golang.org/x/text/unicode/bidi library.
func IsTextWriteDirectionLTR(str string) bool {
	_aeaga := func(_cega rune) bool { return _cega == '\u000A' }
	_egbga := _fa.TrimFunc(str, _aeaga)
	_eaef := _be.Paragraph{}
	_, _gfcgb := _eaef.SetString(_egbga)
	if _gfcgb != nil {
		return true
	}
	_gaga, _gfcgb := _eaef.Order()
	if _gfcgb != nil {
		return true
	}
	if _gaga.NumRuns() < 1 {
		return true
	}
	return _eaef.IsLeftToRight()
}

type objectCache map[int]PdfObject

// String returns the state of the bool as "true" or "false".
func (_fface *PdfObjectBool) String() string {
	if *_fface {
		return "\u0074\u0072\u0075\u0065"
	}
	return "\u0066\u0061\u006cs\u0065"
}

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser(rs _eed.ReadSeeker) (*PdfParser, error) {
	_cgaf := &PdfParser{_gggee: _gcc(rs), ObjCache: make(objectCache), _effa: map[int64]bool{}, _aedf: make([]int64, 0), _bcgf: make(map[*PdfParser]*PdfParser)}
	_aeag := _cgaf.initParser()
	if _aeag != nil {
		return nil, _aeag
	}
	return _cgaf, nil
}

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder() *RunLengthEncoder { return &RunLengthEncoder{} }

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgbb *JBIG2Encoder) MakeStreamDict() *PdfObjectDictionary {
	_adfb := MakeDict()
	_adfb.Set("\u0046\u0069\u006c\u0074\u0065\u0072", MakeName(_fgbb.GetFilterName()))
	return _adfb
}

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder() *RawEncoder { return &RawEncoder{} }

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_feaf *RawEncoder) MakeStreamDict() *PdfObjectDictionary { return MakeDict() }

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool(val bool) *PdfObjectBool { _ceae := PdfObjectBool(val); return &_ceae }

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_gde *JBIG2Encoder) DecodeBytes(encoded []byte) ([]byte, error) {
	return _bb.DecodeBytes(encoded, _ba.Parameters{}, _gde.Globals)
}

func (_fgad *JBIG2Encoder) encodeImage(_agaff _ff.Image) ([]byte, error) {
	const _ebcb = "e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065"
	_aaed, _ddbg := GoImageToJBIG2(_agaff, JB2ImageAutoThreshold)
	if _ddbg != nil {
		return nil, _fag.Wrap(_ddbg, _ebcb, "\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067")
	}
	if _ddbg = _fgad.AddPageImage(_aaed, &_fgad.DefaultPageSettings); _ddbg != nil {
		return nil, _fag.Wrap(_ddbg, _ebcb, "")
	}
	return _fgad.Encode()
}
