//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package model provides an interface for working with high-level objects (models) in PDF files, including
// reading and writing documents.
//
// The document structure of a PDF is constructed of a hierarchy of data models, representing a tree
// of information starting from the Document catalog (Figure 5 p. 80).
// It is based on the core package which handles core functionality such as file i/o, parsing and
// handling of primitive PDF objects (core.PdfObject).
//
// As an example of the interface, the following snippet can read the PDF and output the number of pages:
//
//	f, err := os.Open(inputPath)
//		if err != nil {
//		return nil, err
//	}
//	defer f.Close()
//	pdfReader, err := unipdf.NewPdfReader(f)
//	if err != nil {
//		fmt.Printf("Failed to read PDF file: %v\n", err)
//		os.Exit(1)
//	}
//	numPages, err := pdfReader.GetNumPages()
//	if err != nil {
//		fmt.Printf("Failed to get number of pages: %v\n", err)
//		os.Exit(1)
//	}
//	fmt.Printf("The PDF file has %d pages\n", numPages)
//
// For more examples, see the unidoc-examples repository on GitHub: https://github.com/unidoc/unidoc-examples
package model

import (
	_a "bufio"
	_ea "bytes"
	_ff "crypto/md5"
	_be "crypto/rand"
	_ac "crypto/sha1"
	_cb "crypto/x509"
	_ed "encoding/binary"
	_bf "encoding/hex"
	_gb "errors"
	_f "fmt"
	_gd "github.com/h2non/filetype"
	_fg "github.com/szwede/unipdf/common"
	_bgd "github.com/szwede/unipdf/core"
	_dab "github.com/szwede/unipdf/core/security"
	_gfd "github.com/szwede/unipdf/core/security/crypt"
	_cf "github.com/szwede/unipdf/internal/cmap"
	_daf "github.com/szwede/unipdf/internal/imageutil"
	_gdg "github.com/szwede/unipdf/internal/license"
	_eaa "github.com/szwede/unipdf/internal/sampling"
	_dabf "github.com/szwede/unipdf/internal/textencoding"
	_bfb "github.com/szwede/unipdf/internal/timeutils"
	_ga "github.com/szwede/unipdf/internal/transform"
	_gff "github.com/szwede/unipdf/internal/uuid"
	_ec "github.com/szwede/unipdf/model/internal/docutil"
	_fe "github.com/szwede/unipdf/model/internal/fonts"
	_fa "github.com/szwede/unipdf/model/mdp"
	_bed "github.com/szwede/unipdf/model/sigutil"
	_af "github.com/szwede/unipdf/ps"
	_fga "github.com/unidoc/freetype"
	_eda "github.com/unidoc/freetype/truetype"
	_edf "github.com/unidoc/pkcs7"
	_dag "github.com/unidoc/unitype"
	_efb "golang.org/x/image/font"
	_bg "golang.org/x/xerrors"
	_d "hash"
	_fc "image"
	_e "image/color"
	_eb "image/draw"
	_ "image/gif"
	_gf "image/png"
	_ca "io"
	_da "math"
	_aa "math/rand"
	_gc "os"
	_ee "path/filepath"
	_b "regexp"
	_bb "sort"
	_ae "strconv"
	_ef "strings"
	_g "sync"
	_ge "time"
	_ag "unicode"
	_bc "unicode/utf8"
)

// IsPush returns true if the button field represents a push button, false otherwise.
func (_dbec *PdfFieldButton) IsPush() bool { return _dbec.GetType() == ButtonTypePush }

// ButtonType represents the subtype of a button field, can be one of:
// - Checkbox (ButtonTypeCheckbox)
// - PushButton (ButtonTypePushButton)
// - RadioButton (ButtonTypeRadioButton)
type ButtonType int

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the A, B and C components of the color.
func (_eedd *PdfColorspaceCalRGB) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ffeb, _ggdg := _bgd.GetNumbersAsFloat(objects)
	if _ggdg != nil {
		return nil, _ggdg
	}
	return _eedd.ColorFromFloats(_ffeb)
}

func (_bgbcb *PdfReader) newPdfPageFromDict(_eacbd *_bgd.PdfObjectDictionary) (*PdfPage, error) {
	_ddgde := NewPdfPage()
	_ddgde._cfdgca = _eacbd
	_ddgde._cdfec = *_eacbd
	_fgdeg := *_eacbd
	_ggccg, _adccd := _fgdeg.Get("\u0054\u0079\u0070\u0065").(*_bgd.PdfObjectName)
	if !_adccd {
		return nil, _gb.New("\u006d\u0069ss\u0069\u006e\u0067/\u0069\u006e\u0076\u0061lid\u0020Pa\u0067\u0065\u0020\u0064\u0069\u0063\u0074io\u006e\u0061\u0072\u0079\u0020\u0054\u0079p\u0065")
	}
	if *_ggccg != "\u0050\u0061\u0067\u0065" {
		return nil, _gb.New("\u0070\u0061\u0067\u0065 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079 \u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u0050a\u0067\u0065")
	}
	if _deafe := _fgdeg.Get("\u0050\u0061\u0072\u0065\u006e\u0074"); _deafe != nil {
		_ddgde.Parent = _deafe
	}
	if _gaagf := _fgdeg.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064"); _gaagf != nil {
		_ggefa, _ecdb := _bgd.GetString(_gaagf)
		if !_ecdb {
			return nil, _gb.New("\u0070\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u004c\u0061\u0073\u0074\u004d\u006f\u0064\u0069f\u0069\u0065\u0064\u0020\u0021=\u0020\u0073t\u0072\u0069\u006e\u0067")
		}
		_fdda, _aacbc := NewPdfDate(_ggefa.Str())
		if _aacbc != nil {
			return nil, _aacbc
		}
		_ddgde.LastModified = &_fdda
	}
	if _daadab := _fgdeg.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _daadab != nil && !_bgd.IsNullObject(_daadab) {
		_gegg, _febd := _bgd.GetDict(_daadab)
		if !_febd {
			return nil, _f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _daadab)
		}
		var _gggeg error
		_ddgde.Resources, _gggeg = NewPdfPageResourcesFromDict(_gegg)
		if _gggeg != nil {
			return nil, _gggeg
		}
	} else {
		_eedc, _fbae := _ddgde.getParentResources()
		if _fbae != nil {
			return nil, _fbae
		}
		if _eedc == nil {
			_eedc = NewPdfPageResources()
		}
		_ddgde.Resources = _eedc
	}
	if _efacff := _fgdeg.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _efacff != nil {
		_aecac, _fbgde := _bgd.GetArray(_efacff)
		if !_fbgde {
			return nil, _gb.New("\u0070\u0061\u0067\u0065\u0020\u004d\u0065\u0064\u0069\u0061\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _ecbfca error
		_ddgde.MediaBox, _ecbfca = NewPdfRectangle(*_aecac)
		if _ecbfca != nil {
			return nil, _ecbfca
		}
	}
	if _aebeg := _fgdeg.Get("\u0043r\u006f\u0070\u0042\u006f\u0078"); _aebeg != nil {
		_fbegf, _fbbbe := _bgd.GetArray(_aebeg)
		if !_fbbbe {
			return nil, _gb.New("\u0070a\u0067\u0065\u0020\u0043r\u006f\u0070\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _edcfa error
		_ddgde.CropBox, _edcfa = NewPdfRectangle(*_fbegf)
		if _edcfa != nil {
			return nil, _edcfa
		}
	}
	if _ggdea := _fgdeg.Get("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078"); _ggdea != nil {
		_cfef, _gdbge := _bgd.GetArray(_ggdea)
		if !_gdbge {
			return nil, _gb.New("\u0070\u0061\u0067\u0065\u0020\u0042\u006c\u0065\u0065\u0064\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _afcbg error
		_ddgde.BleedBox, _afcbg = NewPdfRectangle(*_cfef)
		if _afcbg != nil {
			return nil, _afcbg
		}
	}
	if _eagce := _fgdeg.Get("\u0054r\u0069\u006d\u0042\u006f\u0078"); _eagce != nil {
		_egeef, _baeb := _bgd.GetArray(_eagce)
		if !_baeb {
			return nil, _gb.New("\u0070a\u0067\u0065\u0020\u0054r\u0069\u006d\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _gcca error
		_ddgde.TrimBox, _gcca = NewPdfRectangle(*_egeef)
		if _gcca != nil {
			return nil, _gcca
		}
	}
	if _baaed := _fgdeg.Get("\u0041\u0072\u0074\u0042\u006f\u0078"); _baaed != nil {
		_bagefg, _cddae := _bgd.GetArray(_baaed)
		if !_cddae {
			return nil, _gb.New("\u0070a\u0067\u0065\u0020\u0041\u0072\u0074\u0042\u006f\u0078\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		var _eefgf error
		_ddgde.ArtBox, _eefgf = NewPdfRectangle(*_bagefg)
		if _eefgf != nil {
			return nil, _eefgf
		}
	}
	if _fedbd := _fgdeg.Get("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f"); _fedbd != nil {
		_ddgde.BoxColorInfo = _fedbd
	}
	if _edcac := _fgdeg.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _edcac != nil {
		_ddgde.Contents = _edcac
	}
	if _fcgd := _fgdeg.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _fcgd != nil {
		_gggagb, _dggb := _bgd.GetNumberAsInt64(_fcgd)
		if _dggb != nil {
			return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0067e\u0020\u0052\u006f\u0074\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_ddgde.Rotate = &_gggagb
	}
	if _bfbggg := _fgdeg.Get("\u0047\u0072\u006fu\u0070"); _bfbggg != nil {
		_ddgde.Group = _bfbggg
	}
	if _bcfdb := _fgdeg.Get("\u0054\u0068\u0075m\u0062"); _bcfdb != nil {
		_ddgde.Thumb = _bcfdb
	}
	if _cfecb := _fgdeg.Get("\u0042"); _cfecb != nil {
		_ddgde.B = _cfecb
	}
	if _cbgfe := _fgdeg.Get("\u0044\u0075\u0072"); _cbgfe != nil {
		_ddgde.Dur = _cbgfe
	}
	if _bfca := _fgdeg.Get("\u0054\u0072\u0061n\u0073"); _bfca != nil {
		_ddgde.Trans = _bfca
	}
	if _degea := _fgdeg.Get("\u0041\u0041"); _degea != nil {
		_ddgde.AA = _degea
	}
	if _ccafc := _fgdeg.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _ccafc != nil {
		_ddgde.Metadata = _ccafc
	}
	if _aebf := _fgdeg.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o"); _aebf != nil {
		_ddgde.PieceInfo = _aebf
	}
	if _eaegf := _fgdeg.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073"); _eaegf != nil {
		_ddgde.StructParents = _eaegf
	}
	if _fecfe := _fgdeg.Get("\u0049\u0044"); _fecfe != nil {
		_ddgde.ID = _fecfe
	}
	if _bfefd := _fgdeg.Get("\u0050\u005a"); _bfefd != nil {
		_ddgde.PZ = _bfefd
	}
	if _gfdc := _fgdeg.Get("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f"); _gfdc != nil {
		_ddgde.SeparationInfo = _gfdc
	}
	if _dcgec := _fgdeg.Get("\u0054\u0061\u0062\u0073"); _dcgec != nil {
		_ddgde.Tabs = _dcgec
	}
	if _ebgde := _fgdeg.Get("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064"); _ebgde != nil {
		_ddgde.TemplateInstantiated = _ebgde
	}
	if _aceeg := _fgdeg.Get("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s"); _aceeg != nil {
		_ddgde.PresSteps = _aceeg
	}
	if _faegf := _fgdeg.Get("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074"); _faegf != nil {
		_ddgde.UserUnit = _faegf
	}
	if _dgef := _fgdeg.Get("\u0056\u0050"); _dgef != nil {
		_ddgde.VP = _dgef
	}
	if _afeg := _fgdeg.Get("\u0041\u006e\u006e\u006f\u0074\u0073"); _afeg != nil {
		_ddgde.Annots = _afeg
	}
	_ddgde._ccagbb = _bgbcb
	return _ddgde, nil
}

func (_cde *PdfReader) newPdfActionHideFromDict(_aab *_bgd.PdfObjectDictionary) (*PdfActionHide, error) {
	return &PdfActionHide{T: _aab.Get("\u0054"), H: _aab.Get("\u0048")}, nil
}

// SetDisplayDocTitle sets the value of the displayDocTitle flag.
func (_gcdcb *ViewerPreferences) SetDisplayDocTitle(displayDocTitle bool) {
	_gcdcb._fcdcbd = &displayDocTitle
}

// DecodeArray returns the component range values for the DeviceN colorspace.
// [0 1.0 0 1.0 ...] for each color component.
func (_bggbf *PdfColorspaceDeviceN) DecodeArray() []float64 {
	var _bcac []float64
	for _cdba := 0; _cdba < _bggbf.GetNumComponents(); _cdba++ {
		_bcac = append(_bcac, 0.0, 1.0)
	}
	return _bcac
}

// NewOutlineDest returns a new outline destination which can be used
// with outline items.
func NewOutlineDest(page int64, x, y float64) OutlineDest {
	return OutlineDest{Page: page, Mode: "\u0058\u0059\u005a", X: x, Y: y}
}

// NewPdfActionResetForm returns a new "reset form" action.
func NewPdfActionResetForm() *PdfActionResetForm {
	_ddd := NewPdfAction()
	_fca := &PdfActionResetForm{}
	_fca.PdfAction = _ddd
	_ddd.SetContext(_fca)
	return _fca
}

func _bedb(_fagce _bgd.PdfObject) (*PdfColorspaceSpecialIndexed, error) {
	_gfgec := NewPdfColorspaceSpecialIndexed()
	if _aegd, _aaebeg := _fagce.(*_bgd.PdfIndirectObject); _aaebeg {
		_gfgec._ccbaf = _aegd
	}
	_fagce = _bgd.TraceToDirectObject(_fagce)
	_geec, _cdbea := _fagce.(*_bgd.PdfObjectArray)
	if !_cdbea {
		return nil, _f.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _geec.Len() != 4 {
		return nil, _f.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_fagce = _geec.Get(0)
	_ggfg, _cdbea := _fagce.(*_bgd.PdfObjectName)
	if !_cdbea {
		return nil, _f.Errorf("\u0069n\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
	}
	if *_ggfg != "\u0049n\u0064\u0065\u0078\u0065\u0064" {
		return nil, _f.Errorf("\u0069\u006e\u0064\u0065xe\u0064\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u006e\u0061m\u0065")
	}
	_fagce = _geec.Get(1)
	_cbfd, _gefa := DetermineColorspaceNameFromPdfObject(_fagce)
	if _gefa != nil {
		return nil, _gefa
	}
	if _cbfd == "\u0049n\u0064\u0065\u0078\u0065\u0064" || _cbfd == "\u0050a\u0074\u0074\u0065\u0072\u006e" {
		_fg.Log.Debug("E\u0072\u0072o\u0072\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0049\u006e\u0064e\u0078\u0065\u0064\u002f\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043S\u0020\u0061\u0073\u0020\u0062\u0061\u0073\u0065\u0020\u0028\u0025v\u0029", _cbfd)
		return nil, _faef
	}
	_fgece, _gefa := NewPdfColorspaceFromPdfObject(_fagce)
	if _gefa != nil {
		return nil, _gefa
	}
	_gfgec.Base = _fgece
	_fagce = _geec.Get(2)
	_faaad, _gefa := _bgd.GetNumberAsInt64(_fagce)
	if _gefa != nil {
		return nil, _gefa
	}
	if _faaad > 255 {
		return nil, _f.Errorf("\u0069n\u0064\u0065\u0078\u0065d\u0020\u0043\u0053\u003a\u0020I\u006ev\u0061l\u0069\u0064\u0020\u0068\u0069\u0076\u0061l")
	}
	_gfgec.HiVal = int(_faaad)
	_fagce = _geec.Get(3)
	_gfgec.Lookup = _fagce
	_fagce = _bgd.TraceToDirectObject(_fagce)
	var _fafa []byte
	if _degb, _fdd := _fagce.(*_bgd.PdfObjectString); _fdd {
		_fafa = _degb.Bytes()
		_fg.Log.Trace("\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0063\u006f\u006co\u0072\u0020\u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0020\u0064", _fafa)
	} else if _dgba, _bcded := _fagce.(*_bgd.PdfObjectStream); _bcded {
		_fg.Log.Trace("\u0049n\u0064e\u0078\u0065\u0064\u0020\u0073t\u0072\u0065a\u006d\u003a\u0020\u0025\u0073", _fagce.String())
		_fg.Log.Trace("\u0045\u006e\u0063\u006fde\u0064\u0020\u0028\u0025\u0064\u0029\u0020\u003a\u0020\u0025\u0023\u0020\u0078", len(_dgba.Stream), _dgba.Stream)
		_fecfb, _fgcb := _bgd.DecodeStream(_dgba)
		if _fgcb != nil {
			return nil, _fgcb
		}
		_fg.Log.Trace("\u0044e\u0063o\u0064\u0065\u0064\u0020\u0028%\u0064\u0029 \u003a\u0020\u0025\u0020\u0058", len(_fecfb), _fecfb)
		_fafa = _fecfb
	} else {
		_fg.Log.Debug("\u0054\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _fagce)
		return nil, _f.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076a\u006ci\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if len(_fafa) < _gfgec.Base.GetNumComponents()*(_gfgec.HiVal+1) {
		_fg.Log.Debug("\u0050\u0044\u0046\u0020\u0049\u006e\u0063o\u006d\u0070\u0061t\u0069\u0062\u0069\u006ci\u0074\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074\u006f\u006f\u0020\u0073\u0068\u006f\u0072\u0074")
		_fg.Log.Debug("\u0046\u0061i\u006c\u002c\u0020\u006c\u0065\u006e\u0028\u0064\u0061\u0074\u0061\u0029\u003a\u0020\u0025\u0064\u002c\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u002c\u0020\u0068\u0069\u0056\u0061\u006c\u003a\u0020\u0025\u0064", len(_fafa), _gfgec.Base.GetNumComponents(), _gfgec.HiVal)
	} else {
		_fafa = _fafa[:_gfgec.Base.GetNumComponents()*(_gfgec.HiVal+1)]
	}
	_gfgec._bcecd = _fafa
	return _gfgec, nil
}

// NewPdfAnnotation returns an initialized generic PDF annotation model.
func NewPdfAnnotation() *PdfAnnotation {
	_cbd := &PdfAnnotation{}
	_cbd._eag = _bgd.MakeIndirectObject(_bgd.MakeDict())
	return _cbd
}

func _cada(_bcbf _bgd.PdfObject) (*PdfBorderStyle, error) {
	_daeab := &PdfBorderStyle{}
	_daeab._ffc = _bcbf
	var _fbab *_bgd.PdfObjectDictionary
	_bcbf = _bgd.TraceToDirectObject(_bcbf)
	_fbab, _ebdf := _bcbf.(*_bgd.PdfObjectDictionary)
	if !_ebdf {
		return nil, _gb.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	if _ffcb := _fbab.Get("\u0054\u0079\u0070\u0065"); _ffcb != nil {
		_dbdd, _eade := _ffcb.(*_bgd.PdfObjectName)
		if !_eade {
			_fg.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062i\u006c\u0069\u0074\u0079\u0020\u0077\u0069th\u0020\u0054\u0079\u0070e\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061me\u0020\u006fb\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0054", _ffcb)
		} else {
			if *_dbdd != "\u0042\u006f\u0072\u0064\u0065\u0072" {
				_fg.Log.Debug("W\u0061\u0072\u006e\u0069\u006e\u0067,\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020B\u006f\u0072\u0064e\u0072:\u0020\u0025\u0073", *_dbdd)
			}
		}
	}
	if _ggea := _fbab.Get("\u0057"); _ggea != nil {
		_egff, _adbg := _bgd.GetNumberAsFloat(_ggea)
		if _adbg != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006fr \u0072\u0065\u0074\u0072\u0069\u0065\u0076\u0069\u006e\u0067\u0020\u0057\u003a\u0020%\u0076", _adbg)
			return nil, _adbg
		}
		_daeab.W = &_egff
	}
	if _cfbc := _fbab.Get("\u0053"); _cfbc != nil {
		_agcb, _bag := _cfbc.(*_bgd.PdfObjectName)
		if !_bag {
			return nil, _gb.New("\u0062\u006f\u0072\u0064\u0065\u0072\u0020\u0053\u0020\u006e\u006ft\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		var _fbgd BorderStyle
		switch *_agcb {
		case "\u0053":
			_fbgd = BorderStyleSolid
		case "\u0044":
			_fbgd = BorderStyleDashed
		case "\u0042":
			_fbgd = BorderStyleBeveled
		case "\u0049":
			_fbgd = BorderStyleInset
		case "\u0055":
			_fbgd = BorderStyleUnderline
		default:
			_fg.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020s\u0074\u0079\u006c\u0065\u0020n\u0061\u006d\u0065\u0020\u0025\u0073", *_agcb)
			return nil, _gb.New("\u0073\u0074\u0079\u006ce \u0074\u0079\u0070\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065c\u006b")
		}
		_daeab.S = &_fbgd
	}
	if _fbba := _fbab.Get("\u0044"); _fbba != nil {
		_bccg, _ebce := _fbba.(*_bgd.PdfObjectArray)
		if !_ebce {
			_fg.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044\u0020\u0064a\u0073\u0068\u0020\u006e\u006f\u0074\u0020a\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0054", _fbba)
			return nil, _gb.New("\u0062o\u0072\u0064\u0065\u0072 \u0044\u0020\u0074\u0079\u0070e\u0020c\u0068e\u0063\u006b\u0020\u0065\u0072\u0072\u006fr")
		}
		_dgdg, _ddf := _bccg.ToIntegerArray()
		if _ddf != nil {
			_fg.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044 \u0050\u0072\u006fbl\u0065\u006d\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0069\u006e\u0074\u0065\u0067e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u003a \u0025\u0076", _ddf)
			return nil, _ddf
		}
		_daeab.D = &_dgdg
	}
	return _daeab, nil
}

// PdfActionHide represents a hide action.
type PdfActionHide struct {
	*PdfAction
	T _bgd.PdfObject
	H _bgd.PdfObject
}

// SetPatternByName sets a pattern resource specified by keyName.
func (_cdffc *PdfPageResources) SetPatternByName(keyName _bgd.PdfObjectName, pattern _bgd.PdfObject) error {
	if _cdffc.Pattern == nil {
		_cdffc.Pattern = _bgd.MakeDict()
	}
	_ffec, _ceac := _bgd.GetDict(_cdffc.Pattern)
	if !_ceac {
		return _bgd.ErrTypeError
	}
	_ffec.Set(keyName, pattern)
	return nil
}

func (_cccd *pdfFontType0) baseFields() *fontCommon { return &_cccd.fontCommon }

// NewPdfAnnotationRichMedia returns a new rich media annotation.
func NewPdfAnnotationRichMedia() *PdfAnnotationRichMedia {
	_fde := NewPdfAnnotation()
	_eeg := &PdfAnnotationRichMedia{}
	_eeg.PdfAnnotation = _fde
	_fde.SetContext(_eeg)
	return _eeg
}

// PdfAnnotationStamp represents Stamp annotations.
// (Section 12.5.6.12).
type PdfAnnotationStamp struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Name _bgd.PdfObject
}

// GetPageLabels returns the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_becf *PdfReader) GetPageLabels() (_bgd.PdfObject, error) {
	_fgddc := _bgd.ResolveReference(_becf._ffabf.Get("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073"))
	if _fgddc == nil {
		return nil, nil
	}
	if !_becf._ffce {
		_cfdgcc := _becf.traverseObjectData(_fgddc)
		if _cfdgcc != nil {
			return nil, _cfdgcc
		}
	}
	return _fgddc, nil
}

func _afagd(_efcff *PdfField, _gbedf _bgd.PdfObject) error {
	switch _efcff.GetContext().(type) {
	case *PdfFieldText:
		switch _bbbgfc := _gbedf.(type) {
		case *_bgd.PdfObjectName:
			_abccg := _bbbgfc
			_fg.Log.Debug("\u0055\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u003a\u0020\u0047\u006f\u0074 \u0056\u0020\u0061\u0073\u0020\u006e\u0061\u006d\u0065\u0020\u002d\u003e\u0020c\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f s\u0074\u0072\u0069\u006e\u0067\u0020\u0027\u0025\u0073\u0027", _abccg.String())
			_efcff.V = _bgd.MakeEncodedString(_bbbgfc.String(), true)
		case *_bgd.PdfObjectString:
			_efcff.V = _bgd.MakeEncodedString(_bbbgfc.String(), true)
		default:
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0056\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u0028\u0025\u0023\u0076\u0029", _bbbgfc, _bbbgfc)
		}
	case *PdfFieldButton:
		switch _gbedf.(type) {
		case *_bgd.PdfObjectName:
			if len(_gbedf.String()) > 0 {
				_efcff.V = _gbedf
				_aegbe(_efcff, _gbedf)
			}
		case *_bgd.PdfObjectString:
			if len(_gbedf.String()) > 0 {
				_efcff.V = _bgd.MakeName(_gbedf.String())
				_aegbe(_efcff, _efcff.V)
			}
		default:
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _efcff.PartialName(), _gbedf)
			_efcff.V = _gbedf
		}
	case *PdfFieldChoice:
		switch _gbedf.(type) {
		case *_bgd.PdfObjectName:
			if len(_gbedf.String()) > 0 {
				_efcff.V = _bgd.MakeString(_gbedf.String())
				_aegbe(_efcff, _gbedf)
			}
		case *_bgd.PdfObjectString:
			if len(_gbedf.String()) > 0 {
				_efcff.V = _gbedf
				_aegbe(_efcff, _bgd.MakeName(_gbedf.String()))
			}
		default:
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _efcff.PartialName(), _gbedf)
			_efcff.V = _gbedf
		}
	case *PdfFieldSignature:
		_fg.Log.Debug("\u0054\u004f\u0044\u004f\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0061\u0070\u0070e\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0079\u0065\u0074\u003a\u0020\u0025\u0073\u002f\u0025v", _efcff.PartialName(), _gbedf)
	}
	return nil
}

// GetContainingPdfObject returns the container of the outline item (indirect object).
func (_eecbfg *PdfOutlineItem) GetContainingPdfObject() _bgd.PdfObject { return _eecbfg._aacdb }

type fontFile struct {
	_ffeeef string
	_accgf  string
	_edef   _dabf.SimpleEncoder
}

func _aadab(_gaba *_bgd.PdfObjectDictionary) (*PdfTilingPattern, error) {
	_ddbc := &PdfTilingPattern{}
	_dfecg := _gaba.Get("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e")
	if _dfecg == nil {
		_fg.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054\u0079\u0070\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_accgg, _fegcde := _dfecg.(*_bgd.PdfObjectInteger)
	if !_fegcde {
		_fg.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054y\u0070\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _dfecg)
		return nil, _bgd.ErrTypeError
	}
	_ddbc.PaintType = _accgg
	_dfecg = _gaba.Get("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _dfecg == nil {
		_fg.Log.Debug("\u0054i\u006ci\u006e\u0067\u0054\u0079\u0070e\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_faebd, _fegcde := _dfecg.(*_bgd.PdfObjectInteger)
	if !_fegcde {
		_fg.Log.Debug("\u0054\u0069\u006cin\u0067\u0054\u0079\u0070\u0065\u0020\u006e\u006f\u0074 \u0061n\u0020i\u006et\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dfecg)
		return nil, _bgd.ErrTypeError
	}
	_ddbc.TilingType = _faebd
	_dfecg = _gaba.Get("\u0042\u0042\u006f\u0078")
	if _dfecg == nil {
		_fg.Log.Debug("\u0042\u0042\u006fx\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dfecg = _bgd.TraceToDirectObject(_dfecg)
	_gebbg, _fegcde := _dfecg.(*_bgd.PdfObjectArray)
	if !_fegcde {
		_fg.Log.Debug("\u0042B\u006f\u0078 \u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0073p\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061y\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dfecg)
		return nil, _bgd.ErrTypeError
	}
	_bddde, _ddbcb := NewPdfRectangle(*_gebbg)
	if _ddbcb != nil {
		_fg.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _ddbcb)
		return nil, _ddbcb
	}
	_ddbc.BBox = _bddde
	_dfecg = _gaba.Get("\u0058\u0053\u0074e\u0070")
	if _dfecg == nil {
		_fg.Log.Debug("\u0058\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dffe, _ddbcb := _bgd.GetNumberAsFloat(_dfecg)
	if _ddbcb != nil {
		_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0058S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _dffe)
		return nil, _ddbcb
	}
	_ddbc.XStep = _bgd.MakeFloat(_dffe)
	_dfecg = _gaba.Get("\u0059\u0053\u0074e\u0070")
	if _dfecg == nil {
		_fg.Log.Debug("\u0059\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_efff, _ddbcb := _bgd.GetNumberAsFloat(_dfecg)
	if _ddbcb != nil {
		_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0059S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _efff)
		return nil, _ddbcb
	}
	_ddbc.YStep = _bgd.MakeFloat(_efff)
	_dfecg = _gaba.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _dfecg == nil {
		_fg.Log.Debug("\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_gaba, _fegcde = _bgd.TraceToDirectObject(_dfecg).(*_bgd.PdfObjectDictionary)
	if !_fegcde {
		return nil, _f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _dfecg)
	}
	_bfacc, _ddbcb := NewPdfPageResourcesFromDict(_gaba)
	if _ddbcb != nil {
		return nil, _ddbcb
	}
	_ddbc.Resources = _bfacc
	if _dgdbc := _gaba.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _dgdbc != nil {
		_cgbfbb, _fdce := _dgdbc.(*_bgd.PdfObjectArray)
		if !_fdce {
			_fg.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _dgdbc)
			return nil, _bgd.ErrTypeError
		}
		_ddbc.Matrix = _cgbfbb
	}
	return _ddbc, nil
}

// NewPdfColorspaceCalRGB returns a new CalRGB colorspace object.
func NewPdfColorspaceCalRGB() *PdfColorspaceCalRGB {
	_dgaee := &PdfColorspaceCalRGB{}
	_dgaee.BlackPoint = []float64{0.0, 0.0, 0.0}
	_dgaee.Gamma = []float64{1.0, 1.0, 1.0}
	_dgaee.Matrix = []float64{1, 0, 0, 0, 1, 0, 0, 0, 1}
	return _dgaee
}

// ColorToRGB converts a DeviceN color to an RGB color.
func (_cefc *PdfColorspaceDeviceN) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _cefc.AlternateSpace == nil {
		return nil, _gb.New("\u0044\u0065\u0076\u0069\u0063\u0065N\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _cefc.AlternateSpace.ColorToRGB(color)
}

// RepairAcroForm attempts to rebuild the AcroForm fields using the widget
// annotations present in the document pages. Pass nil for the opts parameter
// in order to use the default options.
// NOTE: Currently, the opts parameter is declared in order to enable adding
// future options, but passing nil will always result in the default options
// being used.
func (_fedec *PdfReader) RepairAcroForm(opts *AcroFormRepairOptions) error {
	var _dfcgfb []*PdfField
	_fafga := map[*_bgd.PdfIndirectObject]struct{}{}
	for _, _bfbgf := range _fedec.PageList {
		_dgcad, _bfabg := _bfbgf.GetAnnotations()
		if _bfabg != nil {
			return _bfabg
		}
		for _, _bfafc := range _dgcad {
			var _bfbcb *PdfField
			switch _fgffc := _bfafc.GetContext().(type) {
			case *PdfAnnotationWidget:
				if _fgffc._eded != nil {
					_bfbcb = _fgffc._eded
					break
				}
				if _cafgc, _fcega := _bgd.GetIndirect(_fgffc.Parent); _fcega {
					_bfbcb, _bfabg = _fedec.newPdfFieldFromIndirectObject(_cafgc, nil)
					if _bfabg == nil {
						break
					}
					_fg.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _cafgc, _bfabg)
				}
				if _fgffc._eag != nil {
					_bfbcb, _bfabg = _fedec.newPdfFieldFromIndirectObject(_fgffc._eag, nil)
					if _bfabg == nil {
						break
					}
					_fg.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _fgffc._eag, _bfabg)
				}
			}
			if _bfbcb == nil {
				continue
			}
			if _, _cddgfa := _fafga[_bfbcb._bcgde]; _cddgfa {
				continue
			}
			_fafga[_bfbcb._bcgde] = struct{}{}
			_dfcgfb = append(_dfcgfb, _bfbcb)
		}
	}
	if len(_dfcgfb) == 0 {
		return nil
	}
	if _fedec.AcroForm == nil {
		_fedec.AcroForm = NewPdfAcroForm()
	}
	_fedec.AcroForm.Fields = &_dfcgfb
	return nil
}

// NewPdfColorspaceLab returns a new Lab colorspace object.
func NewPdfColorspaceLab() *PdfColorspaceLab {
	_fggb := &PdfColorspaceLab{}
	_fggb.BlackPoint = []float64{0.0, 0.0, 0.0}
	_fggb.Range = []float64{-100, 100, -100, 100}
	return _fggb
}

// NewPdfColorDeviceGray returns a new grayscale color based on an input grayscale float value in range [0-1].
func NewPdfColorDeviceGray(grayVal float64) *PdfColorDeviceGray {
	_gfag := PdfColorDeviceGray(grayVal)
	return &_gfag
}

// RemoveWatermarkImage removes watermark.
// If you don't know exact name of watermark PDF object, pass empty string as an argument.
func (_dgefb *PdfPage) RemoveWatermarkImage(name string) error {
	if _dgefb.Resources != nil && _dgefb.Resources.XObject != nil {
		if _egbcg, _abdd := _bgd.GetDict(_dgefb.Resources.XObject); _abdd {
			for _, _afdab := range _egbcg.Keys() {
				if name == _afdab.String() {
					_dgefb.removeXObj(_egbcg, _afdab)
					continue
				}
				_dbcgd, _bdgea := _bgd.GetStream(_egbcg.Get(_afdab))
				if !_bdgea {
					continue
				}
				_aecgga, _bdgea := _bgd.GetDict(_dbcgd.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o"))
				if !_bdgea {
					continue
				}
				_afffg, _bdgea := _bgd.GetDict(_aecgga.Get("\u0041\u0044\u0042\u0045\u005f\u0043\u006f\u006d\u0070\u006f\u0075\u006ed\u0054\u0079\u0070\u0065"))
				if !_bdgea {
					continue
				}
				if _afffg.Get("\u0050r\u0069\u0076\u0061\u0074\u0065") != nil && _afffg.Get("\u0050r\u0069\u0076\u0061\u0074\u0065").String() == "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k" {
					_dgefb.removeXObj(_egbcg, _afdab)
				}
			}
		}
	}
	_gfee, _dgcfd := _dgefb.GetAnnotations()
	if _dgcfd == nil {
		_dgff := make([]*PdfAnnotation, 0)
		for _, _ebaba := range _gfee {
			switch _ebaba.GetContext().(type) {
			case *PdfAnnotationWatermark:
			default:
				_dgff = append(_dgff, _ebaba)
			}
		}
		_dgefb.SetAnnotations(_dgff)
	}
	return nil
}

// NewOutline returns a new outline instance.
func NewOutline() *Outline { return &Outline{} }

// NewPdfFilespec returns an initialized generic PDF filespec model.
func NewPdfFilespec() *PdfFilespec {
	_gccc := &PdfFilespec{}
	_gccc._bbbfb = _bgd.MakeIndirectObject(_bgd.MakeDict())
	return _gccc
}

func (_febe *PdfWriter) writeString(_gfdfd string) {
	if _febe._fgegc != nil {
		return
	}
	_gaccf, _cbcda := _febe._ggaff.WriteString(_gfdfd)
	_febe._bcfba += int64(_gaccf)
	_febe._fgegc = _cbcda
}

// NewPdfAnnotationStrikeOut returns a new text strikeout annotation.
func NewPdfAnnotationStrikeOut() *PdfAnnotationStrikeOut {
	_gge := NewPdfAnnotation()
	_cgag := &PdfAnnotationStrikeOut{}
	_cgag.PdfAnnotation = _gge
	_cgag.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gge.SetContext(_cgag)
	return _cgag
}

// Read reads an image and loads into a new Image object with an RGB
// colormap and 8 bits per component.
func (_ddfgb DefaultImageHandler) Read(reader _ca.Reader) (*Image, error) {
	_cadf, _, _fcceb := _fc.Decode(reader)
	if _fcceb != nil {
		_fg.Log.Debug("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _fcceb)
		return nil, _fcceb
	}
	return _ddfgb.NewImageFromGoImage(_cadf)
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_agcbg *PdfColorspaceSpecialPattern) ToPdfObject() _bgd.PdfObject {
	if _agcbg.UnderlyingCS == nil {
		return _bgd.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e")
	}
	_bdaa := _bgd.MakeArray(_bgd.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_bdaa.Append(_agcbg.UnderlyingCS.ToPdfObject())
	if _agcbg._fgfg != nil {
		_agcbg._fgfg.PdfObject = _bdaa
		return _agcbg._fgfg
	}
	return _bdaa
}

// SetDSS sets the DSS dictionary (ETSI TS 102 778-4 V1.1.1) of the current
// document revision.
func (_fcdc *PdfAppender) SetDSS(dss *DSS) {
	if dss != nil {
		_fcdc.updateObjectsDeep(dss.ToPdfObject(), nil)
	}
	_fcdc._bcdeg = dss
}

// NewPdfOutlineItem returns an initialized PdfOutlineItem.
func NewPdfOutlineItem() *PdfOutlineItem {
	_bgagg := &PdfOutlineItem{_aacdb: _bgd.MakeIndirectObject(_bgd.MakeDict())}
	_bgagg._bfff = _bgagg
	return _bgagg
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_cdbfe *PdfShadingType2) ToPdfObject() _bgd.PdfObject {
	_cdbfe.PdfShading.ToPdfObject()
	_addfd, _degga := _cdbfe.getShadingDict()
	if _degga != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _addfd == nil {
		_fg.Log.Error("\u0053\u0068\u0061\u0064in\u0067\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		return nil
	}
	if _cdbfe.Coords != nil {
		_addfd.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _cdbfe.Coords)
	}
	if _cdbfe.Domain != nil {
		_addfd.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _cdbfe.Domain)
	}
	if _cdbfe.Function != nil {
		if len(_cdbfe.Function) == 1 {
			_addfd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _cdbfe.Function[0].ToPdfObject())
		} else {
			_badde := _bgd.MakeArray()
			for _, _eedfd := range _cdbfe.Function {
				_badde.Append(_eedfd.ToPdfObject())
			}
			_addfd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _badde)
		}
	}
	if _cdbfe.Extend != nil {
		_addfd.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _cdbfe.Extend)
	}
	return _cdbfe._gccfe
}

// GenerateXObjectName generates an unused XObject name that can be used for
// adding new XObjects. Uses format XObj1, XObj2, ...
func (_ccfd *PdfPageResources) GenerateXObjectName() _bgd.PdfObjectName {
	_dcdgb := 1
	for {
		_dddg := _bgd.MakeName(_f.Sprintf("\u0058\u004f\u0062\u006a\u0025\u0064", _dcdgb))
		if !_ccfd.HasXObjectByName(*_dddg) {
			return *_dddg
		}
		_dcdgb++
	}
}

// ToPdfObject converts the structure tree root to a PDF object.
func (_cggeeg *StructTreeRoot) ToPdfObject() _bgd.PdfObject {
	_eabaa := _cggeeg._gagf
	if _eabaa == nil {
		_eabaa = &_bgd.PdfIndirectObject{}
		_eabaa.PdfObject = _bgd.MakeDict()
	}
	_eddb := _eabaa.PdfObject.(*_bgd.PdfObjectDictionary)
	var _cabda _bgd.PdfObject
	if len(_cggeeg.K) == 1 {
		_cabda = _bgd.MakeIndirectObject(_cggeeg.K[0].ToPdfObject())
	} else {
		_cgege := _bgd.MakeArray()
		for _, K := range _cggeeg.K {
			_cgege.Append(_bgd.MakeIndirectObject(K.ToPdfObject()))
		}
		_cabda = _cgege
	}
	var (
		_gbfdc = []_bgd.PdfObject{}
		_aeddc = map[_bgd.PdfObject][]_bgd.PdfObject{}
		_afaaa = map[string]_bgd.PdfObject{}
	)
	_bcdcf(_cabda, _eabaa, _aeddc, _afaaa, &_gbfdc)
	_eddb.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074"))
	_eddb.Set("\u004b", _cabda)
	if _cggeeg.IDTree != nil {
		_eddb.Set("\u0049\u0044\u0054\u0072\u0065\u0065", _bgd.MakeIndirectObject(_cggeeg.IDTree.ToPdfObject()))
	} else if len(_afaaa) > 0 {
		_eagfc := _bgd.MakeArray()
		_fbefe := make([]string, 0, len(_afaaa))
		for _ffff := range _afaaa {
			_fbefe = append(_fbefe, _ffff)
		}
		_bb.Strings(_fbefe)
		for _, _gfefe := range _fbefe {
			_eagfc.Append(_bgd.MakeString(_gfefe))
			_eagfc.Append(_afaaa[_gfefe])
		}
		_cggeeg.IDTree = &IDTree{Names: _eagfc, Limits: _bgd.MakeArray(_bgd.MakeString(_fbefe[0]), _bgd.MakeString(_fbefe[len(_fbefe)-1]))}
		_eddb.Set("\u0049\u0044\u0054\u0072\u0065\u0065", _bgd.MakeIndirectObject(_cggeeg.IDTree.ToPdfObject()))
	}
	if _cggeeg.ParentTree != nil {
		_eddb.Set("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065", _bgd.MakeIndirectObject(_cggeeg.ParentTree))
	} else if len(_aeddc) > 0 || len(_gbfdc) > 0 {
		_fabe := _bgd.MakeArray()
		_cadbg := 0
		for _abeag, _afddd := range _aeddc {
			_ddbbg := _bgd.MakeArray()
			for _, _beadg := range _afddd {
				_ddbbg.Append(_beadg)
			}
			_ffcfb := _bgd.MakeInteger(int64(_cadbg))
			_fabe.Append(_ffcfb)
			_fabe.Append(_bgd.MakeIndirectObject(_ddbbg))
			if _gbgag, _aebdg := _bgd.GetIndirect(_abeag); _aebdg {
				if _egcbd, _fbega := _bgd.GetDict(_gbgag.PdfObject); _fbega {
					_abddc := _egcbd.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073")
					if _abddc != nil {
						if _dffccg, _ecbec := _bgd.GetIntVal(_abddc); _ecbec {
							if _cadbg < _dffccg {
								_egcbd.Set("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _ffcfb)
							}
						}
					} else {
						_egcbd.Set("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _ffcfb)
					}
				}
			}
			_cadbg++
		}
		_bfdbg := func(_cbeaf _bgd.PdfObject, _cgce *_bgd.PdfObjectDictionary) bool {
			_cfead := _cgce
			if _eefca := _cgce.Get("\u0054\u0079\u0070\u0065"); _eefca.String() == "\u004f\u0042\u004a\u0052" {
				if _bgadgf := _cgce.Get("\u004f\u0062\u006a"); _bgadgf != nil {
					if _bfccd, _gefda := _bgd.GetDict(_bgadgf); _gefda {
						_cfead = _bfccd
					}
				}
			}
			_ddbag := _cfead.Get("\u0054\u0079\u0070\u0065")
			if _ddbag != nil && _ddbag.String() == "\u0041\u006e\u006eo\u0074" {
				_dcbae := _bgd.MakeInteger(int64(_cadbg))
				_cfead.Set("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _dcbae)
				_fabe.Append(_dcbae)
				_fabe.Append(_cbeaf)
				_cadbg++
				return true
			}
			return false
		}
		for _, _fcdcb := range _gbfdc {
			if _fefde, _ggfe := _bgd.GetDict(_fcdcb); _ggfe {
				if _bdba := _fefde.Get("\u0053"); _bdba != nil {
					if _dcgaf, _ecccd := _bgd.GetNameVal(_bdba); _ecccd && (_dcgaf == string(StructureTypeLink) || _dcgaf == string(StructureTypeAnnot)) {
						if _cbgbb := _fefde.Get("\u004b"); _cbgbb != nil {
							if _ggdee, _bcbad := _bgd.GetArray(_cbgbb); _bcbad {
								for _, _gacgf := range _ggdee.Elements() {
									if _ddfbd, _daaad := _bgd.GetDict(_gacgf); _daaad {
										_bfdbg(_fcdcb, _ddfbd)
									}
								}
							} else if _dffcfe, _bcfgg := _bgd.GetDict(_cbgbb); _bcfgg {
								_bfdbg(_fcdcb, _dffcfe)
							}
						}
					}
				}
			}
		}
		_cggeeg.ParentTree = _bgd.MakeDict()
		_cggeeg.ParentTree.Set("\u004e\u0075\u006d\u0073", _fabe)
		_cggeeg.ParentTreeNextKey = int64(_cadbg)
		_eddb.Set("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065", _bgd.MakeIndirectObject(_cggeeg.ParentTree))
	}
	_eddb.Set("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065\u004e\u0065x\u0074\u004b\u0065\u0079", _bgd.MakeInteger(_cggeeg.ParentTreeNextKey))
	if _cggeeg.RoleMap != nil {
		_eddb.Set("\u0052o\u006c\u0065\u004d\u0061\u0070", _cggeeg.RoleMap)
	}
	if _cggeeg.ClassMap != nil {
		_eddb.Set("\u0043\u006c\u0061\u0073\u0073\u004d\u0061\u0070", _cggeeg.ClassMap)
	}
	return _eabaa
}

func (_eceg *PdfFilespec) getDict() *_bgd.PdfObjectDictionary {
	if _afeae, _geafa := _eceg._bbbfb.(*_bgd.PdfIndirectObject); _geafa {
		_bfbgc, _bfegb := _afeae.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_bfegb {
			return nil
		}
		return _bfbgc
	} else if _dged, _edbd := _eceg._bbbfb.(*_bgd.PdfObjectDictionary); _edbd {
		return _dged
	} else {
		_fg.Log.Debug("\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u006f\u0062\u006a\u0065\u0063\u0074 \u0074\u0079p\u0065\u0020(\u0025T\u0029", _eceg._bbbfb)
		return nil
	}
}

// PdfAnnotationRedact represents Redact annotations.
// (Section 12.5.6.23).
type PdfAnnotationRedact struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints  _bgd.PdfObject
	IC          _bgd.PdfObject
	RO          _bgd.PdfObject
	OverlayText _bgd.PdfObject
	Repeat      _bgd.PdfObject
	DA          _bgd.PdfObject
	Q           _bgd.PdfObject
}

// BorderEffect represents a border effect (Table 167 p. 395).
type BorderEffect int

// GetXObjectImageByName returns the XObjectImage with the specified name from the
// page resources, if it exists.
func (_bgff *PdfPageResources) GetXObjectImageByName(keyName _bgd.PdfObjectName) (*XObjectImage, error) {
	_accbb, _aabd := _bgff.GetXObjectByName(keyName)
	if _accbb == nil {
		return nil, nil
	}
	if _aabd != XObjectTypeImage {
		return nil, _gb.New("\u006e\u006f\u0074 \u0061\u006e\u0020\u0069\u006d\u0061\u0067\u0065")
	}
	_fgbc, _cagfa := NewXObjectImageFromStream(_accbb)
	if _cagfa != nil {
		return nil, _cagfa
	}
	return _fgbc, nil
}

// PdfReader represents a PDF file reader. It is a frontend to the lower level parsing mechanism and provides
// a higher level access to work with PDF structure and information, such as the page structure etc.
type PdfReader struct {
	_ccade   *_bgd.PdfParser
	_fdcbfb  _bgd.PdfObject
	_bbfde   *_bgd.PdfIndirectObject
	_gdea    *_bgd.PdfObjectDictionary
	_gfggf   []*_bgd.PdfIndirectObject
	PageList []*PdfPage
	_dbgd    int
	_ffabf   *_bgd.PdfObjectDictionary
	_gfbcg   *PdfOutlineTreeNode
	AcroForm *PdfAcroForm
	DSS      *DSS
	Rotate   *int64
	_cfdf    *Permissions
	_dcbb    map[*PdfReader]*PdfReader
	_acgcb   []*PdfReader
	_gggb    *modelManager
	_ffce    bool
	_dadbf   map[_bgd.PdfObject]struct{}
	_cfebb   _ca.ReadSeeker
	_cdff    string
	_bfgg    bool
	_babg    string
	_daae    *ReaderOpts
	_dfceg   bool
}

// Val returns the value of the color.
func (_ffgc *PdfColorCalGray) Val() float64 { return float64(*_ffgc) }

// ToPdfObject implements interface PdfModel.
func (_bd *PdfActionSetOCGState) ToPdfObject() _bgd.PdfObject {
	_bd.PdfAction.ToPdfObject()
	_beda := _bd._fab
	_gea := _beda.PdfObject.(*_bgd.PdfObjectDictionary)
	_gea.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeSetOCGState)))
	_gea.SetIfNotNil("\u0053\u0074\u0061t\u0065", _bd.State)
	_gea.SetIfNotNil("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042", _bd.PreserveRB)
	return _beda
}

// ToPdfObject returns the PDF representation of the shading pattern.
func (_fdbgab *PdfShadingPatternType2) ToPdfObject() _bgd.PdfObject {
	_fdbgab.PdfPattern.ToPdfObject()
	_eaafc := _fdbgab.getDict()
	if _fdbgab.Shading != nil {
		_eaafc.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _fdbgab.Shading.ToPdfObject())
	}
	if _fdbgab.Matrix != nil {
		_eaafc.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _fdbgab.Matrix)
	}
	if _fdbgab.ExtGState != nil {
		_eaafc.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _fdbgab.ExtGState)
	}
	return _fdbgab._eaddb
}

// ToPdfObject converts the font to a PDF representation.
func (_ddgce *pdfFontType3) ToPdfObject() _bgd.PdfObject {
	if _ddgce._bafb == nil {
		_ddgce._bafb = &_bgd.PdfIndirectObject{}
	}
	_bcggf := _ddgce.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0033")
	_ddgce._bafb.PdfObject = _bcggf
	if _ddgce.FirstChar != nil {
		_bcggf.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _ddgce.FirstChar)
	}
	if _ddgce.LastChar != nil {
		_bcggf.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _ddgce.LastChar)
	}
	if _ddgce.Widths != nil {
		_bcggf.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _ddgce.Widths)
	}
	if _ddgce.Encoding != nil {
		_bcggf.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _ddgce.Encoding)
	} else if _ddgce._fafcge != nil {
		_cabb := _ddgce._fafcge.ToPdfObject()
		if _cabb != nil {
			_bcggf.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _cabb)
		}
	}
	if _ddgce.FontBBox != nil {
		_bcggf.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _ddgce.FontBBox)
	}
	if _ddgce.FontMatrix != nil {
		_bcggf.Set("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0069\u0072\u0078", _ddgce.FontMatrix)
	}
	if _ddgce.CharProcs != nil {
		_bcggf.Set("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s", _ddgce.CharProcs)
	}
	if _ddgce.Resources != nil {
		_bcggf.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _ddgce.Resources)
	}
	return _ddgce._bafb
}

func (_fadc *PdfReader) newPdfAnnotationTrapNetFromDict(_bdb *_bgd.PdfObjectDictionary) (*PdfAnnotationTrapNet, error) {
	_cda := PdfAnnotationTrapNet{}
	return &_cda, nil
}

func (_fbb *PdfReader) newPdfActionRenditionFromDict(_dcfg *_bgd.PdfObjectDictionary) (*PdfActionRendition, error) {
	return &PdfActionRendition{R: _dcfg.Get("\u0052"), AN: _dcfg.Get("\u0041\u004e"), OP: _dcfg.Get("\u004f\u0050"), JS: _dcfg.Get("\u004a\u0053")}, nil
}

// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
func (_adgg *PdfColorspaceDeviceN) ImageToRGB(img Image) (Image, error) {
	_bbaa := _eaa.NewReader(img.getBase())
	_eff := _daf.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, nil, img._bdgdb, img._agcea)
	_dbde := _eaa.NewWriter(_eff)
	_befdd := _da.Pow(2, float64(img.BitsPerComponent)) - 1
	_fcca := _adgg.GetNumComponents()
	_gcfb := make([]uint32, _fcca)
	_fbeg := make([]float64, _fcca)
	for {
		_ddec := _bbaa.ReadSamples(_gcfb)
		if _ddec == _ca.EOF {
			break
		} else if _ddec != nil {
			return img, _ddec
		}
		for _gdedg := 0; _gdedg < _fcca; _gdedg++ {
			_cdeb := float64(_gcfb[_gdedg]) / _befdd
			_fbeg[_gdedg] = _cdeb
		}
		_cefe, _ddec := _adgg.TintTransform.Evaluate(_fbeg)
		if _ddec != nil {
			return img, _ddec
		}
		for _, _facb := range _cefe {
			_facb = _da.Min(_da.Max(0, _facb), 1.0)
			if _ddec = _dbde.WriteSample(uint32(_facb * _befdd)); _ddec != nil {
				return img, _ddec
			}
		}
	}
	return _adgg.AlternateSpace.ImageToRGB(_acfa(&_eff))
}

// GetNumComponents returns the number of color components (1 for grayscale).
func (_gbaf *PdfColorDeviceGray) GetNumComponents() int { return 1 }

// GetColorspaceByName returns the colorspace with the specified name from the page resources.
func (_beffd *PdfPageResources) GetColorspaceByName(keyName _bgd.PdfObjectName) (PdfColorspace, bool) {
	_afaaf, _eeedg := _beffd.GetColorspaces()
	if _eeedg != nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _eeedg)
		return nil, false
	}
	if _afaaf == nil {
		return nil, false
	}
	_accd, _babd := _afaaf.Colorspaces[string(keyName)]
	if !_babd {
		return nil, false
	}
	return _accd, true
}

// Set sets the colorspace corresponding to key. Add to Names if not set.
func (_cgegg *PdfPageResourcesColorspaces) Set(key _bgd.PdfObjectName, val PdfColorspace) {
	if _, _ebffc := _cgegg.Colorspaces[string(key)]; !_ebffc {
		_cgegg.Names = append(_cgegg.Names, string(key))
	}
	_cgegg.Colorspaces[string(key)] = val
}

// IsValid checks if the given pdf output intent type is valid.
func (_bagg PdfOutputIntentType) IsValid() bool {
	return _bagg >= PdfOutputIntentTypeA1 && _bagg <= PdfOutputIntentTypeX
}

func (_cfe *PdfReader) newPdfAnnotationHighlightFromDict(_acdb *_bgd.PdfObjectDictionary) (*PdfAnnotationHighlight, error) {
	_dfag := PdfAnnotationHighlight{}
	_deg, _afcd := _cfe.newPdfAnnotationMarkupFromDict(_acdb)
	if _afcd != nil {
		return nil, _afcd
	}
	_dfag.PdfAnnotationMarkup = _deg
	_dfag.QuadPoints = _acdb.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_dfag, nil
}

// PdfColorspaceDeviceRGB represents an RGB colorspace.
type PdfColorspaceDeviceRGB struct{}

// PdfShadingPatternType2 is shading patterns that will use a Type 2 shading pattern (Axial).
type PdfShadingPatternType2 struct {
	*PdfPattern
	Shading   *PdfShadingType2
	Matrix    *_bgd.PdfObjectArray
	ExtGState _bgd.PdfObject
}

// GetNumComponents returns the number of color components of the underlying
// colorspace device.
func (_aedca *PdfColorspaceSpecialPattern) GetNumComponents() int {
	return _aedca.UnderlyingCS.GetNumComponents()
}

// GetDSS gets the DSS dictionary (ETSI TS 102 778-4 V1.1.1) of the current
// document revision.
func (_gage *PdfAppender) GetDSS() (_ddb *DSS) { return _gage._bcdeg }

// ToPdfObject implements interface PdfModel.
func (_bbad *PdfAnnotationRichMedia) ToPdfObject() _bgd.PdfObject {
	_bbad.PdfAnnotation.ToPdfObject()
	_bffa := _bbad._eag
	_gaga := _bffa.PdfObject.(*_bgd.PdfObjectDictionary)
	_gaga.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a"))
	_gaga.SetIfNotNil("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073", _bbad.RichMediaSettings)
	_gaga.SetIfNotNil("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074", _bbad.RichMediaContent)
	return _bffa
}

type pdfFontSimple struct {
	fontCommon
	_gaff   *_bgd.PdfIndirectObject
	_ffagd  map[_dabf.CharCode]float64
	_dcfdfd _dabf.TextEncoder
	_dfagc  _dabf.TextEncoder
	_aegbd  *PdfFontDescriptor

	// Encoding is subject to limitations that are described in 9.6.6, "Character Encoding".
	// BaseFont is derived differently.
	FirstChar _bgd.PdfObject
	LastChar  _bgd.PdfObject
	Widths    _bgd.PdfObject
	Encoding  _bgd.PdfObject
	_dcbff    *_fe.RuneCharSafeMap
}

var (
	StructureTypeParagraph       StructureType = "\u0050"
	StructureTypeHeader          StructureType = "\u0048"
	StructureTypeHeading1        StructureType = "\u0048\u0031"
	StructureTypeHeading2        StructureType = "\u0048\u0032"
	StructureTypeHeading3        StructureType = "\u0048\u0033"
	StructureTypeHeading4        StructureType = "\u0048\u0034"
	StructureTypeHeading5        StructureType = "\u0048\u0035"
	StructureTypeHeading6        StructureType = "\u0048\u0036"
	StructureTypeList            StructureType = "\u004c"
	StructureTypeListItem        StructureType = "\u004c\u0049"
	StructureTypeLabel           StructureType = "\u004c\u0062\u006c"
	StructureTypeListBody        StructureType = "\u004c\u0042\u006fd\u0079"
	StructureTypeTable           StructureType = "\u0054\u0061\u0062l\u0065"
	StructureTypeTableRow        StructureType = "\u0054\u0052"
	StructureTypeTableHeaderCell StructureType = "\u0054\u0048"
	StructureTypeTableData       StructureType = "\u0054\u0044"
	StructureTypeTableHead       StructureType = "\u0054\u0048\u0065a\u0064"
	StructureTypeTableBody       StructureType = "\u0054\u0042\u006fd\u0079"
	StructureTypeTableFooter     StructureType = "\u0054\u0046\u006fo\u0074"
)

func (_fcdae *PdfPattern) getDict() *_bgd.PdfObjectDictionary {
	if _cffc, _agdg := _fcdae._eaddb.(*_bgd.PdfIndirectObject); _agdg {
		_bcbd, _cffa := _cffc.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_cffa {
			return nil
		}
		return _bcbd
	} else if _gebbf, _dabcb := _fcdae._eaddb.(*_bgd.PdfObjectStream); _dabcb {
		return _gebbf.PdfObjectDictionary
	} else {
		_fg.Log.Debug("\u0054r\u0079\u0069\u006e\u0067\u0020\u0074\u006f a\u0063\u0063\u0065\u0073\u0073\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020d\u0069\u0063t\u0069\u006f\u006ea\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063t \u0074\u0079\u0070e\u0020\u0028\u0025\u0054\u0029", _fcdae._eaddb)
		return nil
	}
}

// SetContext sets the sub action (context).
func (_ba *PdfAction) SetContext(ctx PdfModel) { _ba._df = ctx }

// NewPdfAnnotationSound returns a new sound annotation.
func NewPdfAnnotationSound() *PdfAnnotationSound {
	_fede := NewPdfAnnotation()
	_agcg := &PdfAnnotationSound{}
	_agcg.PdfAnnotation = _fede
	_agcg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fede.SetContext(_agcg)
	return _agcg
}

// GetBorderWidth returns the border style's width.
func (_egcb *PdfBorderStyle) GetBorderWidth() float64 {
	if _egcb.W == nil {
		return 1
	}
	return *_egcb.W
}

// PdfColorDeviceCMYK is a CMYK32 color, where each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceCMYK [4]float64

// IsHideMenubar returns the value of the hideMenubar flag.
func (_afaeg *ViewerPreferences) IsHideMenubar() bool {
	if _afaeg._gfca == nil {
		return false
	}
	return *_afaeg._gfca
}

// AddAnnotation appends `annot` to the list of page annotations.
func (_dafc *PdfPage) AddAnnotation(annot *PdfAnnotation) {
	if _dafc._dffab == nil {
		_dafc.GetAnnotations()
	}
	_dafc._dffab = append(_dafc._dffab, annot)
}

// SetContext sets the specific fielddata type, e.g. would be PdfFieldButton for a button field.
func (_cfgc *PdfField) SetContext(ctx PdfModel) { _cfgc._babbg = ctx }

// ConvertToBinary converts current image into binary (bi-level) format.
// Binary images are composed of single bits per pixel (only black or white).
// If provided image has more color components, then it would be converted into binary image using
// histogram auto threshold function.
func (_eccfge *Image) ConvertToBinary() error {
	if _eccfge.ColorComponents == 1 && _eccfge.BitsPerComponent == 1 {
		return nil
	}
	_bagaa, _eeffc := _eccfge.ToGoImage()
	if _eeffc != nil {
		return _eeffc
	}
	_bafbe, _eeffc := _daf.MonochromeConverter.Convert(_bagaa)
	if _eeffc != nil {
		return _eeffc
	}
	_eccfge.Data = _bafbe.Base().Data
	_eccfge._bdgdb, _eeffc = _daf.ScaleAlphaToMonochrome(_eccfge._bdgdb, int(_eccfge.Width), int(_eccfge.Height))
	if _eeffc != nil {
		return _eeffc
	}
	_eccfge.BitsPerComponent = 1
	_eccfge.ColorComponents = 1
	_eccfge._agcea = nil
	return nil
}

// OutlineItem represents a PDF outline item dictionary (Table 153 - pp. 376 - 377).
type OutlineItem struct {
	Title   string         `json:"title"`
	Dest    OutlineDest    `json:"dest"`
	Entries []*OutlineItem `json:"entries,omitempty"`
}

func _gcbc(_gfced _bgd.PdfObject) []*_bgd.PdfObjectStream {
	if _gfced == nil {
		return nil
	}
	_bfbfb, _bfda := _bgd.GetArray(_gfced)
	if !_bfda || _bfbfb.Len() == 0 {
		return nil
	}
	_cfdcac := make([]*_bgd.PdfObjectStream, 0, _bfbfb.Len())
	for _, _bgafa := range _bfbfb.Elements() {
		if _dafb, _affde := _bgd.GetStream(_bgafa); _affde {
			_cfdcac = append(_cfdcac, _dafb)
		}
	}
	return _cfdcac
}

// ToPdfObject converts the pdfCIDFontType2 to a PDF representation.
func (_effb *pdfCIDFontType2) ToPdfObject() _bgd.PdfObject {
	if _effb._bcabg == nil {
		_effb._bcabg = &_bgd.PdfIndirectObject{}
	}
	_cgdd := _effb.baseFields().asPdfObjectDictionary("\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032")
	_effb._bcabg.PdfObject = _cgdd
	if _effb.CIDSystemInfo != nil {
		_cgdd.Set("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f", _effb.CIDSystemInfo)
	}
	if _effb.DW != nil {
		_cgdd.Set("\u0044\u0057", _effb.DW)
	}
	if _effb.DW2 != nil {
		_cgdd.Set("\u0044\u0057\u0032", _effb.DW2)
	}
	if _effb.W != nil {
		_cgdd.Set("\u0057", _effb.W)
	}
	if _effb.W2 != nil {
		_cgdd.Set("\u0057\u0032", _effb.W2)
	}
	if _effb.CIDToGIDMap != nil {
		_cgdd.Set("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070", _effb.CIDToGIDMap)
	}
	return _effb._bcabg
}

// SetFontByName sets the font specified by keyName to the given object.
func (_ccdfg *PdfPageResources) SetFontByName(keyName _bgd.PdfObjectName, obj _bgd.PdfObject) error {
	if _ccdfg.Font == nil {
		_ccdfg.Font = _bgd.MakeDict()
	}
	_fgeeb, _ccccb := _bgd.TraceToDirectObject(_ccdfg.Font).(*_bgd.PdfObjectDictionary)
	if !_ccccb {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _bgd.TraceToDirectObject(_ccdfg.Font))
		return _bgd.ErrTypeError
	}
	_fgeeb.Set(keyName, obj)
	return nil
}

// Encoder returns the font's text encoder.
func (_fafgf pdfFontType3) Encoder() _dabf.TextEncoder { return _fafgf._fafcge }

// NewPdfField returns an initialized PdfField.
func NewPdfField() *PdfField { return &PdfField{_bcgde: _bgd.MakeIndirectObject(_bgd.MakeDict())} }

// SetAlpha sets the alpha layer for the image.
func (_efccg *Image) SetAlpha(alpha []byte) { _efccg._bdgdb = alpha }

// NumCopies returns the value of the numCopies.
func (_bfgbd *ViewerPreferences) NumCopies() int { return _bfgbd._bcdg }

// GetContainingPdfObject returns the container of the DSS (indirect object).
func (_bdbf *DSS) GetContainingPdfObject() _bgd.PdfObject { return _bdbf._bdbe }

// DefaultImageHandler is the default implementation of the ImageHandler using the standard go library.
type DefaultImageHandler struct{}

// ToPdfObject implements interface PdfModel.
func (_dcfd *PdfActionGoToR) ToPdfObject() _bgd.PdfObject {
	_dcfd.PdfAction.ToPdfObject()
	_bade := _dcfd._fab
	_cfb := _bade.PdfObject.(*_bgd.PdfObjectDictionary)
	_cfb.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeGoToR)))
	if _dcfd.F != nil {
		_cfb.Set("\u0046", _dcfd.F.ToPdfObject())
	}
	_cfb.SetIfNotNil("\u0044", _dcfd.D)
	_cfb.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _dcfd.NewWindow)
	return _bade
}

// ToPdfObject implements interface PdfModel.
func (_dafa *PdfActionTrans) ToPdfObject() _bgd.PdfObject {
	_dafa.PdfAction.ToPdfObject()
	_cd := _dafa._fab
	_cgb := _cd.PdfObject.(*_bgd.PdfObjectDictionary)
	_cgb.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeTrans)))
	_cgb.SetIfNotNil("\u0054\u0072\u0061n\u0073", _dafa.Trans)
	return _cd
}

// GetRuneMetrics returns the character metrics for the rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_efgac pdfFontSimple) GetRuneMetrics(r rune) (_fe.CharMetrics, bool) {
	if _efgac._dcbff != nil {
		_cdfb, _cdea := _efgac._dcbff.Read(r)
		if _cdea {
			return _cdfb, true
		}
	}
	_dbbfg := _efgac.Encoder()
	if _dbbfg == nil {
		_fg.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _efgac)
		return _fe.CharMetrics{}, false
	}
	_gebg, _ddag := _dbbfg.RuneToCharcode(r)
	if !_ddag {
		if r != ' ' {
			_fg.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _efgac)
		}
		return _fe.CharMetrics{}, false
	}
	_eeedb, _fbgbc := _efgac.GetCharMetrics(_gebg)
	return _eeedb, _fbgbc
}

// PdfAnnotation represents an annotation in PDF (section 12.5 p. 389).
type PdfAnnotation struct {
	_dabfb       PdfModel
	Rect         _bgd.PdfObject
	Contents     _bgd.PdfObject
	P            _bgd.PdfObject
	NM           _bgd.PdfObject
	M            _bgd.PdfObject
	F            _bgd.PdfObject
	AP           _bgd.PdfObject
	AS           _bgd.PdfObject
	Border       _bgd.PdfObject
	C            _bgd.PdfObject
	StructParent _bgd.PdfObject
	OC           _bgd.PdfObject
	_eag         *_bgd.PdfIndirectObject
}

// ToPdfObject implements interface PdfModel.
func (_eced *PdfAnnotationMovie) ToPdfObject() _bgd.PdfObject {
	_eced.PdfAnnotation.ToPdfObject()
	_dfe := _eced._eag
	_bcba := _dfe.PdfObject.(*_bgd.PdfObjectDictionary)
	_bcba.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u004d\u006f\u0076i\u0065"))
	_bcba.SetIfNotNil("\u0054", _eced.T)
	_bcba.SetIfNotNil("\u004d\u006f\u0076i\u0065", _eced.Movie)
	_bcba.SetIfNotNil("\u0041", _eced.A)
	return _dfe
}

// HasXObjectByName checks if has XObject resource by name.
func (_egeg *PdfPage) HasXObjectByName(name _bgd.PdfObjectName) bool {
	_bcfb, _dbdbd := _egeg.Resources.XObject.(*_bgd.PdfObjectDictionary)
	if !_dbdbd {
		return false
	}
	if _ffed := _bcfb.Get(name); _ffed != nil {
		return true
	}
	return false
}

func (_cbdbbf *PdfWriter) writeAcroFormFields() error {
	if _cbdbbf._edcdb == nil {
		return nil
	}
	_fg.Log.Trace("\u0057r\u0069t\u0069\u006e\u0067\u0020\u0061c\u0072\u006f \u0066\u006f\u0072\u006d\u0073")
	_bffac := _cbdbbf._edcdb.ToPdfObject()
	_fg.Log.Trace("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _bffac)
	_cbdbbf._aaea.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _bffac)
	_bfbdd := _cbdbbf.addObjects(_bffac)
	if _bfbdd != nil {
		return _bfbdd
	}
	return nil
}

func (_bebfa *PdfReader) newPdfAnnotationWatermarkFromDict(_bcg *_bgd.PdfObjectDictionary) (*PdfAnnotationWatermark, error) {
	_fgffg := PdfAnnotationWatermark{}
	_fgffg.FixedPrint = _bcg.Get("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074")
	return &_fgffg, nil
}

// SetDocInfo set document info.
// This will overwrite any globally declared document info.
func (_gbfcf *PdfWriter) SetDocInfo(info *PdfInfo) { _gbfcf.setDocInfo(info.ToPdfObject()) }

func _deagf(_gddff []byte) ([]byte, error) {
	_fegaa := _ac.New()
	if _, _gbbf := _ca.Copy(_fegaa, _ea.NewReader(_gddff)); _gbbf != nil {
		return nil, _gbbf
	}
	return _fegaa.Sum(nil), nil
}

// ToPdfObject returns the PDF representation of the pattern.
func (_eeabf *PdfPattern) ToPdfObject() _bgd.PdfObject {
	_dfagg := _eeabf.getDict()
	_dfagg.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_dfagg.Set("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065", _bgd.MakeInteger(_eeabf.PatternType))
	return _eeabf._eaddb
}

// AddRefChild adds a child reference object.
func (_cbcgag *KDict) AddRefChild(kChild _bgd.PdfObject) {
	_cbcgag._fabbb = append(_cbcgag._fabbb, &KValue{_bcdd: kChild})
}

// NewPdfAnnotationCircle returns a new circle annotation.
func NewPdfAnnotationCircle() *PdfAnnotationCircle {
	_geb := NewPdfAnnotation()
	_fge := &PdfAnnotationCircle{}
	_fge.PdfAnnotation = _geb
	_fge.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_geb.SetContext(_fge)
	return _fge
}

// NewCompliancePdfReader creates a PdfReader or an input io.ReadSeeker that during reading will scan the files for the
// metadata details. It could be used for the PDF standard implementations like PDF/A or PDF/X.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
func NewCompliancePdfReader(rs _ca.ReadSeeker) (*CompliancePdfReader, error) {
	const _faag = "\u006d\u006f\u0064\u0065l\u003a\u004e\u0065\u0077\u0043\u006f\u006d\u0070\u006c\u0069a\u006ec\u0065\u0050\u0064\u0066\u0052\u0065\u0061d\u0065\u0072"
	_bedab, _bggf := _acbcg(rs, &ReaderOpts{ComplianceMode: true}, false, _faag)
	if _bggf != nil {
		return nil, _bggf
	}
	return &CompliancePdfReader{PdfReader: _bedab}, nil
}

// SetOCProperties sets the optional content properties.
func (_dgefa *PdfWriter) SetOCProperties(ocProperties _bgd.PdfObject) error {
	_dbbea := _dgefa._aaea
	if ocProperties != nil {
		_fg.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u004f\u0043\u0020\u0050\u0072o\u0070\u0065\u0072\u0074\u0069\u0065\u0073\u002e\u002e\u002e")
		_dbbea.Set("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", ocProperties)
		return _dgefa.addObjects(ocProperties)
	}
	return nil
}

// ToInteger convert to an integer format.
func (_dffa *PdfColorCalRGB) ToInteger(bits int) [3]uint32 {
	_dcee := _da.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_dcee * _dffa.A()), uint32(_dcee * _dffa.B()), uint32(_dcee * _dffa.C())}
}

// GetContentStream returns the XObject Form's content stream.
func (_ffbcb *XObjectForm) GetContentStream() ([]byte, error) {
	_bfgfaf, _bdeae := _bgd.DecodeStream(_ffbcb._aagg)
	if _bdeae != nil {
		return nil, _bdeae
	}
	return _bfgfaf, nil
}

// NewPdfAnnotationCaret returns a new caret annotation.
func NewPdfAnnotationCaret() *PdfAnnotationCaret {
	_bbe := NewPdfAnnotation()
	_bede := &PdfAnnotationCaret{}
	_bede.PdfAnnotation = _bbe
	_bede.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_bbe.SetContext(_bede)
	return _bede
}

// ColorToRGB converts an Indexed color to an RGB color.
func (_fabbg *PdfColorspaceSpecialIndexed) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _fabbg.Base == nil {
		return nil, _gb.New("\u0069\u006e\u0064\u0065\u0078\u0065d\u0020\u0062\u0061\u0073\u0065\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _fabbg.Base.ColorToRGB(color)
}

// ToPdfObject implements interface PdfModel.
func (_ebg *PdfAnnotationLine) ToPdfObject() _bgd.PdfObject {
	_ebg.PdfAnnotation.ToPdfObject()
	_ccgc := _ebg._eag
	_abfa := _ccgc.PdfObject.(*_bgd.PdfObjectDictionary)
	_ebg.appendToPdfDictionary(_abfa)
	_abfa.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u004c\u0069\u006e\u0065"))
	_abfa.SetIfNotNil("\u004c", _ebg.L)
	_abfa.SetIfNotNil("\u0042\u0053", _ebg.BS)
	_abfa.SetIfNotNil("\u004c\u0045", _ebg.LE)
	_abfa.SetIfNotNil("\u0049\u0043", _ebg.IC)
	_abfa.SetIfNotNil("\u004c\u004c", _ebg.LL)
	_abfa.SetIfNotNil("\u004c\u004c\u0045", _ebg.LLE)
	_abfa.SetIfNotNil("\u0043\u0061\u0070", _ebg.Cap)
	_abfa.SetIfNotNil("\u0049\u0054", _ebg.IT)
	_abfa.SetIfNotNil("\u004c\u004c\u004f", _ebg.LLO)
	_abfa.SetIfNotNil("\u0043\u0050", _ebg.CP)
	_abfa.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _ebg.Measure)
	_abfa.SetIfNotNil("\u0043\u004f", _ebg.CO)
	return _ccgc
}

// DefaultFont returns the default font, which is currently the built in Helvetica.
func DefaultFont() *PdfFont {
	_fcfg, _gbdf := _fe.NewStdFontByName(HelveticaName)
	if !_gbdf {
		panic("\u0048\u0065lv\u0065\u0074\u0069c\u0061\u0020\u0073\u0068oul\u0064 a\u006c\u0077\u0061\u0079\u0073\u0020\u0062e \u0061\u0076\u0061\u0069\u006c\u0061\u0062l\u0065")
	}
	_gced := _gaccd(_fcfg)
	return &PdfFont{_cbec: &_gced}
}

// ToInteger convert to an integer format.
func (_fdeab *PdfColorDeviceCMYK) ToInteger(bits int) [4]uint32 {
	_ecdg := _da.Pow(2, float64(bits)) - 1
	return [4]uint32{uint32(_ecdg * _fdeab.C()), uint32(_ecdg * _fdeab.M()), uint32(_ecdg * _fdeab.Y()), uint32(_ecdg * _fdeab.K())}
}

func (_fffaf *Image) getSuitableEncoder() (_bgd.StreamEncoder, error) {
	var (
		_ccgd, _acfc = int(_fffaf.Width), int(_fffaf.Height)
		_aeabd       = make(map[string]bool)
		_acbb        = true
		_bbgfd       = false
		_dcfce       = func() *_bgd.DCTEncoder { return _bgd.NewDCTEncoder() }
		_eeceg       = func() *_bgd.DCTEncoder { _acda := _bgd.NewDCTEncoder(); _acda.BitsPerComponent = 16; return _acda }
	)
	for _cegb := 0; _cegb < _acfc; _cegb++ {
		for _afee := 0; _afee < _ccgd; _afee++ {
			_ebbff, _bfba := _fffaf.ColorAt(_afee, _cegb)
			if _bfba != nil {
				return nil, _bfba
			}
			_gggg, _gfea, _aebd, _cfbbd := _ebbff.RGBA()
			if _acbb && (_gggg != _gfea || _gggg != _aebd || _gfea != _aebd) {
				_acbb = false
			}
			if !_bbgfd {
				switch _ebbff.(type) {
				case _e.NRGBA:
					_bbgfd = _cfbbd > 0
				}
			}
			_aeabd[_f.Sprintf("\u0025\u0064\u002c\u0025\u0064\u002c\u0025\u0064", _gggg, _gfea, _aebd)] = true
			if len(_aeabd) > 2 && _bbgfd {
				return _eeceg(), nil
			}
		}
	}
	if _bbgfd || len(_fffaf._bdgdb) > 0 {
		return _bgd.NewFlateEncoder(), nil
	}
	if len(_aeabd) <= 2 {
		_faba := _fffaf.ConvertToBinary()
		if _faba != nil {
			return nil, _faba
		}
		return _bgd.NewJBIG2Encoder(), nil
	}
	if _acbb {
		return _dcfce(), nil
	}
	if _fffaf.ColorComponents == 1 {
		if _fffaf.BitsPerComponent == 1 {
			return _bgd.NewJBIG2Encoder(), nil
		} else if _fffaf.BitsPerComponent == 8 {
			_adaea := _bgd.NewDCTEncoder()
			_adaea.ColorComponents = 1
			return _adaea, nil
		}
	} else if _fffaf.ColorComponents == 3 {
		if _fffaf.BitsPerComponent == 8 {
			return _dcfce(), nil
		} else if _fffaf.BitsPerComponent == 16 {
			return _eeceg(), nil
		}
	} else if _fffaf.ColorComponents == 4 {
		_ceecf := _eeceg()
		_ceecf.ColorComponents = 4
		return _ceecf, nil
	}
	return _eeceg(), nil
}

// SetAnnotations sets the annotations list.
func (_bbdfa *PdfPage) SetAnnotations(annotations []*PdfAnnotation) { _bbdfa._dffab = annotations }

// Names represents a PDF name tree.
//
// Ref: PDF32000_2008 chapter 7.7.4.
type Names struct {
	_cafda *_bgd.PdfIndirectObject

	// Dests is a name tree mapping name string to destinations.
	Dests *_bgd.PdfObjectDictionary

	// AP is a name tree mapping name strings to annotation appearance streams.
	AP *_bgd.PdfObjectDictionary

	// JavaScript is a name tree mapping name strings to JavaScript actions.
	JavaScript *_bgd.PdfObjectDictionary

	// Pages is a name tree mapping name strings to visible pages for use in interactive forms.
	Pages *_bgd.PdfObjectDictionary

	// Templates is a name tree mapping name strings to invisible (template) pages for use in interactive forms.
	Templates *_bgd.PdfObjectDictionary

	// IDS is a name tree mapping digital identifies to Web Capture content sets.
	IDS *_bgd.PdfObjectDictionary

	// URLS is a name tree mapping URLs to Web Capture content sets.
	URLS *_bgd.PdfObjectDictionary

	// EmbeddedFiles is a name tree mapping name strings to file specifications for embedded file streams.
	EmbeddedFiles *_bgd.PdfObjectDictionary

	// AlternatePresentations is a name tree mapping name strings to alternate presentations.
	AlternatePresentations *_bgd.PdfObjectDictionary

	// Renditions is a name tree mapping name strings (which shall have Unicode encoding) to rendition objects.
	Renditions *_bgd.PdfObjectDictionary
}

// GetXObjectByName returns the XObject with the specified keyName and the object type.
func (_gegfe *PdfPageResources) GetXObjectByName(keyName _bgd.PdfObjectName) (*_bgd.PdfObjectStream, XObjectType) {
	if _gegfe.XObject == nil {
		return nil, XObjectTypeUndefined
	}
	_ceecc, _dcbgfb := _bgd.TraceToDirectObject(_gegfe.XObject).(*_bgd.PdfObjectDictionary)
	if !_dcbgfb {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bgd.TraceToDirectObject(_gegfe.XObject))
		return nil, XObjectTypeUndefined
	}
	if _dgaa := _ceecc.Get(keyName); _dgaa != nil {
		_cbfe, _cfbfa := _bgd.GetStream(_dgaa)
		if !_cfbfa {
			_fg.Log.Debug("X\u004f\u0062\u006a\u0065\u0063\u0074 \u006e\u006f\u0074\u0020\u0070\u006fi\u006e\u0074\u0069\u006e\u0067\u0020\u0074o\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020%\u0054", _dgaa)
			return nil, XObjectTypeUndefined
		}
		_bccd := _cbfe.PdfObjectDictionary
		_beec, _cfbfa := _bgd.TraceToDirectObject(_bccd.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")).(*_bgd.PdfObjectName)
		if !_cfbfa {
			_fg.Log.Debug("\u0058\u004fbj\u0065\u0063\u0074 \u0053\u0075\u0062\u0074ype\u0020no\u0074\u0020\u0061\u0020\u004e\u0061\u006de,\u0020\u0064\u0069\u0063\u0074\u003a\u0020%\u0073", _bccd.String())
			return nil, XObjectTypeUndefined
		}
		if *_beec == "\u0049\u006d\u0061g\u0065" {
			return _cbfe, XObjectTypeImage
		} else if *_beec == "\u0046\u006f\u0072\u006d" {
			return _cbfe, XObjectTypeForm
		} else if *_beec == "\u0050\u0053" {
			return _cbfe, XObjectTypePS
		} else {
			_fg.Log.Debug("\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0053\u0075b\u0074\u0079\u0070\u0065\u0020\u006e\u006ft\u0020\u006b\u006e\u006f\u0077\u006e\u0020\u0028\u0025\u0073\u0029", *_beec)
			return nil, XObjectTypeUndefined
		}
	} else {
		return nil, XObjectTypeUndefined
	}
}

// GetNumComponents returns the number of color components (3 for Lab).
func (_bcbe *PdfColorLab) GetNumComponents() int { return 3 }

// GetCatalogMarkInfo gets catalog MarkInfo object.
func (_ccbed *PdfReader) GetCatalogMarkInfo() (_bgd.PdfObject, bool) {
	if _ccbed._ffabf == nil {
		return nil, false
	}
	_ffdfg := _ccbed._ffabf.Get("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
	return _ffdfg, _ffdfg != nil
}

// NewPdfActionJavaScript returns a new "javaScript" action.
func NewPdfActionJavaScript() *PdfActionJavaScript {
	_cc := NewPdfAction()
	_bad := &PdfActionJavaScript{}
	_bad.PdfAction = _cc
	_cc.SetContext(_bad)
	return _bad
}

// CompliancePdfReader is a wrapper over PdfReader that is used for verifying if the input Pdf document matches the
// compliance rules of standards like PDF/A.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type CompliancePdfReader struct {
	*PdfReader
	_gdff _bgd.ParserMetadata
}

// ImageToRGB converts image in CalGray color space to RGB (A, B, C -> X, Y, Z).
func (_agbc *PdfColorspaceCalGray) ImageToRGB(img Image) (Image, error) {
	_fagcf := _eaa.NewReader(img.getBase())
	_begg := _daf.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_baeg := _eaa.NewWriter(_begg)
	_abag := _da.Pow(2, float64(img.BitsPerComponent)) - 1
	_dfge := make([]uint32, 3)
	var (
		_aacd                                uint32
		ANorm, X, Y, Z, _adefe, _age, _bffag float64
		_gafb                                error
	)
	for {
		_aacd, _gafb = _fagcf.ReadSample()
		if _gafb == _ca.EOF {
			break
		} else if _gafb != nil {
			return img, _gafb
		}
		ANorm = float64(_aacd) / _abag
		X = _agbc.WhitePoint[0] * _da.Pow(ANorm, _agbc.Gamma)
		Y = _agbc.WhitePoint[1] * _da.Pow(ANorm, _agbc.Gamma)
		Z = _agbc.WhitePoint[2] * _da.Pow(ANorm, _agbc.Gamma)
		_adefe = 3.240479*X + -1.537150*Y + -0.498535*Z
		_age = -0.969256*X + 1.875992*Y + 0.041556*Z
		_bffag = 0.055648*X + -0.204043*Y + 1.057311*Z
		_adefe = _da.Min(_da.Max(_adefe, 0), 1.0)
		_age = _da.Min(_da.Max(_age, 0), 1.0)
		_bffag = _da.Min(_da.Max(_bffag, 0), 1.0)
		_dfge[0] = uint32(_adefe * _abag)
		_dfge[1] = uint32(_age * _abag)
		_dfge[2] = uint32(_bffag * _abag)
		if _gafb = _baeg.WriteSamples(_dfge); _gafb != nil {
			return img, _gafb
		}
	}
	return _acfa(&_begg), nil
}

// B returns the value of the B component of the color.
func (_dbaa *PdfColorCalRGB) B() float64 { return _dbaa[1] }

// NewPdfInfoFromObject creates a new PdfInfo from the input core.PdfObject.
func NewPdfInfoFromObject(obj _bgd.PdfObject) (*PdfInfo, error) {
	var _fega PdfInfo
	_aadc, _fggbd := obj.(*_bgd.PdfObjectDictionary)
	if !_fggbd {
		return nil, _f.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054", obj)
	}
	for _, _cgbcf := range _aadc.Keys() {
		switch _cgbcf {
		case "\u0054\u0069\u0074l\u0065":
			_fega.Title, _ = _bgd.GetString(_aadc.Get("\u0054\u0069\u0074l\u0065"))
		case "\u0041\u0075\u0074\u0068\u006f\u0072":
			_fega.Author, _ = _bgd.GetString(_aadc.Get("\u0041\u0075\u0074\u0068\u006f\u0072"))
		case "\u0053u\u0062\u006a\u0065\u0063\u0074":
			_fega.Subject, _ = _bgd.GetString(_aadc.Get("\u0053u\u0062\u006a\u0065\u0063\u0074"))
		case "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073":
			_fega.Keywords, _ = _bgd.GetString(_aadc.Get("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073"))
		case "\u0043r\u0065\u0061\u0074\u006f\u0072":
			_fega.Creator, _ = _bgd.GetString(_aadc.Get("\u0043r\u0065\u0061\u0074\u006f\u0072"))
		case "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072":
			_fega.Producer, _ = _bgd.GetString(_aadc.Get("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072"))
		case "\u0054r\u0061\u0070\u0070\u0065\u0064":
			_fega.Trapped, _ = _bgd.GetName(_aadc.Get("\u0054r\u0061\u0070\u0070\u0065\u0064"))
		case "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065":
			if _dfbf, _acacb := _bgd.GetString(_aadc.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065")); _acacb && _dfbf.String() != "" {
				_cbge, _befe := NewPdfDate(_dfbf.String())
				if _befe != nil {
					return nil, _f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0072e\u0061\u0074\u0069\u006f\u006e\u0044\u0061t\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0077", _befe)
				}
				_fega.CreationDate = &_cbge
			}
		case "\u004do\u0064\u0044\u0061\u0074\u0065":
			if _agd, _bgcc := _bgd.GetString(_aadc.Get("\u004do\u0064\u0044\u0061\u0074\u0065")); _bgcc && _agd.String() != "" {
				_afccc, _gagd := NewPdfDate(_agd.String())
				if _gagd != nil {
					return nil, _f.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u004d\u006f\u0064\u0044a\u0074e\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025w", _gagd)
				}
				_fega.ModifiedDate = &_afccc
			}
		default:
			_ggaf, _ := _bgd.GetString(_aadc.Get(_cgbcf))
			if _fega._dfeee == nil {
				_fega._dfeee = _bgd.MakeDict()
			}
			_fega._dfeee.Set(_cgbcf, _ggaf)
		}
	}
	return &_fega, nil
}

// GetOCProperties returns the optional content properties PdfObject.
func (_bbfag *PdfReader) GetOCProperties() (_bgd.PdfObject, error) {
	_bfbag := _bbfag._ffabf
	_ffbd := _bfbag.Get("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073")
	_ffbd = _bgd.ResolveReference(_ffbd)
	if !_bbfag._ffce {
		_cabgd := _bbfag.traverseObjectData(_ffbd)
		if _cabgd != nil {
			return nil, _cabgd
		}
	}
	return _ffbd, nil
}

// GetRuneMetrics returns the char metrics for a rune.
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
// well give them 0 width. There is no need for the bool return.
func (_afafe *PdfFont) GetRuneMetrics(r rune) (CharMetrics, bool) {
	_dadae := _afafe.actualFont()
	if _dadae == nil {
		_fg.Log.Debug("ER\u0052\u004fR\u003a\u0020\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u004e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020f\u006fr\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079p\u0065=\u0025\u0023T", _afafe._cbec)
		return _fe.CharMetrics{}, false
	}
	if _dcccg, _eccfg := _dadae.GetRuneMetrics(r); _eccfg {
		return _dcccg, true
	}
	if _bcbc, _eceb := _afafe.GetFontDescriptor(); _eceb == nil && _bcbc != nil {
		return _fe.CharMetrics{Wx: _bcbc._aeee}, true
	}
	_fg.Log.Debug("\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061r\u004d\u0065\u0074\u0072i\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _afafe)
	return _fe.CharMetrics{}, false
}

// NewPdfShadingType2 creates an empty shading type 2 dictionary.
func NewPdfShadingType2() *PdfShadingType2 {
	_afcba := &PdfShadingType2{}
	_afcba.PdfShading = &PdfShading{}
	_afcba.PdfShading._gccfe = _bgd.MakeIndirectObject(_bgd.MakeDict())
	_afcba.PdfShading._gggga = _afcba
	return _afcba
}

func (_acefg *pdfCIDFontType2) getFontDescriptor() *PdfFontDescriptor { return _acefg._ggde }

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_fdae pdfFontType0) GetRuneMetrics(r rune) (_fe.CharMetrics, bool) {
	if _fdae.DescendantFont == nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _fdae)
		return _fe.CharMetrics{}, false
	}
	return _fdae.DescendantFont.GetRuneMetrics(r)
}

// CharcodeBytesToUnicode converts PDF character codes `data` to a Go unicode string.
//
// 9.10 Extraction of Text Content (page 292)
// The process of finding glyph descriptions in OpenType fonts by a conforming reader shall be the following:
//   - For Type 1 fonts using “CFF” tables, the process shall be as described in 9.6.6.2, "Encodings
//     for Type 1 Fonts".
//   - For TrueType fonts using “glyf” tables, the process shall be as described in 9.6.6.4,
//     "Encodings for TrueType Fonts". Since this process sometimes produces ambiguous results,
//     conforming writers, instead of using a simple font, shall use a Type 0 font with an Identity-H
//     encoding and use the glyph indices as character codes, as described following Table 118.
func (_cbdd *PdfFont) CharcodeBytesToUnicode(data []byte) (string, int, int) {
	_efaeg, _, _gddc := _cbdd.CharcodesToUnicodeWithStats(_cbdd.BytesToCharcodes(data))
	_aadg := _dabf.ExpandLigatures(_efaeg)
	return _aadg, _bc.RuneCountInString(_aadg), _gddc
}

func (_bcca *PdfPage) removeXObj(_geedcd *_bgd.PdfObjectDictionary, _ccgcgc _bgd.PdfObjectName) {
	_geedcd.Remove(_ccgcgc)
	_gcfd := _bgd.NewFlateEncoder()
	_efdb := _bcca.GetContentStreamObjs()
	_beagd := _bgd.MakeArray()
	for _, _debc := range _efdb {
		_gfbb, _ := _fdccc(_debc)
		if _ef.Contains(_gfbb, _ccgcgc.String()) {
			_cgcff := _ef.Index(_gfbb, _ccgcgc.String())
			_fecdab := _ef.LastIndex(_gfbb[:_cgcff], "\u0071")
			_eedad := _ef.Index(_gfbb[_cgcff:], "\u0051") + _cgcff + 1
			if _fecdab >= 0 && _eedad >= 0 {
				var _cccfa _ef.Builder
				_cccfa.WriteString(_gfbb[:_fecdab])
				_cccfa.WriteString(_gfbb[_eedad:])
				_dafg, _fbacf := _bgd.MakeStream([]byte(_cccfa.String()), _gcfd)
				if _fbacf == nil {
					_beagd.Append(_dafg)
					continue
				}
			}
		}
		_beagd.Append(_debc)
	}
	_bcca.Contents = _beagd
}

// NewPdfColorspaceFromPdfObject loads a PdfColorspace from a PdfObject.  Returns an error if there is
// a failure in loading.
func NewPdfColorspaceFromPdfObject(obj _bgd.PdfObject) (PdfColorspace, error) {
	if obj == nil {
		return nil, nil
	}
	var _afdb *_bgd.PdfIndirectObject
	var _gedf *_bgd.PdfObjectName
	var _ffgd *_bgd.PdfObjectArray
	if _aaa, _dadb := obj.(*_bgd.PdfIndirectObject); _dadb {
		_afdb = _aaa
	}
	obj = _bgd.TraceToDirectObject(obj)
	switch _fdeg := obj.(type) {
	case *_bgd.PdfObjectArray:
		_ffgd = _fdeg
	case *_bgd.PdfObjectName:
		_gedf = _fdeg
	}
	if _gedf != nil {
		switch *_gedf {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
			return NewPdfColorspaceDeviceGray(), nil
		case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
			return NewPdfColorspaceDeviceRGB(), nil
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return NewPdfColorspaceDeviceCMYK(), nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return NewPdfColorspaceSpecialPattern(), nil
		default:
			_fg.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0025\u0073", *_gedf)
			return nil, _faef
		}
	}
	if _ffgd != nil && _ffgd.Len() > 0 {
		var _cbbd _bgd.PdfObject = _afdb
		if _afdb == nil {
			_cbbd = _ffgd
		}
		if _gcbb, _adega := _bgd.GetName(_ffgd.Get(0)); _adega {
			switch _gcbb.String() {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
				if _ffgd.Len() == 1 {
					return NewPdfColorspaceDeviceGray(), nil
				}
			case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
				if _ffgd.Len() == 1 {
					return NewPdfColorspaceDeviceRGB(), nil
				}
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _ffgd.Len() == 1 {
					return NewPdfColorspaceDeviceCMYK(), nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079":
				return _befc(_cbbd)
			case "\u0043\u0061\u006c\u0052\u0047\u0042":
				return _fdgb(_cbbd)
			case "\u004c\u0061\u0062":
				return _bdcec(_cbbd)
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064":
				return _beaa(_cbbd)
			case "\u0050a\u0074\u0074\u0065\u0072\u006e":
				return _cfgfg(_cbbd)
			case "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return _bedb(_cbbd)
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e":
				return _cgcb(_cbbd)
			case "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return _bgdf(_cbbd)
			default:
				_fg.Log.Debug("A\u0072\u0072\u0061\u0079\u0020\u0077i\u0074\u0068\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u006e\u0061m\u0065:\u0020\u0025\u0073", *_gcbb)
			}
		}
	}
	_fg.Log.Debug("\u0050\u0044\u0046\u0020\u0046i\u006c\u0065\u0020\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", obj.String())
	return nil, ErrTypeCheck
}

func (_efge *PdfColorspaceCalGray) String() string { return "\u0043a\u006c\u0047\u0072\u0061\u0079" }

// ColorToRGB converts a CMYK32 color to an RGB color.
func (_dfagb *PdfColorspaceDeviceCMYK) ColorToRGB(color PdfColor) (PdfColor, error) {
	_aacea, _cgfb := color.(*PdfColorDeviceCMYK)
	if !_cgfb {
		_fg.Log.Debug("I\u006e\u0070\u0075\u0074\u0020\u0063o\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0064e\u0076\u0069\u0063e\u0020c\u006d\u0079\u006b")
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_fcda := _aacea.C()
	_caaa := _aacea.M()
	_fgda := _aacea.Y()
	_fdfa := _aacea.K()
	_fcda = _fcda*(1-_fdfa) + _fdfa
	_caaa = _caaa*(1-_fdfa) + _fdfa
	_fgda = _fgda*(1-_fdfa) + _fdfa
	_baea := 1 - _fcda
	_fdcb := 1 - _caaa
	_bdgg := 1 - _fgda
	return NewPdfColorDeviceRGB(_baea, _fdcb, _bdgg), nil
}

// GetContext returns the context of the outline tree node, which is either a
// *PdfOutline or a *PdfOutlineItem. The method returns nil for uninitialized
// tree nodes.
func (_accfa *PdfOutlineTreeNode) GetContext() PdfModel {
	if _bead, _cfgac := _accfa._bfff.(*PdfOutline); _cfgac {
		return _bead
	}
	if _bebab, _eacgb := _accfa._bfff.(*PdfOutlineItem); _eacgb {
		return _bebab
	}
	_fg.Log.Debug("\u0045\u0052RO\u0052\u0020\u0049n\u0076\u0061\u006c\u0069d o\u0075tl\u0069\u006e\u0065\u0020\u0074\u0072\u0065e \u006e\u006f\u0064\u0065\u0020\u0069\u0074e\u006d")
	return nil
}

// ToPdfObject returns a PDF object representation of the outline destination.
func (_gcabc OutlineDest) ToPdfObject() _bgd.PdfObject {
	if (_gcabc.PageObj == nil && _gcabc.Page < 0) || _gcabc.Mode == "" {
		return _bgd.MakeNull()
	}
	_fcfgga := _bgd.MakeArray()
	if _gcabc.PageObj != nil {
		_fcfgga.Append(_gcabc.PageObj)
	} else {
		_fcfgga.Append(_bgd.MakeInteger(_gcabc.Page))
	}
	_fcfgga.Append(_bgd.MakeName(_gcabc.Mode))
	switch _gcabc.Mode {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		_fcfgga.Append(_bgd.MakeFloat(_gcabc.Y))
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		_fcfgga.Append(_bgd.MakeFloat(_gcabc.X))
	case "\u0058\u0059\u005a":
		_fcfgga.Append(_bgd.MakeFloat(_gcabc.X))
		_fcfgga.Append(_bgd.MakeFloat(_gcabc.Y))
		_fcfgga.Append(_bgd.MakeFloat(_gcabc.Zoom))
	default:
		_fcfgga.Set(1, _bgd.MakeName("\u0046\u0069\u0074"))
	}
	return _fcfgga
}

func (_eeff *PdfColorspaceDeviceCMYK) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b"
}

func (_gegc *PdfReader) newPdfActionSubmitFormFromDict(_gbe *_bgd.PdfObjectDictionary) (*PdfActionSubmitForm, error) {
	_aaf, _adac := _ada(_gbe.Get("\u0046"))
	if _adac != nil {
		return nil, _adac
	}
	return &PdfActionSubmitForm{F: _aaf, Fields: _gbe.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _gbe.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// GetAllContentStreams gets all the content streams for a page as one string.
func (_fceaa *PdfPage) GetAllContentStreams() (string, error) {
	_adfea, _acfeg := _fceaa.GetContentStreams()
	if _acfeg != nil {
		return "", _acfeg
	}
	return _ef.Join(_adfea, "\u0020"), nil
}

func _fdggb(_faca string) map[string]string {
	_cecfb := _fdfg.Split(_faca, -1)
	_acefdd := map[string]string{}
	for _, _gggf := range _cecfb {
		_dcfe := _ceeed.FindStringSubmatch(_gggf)
		if _dcfe == nil {
			continue
		}
		_debg, _gbdcd := _dcfe[1], _dcfe[2]
		_acefdd[_debg] = _gbdcd
	}
	return _acefdd
}

// Duplex represents the paper handling option that shall be used when printing
// the file from the print dialog.
type Duplex string

// GetParamsDict returns *core.PdfObjectDictionary with a set of basic image parameters.
func (_beaaa *Image) GetParamsDict() *_bgd.PdfObjectDictionary {
	_eaagf := _bgd.MakeDict()
	_eaagf.Set("\u0057\u0069\u0064t\u0068", _bgd.MakeInteger(_beaaa.Width))
	_eaagf.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _bgd.MakeInteger(_beaaa.Height))
	_eaagf.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _bgd.MakeInteger(int64(_beaaa.ColorComponents)))
	_eaagf.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _bgd.MakeInteger(_beaaa.BitsPerComponent))
	return _eaagf
}

// ToPdfObject returns the PDF representation of the VRI dictionary.
func (_bbfc *VRI) ToPdfObject() *_bgd.PdfObjectDictionary {
	_fgef := _bgd.MakeDict()
	_fgef.SetIfNotNil(_bgd.PdfObjectName("\u0043\u0065\u0072\u0074"), _befa(_bbfc.Cert))
	_fgef.SetIfNotNil(_bgd.PdfObjectName("\u004f\u0043\u0053\u0050"), _befa(_bbfc.OCSP))
	_fgef.SetIfNotNil(_bgd.PdfObjectName("\u0043\u0052\u004c"), _befa(_bbfc.CRL))
	_fgef.SetIfNotNil("\u0054\u0055", _bbfc.TU)
	_fgef.SetIfNotNil("\u0054\u0053", _bbfc.TS)
	return _fgef
}

// PdfColorspaceCalGray represents CalGray color space.
type PdfColorspaceCalGray struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      float64
	_ecad      *_bgd.PdfIndirectObject
}

// SetDuplex sets the value of the duplex.
func (_cgbeg *ViewerPreferences) SetDuplex(duplex Duplex) { _cgbeg._affbc = duplex }

func (_ddggc *PdfColorspaceDeviceRGB) String() string {
	return "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B"
}

// PdfAnnotationCaret represents Caret annotations.
// (Section 12.5.6.11).
type PdfAnnotationCaret struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	RD _bgd.PdfObject
	Sy _bgd.PdfObject
}

// Register registers (caches) a model to primitive object relationship.
func (_cbeg *modelManager) Register(primitive _bgd.PdfObject, model PdfModel) {
	_cbeg._cegbb.Lock()
	defer _cbeg._cegbb.Unlock()
	_cbeg._bagb.Lock()
	defer _cbeg._bagb.Unlock()
	_cbeg._dagg[model] = primitive
	_cbeg._bcdf[primitive] = model
}

// EncryptOptions represents encryption options for an output PDF.
type EncryptOptions struct {
	Permissions _dab.Permissions
	Algorithm   EncryptionAlgorithm
}

// SetRefObject sets the reference object for the KValue.
func (_efcbe *KValue) SetRefObject(refObject _bgd.PdfObject) {
	_efcbe.Clear()
	_efcbe._bcdd = refObject
}

// ToPdfObject returns a PDF object representation of the outline.
func (_gebaa *Outline) ToPdfObject() _bgd.PdfObject { return _gebaa.ToPdfOutline().ToPdfObject() }

// CharcodesToStrings returns the unicode strings corresponding to `charcodes`.
// The int returns are the number of strings and the number of unconvereted codes.
// NOTE: The number of strings returned is equal to the number of charcodes
func (_accga *PdfFont) CharcodesToStrings(charcodes []_dabf.CharCode, replacementText string) ([]string, int, int) {
	_dfaf := _accga.baseFields()
	_gcbg := make([]string, 0, len(charcodes))
	_dbbef := 0
	_fefg := _accga.Encoder()
	_bdcd := _dfaf._edab != nil && _accga.IsSimple() && _accga.Subtype() == "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065" && !_ef.Contains(_dfaf._edab.Name(), "\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-")
	if !_bdcd && _fefg != nil {
		switch _beba := _fefg.(type) {
		case _dabf.SimpleEncoder:
			_fedb := _beba.BaseName()
			if _, _bbagf := _eaaga[_fedb]; _bbagf {
				for _, _abagg := range charcodes {
					if _gaab, _dbce := _fefg.CharcodeToRune(_abagg); _dbce {
						_gcbg = append(_gcbg, string(_gaab))
					} else {
						_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _abagg, charcodes, _dfaf.isCIDFont(), _accga, _fefg)
						_dbbef++
						_gcbg = append(_gcbg, _cf.MissingCodeString)
					}
				}
				return _gcbg, len(_gcbg), _dbbef
			}
		}
	}
	for _, _agbea := range charcodes {
		if _dfaf._edab != nil {
			if _cfdae, _dceee := _dfaf._edab.CharcodeToUnicode(_cf.CharCode(_agbea)); _dceee {
				_aebb, _ := _bc.DecodeLastRuneInString(_cfdae)
				_ecfce := _afgb(_aebb)
				if _ecfce != "\u0043\u006f" {
					_gcbg = append(_gcbg, _cfdae)
					continue
				}
				_fg.Log.Debug("E\u0052\u0052\u004fR\u003a\u0020\u0054\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u0020\u0043\u006d\u0061p\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u0020\u006d\u0061\u0070\u0070\u0069\u006e\u0067.\u0020\u0063\u006f\u0064\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u0020\u0069\u0073\u0020m\u0061\u0070\u0070\u0065\u0064 \u0074\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0063\u006f\u0064\u0065 \u0070\u006f\u0069\u006e\u0074\u0020\u0025\u0073", _agbea, _cfdae)
			}
		}
		if _fefg != nil {
			if _eagc, _bcfg := _fefg.CharcodeToRune(_agbea); _bcfg {
				_bbeaf := _afgb(_eagc)
				if _bbeaf != "\u0043\u006f" {
					_gcbg = append(_gcbg, string(_eagc))
					continue
				}
				_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e \u0063\u006f\u0064\u0065\u003d\u0030x\u0025\u0030\u0034\u0078\u0020\u0069\u0073\u0020\u0064\u0065\u0063\u006f\u0064\u0065d\u0020\u0074o\u0020\u0061\u006e\u0020i\u006e\u0076\u0061\u006c\u0069d\u0020\u0072\u0075\u006e\u0020\u0025\u0073", _agbea, string(_eagc))
			}
		}
		if replacementText != "" {
			_gcbg = append(_gcbg, replacementText)
		} else {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _agbea, charcodes, _dfaf.isCIDFont(), _accga, _fefg)
			_dbbef++
			_gcbg = append(_gcbg, _cf.MissingCodeString)
		}
	}
	if _dbbef != 0 {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0043\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0074\u006f\u0020u\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020i\u006ep\u0075\u0074\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0043\u0068\u0061\u0072\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073", len(charcodes), _dbbef, _accga)
	}
	return _gcbg, len(_gcbg), _dbbef
}

// GetStandardApplier gets currently used StandardApplier..
func (_bfcca *PdfWriter) GetStandardApplier() StandardApplier { return _bfcca._egbb }

func (_bgfbf *PdfPage) getParentResources() (*PdfPageResources, error) {
	_eaad := _bgfbf.Parent
	for _eaad != nil {
		_gaedg, _efadf := _bgd.GetDict(_eaad)
		if !_efadf {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020n\u006f\u0064\u0065")
			return nil, _gb.New("i\u006e\u0076\u0061\u006cid\u0020p\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		if _gdcge := _gaedg.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _gdcge != nil {
			_gbec, _ccac := _bgd.GetDict(_gdcge)
			if !_ccac {
				return nil, _gb.New("i\u006e\u0076\u0061\u006cid\u0020r\u0065\u0073\u006f\u0075\u0072c\u0065\u0020\u0064\u0069\u0063\u0074")
			}
			_daac, _dadee := NewPdfPageResourcesFromDict(_gbec)
			if _dadee != nil {
				return nil, _dadee
			}
			return _daac, nil
		}
		_eaad = _gaedg.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, nil
}

func (_gdcea fontCommon) coreString() string {
	_addfb := ""
	if _gdcea._ggde != nil {
		_addfb = _gdcea._ggde.String()
	}
	return _f.Sprintf("\u0025#\u0071\u0020%\u0023\u0071\u0020%\u0071\u0020\u006f\u0062\u006a\u003d\u0025d\u0020\u0054\u006f\u0055\u006e\u0069c\u006f\u0064\u0065\u003d\u0025\u0074\u0020\u0066\u006c\u0061\u0067s\u003d\u0030\u0078\u0025\u0030\u0078\u0020\u0025\u0073", _gdcea._gecd, _gdcea._eebe, _gdcea._ggef, _gdcea._eaaec, _gdcea._cagce != nil, _gdcea.fontFlags(), _addfb)
}

// PdfAnnotationProjection represents Projection annotations.
type PdfAnnotationProjection struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
}

// HasFontByName checks whether a font is defined by the specified keyName.
func (_ggdbd *PdfPageResources) HasFontByName(keyName _bgd.PdfObjectName) bool {
	_, _fbefd := _ggdbd.GetFontByName(keyName)
	return _fbefd
}

// PrintScaling represents the page scaling option that shall be selected
// when a print dialog is displayed for this document.
type PrintScaling string

// ToPdfObject implements interface PdfModel.
func (_fddee *Permissions) ToPdfObject() _bgd.PdfObject { return _fddee._cfgcg }

// PdfAnnotationFreeText represents FreeText annotations.
// (Section 12.5.6.6).
type PdfAnnotationFreeText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	DA _bgd.PdfObject
	Q  _bgd.PdfObject
	RC _bgd.PdfObject
	DS _bgd.PdfObject
	CL _bgd.PdfObject
	IT _bgd.PdfObject
	BE _bgd.PdfObject
	RD _bgd.PdfObject
	BS _bgd.PdfObject
	LE _bgd.PdfObject
}

func (_agfgb *PdfReader) loadDSS() (*DSS, error) {
	if _agfgb._ccade.GetCrypter() != nil && !_agfgb._ccade.IsAuthenticated() {
		return nil, _f.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_fdgfa := _agfgb._ffabf.Get("\u0044\u0053\u0053")
	if _fdgfa == nil {
		return nil, nil
	}
	_cccgg, _ := _bgd.GetIndirect(_fdgfa)
	_fdgfa = _bgd.TraceToDirectObject(_fdgfa)
	switch _eedg := _fdgfa.(type) {
	case *_bgd.PdfObjectNull:
		return nil, nil
	case *_bgd.PdfObjectDictionary:
		return _ebgd(_cccgg, _eedg)
	}
	return nil, _f.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u0053\u0053 \u0065\u006e\u0074\u0072y \u0025\u0054", _fdgfa)
}

// NewPdfAnnotationScreen returns a new screen annotation.
func NewPdfAnnotationScreen() *PdfAnnotationScreen {
	_ccfb := NewPdfAnnotation()
	_gcc := &PdfAnnotationScreen{}
	_gcc.PdfAnnotation = _ccfb
	_ccfb.SetContext(_gcc)
	return _gcc
}

// MergePageWith appends page content to source Pdf file page content.
func (_defbe *PdfAppender) MergePageWith(pageNum int, page *PdfPage) error {
	_dbbe := pageNum - 1
	var _dgc *PdfPage
	for _cbebe, _cfbe := range _defbe._ffcf {
		if _cbebe == _dbbe {
			_dgc = _cfbe
		}
	}
	if _dgc == nil {
		return _f.Errorf("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073o\u0075\u0072\u0063\u0065\u0020\u0064o\u0063\u0075\u006de\u006e\u0074", pageNum)
	}
	if _dgc._bbgfg != nil && _dgc._bbgfg.GetParser() == _defbe._gdf._ccade {
		_dgc = _dgc.Duplicate()
		_defbe._ffcf[_dbbe] = _dgc
	}
	page = page.Duplicate()
	_fdbfd(page)
	_gdce := _acf(_dgc)
	_bffaf := _acf(page)
	_ebff := make(map[_bgd.PdfObjectName]_bgd.PdfObjectName)
	for _cgdb := range _bffaf {
		if _, _cdac := _gdce[_cgdb]; _cdac {
			for _efba := 1; true; _efba++ {
				_gfbc := _bgd.PdfObjectName(string(_cgdb) + _ae.Itoa(_efba))
				if _, _dgabd := _gdce[_gfbc]; !_dgabd {
					_ebff[_cgdb] = _gfbc
					break
				}
			}
		}
	}
	_gaac, _adcg := page.GetContentStreams()
	if _adcg != nil {
		return _adcg
	}
	_bbfa, _adcg := _dgc.GetContentStreams()
	if _adcg != nil {
		return _adcg
	}
	for _fabg, _bgfd := range _gaac {
		for _ceda, _ceeb := range _ebff {
			_bgfd = _ef.ReplaceAll(_bgfd, "\u002f"+string(_ceda), "\u002f"+string(_ceeb))
		}
		_gaac[_fabg] = _bgfd
	}
	_bbfa = append(_bbfa, _gaac...)
	if _gfac := _dgc.SetContentStreams(_bbfa, _bgd.NewFlateEncoder()); _gfac != nil {
		return _gfac
	}
	_dgc._dffab = append(_dgc._dffab, page._dffab...)
	if _dgc.Resources == nil {
		_dgc.Resources = NewPdfPageResources()
	}
	if page.Resources != nil {
		_dgc.Resources.Font = _defbe.mergeResources(_dgc.Resources.Font, page.Resources.Font, _ebff)
		_dgc.Resources.XObject = _defbe.mergeResources(_dgc.Resources.XObject, page.Resources.XObject, _ebff)
		_dgc.Resources.Properties = _defbe.mergeResources(_dgc.Resources.Properties, page.Resources.Properties, _ebff)
		if _dgc.Resources.ProcSet == nil {
			_dgc.Resources.ProcSet = page.Resources.ProcSet
		}
		_dgc.Resources.Shading = _defbe.mergeResources(_dgc.Resources.Shading, page.Resources.Shading, _ebff)
		_dgc.Resources.ExtGState = _defbe.mergeResources(_dgc.Resources.ExtGState, page.Resources.ExtGState, _ebff)
	}
	_bgbg, _adcg := _dgc.GetMediaBox()
	if _adcg != nil {
		return _adcg
	}
	_edd, _adcg := page.GetMediaBox()
	if _adcg != nil {
		return _adcg
	}
	var _fadgb bool
	if _bgbg.Llx > _edd.Llx {
		_bgbg.Llx = _edd.Llx
		_fadgb = true
	}
	if _bgbg.Lly > _edd.Lly {
		_bgbg.Lly = _edd.Lly
		_fadgb = true
	}
	if _bgbg.Urx < _edd.Urx {
		_bgbg.Urx = _edd.Urx
		_fadgb = true
	}
	if _bgbg.Ury < _edd.Ury {
		_bgbg.Ury = _edd.Ury
		_fadgb = true
	}
	if _fadgb {
		_dgc.MediaBox = _bgbg
	}
	return nil
}

func NewViewerPreferencesFromPdfObject(obj _bgd.PdfObject) (*ViewerPreferences, error) {
	_ebebe := _bgd.ResolveReference(obj)
	_aaddag, _adgacb := _bgd.GetDict(_ebebe)
	if !_adgacb {
		return nil, _f.Errorf("e\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0076i\u0065\u0077\u0065\u0072\u0020\u0070\u0072ef\u0065\u0072\u0065\u006ec\u0065\u0073\u0020\u0069\u0073\u0020\u006e\u006f\u0074 a\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_gedbf := NewViewerPreferences()
	if _caada := _aaddag.Get("H\u0069\u0064\u0065\u0054\u006f\u006f\u006c\u0062\u0061\u0072"); _caada != nil {
		if _fecdg, _afabf := _bgd.GetBool(_caada); _afabf {
			_gedbf._ebbdd = (*bool)(_fecdg)
		}
	}
	if _eeada := _aaddag.Get("H\u0069\u0064\u0065\u004d\u0065\u006e\u0075\u0062\u0061\u0072"); _eeada != nil {
		if _fcdee, _aeebg := _bgd.GetBool(_eeada); _aeebg {
			_gedbf._gfca = (*bool)(_fcdee)
		}
	}
	if _fcaec := _aaddag.Get("\u0048\u0069\u0064e\u0057\u0069\u006e\u0064\u006f\u0077\u0055\u0049"); _fcaec != nil {
		if _efgcf, _bbedee := _bgd.GetBool(_fcaec); _bbedee {
			_gedbf._eagcc = (*bool)(_efgcf)
		}
	}
	if _ceadb := _aaddag.Get("\u0046i\u0074\u0057\u0069\u006e\u0064\u006fw"); _ceadb != nil {
		if _eddbc, _befdf := _bgd.GetBool(_ceadb); _befdf {
			_gedbf._faccc = (*bool)(_eddbc)
		}
	}
	if _abcfd := _aaddag.Get("\u0043\u0065\u006et\u0065\u0072\u0057\u0069\u006e\u0064\u006f\u0077"); _abcfd != nil {
		if _aggc, _feecc := _bgd.GetBool(_abcfd); _feecc {
			_gedbf._bbfdf = (*bool)(_aggc)
		}
	}
	if _gcaca := _aaddag.Get("\u0044i\u0073p\u006c\u0061\u0079\u0044\u006f\u0063\u0054\u0069\u0074\u006c\u0065"); _gcaca != nil {
		if _gbaaf, _ffeac := _bgd.GetBool(_gcaca); _ffeac {
			_gedbf._fcdcbd = (*bool)(_gbaaf)
		}
	}
	if _eeebdb := _aaddag.Get("N\u006f\u006e\u0046\u0075ll\u0053c\u0072\u0065\u0065\u006e\u0050a\u0067\u0065\u004d\u006f\u0064\u0065"); _eeebdb != nil {
		if _facbae, _ffdad := _bgd.GetName(_eeebdb); _ffdad {
			_gedbf._ggfcc = NonFullScreenPageMode(*_facbae)
		}
	}
	if _afdabd := _aaddag.Get("\u0044i\u0072\u0065\u0063\u0074\u0069\u006fn"); _afdabd != nil {
		if _ddfge, _fedd := _bgd.GetName(_afdabd); _fedd {
			_gedbf._fdcge = Direction(*_ddfge)
		}
	}
	if _adeebf := _aaddag.Get("\u0056\u0069\u0065\u0077\u0041\u0072\u0065\u0061"); _adeebf != nil {
		if _accac, _bbdab := _bgd.GetName(_adeebf); _bbdab {
			_gedbf._eabg = PageBoundary(*_accac)
		}
	}
	if _geafe := _aaddag.Get("\u0056\u0069\u0065\u0077\u0043\u006c\u0069\u0070"); _geafe != nil {
		if _dbaee, _dabga := _bgd.GetName(_geafe); _dabga {
			_gedbf._bedce = PageBoundary(*_dbaee)
		}
	}
	if _feab := _aaddag.Get("\u0050r\u0069\u006e\u0074\u0041\u0072\u0065a"); _feab != nil {
		if _faffcc, _fbgfd := _bgd.GetName(_feab); _fbgfd {
			_gedbf._fccec = PageBoundary(*_faffcc)
		}
	}
	if _feaff := _aaddag.Get("\u0050r\u0069\u006e\u0074\u0043\u006c\u0069p"); _feaff != nil {
		if _ceecb, _gbdfb := _bgd.GetName(_feaff); _gbdfb {
			_gedbf._fffgf = PageBoundary(*_ceecb)
		}
	}
	if _gbfgc := _aaddag.Get("\u0050\u0072\u0069n\u0074\u0053\u0063\u0061\u006c\u0069\u006e\u0067"); _gbfgc != nil {
		if _gecgd, _gcdgc := _bgd.GetName(_gbfgc); _gcdgc {
			_gedbf._edfcg = PrintScaling(*_gecgd)
		}
	}
	if _cgbde := _aaddag.Get("\u0044\u0075\u0070\u006c\u0065\u0078"); _cgbde != nil {
		if _edebg, _gbfe := _bgd.GetName(_cgbde); _gbfe {
			_gedbf._affbc = Duplex(*_edebg)
		}
	}
	if _bbece := _aaddag.Get("\u0050\u0069\u0063\u006b\u0054\u0072\u0061\u0079\u0042\u0079\u0050\u0044F\u0053\u0069\u007a\u0065"); _bbece != nil {
		if _ceeca, _edaca := _bgd.GetBool(_bbece); _edaca {
			_gedbf._babbb = (*bool)(_ceeca)
		}
	}
	if _eccb := _aaddag.Get("\u0050\u0072\u0069\u006e\u0074\u0050\u0061\u0067\u0065R\u0061\u006e\u0067\u0065"); _eccb != nil {
		if _bcgad, _cgbgee := _bgd.GetArray(_eccb); _cgbgee {
			_gedbf._gdfab = make([]int, _bcgad.Len())
			for _ggbc := range _gedbf._gdfab {
				if _fgddf := _bcgad.Get(_ggbc); _fgddf != nil {
					if _efcef, _dfagge := _bgd.GetInt(_fgddf); _dfagge {
						_gedbf._gdfab[_ggbc] = int(*_efcef)
					}
				}
			}
		}
	}
	if _acde := _aaddag.Get("\u004eu\u006d\u0043\u006f\u0070\u0069\u0065s"); _acde != nil {
		if _cddf, _cfcc := _bgd.GetInt(_acde); _cfcc {
			_gedbf._bcdg = int(*_cddf)
		}
	}
	return _gedbf, nil
}

func _cfgfg(_beee _bgd.PdfObject) (*PdfColorspaceSpecialPattern, error) {
	_fg.Log.Trace("\u004e\u0065\u0077\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020\u0043\u0053\u0020\u0066\u0072\u006fm\u0020\u006f\u0062\u006a\u003a\u0020\u0025\u0073\u0020\u0025\u0054", _beee.String(), _beee)
	_bffd := NewPdfColorspaceSpecialPattern()
	if _edff, _bgeb := _beee.(*_bgd.PdfIndirectObject); _bgeb {
		_bffd._fgfg = _edff
	}
	_beee = _bgd.TraceToDirectObject(_beee)
	if _afaga, _gadf := _beee.(*_bgd.PdfObjectName); _gadf {
		if *_afaga != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			return nil, _f.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
		return _bffd, nil
	}
	_ecce, _fbef := _beee.(*_bgd.PdfObjectArray)
	if !_fbef {
		_fg.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061t\u0074\u0065\u0072\u006e\u0020\u0043\u0053 \u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0023\u0076", _beee)
		return nil, _f.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0050\u0061\u0074\u0074e\u0072n\u0020C\u0053\u0020\u006f\u0062\u006a\u0065\u0063t")
	}
	if _ecce.Len() != 1 && _ecce.Len() != 2 {
		_fg.Log.Error("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079\u003a %\u0023\u0076", _ecce)
		return nil, _f.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065r\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_beee = _ecce.Get(0)
	if _cgaa, _gefd := _beee.(*_bgd.PdfObjectName); _gefd {
		if *_cgaa != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			_fg.Log.Error("\u0049\u006e\u0076al\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020C\u0053 \u0061r\u0072\u0061\u0079\u0020\u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0023\u0076", _cgaa)
			return nil, _f.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
	}
	if _ecce.Len() > 1 {
		_beee = _ecce.Get(1)
		_beee = _bgd.TraceToDirectObject(_beee)
		_cfga, _ccec := NewPdfColorspaceFromPdfObject(_beee)
		if _ccec != nil {
			return nil, _ccec
		}
		_bffd.UnderlyingCS = _cfga
	}
	_fg.Log.Trace("R\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0077i\u0074\u0068\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079in\u0067\u0020\u0063s\u003a \u0025\u0054", _bffd.UnderlyingCS)
	return _bffd, nil
}

// ImageToRGB converts an image with samples in Separation CS to an image with samples specified in
// DeviceRGB CS.
func (_fecfd *PdfColorspaceSpecialSeparation) ImageToRGB(img Image) (Image, error) {
	_dge := _eaa.NewReader(img.getBase())
	_bece := _daf.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), _fecfd.AlternateSpace.GetNumComponents(), nil, img._bdgdb, nil)
	_dcdff := _eaa.NewWriter(_bece)
	_bgaae := _da.Pow(2, float64(img.BitsPerComponent)) - 1
	_fg.Log.Trace("\u0053\u0065\u0070a\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0073\u0070\u0061\u0063\u0065\u0020\u002d\u003e\u0020\u0054\u006f\u0052\u0047\u0042\u0020\u0063o\u006e\u0076\u0065\u0072\u0073\u0069\u006f\u006e")
	_fg.Log.Trace("\u0054i\u006et\u0054\u0072\u0061\u006e\u0073f\u006f\u0072m\u003a\u0020\u0025\u002b\u0076", _fecfd.TintTransform)
	_bcfdg := _fecfd.AlternateSpace.DecodeArray()
	var (
		_beeeg uint32
		_ggec  error
	)
	for {
		_beeeg, _ggec = _dge.ReadSample()
		if _ggec == _ca.EOF {
			break
		}
		if _ggec != nil {
			return img, _ggec
		}
		_bgef := float64(_beeeg) / _bgaae
		_dbgg, _gafc := _fecfd.TintTransform.Evaluate([]float64{_bgef})
		if _gafc != nil {
			return img, _gafc
		}
		for _cdfc, _fgab := range _dbgg {
			_eegab := _daf.LinearInterpolate(_fgab, _bcfdg[_cdfc*2], _bcfdg[_cdfc*2+1], 0, 1)
			if _gafc = _dcdff.WriteSample(uint32(_eegab * _bgaae)); _gafc != nil {
				return img, _gafc
			}
		}
	}
	return _fecfd.AlternateSpace.ImageToRGB(_acfa(&_bece))
}

// RemoveChild removes a specific KValue child from the kChildren slice.
func (_ecdgf *KDict) RemoveChild(kv *KValue) bool {
	for _eefab, _aaffa := range _ecdgf._fabbb {
		if _aaffa == kv {
			_ecdgf._fabbb = append(_ecdgf._fabbb[:_eefab], _ecdgf._fabbb[_eefab+1:]...)
			return true
		}
	}
	return false
}

// AddImageResource adds an image to the XObject resources.
func (_gffce *PdfPage) AddImageResource(name _bgd.PdfObjectName, ximg *XObjectImage) error {
	var _cgfbb *_bgd.PdfObjectDictionary
	if _gffce.Resources.XObject == nil {
		_cgfbb = _bgd.MakeDict()
		_gffce.Resources.XObject = _cgfbb
	} else {
		var _bedbc bool
		_cgfbb, _bedbc = (_gffce.Resources.XObject).(*_bgd.PdfObjectDictionary)
		if !_bedbc {
			return _gb.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u0078\u0072\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020\u0074\u0079p\u0065")
		}
	}
	_cgfbb.Set(name, ximg.ToPdfObject())
	return nil
}

// LTV represents an LTV (Long-Term Validation) client. It is used to LTV
// enable signatures by adding validation and revocation data (certificate,
// OCSP and CRL information) to the DSS dictionary of a PDF document.
//
// LTV is added through the DSS by:
//   - Adding certificates, OCSP and CRL information in the global scope of the
//     DSS. The global data is used for validating any of the signatures present
//     in the document.
//   - Adding certificates, OCSP and CRL information for a single signature,
//     through an entry in the VRI dictionary of the DSS. The added data is used
//     for validating that particular signature only. This is the recommended
//     method for adding validation data for a signature. However, this is not
//     is not possible in the same revision the signature is applied. Validation
//     data for a signature is added based on the Contents entry of the signature,
//     which is known only after the revision is written. Even if the Contents
//     are known (e.g. when signing externally), updating the DSS at that point
//     would invalidate the calculated signature. As a result, if adding LTV
//     in the same revision is a requirement, use the first method.
//     See LTV.EnableChain.
//
// The client applies both methods, when possible.
//
// If `LTV.SkipExisting` is set to true (the default), validations are
// not added for signatures which are already present in the VRI entry of the
// document's DSS dictionary.
type LTV struct {

	// CertClient is the client used to retrieve certificates.
	CertClient *_bed.CertClient

	// OCSPClient is the client used to retrieve OCSP validation information.
	OCSPClient *_bed.OCSPClient

	// CRLClient is the client used to retrieve CRL validation information.
	CRLClient *_bed.CRLClient

	// SkipExisting specifies whether existing signature validations
	// should be skipped.
	SkipExisting bool
	_deefd       *PdfAppender
	_bfafg       *DSS
}

// SetFileName sets the pdf writer file name for metered usage tracker.
func (_gadab *PdfWriter) SetFileName(name string) { _gadab._cfadf = name }

func (_fcdgeg *PdfSignature) extractChainFromCert() ([]*_cb.Certificate, error) {
	var _ffeaec *_bgd.PdfObjectArray
	switch _bafc := _fcdgeg.Cert.(type) {
	case *_bgd.PdfObjectString:
		_ffeaec = _bgd.MakeArray(_bafc)
	case *_bgd.PdfObjectArray:
		_ffeaec = _bafc
	default:
		return nil, _f.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _bafc)
	}
	var _bcfea _ea.Buffer
	for _, _dbbfc := range _ffeaec.Elements() {
		_faee, _fdcda := _bgd.GetString(_dbbfc)
		if !_fdcda {
			return nil, _f.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054", _dbbfc)
		}
		if _, _fdffg := _bcfea.Write(_faee.Bytes()); _fdffg != nil {
			return nil, _fdffg
		}
	}
	return _cb.ParseCertificates(_bcfea.Bytes())
}

// WatermarkTextOptions contains options for configuring the text watermark process.
type WatermarkTextOptions struct {

	// opacity, 0.5 by default.
	Alpha float64

	// font size, 20 by default.
	FontSize float64

	// it is mandatory to set FontPath to the path of .ttf font file you would like to use for drawing.
	FontPath string

	// font color, black by default.
	FontColor _e.Color

	// rotation angle in degrees, 0 by default.
	Angle float64
}

// B returns the value of the B component of the color.
func (_aabcf *PdfColorLab) B() float64 { return _aabcf[2] }

// PdfActionSound represents a sound action.
type PdfActionSound struct {
	*PdfAction
	Sound       _bgd.PdfObject
	Volume      _bgd.PdfObject
	Synchronous _bgd.PdfObject
	Repeat      _bgd.PdfObject
	Mix         _bgd.PdfObject
}

// GetContext returns the annotation context which contains the specific type-dependent context.
// The context represents the subannotation.
func (_edb *PdfAnnotation) GetContext() PdfModel {
	if _edb == nil {
		return nil
	}
	return _edb._dabfb
}

// BorderStyle defines border type, typically used for annotations.
type BorderStyle int

func (_fcaf *Artifact) GenerateMap() map[string]_bgd.PdfObject {
	_eebb := make(map[string]_bgd.PdfObject)
	if _fcaf.Type != ArtifactTypeNone {
		_eebb["\u0054\u0079\u0070\u0065"] = _bgd.MakeName(string(_fcaf.Type))
	}
	if _fcaf.BBox != nil {
		_eebb["\u0042\u0042\u006f\u0078"] = _bgd.MakeArrayFromFloats([]float64{_fcaf.BBox.Llx, _fcaf.BBox.Lly, _fcaf.BBox.Urx, _fcaf.BBox.Ury})
	}
	if len(_fcaf.AttachPositions) > 0 {
		var _bfgd []_bgd.PdfObject
		for _, _dbfa := range _fcaf.AttachPositions {
			_bfgd = append(_bfgd, _bgd.MakeName(string(_dbfa)))
		}
		_eebb["\u0041\u0074\u0074\u0061\u0063\u0068"] = _bgd.MakeArray(_bfgd...)
	}
	if _fcaf.Subtype != "" {
		_eebb["\u0053u\u0062\u0074\u0079\u0070\u0065"] = _bgd.MakeName(_fcaf.Subtype)
	}
	return _eebb
}

// ToPdfObject implements interface PdfModel.
func (_ccf *PdfActionJavaScript) ToPdfObject() _bgd.PdfObject {
	_ccf.PdfAction.ToPdfObject()
	_ebc := _ccf._fab
	_aefd := _ebc.PdfObject.(*_bgd.PdfObjectDictionary)
	_aefd.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeJavaScript)))
	_aefd.SetIfNotNil("\u004a\u0053", _ccf.JS)
	return _ebc
}

func _bdcec(_baeda _bgd.PdfObject) (*PdfColorspaceLab, error) {
	_fbfc := NewPdfColorspaceLab()
	if _afacf, _cgbgb := _baeda.(*_bgd.PdfIndirectObject); _cgbgb {
		_fbfc._dccfbb = _afacf
	}
	_baeda = _bgd.TraceToDirectObject(_baeda)
	_abea, _ddfe := _baeda.(*_bgd.PdfObjectArray)
	if !_ddfe {
		return nil, _f.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _abea.Len() != 2 {
		return nil, _f.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_baeda = _bgd.TraceToDirectObject(_abea.Get(0))
	_cdcb, _ddfe := _baeda.(*_bgd.PdfObjectName)
	if !_ddfe {
		return nil, _f.Errorf("\u006c\u0061\u0062\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if *_cdcb != "\u004c\u0061\u0062" {
		return nil, _f.Errorf("n\u006ft\u0020\u0061\u0020\u004c\u0061\u0062\u0020\u0063o\u006c\u006f\u0072\u0073pa\u0063\u0065")
	}
	_baeda = _bgd.TraceToDirectObject(_abea.Get(1))
	_fbgcc, _ddfe := _baeda.(*_bgd.PdfObjectDictionary)
	if !_ddfe {
		return nil, _f.Errorf("c\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006ev\u0061l\u0069\u0064")
	}
	_baeda = _fbgcc.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_baeda = _bgd.TraceToDirectObject(_baeda)
	_cdaac, _ddfe := _baeda.(*_bgd.PdfObjectArray)
	if !_ddfe {
		return nil, _f.Errorf("\u006c\u0061\u0062\u0020In\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069n\u0074")
	}
	if _cdaac.Len() != 3 {
		return nil, _f.Errorf("\u006c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
	}
	_agec, _cfeg := _cdaac.GetAsFloat64Slice()
	if _cfeg != nil {
		return nil, _cfeg
	}
	_fbfc.WhitePoint = _agec
	_baeda = _fbgcc.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _baeda != nil {
		_baeda = _bgd.TraceToDirectObject(_baeda)
		_daeed, _bgbe := _baeda.(*_bgd.PdfObjectArray)
		if !_bgbe {
			return nil, _f.Errorf("\u006c\u0061\u0062: \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
		}
		if _daeed.Len() != 3 {
			return nil, _f.Errorf("\u006c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
		}
		_bfaee, _eac := _daeed.GetAsFloat64Slice()
		if _eac != nil {
			return nil, _eac
		}
		_fbfc.BlackPoint = _bfaee
	}
	_baeda = _fbgcc.Get("\u0052\u0061\u006eg\u0065")
	if _baeda != nil {
		_baeda = _bgd.TraceToDirectObject(_baeda)
		_cfec, _aacb := _baeda.(*_bgd.PdfObjectArray)
		if !_aacb {
			_fg.Log.Error("\u0052\u0061n\u0067\u0065\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
			return nil, _f.Errorf("\u006ca\u0062:\u0020\u0054\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if _cfec.Len() != 4 {
			_fg.Log.Error("\u0052\u0061\u006e\u0067\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020e\u0072\u0072\u006f\u0072")
			return nil, _f.Errorf("\u006c\u0061b\u003a\u0020\u0052a\u006e\u0067\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_caba, _aaeb := _cfec.GetAsFloat64Slice()
		if _aaeb != nil {
			return nil, _aaeb
		}
		_fbfc.Range = _caba
	}
	return _fbfc, nil
}

// PdfColorspaceSpecialPattern is a Pattern colorspace.
// Can be defined either as /Pattern or with an underlying colorspace [/Pattern cs].
type PdfColorspaceSpecialPattern struct {
	UnderlyingCS PdfColorspace
	_fgfg        *_bgd.PdfIndirectObject
}

// NewPdfAnnotationProjection returns a new projection annotation.
func NewPdfAnnotationProjection() *PdfAnnotationProjection {
	_cdbf := NewPdfAnnotation()
	_efg := &PdfAnnotationProjection{}
	_efg.PdfAnnotation = _cdbf
	_efg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cdbf.SetContext(_efg)
	return _efg
}

// DecodeArray returns the range of color component values in the Lab colorspace.
func (_befd *PdfColorspaceLab) DecodeArray() []float64 {
	_afaa := []float64{0, 100}
	if _befd != nil && _befd.Range != nil && len(_befd.Range) == 4 {
		_afaa = append(_afaa, _befd.Range...)
	} else {
		_afaa = append(_afaa, -100, 100, -100, 100)
	}
	return _afaa
}

// NewPdfAnnotationTrapNet returns a new trapnet annotation.
func NewPdfAnnotationTrapNet() *PdfAnnotationTrapNet {
	_ddgd := NewPdfAnnotation()
	_eagd := &PdfAnnotationTrapNet{}
	_eagd.PdfAnnotation = _ddgd
	_ddgd.SetContext(_eagd)
	return _eagd
}

func _eagb(_ccecb *_bgd.PdfObjectDictionary) {
	_ffge, _gfeb := _bgd.GetArray(_ccecb.Get("\u0057\u0069\u0064\u0074\u0068\u0073"))
	_ceba, _ebgda := _bgd.GetIntVal(_ccecb.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r"))
	_agba, _cgcd := _bgd.GetIntVal(_ccecb.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072"))
	if _gfeb && _ebgda && _cgcd {
		_gecac := _ffge.Len()
		if _gecac != _agba-_ceba+1 {
			_fg.Log.Debug("\u0055\u006e\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0057\u0069\u0064\u0074\u0068\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076\u002c\u0020\u004c\u0061\u0073t\u0043\u0068\u0061\u0072\u003a\u0020\u0025\u0076", _gecac, _agba)
			_aeba := _bgd.PdfObjectInteger(_ceba + _gecac - 1)
			_ccecb.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", &_aeba)
		}
	}
}

// ToPdfObject converts the pdfCIDFontType0 to a PDF representation.
func (_bacdc *pdfCIDFontType0) ToPdfObject() _bgd.PdfObject { return _bgd.MakeNull() }

// A returns the value of the A component of the color.
func (_ebbb *PdfColorLab) A() float64 { return _ebbb[1] }

func _gbaba(_bddeg *_bgd.PdfObjectStream) (*PdfFunctionType4, error) {
	_dbgec := &PdfFunctionType4{}
	_dbgec._baegf = _bddeg
	_abfdd := _bddeg.PdfObjectDictionary
	_dffb, _eage := _bgd.TraceToDirectObject(_abfdd.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_bgd.PdfObjectArray)
	if !_eage {
		_fg.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _dffb.Len()%2 != 0 {
		_fg.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _gb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_cgec, _ffca := _dffb.ToFloat64Array()
	if _ffca != nil {
		return nil, _ffca
	}
	_dbgec.Domain = _cgec
	_dffb, _eage = _bgd.TraceToDirectObject(_abfdd.Get("\u0052\u0061\u006eg\u0065")).(*_bgd.PdfObjectArray)
	if _eage {
		if _dffb.Len() < 0 || _dffb.Len()%2 != 0 {
			return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_fcedf, _cddbbe := _dffb.ToFloat64Array()
		if _cddbbe != nil {
			return nil, _cddbbe
		}
		_dbgec.Range = _fcedf
	}
	_fgcfb, _ffca := _bgd.DecodeStream(_bddeg)
	if _ffca != nil {
		return nil, _ffca
	}
	_dbgec._bbbdd = _fgcfb
	_aaef := _af.NewPSParser(_fgcfb)
	_bfeca, _ffca := _aaef.Parse()
	if _ffca != nil {
		return nil, _ffca
	}
	_dbgec.Program = _bfeca
	return _dbgec, nil
}

// SetBorderWidth sets the style's border width.
func (_affg *PdfBorderStyle) SetBorderWidth(width float64) { _affg.W = &width }

// ImageToRGB converts an image in CMYK32 colorspace to an RGB image.
func (_eecb *PdfColorspaceDeviceCMYK) ImageToRGB(img Image) (Image, error) {
	_fg.Log.Trace("\u0043\u004d\u0059\u004b\u0033\u0032\u0020\u002d\u003e\u0020\u0052\u0047\u0042")
	_fg.Log.Trace("I\u006d\u0061\u0067\u0065\u0020\u0042P\u0043\u003a\u0020\u0025\u0064\u002c \u0043\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020%\u0064", img.BitsPerComponent, img.ColorComponents)
	_fg.Log.Trace("\u004c\u0065\u006e \u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0064", len(img.Data))
	_fg.Log.Trace("H\u0065\u0069\u0067\u0068t:\u0020%\u0064\u002c\u0020\u0057\u0069d\u0074\u0068\u003a\u0020\u0025\u0064", img.Height, img.Width)
	_aedcc, _ffcfe := _daf.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._bdgdb, img._agcea)
	if _ffcfe != nil {
		return Image{}, _ffcfe
	}
	_cfaf, _ffcfe := _daf.NRGBAConverter.Convert(_aedcc)
	if _ffcfe != nil {
		return Image{}, _ffcfe
	}
	return _acfa(_cfaf.Base()), nil
}

func _gcdfc() _ge.Time { _adcf.Lock(); defer _adcf.Unlock(); return _fcfbfa }

// StdFontName represents name of a standard font.
type StdFontName = _fe.StdFontName

func _fgbfc(_ccafe *_bgd.PdfObjectDictionary) (*PdfShadingType6, error) {
	_eabee := PdfShadingType6{}
	_ddcde := _ccafe.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _ddcde == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_fgaf, _gcdce := _ddcde.(*_bgd.PdfObjectInteger)
	if !_gcdce {
		_fg.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _ddcde)
		return nil, _bgd.ErrTypeError
	}
	_eabee.BitsPerCoordinate = _fgaf
	_ddcde = _ccafe.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _ddcde == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_fgaf, _gcdce = _ddcde.(*_bgd.PdfObjectInteger)
	if !_gcdce {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _ddcde)
		return nil, _bgd.ErrTypeError
	}
	_eabee.BitsPerComponent = _fgaf
	_ddcde = _ccafe.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _ddcde == nil {
		_fg.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_fgaf, _gcdce = _ddcde.(*_bgd.PdfObjectInteger)
	if !_gcdce {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _ddcde)
		return nil, _bgd.ErrTypeError
	}
	_eabee.BitsPerComponent = _fgaf
	_ddcde = _ccafe.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _ddcde == nil {
		_fg.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_geaad, _gcdce := _ddcde.(*_bgd.PdfObjectArray)
	if !_gcdce {
		_fg.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ddcde)
		return nil, _bgd.ErrTypeError
	}
	_eabee.Decode = _geaad
	if _fdgdb := _ccafe.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _fdgdb != nil {
		_eabee.Function = []PdfFunction{}
		if _daegde, _ccfc := _fdgdb.(*_bgd.PdfObjectArray); _ccfc {
			for _, _deafeg := range _daegde.Elements() {
				_eaec, _cccb := _fbbb(_deafeg)
				if _cccb != nil {
					_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _cccb)
					return nil, _cccb
				}
				_eabee.Function = append(_eabee.Function, _eaec)
			}
		} else {
			_gbccf, _fgbae := _fbbb(_fdgdb)
			if _fgbae != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _fgbae)
				return nil, _fgbae
			}
			_eabee.Function = append(_eabee.Function, _gbccf)
		}
	}
	return &_eabee, nil
}

// GetFillImage get attached model.Image in push button.
func (_ecdd *PdfFieldButton) GetFillImage() *Image {
	if _ecdd.IsPush() {
		return _ecdd._fbedg
	}
	return nil
}

// SetEncoder sets the encoding for the underlying font.
// TODO(peterwilliams97): Change function signature to SetEncoder(encoder *textencoding.simpleEncoder).
// TODO(gunnsth): Makes sense if SetEncoder is removed from the interface fonts.Font as proposed in PR #260.
func (_eagag *pdfFontSimple) SetEncoder(encoder _dabf.TextEncoder) { _eagag._dcfdfd = encoder }

// Insert adds a top level outline item in the outline,
// at the specified index.
func (_cffb *Outline) Insert(index uint, item *OutlineItem) {
	_gcabb := uint(len(_cffb.Entries))
	if index > _gcabb {
		index = _gcabb
	}
	_cffb.Entries = append(_cffb.Entries[:index], append([]*OutlineItem{item}, _cffb.Entries[index:]...)...)
}

// NewPdfColorspaceDeviceN returns an initialized PdfColorspaceDeviceN.
func NewPdfColorspaceDeviceN() *PdfColorspaceDeviceN { _bbgg := &PdfColorspaceDeviceN{}; return _bbgg }

// GetRefObject returns the reference object of the KValue.
func (_aaffb *KValue) GetRefObject() _bgd.PdfObject { return _aaffb._bcdd }

func (_efcce *DSS) add(_egbf *[]*_bgd.PdfObjectStream, _ceefa map[string]*_bgd.PdfObjectStream, _degg [][]byte) ([]*_bgd.PdfObjectStream, error) {
	_ddfec := make([]*_bgd.PdfObjectStream, 0, len(_degg))
	for _, _bbed := range _degg {
		_dace, _ggdff := _deagf(_bbed)
		if _ggdff != nil {
			return nil, _ggdff
		}
		_abfe, _geaa := _ceefa[string(_dace)]
		if !_geaa {
			_abfe, _ggdff = _bgd.MakeStream(_bbed, _bgd.NewRawEncoder())
			if _ggdff != nil {
				return nil, _ggdff
			}
			_ceefa[string(_dace)] = _abfe
			*_egbf = append(*_egbf, _abfe)
		}
		_ddfec = append(_ddfec, _abfe)
	}
	return _ddfec, nil
}

func _gbdea() string { _adcf.Lock(); defer _adcf.Unlock(); return _fcfe }

// PdfAnnotationLink represents Link annotations.
// (Section 12.5.6.5 p. 403).
type PdfAnnotationLink struct {
	*PdfAnnotation
	A          _bgd.PdfObject
	Dest       _bgd.PdfObject
	H          _bgd.PdfObject
	PA         _bgd.PdfObject
	QuadPoints _bgd.PdfObject
	BS         _bgd.PdfObject
	_ecb       *PdfAction
	_adf       *PdfReader
}

// NewPdfActionGoToR returns a new "go to remote" action.
func NewPdfActionGoToR() *PdfActionGoToR {
	_efa := NewPdfAction()
	_agg := &PdfActionGoToR{}
	_agg.PdfAction = _efa
	_efa.SetContext(_agg)
	return _agg
}

func _fafbb() string { _adcf.Lock(); defer _adcf.Unlock(); return _agbbd }

// NewPdfColorPattern returns an empty color pattern.
func NewPdfColorPattern() *PdfColorPattern { _deef := &PdfColorPattern{}; return _deef }

// SetDirection sets the value of the direction.
func (_aeec *ViewerPreferences) SetDirection(direction Direction) { _aeec._fdcge = direction }

// ToPdfObject returns the PdfFontDescriptor as a PDF dictionary inside an indirect object.
func (_adebd *PdfFontDescriptor) ToPdfObject() _bgd.PdfObject {
	_dddda := _bgd.MakeDict()
	if _adebd._gfgee == nil {
		_adebd._gfgee = &_bgd.PdfIndirectObject{}
	}
	_adebd._gfgee.PdfObject = _dddda
	_dddda.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072"))
	if _adebd.FontName != nil {
		_dddda.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _adebd.FontName)
	}
	if _adebd.FontFamily != nil {
		_dddda.Set("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079", _adebd.FontFamily)
	}
	if _adebd.FontStretch != nil {
		_dddda.Set("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068", _adebd.FontStretch)
	}
	if _adebd.FontWeight != nil {
		_dddda.Set("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074", _adebd.FontWeight)
	}
	if _adebd.Flags != nil {
		_dddda.Set("\u0046\u006c\u0061g\u0073", _adebd.Flags)
	}
	if _adebd.FontBBox != nil {
		_dddda.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _adebd.FontBBox)
	}
	if _adebd.ItalicAngle != nil {
		_dddda.Set("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065", _adebd.ItalicAngle)
	}
	if _adebd.Ascent != nil {
		_dddda.Set("\u0041\u0073\u0063\u0065\u006e\u0074", _adebd.Ascent)
	}
	if _adebd.Descent != nil {
		_dddda.Set("\u0044e\u0073\u0063\u0065\u006e\u0074", _adebd.Descent)
	}
	if _adebd.Leading != nil {
		_dddda.Set("\u004ce\u0061\u0064\u0069\u006e\u0067", _adebd.Leading)
	}
	if _adebd.CapHeight != nil {
		_dddda.Set("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t", _adebd.CapHeight)
	}
	if _adebd.XHeight != nil {
		_dddda.Set("\u0058H\u0065\u0069\u0067\u0068\u0074", _adebd.XHeight)
	}
	if _adebd.StemV != nil {
		_dddda.Set("\u0053\u0074\u0065m\u0056", _adebd.StemV)
	}
	if _adebd.StemH != nil {
		_dddda.Set("\u0053\u0074\u0065m\u0048", _adebd.StemH)
	}
	if _adebd.AvgWidth != nil {
		_dddda.Set("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068", _adebd.AvgWidth)
	}
	if _adebd.MaxWidth != nil {
		_dddda.Set("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068", _adebd.MaxWidth)
	}
	if _adebd.MissingWidth != nil {
		_dddda.Set("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068", _adebd.MissingWidth)
	}
	if _adebd.FontFile != nil {
		_dddda.Set("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065", _adebd.FontFile)
	}
	if _adebd.FontFile2 != nil {
		_dddda.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652", _adebd.FontFile2)
	}
	if _adebd.FontFile3 != nil {
		_dddda.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653", _adebd.FontFile3)
	}
	if _adebd.CharSet != nil {
		_dddda.Set("\u0043h\u0061\u0072\u0053\u0065\u0074", _adebd.CharSet)
	}
	if _adebd.Style != nil {
		_dddda.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _adebd.FontName)
	}
	if _adebd.Lang != nil {
		_dddda.Set("\u004c\u0061\u006e\u0067", _adebd.Lang)
	}
	if _adebd.FD != nil {
		_dddda.Set("\u0046\u0044", _adebd.FD)
	}
	if _adebd.CIDSet != nil {
		_dddda.Set("\u0043\u0049\u0044\u0053\u0065\u0074", _adebd.CIDSet)
	}
	return _adebd._gfgee
}

func _dcbeb(_cceg *_bgd.PdfObjectStream) (*PdfFunctionType0, error) {
	_ecgfb := &PdfFunctionType0{}
	_ecgfb._fgeeg = _cceg
	_feeg := _cceg.PdfObjectDictionary
	_bdgda, _fdac := _bgd.TraceToDirectObject(_feeg.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_bgd.PdfObjectArray)
	if !_fdac {
		_fg.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _bdgda.Len() < 0 || _bdgda.Len()%2 != 0 {
		_fg.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _gb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_ecgfb.NumInputs = _bdgda.Len() / 2
	_gfbd, _gbea := _bdgda.ToFloat64Array()
	if _gbea != nil {
		return nil, _gbea
	}
	_ecgfb.Domain = _gfbd
	_bdgda, _fdac = _bgd.TraceToDirectObject(_feeg.Get("\u0052\u0061\u006eg\u0065")).(*_bgd.PdfObjectArray)
	if !_fdac {
		_fg.Log.Error("\u0052\u0061\u006e\u0067e \u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _bdgda.Len() < 0 || _bdgda.Len()%2 != 0 {
		return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_ecgfb.NumOutputs = _bdgda.Len() / 2
	_cgcfbb, _gbea := _bdgda.ToFloat64Array()
	if _gbea != nil {
		return nil, _gbea
	}
	_ecgfb.Range = _cgcfbb
	_bdgda, _fdac = _bgd.TraceToDirectObject(_feeg.Get("\u0053\u0069\u007a\u0065")).(*_bgd.PdfObjectArray)
	if !_fdac {
		_fg.Log.Error("\u0053i\u007ae\u0020\u006e\u006f\u0074\u0020s\u0070\u0065c\u0069\u0066\u0069\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_cddbb, _gbea := _bdgda.ToIntegerArray()
	if _gbea != nil {
		return nil, _gbea
	}
	if len(_cddbb) != _ecgfb.NumInputs {
		_fg.Log.Error("T\u0061\u0062\u006c\u0065\u0020\u0073\u0069\u007a\u0065\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063h\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072 o\u0066\u0020\u0069n\u0070u\u0074\u0073")
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ecgfb.Size = _cddbb
	_cebea, _fdac := _bgd.TraceToDirectObject(_feeg.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065")).(*_bgd.PdfObjectInteger)
	if !_fdac {
		_fg.Log.Error("B\u0069\u0074\u0073\u0050\u0065\u0072S\u0061\u006d\u0070\u006c\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if *_cebea != 1 && *_cebea != 2 && *_cebea != 4 && *_cebea != 8 && *_cebea != 12 && *_cebea != 16 && *_cebea != 24 && *_cebea != 32 {
		_fg.Log.Error("\u0042\u0069\u0074s \u0070\u0065\u0072\u0020\u0073\u0061\u006d\u0070\u006ce\u0020o\u0075t\u0073i\u0064\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064\u0029", *_cebea)
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ecgfb.BitsPerSample = int(*_cebea)
	_ecgfb.Order = 1
	_dbbad, _fdac := _bgd.TraceToDirectObject(_feeg.Get("\u004f\u0072\u0064e\u0072")).(*_bgd.PdfObjectInteger)
	if _fdac {
		if *_dbbad != 1 && *_dbbad != 3 {
			_fg.Log.Error("\u0049n\u0076a\u006c\u0069\u0064\u0020\u006fr\u0064\u0065r\u0020\u0028\u0025\u0064\u0029", *_dbbad)
			return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
		}
		_ecgfb.Order = int(*_dbbad)
	}
	_bdgda, _fdac = _bgd.TraceToDirectObject(_feeg.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_bgd.PdfObjectArray)
	if _fdac {
		_dbag, _ccadb := _bdgda.ToFloat64Array()
		if _ccadb != nil {
			return nil, _ccadb
		}
		_ecgfb.Encode = _dbag
	}
	_bdgda, _fdac = _bgd.TraceToDirectObject(_feeg.Get("\u0044\u0065\u0063\u006f\u0064\u0065")).(*_bgd.PdfObjectArray)
	if _fdac {
		_ccfec, _egag := _bdgda.ToFloat64Array()
		if _egag != nil {
			return nil, _egag
		}
		_ecgfb.Decode = _ccfec
	}
	_efbgfg, _gbea := _bgd.DecodeStream(_cceg)
	if _gbea != nil {
		return nil, _gbea
	}
	_ecgfb._eggg = _efbgfg
	return _ecgfb, nil
}

func (_ddg *PdfReader) newPdfActionFromIndirectObject(_gbb *_bgd.PdfIndirectObject) (*PdfAction, error) {
	_ded, _cdb := _gbb.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_cdb {
		return nil, _f.Errorf("\u0061\u0063\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u006e\u006f\u0074 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _ddg._gggb.GetModelFromPrimitive(_ded); model != nil {
		_cgbc, _ab := model.(*PdfAction)
		if !_ab {
			return nil, _f.Errorf("\u0063\u0061c\u0068\u0065\u0064\u0020\u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050\u0044\u0046\u0020\u0061\u0063ti\u006f\u006e")
		}
		return _cgbc, nil
	}
	_gec := &PdfAction{}
	_gec._fab = _gbb
	_ddg._gggb.Register(_ded, _gec)
	if _aag := _ded.Get("\u0054\u0079\u0070\u0065"); _aag != nil {
		_cdf, _ebe := _aag.(*_bgd.PdfObjectName)
		if !_ebe {
			_fg.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _aag)
		} else {
			if *_cdf != "\u0041\u0063\u0074\u0069\u006f\u006e" {
				_fg.Log.Trace("\u0055\u006e\u0073u\u0073\u0070\u0065\u0063t\u0065\u0064\u0020\u0054\u0079\u0070\u0065 \u0021\u003d\u0020\u0041\u0063\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029", *_cdf)
			}
			_gec.Type = _cdf
		}
	}
	if _dbd := _ded.Get("\u004e\u0065\u0078\u0074"); _dbd != nil {
		_gec.Next = _dbd
	}
	if _dafab := _ded.Get("\u0053"); _dafab != nil {
		_gec.S = _dafab
	}
	_fagf, _ffdg := _gec.S.(*_bgd.PdfObjectName)
	if !_ffdg {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _gec.S)
		return nil, _f.Errorf("\u0069\u006e\u0076al\u0069\u0064\u0020\u0053\u0020\u006f\u0062\u006a\u0065c\u0074 \u0074y\u0070e\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _gec.S)
	}
	_feg := PdfActionType(_fagf.String())
	switch _feg {
	case ActionTypeGoTo:
		_gecc, _dad := _ddg.newPdfActionGotoFromDict(_ded)
		if _dad != nil {
			return nil, _dad
		}
		_gecc.PdfAction = _gec
		_gec._df = _gecc
		return _gec, nil
	case ActionTypeGoToR:
		_fced, _daa := _ddg.newPdfActionGotoRFromDict(_ded)
		if _daa != nil {
			return nil, _daa
		}
		_fced.PdfAction = _gec
		_gec._df = _fced
		return _gec, nil
	case ActionTypeGoToE:
		_dbg, _ggcd := _ddg.newPdfActionGotoEFromDict(_ded)
		if _ggcd != nil {
			return nil, _ggcd
		}
		_dbg.PdfAction = _gec
		_gec._df = _dbg
		return _gec, nil
	case ActionTypeLaunch:
		_beb, _fcb := _ddg.newPdfActionLaunchFromDict(_ded)
		if _fcb != nil {
			return nil, _fcb
		}
		_beb.PdfAction = _gec
		_gec._df = _beb
		return _gec, nil
	case ActionTypeThread:
		_ced, _afd := _ddg.newPdfActionThreadFromDict(_ded)
		if _afd != nil {
			return nil, _afd
		}
		_ced.PdfAction = _gec
		_gec._df = _ced
		return _gec, nil
	case ActionTypeURI:
		_fda, _gab := _ddg.newPdfActionURIFromDict(_ded)
		if _gab != nil {
			return nil, _gab
		}
		_fda.PdfAction = _gec
		_gec._df = _fda
		return _gec, nil
	case ActionTypeSound:
		_dcb, _bgfe := _ddg.newPdfActionSoundFromDict(_ded)
		if _bgfe != nil {
			return nil, _bgfe
		}
		_dcb.PdfAction = _gec
		_gec._df = _dcb
		return _gec, nil
	case ActionTypeMovie:
		_cdfa, _bce := _ddg.newPdfActionMovieFromDict(_ded)
		if _bce != nil {
			return nil, _bce
		}
		_cdfa.PdfAction = _gec
		_gec._df = _cdfa
		return _gec, nil
	case ActionTypeHide:
		_fcc, _caf := _ddg.newPdfActionHideFromDict(_ded)
		if _caf != nil {
			return nil, _caf
		}
		_fcc.PdfAction = _gec
		_gec._df = _fcc
		return _gec, nil
	case ActionTypeNamed:
		_cbg, _gfde := _ddg.newPdfActionNamedFromDict(_ded)
		if _gfde != nil {
			return nil, _gfde
		}
		_cbg.PdfAction = _gec
		_gec._df = _cbg
		return _gec, nil
	case ActionTypeSubmitForm:
		_afa, _fbga := _ddg.newPdfActionSubmitFormFromDict(_ded)
		if _fbga != nil {
			return nil, _fbga
		}
		_afa.PdfAction = _gec
		_gec._df = _afa
		return _gec, nil
	case ActionTypeResetForm:
		_adc, _fff := _ddg.newPdfActionResetFormFromDict(_ded)
		if _fff != nil {
			return nil, _fff
		}
		_adc.PdfAction = _gec
		_gec._df = _adc
		return _gec, nil
	case ActionTypeImportData:
		_dedc, _agc := _ddg.newPdfActionImportDataFromDict(_ded)
		if _agc != nil {
			return nil, _agc
		}
		_dedc.PdfAction = _gec
		_gec._df = _dedc
		return _gec, nil
	case ActionTypeSetOCGState:
		_ccg, _dae := _ddg.newPdfActionSetOCGStateFromDict(_ded)
		if _dae != nil {
			return nil, _dae
		}
		_ccg.PdfAction = _gec
		_gec._df = _ccg
		return _gec, nil
	case ActionTypeRendition:
		_ecg, _ceg := _ddg.newPdfActionRenditionFromDict(_ded)
		if _ceg != nil {
			return nil, _ceg
		}
		_ecg.PdfAction = _gec
		_gec._df = _ecg
		return _gec, nil
	case ActionTypeTrans:
		_bcf, _gded := _ddg.newPdfActionTransFromDict(_ded)
		if _gded != nil {
			return nil, _gded
		}
		_bcf.PdfAction = _gec
		_gec._df = _bcf
		return _gec, nil
	case ActionTypeGoTo3DView:
		_fdaf, _edg := _ddg.newPdfActionGoTo3DViewFromDict(_ded)
		if _edg != nil {
			return nil, _edg
		}
		_fdaf.PdfAction = _gec
		_gec._df = _fdaf
		return _gec, nil
	case ActionTypeJavaScript:
		_gfg, _aead := _ddg.newPdfActionJavaScriptFromDict(_ded)
		if _aead != nil {
			return nil, _aead
		}
		_gfg.PdfAction = _gec
		_gec._df = _gfg
		return _gec, nil
	}
	_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006eg\u0020u\u006ek\u006eo\u0077\u006e\u0020\u0061\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073", _feg)
	return nil, nil
}

// IsCenterWindow returns the value of the centerWindow flag.
func (_afgcg *ViewerPreferences) IsCenterWindow() bool {
	if _afgcg._bbfdf == nil {
		return false
	}
	return *_afgcg._bbfdf
}

// ToPdfObject returns the PDF representation of the shading pattern.
func (_gagec *PdfShadingPattern) ToPdfObject() _bgd.PdfObject {
	_gagec.PdfPattern.ToPdfObject()
	_eadca := _gagec.getDict()
	if _gagec.Shading != nil {
		_eadca.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _gagec.Shading.ToPdfObject())
	}
	if _gagec.Matrix != nil {
		_eadca.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _gagec.Matrix)
	}
	if _gagec.ExtGState != nil {
		_eadca.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _gagec.ExtGState)
	}
	return _gagec._eaddb
}

// ToPdfObject implements interface PdfModel.
func (_gfdf *PdfAnnotationCircle) ToPdfObject() _bgd.PdfObject {
	_gfdf.PdfAnnotation.ToPdfObject()
	_aafe := _gfdf._eag
	_fbf := _aafe.PdfObject.(*_bgd.PdfObjectDictionary)
	_gfdf.appendToPdfDictionary(_fbf)
	_fbf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0043\u0069\u0072\u0063\u006c\u0065"))
	_fbf.SetIfNotNil("\u0042\u0053", _gfdf.BS)
	_fbf.SetIfNotNil("\u0049\u0043", _gfdf.IC)
	_fbf.SetIfNotNil("\u0042\u0045", _gfdf.BE)
	_fbf.SetIfNotNil("\u0052\u0044", _gfdf.RD)
	return _aafe
}

// NewPdfPageResourcesFromDict creates and returns a new PdfPageResources object
// from the input dictionary.
func NewPdfPageResourcesFromDict(dict *_bgd.PdfObjectDictionary) (*PdfPageResources, error) {
	_edfdf := NewPdfPageResources()
	if _ggggf := dict.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _ggggf != nil {
		_edfdf.ExtGState = _ggggf
	}
	if _aeded := dict.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065"); _aeded != nil && !_bgd.IsNullObject(_aeded) {
		_edfdf.ColorSpace = _aeded
	}
	if _dgdfag := dict.Get("\u0050a\u0074\u0074\u0065\u0072\u006e"); _dgdfag != nil {
		_edfdf.Pattern = _dgdfag
	}
	if _dgdff := dict.Get("\u0053h\u0061\u0064\u0069\u006e\u0067"); _dgdff != nil {
		_edfdf.Shading = _dgdff
	}
	if _bbde := dict.Get("\u0058O\u0062\u006a\u0065\u0063\u0074"); _bbde != nil {
		_edfdf.XObject = _bbde
	}
	if _bdcdd := _bgd.ResolveReference(dict.Get("\u0046\u006f\u006e\u0074")); _bdcdd != nil {
		_edfdf.Font = _bdcdd
	}
	if _cbce := dict.Get("\u0050r\u006f\u0063\u0053\u0065\u0074"); _cbce != nil {
		_edfdf.ProcSet = _cbce
	}
	if _gcec := dict.Get("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073"); _gcec != nil {
		_edfdf.Properties = _gcec
	}
	return _edfdf, nil
}

// ToInteger convert to an integer format.
func (_cgba *PdfColorLab) ToInteger(bits int) [3]uint32 {
	_dbca := _da.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_dbca * _cgba.L()), uint32(_dbca * _cgba.A()), uint32(_dbca * _cgba.B())}
}

// SetPageNumber sets the page number.
func (_fddf *KDict) SetPageNumber(pageNumber int64) { _fddf._eddd = pageNumber }

var (
	_fgfa  = _b.MustCompile("\u005cd\u002b\u0020\u0064\u0069c\u0074\u005c\u0073\u002b\u0028d\u0075p\u005cs\u002b\u0029\u003f\u0062\u0065\u0067\u0069n")
	_ceeed = _b.MustCompile("\u005e\u005cs\u002a\u002f\u0028\u005c\u0053\u002b\u003f\u0029\u005c\u0073\u002b\u0028\u002e\u002b\u003f\u0029\u005c\u0073\u002b\u0064\u0065\u0066\\s\u002a\u0024")
	_bcfaf = _b.MustCompile("\u005e\u005c\u0073*\u0064\u0075\u0070\u005c\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002a\u002f\u0028\u005c\u0077\u002b\u003f\u0029\u0028\u003f\u003a\u005c\u002e\u005c\u0064\u002b)\u003f\u005c\u0073\u002b\u0070\u0075\u0074\u0024")
	_gbefb = "\u002f\u0045\u006e\u0063od\u0069\u006e\u0067\u0020\u0032\u0035\u0036\u0020\u0061\u0072\u0072\u0061\u0079"
	_dabc  = "\u0072\u0065\u0061d\u006f\u006e\u006c\u0079\u0020\u0064\u0065\u0066"
	_fbbe  = "\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0066\u0069\u006c\u0065\u0020e\u0065\u0078\u0065\u0063"
)

// ParsePdfObject parses input pdf object into given output intent.
func (_eceec *PdfOutputIntent) ParsePdfObject(object _bgd.PdfObject) error {
	_fgaaa, _gffb := _bgd.GetDict(object)
	if !_gffb {
		_fg.Log.Error("\u0055\u006e\u006bno\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020%\u0054 \u0066o\u0072 \u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0069\u006e\u0074\u0065\u006e\u0074", object)
		return _gb.New("\u0075\u006e\u006b\u006e\u006fw\u006e\u0020\u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0069\u006e\u0074\u0065\u006e\u0074")
	}
	_eceec._gfcce = _fgaaa
	_eceec.Type, _ = _fgaaa.GetString("\u0054\u0079\u0070\u0065")
	_eeacf, _gffb := _fgaaa.GetString("\u0053")
	if _gffb {
		switch _eeacf {
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411":
			_eceec.S = PdfOutputIntentTypeA1
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00412":
			_eceec.S = PdfOutputIntentTypeA2
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00413":
			_eceec.S = PdfOutputIntentTypeA3
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00414":
			_eceec.S = PdfOutputIntentTypeA4
		case "\u0047\u0054\u0053\u005f\u0050\u0044\u0046\u0058":
			_eceec.S = PdfOutputIntentTypeX
		}
	}
	_eceec.OutputCondition, _ = _fgaaa.GetString("\u004fu\u0074p\u0075\u0074\u0043\u006f\u006e\u0064\u0069\u0074\u0069\u006f\u006e")
	_eceec.OutputConditionIdentifier, _ = _fgaaa.GetString("\u004fu\u0074\u0070\u0075\u0074C\u006f\u006e\u0064\u0069\u0074i\u006fn\u0049d\u0065\u006e\u0074\u0069\u0066\u0069\u0065r")
	_eceec.RegistryName, _ = _fgaaa.GetString("\u0052\u0065\u0067i\u0073\u0074\u0072\u0079\u004e\u0061\u006d\u0065")
	_eceec.Info, _ = _fgaaa.GetString("\u0049\u006e\u0066\u006f")
	if _cedf, _dagaf := _bgd.GetStream(_fgaaa.Get("\u0044\u0065\u0073\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0050\u0072o\u0066\u0069\u006c\u0065")); _dagaf {
		_eceec.ColorComponents, _ = _bgd.GetIntVal(_cedf.Get("\u004e"))
		_baeea, _gdceff := _bgd.DecodeStream(_cedf)
		if _gdceff != nil {
			return _gdceff
		}
		_eceec.DestOutputProfile = _baeea
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_bdgc *PdfAnnotationScreen) ToPdfObject() _bgd.PdfObject {
	_bdgc.PdfAnnotation.ToPdfObject()
	_eea := _bdgc._eag
	_gace := _eea.PdfObject.(*_bgd.PdfObjectDictionary)
	_gace.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0053\u0063\u0072\u0065\u0065\u006e"))
	_gace.SetIfNotNil("\u0054", _bdgc.T)
	_gace.SetIfNotNil("\u004d\u004b", _bdgc.MK)
	_gace.SetIfNotNil("\u0041", _bdgc.A)
	_gace.SetIfNotNil("\u0041\u0041", _bdgc.AA)
	return _eea
}

// GetChildren returns the children of the K dictionary object.
func (_abeff *KDict) GetChildren() []*KValue { return _abeff._fabbb }

// ToPdfObject implements interface PdfModel.
func (_egfa *PdfAnnotationLink) ToPdfObject() _bgd.PdfObject {
	_egfa.PdfAnnotation.ToPdfObject()
	_dfda := _egfa._eag
	_bfcc := _dfda.PdfObject.(*_bgd.PdfObjectDictionary)
	_bfcc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u004c\u0069\u006e\u006b"))
	if _egfa._ecb != nil && _egfa._ecb._df != nil {
		_bfcc.Set("\u0041", _egfa._ecb._df.ToPdfObject())
	} else if _egfa.A != nil {
		_bfcc.Set("\u0041", _egfa.A)
	}
	_bfcc.SetIfNotNil("\u0044\u0065\u0073\u0074", _egfa.Dest)
	_bfcc.SetIfNotNil("\u0048", _egfa.H)
	_bfcc.SetIfNotNil("\u0050\u0041", _egfa.PA)
	_bfcc.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _egfa.QuadPoints)
	_bfcc.SetIfNotNil("\u0042\u0053", _egfa.BS)
	return _dfda
}

var (
	TabOrderRow       TabOrderType = "\u0052"
	TabOrderColumn    TabOrderType = "\u0043"
	TabOrderStructure TabOrderType = "\u0053"
)

// Encoder returns the font's text encoder.
func (_cbbde pdfCIDFontType2) Encoder() _dabf.TextEncoder { return _cbbde._bgadg }

func _ecbb(_efeeg *_bgd.PdfObjectDictionary) (*PdfShadingType5, error) {
	_cdcfe := PdfShadingType5{}
	_eebbag := _efeeg.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _eebbag == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_ggbfc, _aacdc := _eebbag.(*_bgd.PdfObjectInteger)
	if !_aacdc {
		_fg.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _eebbag)
		return nil, _bgd.ErrTypeError
	}
	_cdcfe.BitsPerCoordinate = _ggbfc
	_eebbag = _efeeg.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _eebbag == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_ggbfc, _aacdc = _eebbag.(*_bgd.PdfObjectInteger)
	if !_aacdc {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _eebbag)
		return nil, _bgd.ErrTypeError
	}
	_cdcfe.BitsPerComponent = _ggbfc
	_eebbag = _efeeg.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077")
	if _eebbag == nil {
		_fg.Log.Debug("\u0052\u0065\u0071u\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0056\u0065\u0072\u0074\u0069c\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077")
		return nil, ErrRequiredAttributeMissing
	}
	_ggbfc, _aacdc = _eebbag.(*_bgd.PdfObjectInteger)
	if !_aacdc {
		_fg.Log.Debug("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006et\u0065\u0067\u0065\u0072\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _eebbag)
		return nil, _bgd.ErrTypeError
	}
	_cdcfe.VerticesPerRow = _ggbfc
	_eebbag = _efeeg.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _eebbag == nil {
		_fg.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_agefb, _aacdc := _eebbag.(*_bgd.PdfObjectArray)
	if !_aacdc {
		_fg.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _eebbag)
		return nil, _bgd.ErrTypeError
	}
	_cdcfe.Decode = _agefb
	if _eaaef := _efeeg.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _eaaef != nil {
		_cdcfe.Function = []PdfFunction{}
		if _begce, _ggggd := _eaaef.(*_bgd.PdfObjectArray); _ggggd {
			for _, _cedba := range _begce.Elements() {
				_gaafad, _beagc := _fbbb(_cedba)
				if _beagc != nil {
					_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _beagc)
					return nil, _beagc
				}
				_cdcfe.Function = append(_cdcfe.Function, _gaafad)
			}
		} else {
			_cbced, _dgabef := _fbbb(_eaaef)
			if _dgabef != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dgabef)
				return nil, _dgabef
			}
			_cdcfe.Function = append(_cdcfe.Function, _cbced)
		}
	}
	return &_cdcfe, nil
}

func _ebgd(_aeac *_bgd.PdfIndirectObject, _ebagc *_bgd.PdfObjectDictionary) (*DSS, error) {
	if _aeac == nil {
		_aeac = _bgd.MakeIndirectObject(nil)
	}
	_aeac.PdfObject = _bgd.MakeDict()
	_ecca := map[string]*VRI{}
	if _fedc, _geage := _bgd.GetDict(_ebagc.Get("\u0056\u0052\u0049")); _geage {
		for _, _agff := range _fedc.Keys() {
			if _bdga, _adfd := _bgd.GetDict(_fedc.Get(_agff)); _adfd {
				_ecca[_ef.ToUpper(_agff.String())] = _afacg(_bdga)
			}
		}
	}
	return &DSS{Certs: _gcbc(_ebagc.Get("\u0043\u0065\u0072t\u0073")), OCSPs: _gcbc(_ebagc.Get("\u004f\u0043\u0053P\u0073")), CRLs: _gcbc(_ebagc.Get("\u0043\u0052\u004c\u0073")), VRI: _ecca, _bdbe: _aeac}, nil
}

// NewPdfActionTrans returns a new "trans" action.
func NewPdfActionTrans() *PdfActionTrans {
	_dfg := NewPdfAction()
	_bgf := &PdfActionTrans{}
	_bgf.PdfAction = _dfg
	_dfg.SetContext(_bgf)
	return _bgf
}

// NewPdfColorspaceSpecialPattern returns a new pattern color.
func NewPdfColorspaceSpecialPattern() *PdfColorspaceSpecialPattern {
	return &PdfColorspaceSpecialPattern{}
}

// ImageToRGB converts ICCBased colorspace image to RGB and returns the result.
func (_bgbd *PdfColorspaceICCBased) ImageToRGB(img Image) (Image, error) {
	if _bgbd.Alternate == nil {
		_fg.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _bgbd.N == 1 {
			_fg.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_bebfe := NewPdfColorspaceDeviceGray()
			return _bebfe.ImageToRGB(img)
		} else if _bgbd.N == 3 {
			_fg.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return img, nil
		} else if _bgbd.N == 4 {
			_fg.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_dbfd := NewPdfColorspaceDeviceCMYK()
			return _dbfd.ImageToRGB(img)
		} else {
			return img, _gb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_fg.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _bgbd)
	_efgab, _feeag := _bgbd.Alternate.ImageToRGB(img)
	_fg.Log.Trace("I\u0043C\u0020\u0049\u006e\u0070\u0075\u0074\u0020\u0069m\u0061\u0067\u0065\u003a %\u002b\u0076", img)
	_fg.Log.Trace("I\u0043\u0043\u0020\u004fut\u0070u\u0074\u0020\u0069\u006d\u0061g\u0065\u003a\u0020\u0025\u002b\u0076", _efgab)
	return _efgab, _feeag
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a Lab device.
func (_cgfea *PdfColorspaceLab) GetNumComponents() int { return 3 }

// PdfColorspaceDeviceNAttributes contains additional information about the components of colour space that
// conforming readers may use. Conforming readers need not use the alternateSpace and tintTransform parameters,
// and may instead use a custom blending algorithms, along with other information provided in the attributes
// dictionary if present.
type PdfColorspaceDeviceNAttributes struct {
	Subtype     *_bgd.PdfObjectName
	Colorants   _bgd.PdfObject
	Process     _bgd.PdfObject
	MixingHints _bgd.PdfObject
	_gecge      *_bgd.PdfIndirectObject
}

// NewLTV returns a new LTV client.
func NewLTV(appender *PdfAppender) (*LTV, error) {
	_daddg := appender.Reader.DSS
	if _daddg == nil {
		_daddg = NewDSS()
	}
	if _cgffg := _daddg.GenerateHashMaps(); _cgffg != nil {
		return nil, _cgffg
	}
	return &LTV{CertClient: _bed.NewCertClient(), OCSPClient: _bed.NewOCSPClient(), CRLClient: _bed.NewCRLClient(), SkipExisting: true, _deefd: appender, _bfafg: _daddg}, nil
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_egce *PdfColorspaceLab) ToPdfObject() _bgd.PdfObject {
	_addb := _bgd.MakeArray()
	_addb.Append(_bgd.MakeName("\u004c\u0061\u0062"))
	_afbg := _bgd.MakeDict()
	if _egce.WhitePoint != nil {
		_dbbb := _bgd.MakeArray(_bgd.MakeFloat(_egce.WhitePoint[0]), _bgd.MakeFloat(_egce.WhitePoint[1]), _bgd.MakeFloat(_egce.WhitePoint[2]))
		_afbg.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _dbbb)
	} else {
		_fg.Log.Error("\u004c\u0061\u0062: \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057h\u0069t\u0065P\u006fi\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	if _egce.BlackPoint != nil {
		_efgef := _bgd.MakeArray(_bgd.MakeFloat(_egce.BlackPoint[0]), _bgd.MakeFloat(_egce.BlackPoint[1]), _bgd.MakeFloat(_egce.BlackPoint[2]))
		_afbg.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _efgef)
	}
	if _egce.Range != nil {
		_beage := _bgd.MakeArray(_bgd.MakeFloat(_egce.Range[0]), _bgd.MakeFloat(_egce.Range[1]), _bgd.MakeFloat(_egce.Range[2]), _bgd.MakeFloat(_egce.Range[3]))
		_afbg.Set("\u0052\u0061\u006eg\u0065", _beage)
	}
	_addb.Append(_afbg)
	if _egce._dccfbb != nil {
		_egce._dccfbb.PdfObject = _addb
		return _egce._dccfbb
	}
	return _addb
}

// Write writes the Appender output to io.Writer.
// It can only be called once and further invocations will result in an error.
func (_acee *PdfAppender) Write(w _ca.Writer) error {
	if _acee._dage {
		return _gb.New("\u0061\u0070\u0070\u0065\u006e\u0064\u0065\u0072\u0020\u0077\u0072\u0069\u0074e\u0020\u0063\u0061\u006e\u0020\u006fn\u006c\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0076\u006f\u006b\u0065\u0064 \u006f\u006e\u0063\u0065")
	}
	_bbbac := NewPdfWriter()
	_fbad, _ecag := _bgd.GetDict(_bbbac._cfaee)
	if !_ecag {
		return _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_cbff, _ecag := _fbad.Get("\u004b\u0069\u0064\u0073").(*_bgd.PdfObjectArray)
	if !_ecag {
		return _gb.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_ddbb, _ecag := _fbad.Get("\u0043\u006f\u0075n\u0074").(*_bgd.PdfObjectInteger)
	if !_ecag {
		return _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	_efgc := _acee._gdf._ccade
	_eggd := _efgc.GetTrailer()
	if _eggd == nil {
		return _gb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_bee, _ecag := _bgd.GetIndirect(_eggd.Get("\u0052\u006f\u006f\u0074"))
	if !_ecag {
		return _gb.New("c\u0061\u0074\u0061\u006c\u006f\u0067 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064")
	}
	_fcec, _ecag := _bgd.GetDict(_bee)
	if !_ecag {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _bee, *_eggd)
		return _gb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_fcga := false
	for _, _caad := range _acee._gdf.AcroForm.signatureFields() {
		if _caad.Lock != nil {
			_fcga = true
			break
		}
	}
	if _fcga {
		_bbbac._fcgc = _bee
	}
	for _, _afcbe := range _fcec.Keys() {
		if _bbbac._aaea.Get(_afcbe) == nil {
			_eegf := _fcec.Get(_afcbe)
			_bbbac._aaea.Set(_afcbe, _eegf)
		}
	}
	if _acee._cabc != nil {
		if _acee._cabc._gbfgd {
			if _edcb := _bgd.TraceToDirectObject(_acee._cabc.ToPdfObject()); !_bgd.IsNullObject(_edcb) {
				_bbbac._aaea.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _edcb)
				_acee.updateObjectsDeep(_edcb, nil)
			} else {
				_fg.Log.Debug("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020t\u0072\u0061\u0063e\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u0020o\u0062\u006a\u0065\u0063\u0074, \u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u002e")
			}
		} else {
			_bbbac._aaea.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _acee._cabc.ToPdfObject())
			_acee.updateObjectsDeep(_acee._cabc.ToPdfObject(), nil)
		}
	}
	if _acee._bcdeg != nil {
		_acee.updateObjectsDeep(_acee._bcdeg.ToPdfObject(), nil)
		_bbbac._aaea.Set("\u0044\u0053\u0053", _acee._bcdeg.GetContainingPdfObject())
	}
	if _acee._gdbgd != nil {
		_bbbac._aaea.Set("\u0050\u0065\u0072m\u0073", _acee._gdbgd.ToPdfObject())
		_acee.updateObjectsDeep(_acee._gdbgd.ToPdfObject(), nil)
	}
	if _bbbac._egbga.Major < 2 {
		_bbbac.AddExtension("\u0045\u0053\u0049\u0043", "\u0031\u002e\u0037", 5)
		_bbbac.AddExtension("\u0041\u0044\u0042\u0045", "\u0031\u002e\u0037", 8)
	}
	if _efcc, _efeg := _bgd.GetDict(_eggd.Get("\u0049\u006e\u0066\u006f")); _efeg {
		if _bfbe, _daeg := _bgd.GetDict(_bbbac._gefe); _daeg {
			for _, _fdgff := range _efcc.Keys() {
				if _bfbe.Get(_fdgff) == nil {
					_bfbe.Set(_fdgff, _efcc.Get(_fdgff))
				}
			}
		}
	}
	if _acee._ggag != nil {
		_bbbac._gefe = _bgd.MakeIndirectObject(_acee._ggag.ToPdfObject())
	}
	_acee.updateObjectsDeep(_bbbac._gefe, nil)
	_acee.updateObjectsDeep(_bbbac._fcgc, nil)
	_egbe := false
	if len(_acee._gdf.PageList) != len(_acee._ffcf) {
		_egbe = true
	} else {
		for _addc := range _acee._gdf.PageList {
			switch {
			case _acee._ffcf[_addc] == _acee._gdf.PageList[_addc]:
			case _acee._ffcf[_addc] == _acee.Reader.PageList[_addc]:
			default:
				_egbe = true
			}
			if _egbe {
				break
			}
		}
	}
	if _egbe {
		_acee.updateObjectsDeep(_bbbac._cfaee, nil)
	} else {
		_acee._gffc[_bbbac._cfaee] = struct{}{}
	}
	_bbbac._cfaee.ObjectNumber = _acee.Reader._bbfde.ObjectNumber
	_acee._baae[_bbbac._cfaee] = _acee.Reader._bbfde.ObjectNumber
	_bbd := []_bgd.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	for _, _caee := range _acee._ffcf {
		_fdfb := _caee.ToPdfObject()
		*_ddbb = *_ddbb + 1
		if _eeed, _ggcc := _fdfb.(*_bgd.PdfIndirectObject); _ggcc && _eeed.GetParser() == _acee._gdf._ccade {
			_cbff.Append(&_eeed.PdfObjectReference)
			continue
		}
		if _bbda, _bga := _bgd.GetDict(_fdfb); _bga {
			_dac, _cade := _bbda.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_bgd.PdfIndirectObject)
			for _cade {
				_fg.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _dac)
				_bggc, _bgea := _dac.PdfObject.(*_bgd.PdfObjectDictionary)
				if !_bgea {
					return _gb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
				}
				for _, _ggcf := range _bbd {
					_fg.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _ggcf)
					if _bbbe := _bbda.Get(_ggcf); _bbbe != nil {
						_fg.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
						if len(_caee._cdfec.Keys()) > 0 && !_egbe {
							_bef := _caee._cdfec
							if _eegb := _bef.Get(_ggcf); _eegb != nil {
								if _bbbe != _eegb {
									_fg.Log.Trace("\u0049\u006e\u0068\u0065\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u006f\u0072\u0069\u0067i\u006ea\u006c\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073\u002c\u0020\u0025\u0054", _ggcf, _eegb)
									_bbda.Set(_ggcf, _eegb)
								}
							}
						}
						continue
					}
					if _gegca := _bggc.Get(_ggcf); _gegca != nil {
						_fg.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _ggcf)
						_bbda.Set(_ggcf, _gegca)
					}
				}
				_dac, _cade = _bggc.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_bgd.PdfIndirectObject)
				_fg.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _bggc.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
			}
			if _egbe {
				_bbda.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _bbbac._cfaee)
			}
		}
		_acee.updateObjectsDeep(_fdfb, nil)
		_cbff.Append(_fdfb)
	}
	if _, _geff := _acee._bddc.Seek(0, _ca.SeekStart); _geff != nil {
		return _geff
	}
	_efga := make(map[SignatureHandler]_ca.Writer)
	_adbdg := _bgd.MakeArray()
	for _, _cdga := range _acee._ddce {
		if _cgeee, _adfg := _bgd.GetIndirect(_cdga); _adfg {
			if _fbc, _gdec := _cgeee.PdfObject.(*pdfSignDictionary); _gdec {
				_cgg := *_fbc._bcdbef
				var _eadg error
				_efga[_cgg], _eadg = _cgg.NewDigest(_fbc._egebe)
				if _eadg != nil {
					return _eadg
				}
				_adbdg.Append(_bgd.MakeInteger(0xfffff), _bgd.MakeInteger(0xfffff))
			}
		}
	}
	if _adbdg.Len() > 0 {
		_adbdg.Append(_bgd.MakeInteger(0xfffff), _bgd.MakeInteger(0xfffff))
	}
	for _, _eaac := range _acee._ddce {
		if _cegf, _edcf := _bgd.GetIndirect(_eaac); _edcf {
			if _daecc, _fcae := _cegf.PdfObject.(*pdfSignDictionary); _fcae {
				_daecc.Set("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _adbdg)
			}
		}
	}
	_cbb := len(_efga) > 0
	var _cgbg _ca.Reader = _acee._bddc
	if _cbb {
		_bcdc := make([]_ca.Writer, 0, len(_efga))
		for _, _ecd := range _efga {
			_bcdc = append(_bcdc, _ecd)
		}
		_cgbg = _ca.TeeReader(_acee._bddc, _ca.MultiWriter(_bcdc...))
	}
	_bgaa, _gaacc := _ca.Copy(w, _cgbg)
	if _gaacc != nil {
		return _gaacc
	}
	if len(_acee._ddce) == 0 {
		return nil
	}
	_bbbac._dceeb = _bgaa
	_bbbac.ObjNumOffset = _acee._gaae
	_bbbac._fgaba = true
	_bbbac._daffe = _acee._adda
	_bbbac._gebgb = _acee._cege
	_bbbac._bdgag = _acee._eega
	_bbbac._egbga = _acee._gdf.PdfVersion()
	_bbbac._gbcg = _acee._baae
	_bbbac._ddcee = _acee._badc.GetCrypter()
	_bbbac._abeb = _acee._badc.GetEncryptObj()
	_dgca := _acee._badc.GetXrefType()
	if _dgca != nil {
		_fcge := *_dgca == _bgd.XrefTypeObjectStream
		_bbbac._dadab = &_fcge
	}
	_bbbac._abccd = map[_bgd.PdfObject]struct{}{}
	_bbbac._edcbg = []_bgd.PdfObject{}
	for _, _gcf := range _acee._ddce {
		if _, _ecgd := _acee._gffc[_gcf]; _ecgd {
			continue
		}
		_bbbac.addObject(_gcf)
	}
	_baed := w
	if _cbb {
		_baed = _ea.NewBuffer(nil)
	}
	if _acee._cdg != "" && _bbbac._ddcee == nil {
		_bbbac.Encrypt([]byte(_acee._cdg), []byte(_acee._cdg), _acee._bcgd)
	}
	if _gecgb := _eggd.Get("\u0049\u0044"); _gecgb != nil {
		if _ddcb, _eegg := _bgd.GetArray(_gecgb); _eegg {
			_bbbac._beadb = _ddcb
		}
	}
	if _fecc := _bbbac.Write(_baed); _fecc != nil {
		return _fecc
	}
	if _cbb {
		_fbdg := _baed.(*_ea.Buffer).Bytes()
		_fgbe := _bgd.MakeArray()
		var _bbdg []*pdfSignDictionary
		var _eadd int64
		for _, _bfbf := range _bbbac._edcbg {
			if _ebag, _gaef := _bgd.GetIndirect(_bfbf); _gaef {
				if _bcgg, _eggda := _ebag.PdfObject.(*pdfSignDictionary); _eggda {
					_bbdg = append(_bbdg, _bcgg)
					_eed := _bcgg._becbf + int64(_bcgg._gcgged)
					_fgbe.Append(_bgd.MakeInteger(_eadd), _bgd.MakeInteger(_eed-_eadd))
					_eadd = _bcgg._becbf + int64(_bcgg._feefb)
				}
			}
		}
		_fgbe.Append(_bgd.MakeInteger(_eadd), _bgd.MakeInteger(_bgaa+int64(len(_fbdg))-_eadd))
		_ccdf := _fgbe.Write()
		for _, _feed := range _bbdg {
			_cbgc := int(_feed._becbf - _bgaa)
			for _gbdc := _feed._bdbga; _gbdc < _feed._gfagd; _gbdc++ {
				_fbdg[_cbgc+_gbdc] = ' '
			}
			_fgcg := _fbdg[_cbgc+_feed._bdbga : _cbgc+_feed._gfagd]
			copy(_fgcg, _ccdf)
		}
		var _dfbb int
		for _, _cbad := range _bbdg {
			_gadg := int(_cbad._becbf - _bgaa)
			_dddf := _fbdg[_dfbb : _gadg+_cbad._gcgged]
			_faab := *_cbad._bcdbef
			_efga[_faab].Write(_dddf)
			_dfbb = _gadg + _cbad._feefb
		}
		for _, _cbae := range _bbdg {
			_abba := _fbdg[_dfbb:]
			_bcagg := *_cbae._bcdbef
			_efga[_bcagg].Write(_abba)
		}
		for _, _fgacc := range _bbdg {
			_fgee := int(_fgacc._becbf - _bgaa)
			_cafc := *_fgacc._bcdbef
			_cebe := _efga[_cafc]
			if _caegf := _cafc.Sign(_fgacc._egebe, _cebe); _caegf != nil {
				return _caegf
			}
			_fgacc._egebe.ByteRange = _fgbe
			_eafe := _fgacc._egebe.Contents.Write()
			for _fcaee := _fgacc._bdbga; _fcaee < _fgacc._gfagd; _fcaee++ {
				_fbdg[_fgee+_fcaee] = ' '
			}
			for _facd := _fgacc._gcgged; _facd < _fgacc._feefb; _facd++ {
				_fbdg[_fgee+_facd] = ' '
			}
			_dgabdb := _fbdg[_fgee+_fgacc._bdbga : _fgee+_fgacc._gfagd]
			copy(_dgabdb, _ccdf)
			_dgabdb = _fbdg[_fgee+_fgacc._gcgged : _fgee+_fgacc._feefb]
			copy(_dgabdb, _eafe)
		}
		_bfbg := _ea.NewBuffer(_fbdg)
		_, _gaacc = _ca.Copy(w, _bfbg)
		if _gaacc != nil {
			return _gaacc
		}
	}
	_acee._dage = true
	return nil
}

func _cgcb(_abaa _bgd.PdfObject) (*PdfColorspaceSpecialSeparation, error) {
	_eebdf := NewPdfColorspaceSpecialSeparation()
	if _dbaca, _fcbc := _abaa.(*_bgd.PdfIndirectObject); _fcbc {
		_eebdf._gaeb = _dbaca
	}
	_abaa = _bgd.TraceToDirectObject(_abaa)
	_fcgg, _efgd := _abaa.(*_bgd.PdfObjectArray)
	if !_efgd {
		return nil, _f.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062je\u0063\u0074")
	}
	if _fcgg.Len() != 4 {
		return nil, _f.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074i\u006f\u006e \u0043\u0053\u003a\u0020\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006ce\u006e\u0067\u0074\u0068")
	}
	_abaa = _fcgg.Get(0)
	_dbbd, _efgd := _abaa.(*_bgd.PdfObjectName)
	if !_efgd {
		return nil, _f.Errorf("\u0073\u0065\u0070ar\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a \u0069n\u0076a\u006ci\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_dbbd != "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e" {
		return nil, _f.Errorf("\u0073\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020w\u0072o\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	_abaa = _fcgg.Get(1)
	_dbbd, _efgd = _abaa.(*_bgd.PdfObjectName)
	if !_efgd {
		return nil, _f.Errorf("\u0073\u0065pa\u0072\u0061\u0074i\u006f\u006e\u0020\u0043S: \u0049nv\u0061\u006c\u0069\u0064\u0020\u0063\u006flo\u0072\u0061\u006e\u0074\u0020\u006e\u0061m\u0065")
	}
	_eebdf.ColorantName = _dbbd
	_abaa = _fcgg.Get(2)
	_aeeg, _gegcf := NewPdfColorspaceFromPdfObject(_abaa)
	if _gegcf != nil {
		return nil, _gegcf
	}
	_eebdf.AlternateSpace = _aeeg
	_gcgcd, _gegcf := _fbbb(_fcgg.Get(3))
	if _gegcf != nil {
		return nil, _gegcf
	}
	_eebdf.TintTransform = _gcgcd
	return _eebdf, nil
}

// RemovePage removes a page by number.
func (_ggf *PdfAppender) RemovePage(pageNum int) {
	_dbfb := pageNum - 1
	_ggf._ffcf = append(_ggf._ffcf[0:_dbfb], _ggf._ffcf[pageNum:]...)
}

// BaseFont returns the font's "BaseFont" field.
func (_dgag *PdfFont) BaseFont() string { return _dgag.baseFields()._eebe }

// FieldFlattenOpts defines a set of options which can be used to configure
// the field flattening process.
type FieldFlattenOpts struct {

	// FilterFunc allows filtering the form fields used in the flattening
	// process. If the filter function returns true, the field is flattened,
	// otherwise it is skipped.
	// If a non-terminal field is discarded, all of its children (the fields
	// present in the Kids array) are discarded as well.
	// Non-terminal fields are kept in the AcroForm if one or more of their
	// child fields have not been selected for flattening.
	// If a filter function is not provided, all form fields are flattened.
	FilterFunc FieldFilterFunc

	// AnnotFilterFunc allows filtering the annotations in the flattening
	// process. If the filter function returns true, the annotation is flattened,
	// otherwise it is skipped.
	AnnotFilterFunc AnnotFilterFunc
}

// PdfOutlineItem represents an outline item dictionary (Table 153 - pp. 376 - 377).
type PdfOutlineItem struct {
	PdfOutlineTreeNode
	Title  *_bgd.PdfObjectString
	Parent *PdfOutlineTreeNode
	Prev   *PdfOutlineTreeNode
	Next   *PdfOutlineTreeNode
	Count  *int64
	Dest   _bgd.PdfObject
	A      _bgd.PdfObject
	SE     _bgd.PdfObject
	C      _bgd.PdfObject
	F      _bgd.PdfObject
	_aacdb *_bgd.PdfIndirectObject
}

// ToPdfObject converts PdfAcroForm to a PdfObject, i.e. an indirect object containing the
// AcroForm dictionary.
func (_eeaca *PdfAcroForm) ToPdfObject() _bgd.PdfObject {
	_efec := _eeaca._fecg
	_gacag := _efec.PdfObject.(*_bgd.PdfObjectDictionary)
	if _eeaca.Fields != nil {
		_ebgdb := _bgd.PdfObjectArray{}
		for _, _bcge := range *_eeaca.Fields {
			_cecbb := _bcge.GetContext()
			if _cecbb != nil {
				_ebgdb.Append(_cecbb.ToPdfObject())
			} else {
				_ebgdb.Append(_bcge.ToPdfObject())
			}
		}
		_gacag.Set("\u0046\u0069\u0065\u006c\u0064\u0073", &_ebgdb)
	}
	if _eeaca.NeedAppearances != nil {
		_gacag.Set("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073", _eeaca.NeedAppearances)
	} else {
		if _gdaa := _gacag.Get("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073"); _gdaa != nil {
			_gacag.Remove("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073")
		}
	}
	if _eeaca.SigFlags != nil {
		_gacag.Set("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073", _eeaca.SigFlags)
	}
	if _eeaca.CO != nil {
		_gacag.Set("\u0043\u004f", _eeaca.CO)
	}
	if _eeaca.DR != nil {
		_gacag.Set("\u0044\u0052", _eeaca.DR.ToPdfObject())
	}
	if _eeaca.DA != nil {
		_gacag.Set("\u0044\u0041", _eeaca.DA)
	}
	if _eeaca.Q != nil {
		_gacag.Set("\u0051", _eeaca.Q)
	}
	if _eeaca.XFA != nil {
		_gacag.Set("\u0058\u0046\u0041", _eeaca.XFA)
	}
	if _eeaca.ADBEEchoSign != nil {
		_gacag.Set("\u0041\u0044\u0042\u0045\u005f\u0045\u0063\u0068\u006f\u0053\u0069\u0067\u006e", _eeaca.ADBEEchoSign)
	}
	return _efec
}

// Encrypt encrypts the output file with a specified user/owner password.
func (_eeacac *PdfWriter) Encrypt(userPass, ownerPass []byte, options *EncryptOptions) error {
	_gcaef := RC4_128bit
	if options != nil {
		_gcaef = options.Algorithm
	}
	_aaced := _dab.PermOwner
	if options != nil {
		_aaced = options.Permissions
	}
	var _fabgbd _gfd.Filter
	switch _gcaef {
	case RC4_128bit:
		_fabgbd = _gfd.NewFilterV2(16)
	case AES_128bit:
		_fabgbd = _gfd.NewFilterAESV2()
	case AES_256bit:
		_fabgbd = _gfd.NewFilterAESV3()
	default:
		return _f.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020a\u006cg\u006fr\u0069\u0074\u0068\u006d\u003a\u0020\u0025v", options.Algorithm)
	}
	_degcc, _cgbff, _dbgaf := _bgd.PdfCryptNewEncrypt(_fabgbd, userPass, ownerPass, _aaced)
	if _dbgaf != nil {
		return _dbgaf
	}
	_eeacac._ddcee = _degcc
	if _cgbff.Major != 0 {
		_eeacac.SetVersion(_cgbff.Major, _cgbff.Minor)
	}
	_eeacac._bbfge = _cgbff.Encrypt
	_eeacac._fedfb, _eeacac._gdcfb = _cgbff.ID0, _cgbff.ID1
	_ddefb := _bgd.MakeIndirectObject(_cgbff.Encrypt)
	_eeacac._abeb = _ddefb
	_eeacac.addObject(_ddefb)
	return nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_fbefac *PdfShadingType3) ToPdfObject() _bgd.PdfObject {
	_fbefac.PdfShading.ToPdfObject()
	_bgffe, _ebcaf := _fbefac.getShadingDict()
	if _ebcaf != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _fbefac.Coords != nil {
		_bgffe.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _fbefac.Coords)
	}
	if _fbefac.Domain != nil {
		_bgffe.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _fbefac.Domain)
	}
	if _fbefac.Function != nil {
		if len(_fbefac.Function) == 1 {
			_bgffe.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fbefac.Function[0].ToPdfObject())
		} else {
			_cdbeda := _bgd.MakeArray()
			for _, _beecc := range _fbefac.Function {
				_cdbeda.Append(_beecc.ToPdfObject())
			}
			_bgffe.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _cdbeda)
		}
	}
	if _fbefac.Extend != nil {
		_bgffe.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _fbefac.Extend)
	}
	return _fbefac._gccfe
}

// GetAlphabet returns a map of the runes in `text` and their frequencies.
func GetAlphabet(text string) map[rune]int {
	_fecdc := map[rune]int{}
	for _, _febff := range text {
		_fecdc[_febff]++
	}
	return _fecdc
}

// NewCompositePdfFontFromTTFFile loads a composite font from a TTF font file. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTFFile.
func NewCompositePdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_ceaf, _cfff := _gc.Open(filePath)
	if _cfff != nil {
		_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u006f\u0070\u0065\u006e\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _cfff)
		return nil, _cfff
	}
	defer _ceaf.Close()
	return NewCompositePdfFontFromTTF(_ceaf)
}

// FontDescriptor returns font's PdfFontDescriptor. This may be a builtin descriptor for standard 14
// fonts but must be an explicit descriptor for other fonts.
func (_geedc *PdfFont) FontDescriptor() *PdfFontDescriptor {
	if _geedc.baseFields()._ggde != nil {
		return _geedc.baseFields()._ggde
	}
	if _cfgga := _geedc._cbec.getFontDescriptor(); _cfgga != nil {
		return _cfgga
	}
	_fg.Log.Error("\u0041\u006cl \u0066\u006f\u006et\u0073\u0020\u0068\u0061ve \u0061 D\u0065\u0073\u0063\u0072\u0069\u0070\u0074or\u002e\u0020\u0066\u006f\u006e\u0074\u003d%\u0073", _geedc)
	return nil
}

func _gaebc() string {
	_adcf.Lock()
	defer _adcf.Unlock()
	if len(_dccdf) > 0 {
		return _dccdf
	}
	return "\u0055n\u0069\u0044\u006f\u0063 \u002d\u0020\u0068\u0074\u0074p\u003a/\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069o"
}

// Encoder returns the font's text encoder.
func (_aabg pdfFontType0) Encoder() _dabf.TextEncoder { return _aabg._dbcf }

func (_fded *PdfReader) newPdfAnnotationSquigglyFromDict(_adeg *_bgd.PdfObjectDictionary) (*PdfAnnotationSquiggly, error) {
	_cdbe := PdfAnnotationSquiggly{}
	_bgbf, _ddeb := _fded.newPdfAnnotationMarkupFromDict(_adeg)
	if _ddeb != nil {
		return nil, _ddeb
	}
	_cdbe.PdfAnnotationMarkup = _bgbf
	_cdbe.QuadPoints = _adeg.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_cdbe, nil
}

// AnnotFilterFunc represents a PDF annotation filtering function. If the function
// returns true, the annotation is kept, otherwise it is discarded.
type AnnotFilterFunc func(*PdfAnnotation) bool

// HasExtGState checks if ExtGState name is available.
func (_gdgea *PdfPage) HasExtGState(name _bgd.PdfObjectName) bool {
	if _gdgea.Resources == nil {
		return false
	}
	if _gdgea.Resources.ExtGState == nil {
		return false
	}
	_bceba, _dcbdc := _bgd.TraceToDirectObject(_gdgea.Resources.ExtGState).(*_bgd.PdfObjectDictionary)
	if !_dcbdc {
		_fg.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _bgd.TraceToDirectObject(_gdgea.Resources.ExtGState))
		return false
	}
	_cgfgf := _bceba.Get(name)
	_cadd := _cgfgf != nil
	return _cadd
}

// NewMultipleFontEncoder returns instantiates a new *MultipleFontEncoder
func NewMultipleFontEncoder(fonts []*PdfFont) *MultipleFontEncoder {
	return &MultipleFontEncoder{_acaed: fonts, CurrentFont: fonts[0]}
}

// ToPdfObject implements interface PdfModel.
func (_defbf *PdfAnnotationStamp) ToPdfObject() _bgd.PdfObject {
	_defbf.PdfAnnotation.ToPdfObject()
	_cfa := _defbf._eag
	_adbd := _cfa.PdfObject.(*_bgd.PdfObjectDictionary)
	_defbf.appendToPdfDictionary(_adbd)
	_adbd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0053\u0074\u0061m\u0070"))
	_adbd.SetIfNotNil("\u004e\u0061\u006d\u0065", _defbf.Name)
	return _cfa
}

// Reset sets the multi font encoder to its initial state.
func (_afgc *MultipleFontEncoder) Reset() { _afgc.CurrentFont = _afgc._acaed[0] }

// GetNumComponents returns the number of color components (1 for CalGray).
func (_dcfdf *PdfColorCalGray) GetNumComponents() int { return 1 }

// NewPdfColorspaceCalGray returns a new CalGray colorspace object.
func NewPdfColorspaceCalGray() *PdfColorspaceCalGray {
	_feagg := &PdfColorspaceCalGray{}
	_feagg.BlackPoint = []float64{0.0, 0.0, 0.0}
	_feagg.Gamma = 1
	return _feagg
}

const (
	TrappedUnknown PdfInfoTrapped = "\u0055n\u006b\u006e\u006f\u0077\u006e"
	TrappedTrue    PdfInfoTrapped = "\u0054\u0072\u0075\u0065"
	TrappedFalse   PdfInfoTrapped = "\u0046\u0061\u006cs\u0065"
)

// ColorToRGB converts a CalGray color to an RGB color.
func (_begd *PdfColorspaceCalGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_bafe, _fbfa := color.(*PdfColorCalGray)
	if !_fbfa {
		_fg.Log.Debug("\u0049n\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006eo\u0074\u0020\u0063\u0061\u006c\u0020\u0067\u0072\u0061\u0079")
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	ANorm := _bafe.Val()
	X := _begd.WhitePoint[0] * _da.Pow(ANorm, _begd.Gamma)
	Y := _begd.WhitePoint[1] * _da.Pow(ANorm, _begd.Gamma)
	Z := _begd.WhitePoint[2] * _da.Pow(ANorm, _begd.Gamma)
	_ege := 3.240479*X + -1.537150*Y + -0.498535*Z
	_ccgg := -0.969256*X + 1.875992*Y + 0.041556*Z
	_ccfeg := 0.055648*X + -0.204043*Y + 1.057311*Z
	_ege = _da.Min(_da.Max(_ege, 0), 1.0)
	_ccgg = _da.Min(_da.Max(_ccgg, 0), 1.0)
	_ccfeg = _da.Min(_da.Max(_ccfeg, 0), 1.0)
	return NewPdfColorDeviceRGB(_ege, _ccgg, _ccfeg), nil
}

// Encoder returns the font's text encoder.
func (_bdfe *pdfFontSimple) Encoder() _dabf.TextEncoder {
	if _bdfe._dcfdfd != nil {
		return _bdfe._dcfdfd
	}
	if _bdfe._dfagc != nil {
		return _bdfe._dfagc
	}
	_fafg, _ := _dabf.NewSimpleTextEncoder("\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", nil)
	return _fafg
}

func _fcegd(_faacc *fontCommon) *pdfCIDFontType2 { return &pdfCIDFontType2{fontCommon: *_faacc} }

func _gede() _ge.Time { _adcf.Lock(); defer _adcf.Unlock(); return _eccfcf }

// NewPdfPage returns a new PDF page.
func NewPdfPage() *PdfPage {
	_dcfb := PdfPage{}
	_dcfb._cfdgca = _bgd.MakeDict()
	_dcfb.Resources = NewPdfPageResources()
	_cgaef := _bgd.PdfIndirectObject{}
	_cgaef.PdfObject = _dcfb._cfdgca
	_dcfb._bbgfg = &_cgaef
	_dcfb._cdfec = *_dcfb._cfdgca
	return &_dcfb
}

// ToPdfObject implements interface PdfModel.
func (_eaae *PdfActionGoTo3DView) ToPdfObject() _bgd.PdfObject {
	_eaae.PdfAction.ToPdfObject()
	_ceb := _eaae._fab
	_adb := _ceb.PdfObject.(*_bgd.PdfObjectDictionary)
	_adb.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeGoTo3DView)))
	_adb.SetIfNotNil("\u0054\u0041", _eaae.TA)
	_adb.SetIfNotNil("\u0056", _eaae.V)
	return _ceb
}

func (_aacc *PdfReader) newPdfAnnotationSquareFromDict(_aagd *_bgd.PdfObjectDictionary) (*PdfAnnotationSquare, error) {
	_daea := PdfAnnotationSquare{}
	_ebd, _aecg := _aacc.newPdfAnnotationMarkupFromDict(_aagd)
	if _aecg != nil {
		return nil, _aecg
	}
	_daea.PdfAnnotationMarkup = _ebd
	_daea.BS = _aagd.Get("\u0042\u0053")
	_daea.IC = _aagd.Get("\u0049\u0043")
	_daea.BE = _aagd.Get("\u0042\u0045")
	_daea.RD = _aagd.Get("\u0052\u0044")
	return &_daea, nil
}

// GetContentStream returns the pattern cell's content stream
func (_efcfc *PdfTilingPattern) GetContentStream() ([]byte, error) {
	_fbbc, _, _bdbd := _efcfc.GetContentStreamWithEncoder()
	return _fbbc, _bdbd
}

var (
	ErrRequiredAttributeMissing = _gb.New("\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074t\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
	ErrInvalidAttribute         = _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	ErrTypeCheck                = _gb.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	_faef                       = _gb.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	ErrEncrypted                = _gb.New("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	ErrNoFont                   = _gb.New("\u0066\u006fn\u0074\u0020\u006eo\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	ErrFontNotSupported         = _bg.Errorf("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u006fn\u0074\u0020\u0028\u0025\u0077\u0029", _bgd.ErrNotSupported)
	ErrType1CFontNotSupported   = _bg.Errorf("\u0054y\u0070\u00651\u0043\u0020\u0066o\u006e\u0074\u0073\u0020\u0061\u0072\u0065 \u006e\u006f\u0074\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0028\u0025\u0077\u0029", _bgd.ErrNotSupported)
	ErrType3FontNotSupported    = _bg.Errorf("\u0054y\u0070\u00653\u0020\u0066\u006f\u006et\u0073\u0020\u0061r\u0065\u0020\u006e\u006f\u0074\u0020\u0063\u0075\u0072re\u006e\u0074\u006cy\u0020\u0073u\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0028%\u0077\u0029", _bgd.ErrNotSupported)
	ErrTTCmapNotSupported       = _bg.Errorf("\u0075\u006es\u0075\u0070\u0070\u006fr\u0074\u0065d\u0020\u0054\u0072\u0075\u0065\u0054\u0079\u0070e\u0020\u0063\u006d\u0061\u0070\u0020\u0066\u006f\u0072\u006d\u0061\u0074 \u0028\u0025\u0077\u0029", _bgd.ErrNotSupported)
	ErrSignNotEnoughSpace       = _bg.Errorf("\u0069\u006e\u0073\u0075\u0066\u0066\u0069c\u0069\u0065\u006et\u0020\u0073\u0070a\u0063\u0065 \u0061\u006c\u006c\u006f\u0063\u0061t\u0065d \u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073")
	ErrSignNoCertificates       = _bg.Errorf("\u0063\u006ful\u0064\u0020\u006eo\u0074\u0020\u0072\u0065tri\u0065ve\u0020\u0063\u0065\u0072\u0074\u0069\u0066ic\u0061\u0074\u0065\u0020\u0063\u0068\u0061i\u006e")
)

// ToPdfObject implements interface PdfModel.
func (_dbac *PdfActionRendition) ToPdfObject() _bgd.PdfObject {
	_dbac.PdfAction.ToPdfObject()
	_edfe := _dbac._fab
	_fag := _edfe.PdfObject.(*_bgd.PdfObjectDictionary)
	_fag.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeRendition)))
	_fag.SetIfNotNil("\u0052", _dbac.R)
	_fag.SetIfNotNil("\u0041\u004e", _dbac.AN)
	_fag.SetIfNotNil("\u004f\u0050", _dbac.OP)
	_fag.SetIfNotNil("\u004a\u0053", _dbac.JS)
	return _edfe
}

// PrintClip returns the value of the printClip.
func (_eeaee *ViewerPreferences) PrintClip() PageBoundary { return _eeaee._fffgf }

func (_geeeb *pdfFontSimple) updateStandard14Font() {
	_aeab, _dbddd := _geeeb.Encoder().(_dabf.SimpleEncoder)
	if !_dbddd {
		_fg.Log.Error("\u0057\u0072\u006f\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0074y\u0070e\u003a\u0020\u0025\u0054\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u002e", _geeeb.Encoder(), _geeeb)
		return
	}
	_effg := _aeab.Charcodes()
	_geeeb._ffagd = make(map[_dabf.CharCode]float64, len(_effg))
	for _, _bccfb := range _effg {
		_aggad, _ := _aeab.CharcodeToRune(_bccfb)
		_ebfgb, _ := _geeeb._dcbff.Read(_aggad)
		_geeeb._ffagd[_bccfb] = _ebfgb.Wx
	}
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_fcebgg *PdfShadingType4) ToPdfObject() _bgd.PdfObject {
	_fcebgg.PdfShading.ToPdfObject()
	_cfbdc, _gcff := _fcebgg.getShadingDict()
	if _gcff != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _fcebgg.BitsPerCoordinate != nil {
		_cfbdc.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _fcebgg.BitsPerCoordinate)
	}
	if _fcebgg.BitsPerComponent != nil {
		_cfbdc.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fcebgg.BitsPerComponent)
	}
	if _fcebgg.BitsPerFlag != nil {
		_cfbdc.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _fcebgg.BitsPerFlag)
	}
	if _fcebgg.Decode != nil {
		_cfbdc.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _fcebgg.Decode)
	}
	if _fcebgg.Function != nil {
		if len(_fcebgg.Function) == 1 {
			_cfbdc.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fcebgg.Function[0].ToPdfObject())
		} else {
			_afeba := _bgd.MakeArray()
			for _, _abadb := range _fcebgg.Function {
				_afeba.Append(_abadb.ToPdfObject())
			}
			_cfbdc.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _afeba)
		}
	}
	return _fcebgg._gccfe
}

// PdfTransformParamsDocMDP represents a transform parameters dictionary for the DocMDP method and is used to detect
// modifications relative to a signature field that is signed by the author of a document.
// (Section 12.8.2.2, Table 254 - Entries in the DocMDP transform parameters dictionary p. 471 in PDF32000_2008).
type PdfTransformParamsDocMDP struct {
	Type *_bgd.PdfObjectName
	P    *_bgd.PdfObjectInteger
	V    *_bgd.PdfObjectName
}

// AddWatermarkImage adds an image watermark to the page.
func (_dcef *PdfPage) AddWatermarkImage(ximg *XObjectImage, opt WatermarkImageOptions) error {
	_gfffd, _ffbcc := _dcef.GetMediaBox()
	if _ffbcc != nil {
		return _ffbcc
	}
	_afdbd := _gfffd.Urx - _gfffd.Llx
	_fcfacc := _gfffd.Ury - _gfffd.Lly
	_cbdbb := opt.Angle * _da.Pi / 180
	_bdcda := float64(*ximg.Width)
	_gacf := (_afdbd - _bdcda*_da.Cos(_cbdbb)) / 2
	if opt.FitToWidth {
		_bdcda = _afdbd
		_gacf = 0
	}
	_ddfgg := _fcfacc
	_eccfc := float64(0)
	if opt.PreserveAspectRatio {
		_ddfgg = _bdcda * float64(*ximg.Height) / float64(*ximg.Width)
		_eccfc = (_fcfacc - _ddfgg) / 2
		_eccfc -= float64(*ximg.Width) / 2 * _da.Sin(_cbdbb)
	}
	if _dcef.Resources == nil {
		_dcef.Resources = NewPdfPageResources()
	}
	_agcgf := NewXObjectForm()
	_agcgf.BBox = _bgd.MakeArrayFromFloats([]float64{0, 0, _bdcda, _ddfgg})
	_agcgf.Resources = NewPdfPageResources()
	_acbc := 0
	_degead := _bgd.PdfObjectName(_f.Sprintf("\u0049\u006d\u0077%\u0064", _acbc))
	for _agcgf.Resources.HasXObjectByName(_degead) {
		_acbc++
		_degead = _bgd.PdfObjectName(_f.Sprintf("\u0049\u006d\u0077%\u0064", _acbc))
	}
	_ffbcc = _agcgf.Resources.SetXObjectImageByName(_degead, ximg)
	if _ffbcc != nil {
		return _ffbcc
	}
	_acbc = 0
	_cfgca := _bgd.PdfObjectName(_f.Sprintf("\u0047\u0053\u0025\u0064", _acbc))
	for _agcgf.Resources.HasExtGState(_cfgca) {
		_acbc++
		_cfgca = _bgd.PdfObjectName(_f.Sprintf("\u0047\u0053\u0025\u0064", _acbc))
	}
	_defgb := _bgd.MakeDict()
	_defgb.Set("\u0042\u004d", _bgd.MakeName("\u004e\u006f\u0072\u006d\u0061\u006c"))
	_defgb.Set("\u0043\u0041", _bgd.MakeFloat(opt.Alpha))
	_defgb.Set("\u0063\u0061", _bgd.MakeFloat(opt.Alpha))
	_ffbcc = _agcgf.Resources.AddExtGState(_cfgca, _defgb)
	if _ffbcc != nil {
		return _ffbcc
	}
	_ddbbbg := _f.Sprintf("\u0071\u000a"+"\u002f%\u0073\u0020\u0067\u0073\u000a"+"%\u002e\u0030\u0066\u0020\u0030\u00200\u0020\u0025\u002e\u0030\u0066\u0020\u0025\u002e\u0034f\u0020\u0025\u002e4\u0066 \u0063\u006d\u000a"+"\u002f%\u0073\u0020\u0044\u006f\u000a"+"\u0051", _cfgca, _bdcda, _ddfgg, 0.0, 0.0, _degead)
	_agcgf.SetContentStream([]byte(_ddbbbg), nil)
	_cagcee := _ga.IdentityMatrix().Rotate(_cbdbb)
	_aefadb := []float64{_cagcee[0], _cagcee[1], _cagcee[3], _cagcee[4], _cagcee[6], _cagcee[7]}
	_agcgf.Matrix = _bgd.MakeArrayFromFloats(_aefadb)
	_geggb := _dcef.Resources.GenerateXObjectName()
	_ffbcc = _dcef.Resources.SetXObjectFormByName(_geggb, _agcgf)
	if _ffbcc != nil {
		return _ffbcc
	}
	_geeaf := _f.Sprintf("\u0071\u000a"+"%\u002e\u0030\u0066\u0020\u0030\u00200\u0020\u0025\u002e\u0030\u0066\u0020\u0025\u002e\u0034f\u0020\u0025\u002e4\u0066 \u0063\u006d\u000a"+"\u002f%\u0073\u0020\u0044\u006f\u000a"+"\u0051", 1.0, 1.0, _gacf, _eccfc, _geggb)
	return _dcef.AppendContentBytes([]byte(_geeaf), true)
}

func _acade(_cgcfb *_bgd.PdfObjectDictionary) (*PdfFieldText, error) {
	_agbe := &PdfFieldText{}
	_agbe.DA, _ = _bgd.GetString(_cgcfb.Get("\u0044\u0041"))
	_agbe.Q, _ = _bgd.GetInt(_cgcfb.Get("\u0051"))
	_agbe.DS, _ = _bgd.GetString(_cgcfb.Get("\u0044\u0053"))
	_agbe.RV = _cgcfb.Get("\u0052\u0056")
	_agbe.MaxLen, _ = _bgd.GetInt(_cgcfb.Get("\u004d\u0061\u0078\u004c\u0065\u006e"))
	return _agbe, nil
}

// DecodeArray returns the range of color component values in CalRGB colorspace.
func (_bceg *PdfColorspaceCalRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// Tab order types.
type TabOrderType string

func (_fcd *PdfAnnotation) String() string {
	_cgfc := ""
	_fcfa, _gabe := _fcd.ToPdfObject().(*_bgd.PdfIndirectObject)
	if _gabe {
		_cgfc = _f.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _fcd._dabfb, _fcfa.PdfObject.String())
	}
	return _cgfc
}

func _afgb(_fccg rune) string {
	for _bfdce, _bgeccd := range _ag.Categories {
		if len(_bfdce) == 2 && _ag.Is(_bgeccd, _fccg) {
			return _bfdce
		}
	}
	return "\u0043\u006e"
}

// ToPdfObject returns the PDF representation of the outline tree node.
func (_cfbf *PdfOutlineTreeNode) ToPdfObject() _bgd.PdfObject {
	return _cfbf.GetContext().ToPdfObject()
}

// NewPdfColorPatternType2 returns an empty color shading pattern type 2 (Axial).
func NewPdfColorPatternType2() *PdfColorPatternType2 { _cec := &PdfColorPatternType2{}; return _cec }

// ToUnicode returns the name of the font's "ToUnicode" field if there is one, or "" if there isn't.
func (_aacg *PdfFont) ToUnicode() string {
	if _aacg.baseFields()._edab == nil {
		return ""
	}
	return _aacg.baseFields()._edab.Name()
}

// PdfFontDescriptor specifies metrics and other attributes of a font and can refer to a FontFile
// for embedded fonts.
// 9.8 Font Descriptors (page 281)
type PdfFontDescriptor struct {
	FontName     _bgd.PdfObject
	FontFamily   _bgd.PdfObject
	FontStretch  _bgd.PdfObject
	FontWeight   _bgd.PdfObject
	Flags        _bgd.PdfObject
	FontBBox     _bgd.PdfObject
	ItalicAngle  _bgd.PdfObject
	Ascent       _bgd.PdfObject
	Descent      _bgd.PdfObject
	Leading      _bgd.PdfObject
	CapHeight    _bgd.PdfObject
	XHeight      _bgd.PdfObject
	StemV        _bgd.PdfObject
	StemH        _bgd.PdfObject
	AvgWidth     _bgd.PdfObject
	MaxWidth     _bgd.PdfObject
	MissingWidth _bgd.PdfObject
	FontFile     _bgd.PdfObject
	FontFile2    _bgd.PdfObject
	FontFile3    _bgd.PdfObject
	CharSet      _bgd.PdfObject
	_bfgdg       int
	_aeee        float64
	*fontFile
	_agdd *_fe.TtfType

	// Additional entries for CIDFonts
	Style  _bgd.PdfObject
	Lang   _bgd.PdfObject
	FD     _bgd.PdfObject
	CIDSet _bgd.PdfObject
	_gfgee *_bgd.PdfIndirectObject
}

// GetNamedDestinations returns the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_bccaa *PdfReader) GetNamedDestinations() (_bgd.PdfObject, error) {
	_fadab := _bgd.ResolveReference(_bccaa._ffabf.Get("\u0044\u0065\u0073t\u0073"))
	if _fadab == nil {
		return nil, nil
	}
	if !_bccaa._ffce {
		_bgebg := _bccaa.traverseObjectData(_fadab)
		if _bgebg != nil {
			return nil, _bgebg
		}
	}
	return _fadab, nil
}

// GetNumComponents returns the number of color components (4 for CMYK32).
func (_bfbc *PdfColorDeviceCMYK) GetNumComponents() int { return 4 }

func _dfac(_dbcfd _bgd.PdfObject, _edbgd *PdfReader) (*OutlineDest, error) {
	_bccb, _gbcba := _bgd.GetArray(_dbcfd)
	if !_gbcba {
		return nil, _gb.New("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0064\u0065\u0073t\u0069\u006e\u0061\u0074i\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_cgbfb := _bccb.Len()
	if _cgbfb < 2 {
		return nil, _f.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020\u006fu\u0074\u006c\u0069n\u0065\u0020\u0064\u0065\u0073\u0074\u0069\u006e\u0061ti\u006f\u006e\u0020a\u0072\u0072a\u0079\u0020\u006c\u0065\u006e\u0067t\u0068\u003a \u0025\u0064", _cgbfb)
	}
	_ddaba := &OutlineDest{Mode: "\u0046\u0069\u0074"}
	_dagdd := _bccb.Get(0)
	if _dacbf, _geede := _bgd.GetIndirect(_dagdd); _geede {
		if _, _fccc, _ffgcd := _edbgd.PageFromIndirectObject(_dacbf); _ffgcd == nil {
			_ddaba.Page = int64(_fccc - 1)
		} else {
			_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020g\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u002b\u0076", _dacbf)
		}
		_ddaba.PageObj = _dacbf
	} else if _bccgd, _edce := _bgd.GetIntVal(_dagdd); _edce {
		if _bccgd >= 0 && _bccgd < len(_edbgd.PageList) {
			_ddaba.PageObj = _edbgd.PageList[_bccgd].GetPageAsIndirectObject()
		} else {
			_fg.Log.Debug("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064", _bccgd)
		}
		_ddaba.Page = int64(_bccgd)
	} else {
		return nil, _f.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u006f\u0075\u0074\u006cine\u0020de\u0073\u0074\u0069\u006e\u0061\u0074\u0069on\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0054", _dagdd)
	}
	_gbfcb, _gbcba := _bgd.GetNameVal(_bccb.Get(1))
	if !_gbcba {
		_fg.Log.Debug("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006fn\u0020\u006d\u0061\u0067\u006e\u0069\u0066\u0069\u0063\u0061\u0074i\u006f\u006e\u0020\u006d\u006f\u0064\u0065\u003a\u0020\u0025\u0076", _bccb.Get(1))
		return _ddaba, nil
	}
	switch _gbfcb {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		if _cgbfb > 2 {
			_ddaba.Y, _ = _bgd.GetNumberAsFloat(_bgd.TraceToDirectObject(_bccb.Get(2)))
		}
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		if _cgbfb > 2 {
			_ddaba.X, _ = _bgd.GetNumberAsFloat(_bgd.TraceToDirectObject(_bccb.Get(2)))
		}
	case "\u0058\u0059\u005a":
		if _cgbfb > 4 {
			_ddaba.X, _ = _bgd.GetNumberAsFloat(_bgd.TraceToDirectObject(_bccb.Get(2)))
			_ddaba.Y, _ = _bgd.GetNumberAsFloat(_bgd.TraceToDirectObject(_bccb.Get(3)))
			_ddaba.Zoom, _ = _bgd.GetNumberAsFloat(_bgd.TraceToDirectObject(_bccb.Get(4)))
		}
	default:
		_gbfcb = "\u0046\u0069\u0074"
	}
	_ddaba.Mode = _gbfcb
	return _ddaba, nil
}

func (_cef *PdfAnnotationMarkup) appendToPdfDictionary(_fbafd *_bgd.PdfObjectDictionary) {
	_fbafd.SetIfNotNil("\u0054", _cef.T)
	if _cef.Popup != nil {
		_fbafd.Set("\u0050\u006f\u0070u\u0070", _cef.Popup.ToPdfObject())
	}
	_fbafd.SetIfNotNil("\u0043\u0041", _cef.CA)
	_fbafd.SetIfNotNil("\u0052\u0043", _cef.RC)
	_fbafd.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _cef.CreationDate)
	_fbafd.SetIfNotNil("\u0049\u0052\u0054", _cef.IRT)
	_fbafd.SetIfNotNil("\u0053\u0075\u0062\u006a", _cef.Subj)
	_fbafd.SetIfNotNil("\u0052\u0054", _cef.RT)
	_fbafd.SetIfNotNil("\u0049\u0054", _cef.IT)
	_fbafd.SetIfNotNil("\u0045\u0078\u0044\u0061\u0074\u0061", _cef.ExData)
}

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_fddbc *PdfWriter) SetOptimizer(optimizer Optimizer) { _fddbc._acff = optimizer }

func (_gba *PdfReader) newPdfActionThreadFromDict(_bebe *_bgd.PdfObjectDictionary) (*PdfActionThread, error) {
	_gfc, _cfbda := _ada(_bebe.Get("\u0046"))
	if _cfbda != nil {
		return nil, _cfbda
	}
	return &PdfActionThread{D: _bebe.Get("\u0044"), B: _bebe.Get("\u0042"), F: _gfc}, nil
}

// A returns the value of the A component of the color.
func (_gfdb *PdfColorCalRGB) A() float64 { return _gfdb[0] }

// PdfAcroForm represents the AcroForm dictionary used for representation of form data in PDF.
type PdfAcroForm struct {
	Fields          *[]*PdfField
	NeedAppearances *_bgd.PdfObjectBool
	SigFlags        *_bgd.PdfObjectInteger
	CO              *_bgd.PdfObjectArray
	DR              *PdfPageResources
	DA              *_bgd.PdfObjectString
	Q               *_bgd.PdfObjectInteger
	XFA             _bgd.PdfObject

	// ADBEEchoSign extra objects from Adobe Acrobat, causing signature invalid if not exists.
	ADBEEchoSign _bgd.PdfObject
	_fecg        *_bgd.PdfIndirectObject
	_gbfgd       bool
}

// NewPdfColorspaceDeviceRGB returns a new RGB colorspace object.
func NewPdfColorspaceDeviceRGB() *PdfColorspaceDeviceRGB { return &PdfColorspaceDeviceRGB{} }

// IsTiling specifies if the pattern is a tiling pattern.
func (_bdfc *PdfPattern) IsTiling() bool { return _bdfc.PatternType == 1 }

// NewPdfAnnotationFileAttachment returns a new file attachment annotation.
func NewPdfAnnotationFileAttachment() *PdfAnnotationFileAttachment {
	_eba := NewPdfAnnotation()
	_dce := &PdfAnnotationFileAttachment{}
	_dce.PdfAnnotation = _eba
	_dce.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_eba.SetContext(_dce)
	return _dce
}

// ViewArea returns the value of the viewArea.
func (_acaf *ViewerPreferences) ViewArea() PageBoundary { return _acaf._eabg }

// SetNonFullScreenPageMode sets the value of the nonFullScreenPageMode.
func (_gffgc *ViewerPreferences) SetNonFullScreenPageMode(nonFullScreenPageMode NonFullScreenPageMode) {
	_gffgc._ggfcc = nonFullScreenPageMode
}

// NewPdfColorCalRGB returns a new CalRBG color.
func NewPdfColorCalRGB(a, b, c float64) *PdfColorCalRGB {
	_egfd := PdfColorCalRGB{a, b, c}
	return &_egfd
}

// SetHideWindowUI sets the value of the hideWindowUI flag.
func (_dabe *ViewerPreferences) SetHideWindowUI(hideWindowUI bool) { _dabe._eagcc = &hideWindowUI }

// ToPdfObject returns a PdfObject representation of PdfColorspaceDeviceNAttributes as a PdfObjectDictionary directly
// or indirectly within an indirect object container.
func (_eccea *PdfColorspaceDeviceNAttributes) ToPdfObject() _bgd.PdfObject {
	_dgeb := _bgd.MakeDict()
	if _eccea.Subtype != nil {
		_dgeb.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _eccea.Subtype)
	}
	_dgeb.SetIfNotNil("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s", _eccea.Colorants)
	_dgeb.SetIfNotNil("\u0050r\u006f\u0063\u0065\u0073\u0073", _eccea.Process)
	_dgeb.SetIfNotNil("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073", _eccea.MixingHints)
	if _eccea._gecge != nil {
		_eccea._gecge.PdfObject = _dgeb
		return _eccea._gecge
	}
	return _dgeb
}

// PdfAnnotationScreen represents Screen annotations.
// (Section 12.5.6.18).
type PdfAnnotationScreen struct {
	*PdfAnnotation
	T  _bgd.PdfObject
	MK _bgd.PdfObject
	A  _bgd.PdfObject
	AA _bgd.PdfObject
}

// SetViewArea sets the value of the viewArea.
func (_bfbbe *ViewerPreferences) SetViewArea(viewArea PageBoundary) { _bfbbe._eabg = viewArea }

// Insert adds an outline item as a child of the current outline item,
// at the specified index.
func (_gfedf *OutlineItem) Insert(index uint, item *OutlineItem) {
	_bffgd := uint(len(_gfedf.Entries))
	if index > _bffgd {
		index = _bffgd
	}
	_gfedf.Entries = append(_gfedf.Entries[:index], append([]*OutlineItem{item}, _gfedf.Entries[index:]...)...)
}

func (_dcfa *pdfFontSimple) getFontDescriptor() *PdfFontDescriptor {
	if _eccaa := _dcfa._ggde; _eccaa != nil {
		return _eccaa
	}
	return _dcfa._aegbd
}

func _befc(_ega _bgd.PdfObject) (*PdfColorspaceCalGray, error) {
	_ffgad := NewPdfColorspaceCalGray()
	if _ebec, _fffge := _ega.(*_bgd.PdfIndirectObject); _fffge {
		_ffgad._ecad = _ebec
	}
	_ega = _bgd.TraceToDirectObject(_ega)
	_aafd, _cbfg := _ega.(*_bgd.PdfObjectArray)
	if !_cbfg {
		return nil, _f.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _aafd.Len() != 2 {
		return nil, _f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0061\u006cG\u0072\u0061\u0079\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_ega = _bgd.TraceToDirectObject(_aafd.Get(0))
	_gcgf, _cbfg := _ega.(*_bgd.PdfObjectName)
	if !_cbfg {
		return nil, _f.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u0020\u006e\u0061m\u0065\u0020\u006e\u006f\u0074\u0020\u0061 \u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_gcgf != "\u0043a\u006c\u0047\u0072\u0061\u0079" {
		return nil, _f.Errorf("\u006eo\u0074\u0020\u0061\u0020\u0043\u0061\u006c\u0047\u0072\u0061\u0079 \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_ega = _bgd.TraceToDirectObject(_aafd.Get(1))
	_aefde, _cbfg := _ega.(*_bgd.PdfObjectDictionary)
	if !_cbfg {
		return nil, _f.Errorf("\u0043\u0061lG\u0072\u0061\u0079 \u0064\u0069\u0063\u0074 no\u0074 a\u0020\u0044\u0069\u0063\u0074\u0069\u006fna\u0072\u0079\u0020\u006f\u0062\u006a\u0065c\u0074")
	}
	_ega = _aefde.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_ega = _bgd.TraceToDirectObject(_ega)
	_fdgc, _cbfg := _ega.(*_bgd.PdfObjectArray)
	if !_cbfg {
		return nil, _f.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020W\u0068\u0069\u0074e\u0050o\u0069\u006e\u0074")
	}
	if _fdgc.Len() != 3 {
		return nil, _f.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
	}
	_cbgb, _abde := _fdgc.GetAsFloat64Slice()
	if _abde != nil {
		return nil, _abde
	}
	_ffgad.WhitePoint = _cbgb
	_ega = _aefde.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _ega != nil {
		_ega = _bgd.TraceToDirectObject(_ega)
		_cdce, _dcbe := _ega.(*_bgd.PdfObjectArray)
		if !_dcbe {
			return nil, _f.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020B\u006c\u0061\u0063k\u0050o\u0069\u006e\u0074")
		}
		if _cdce.Len() != 3 {
			return nil, _f.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061c\u006b\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
		}
		_gfce, _cdcc := _cdce.GetAsFloat64Slice()
		if _cdcc != nil {
			return nil, _cdcc
		}
		_ffgad.BlackPoint = _gfce
	}
	_ega = _aefde.Get("\u0047\u0061\u006dm\u0061")
	if _ega != nil {
		_ega = _bgd.TraceToDirectObject(_ega)
		_dedb, _gdgc := _bgd.GetNumberAsFloat(_ega)
		if _gdgc != nil {
			return nil, _f.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0067\u0061\u006d\u006d\u0061\u0020\u006e\u006ft\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_ffgad.Gamma = _dedb
	}
	return _ffgad, nil
}

// GetContentStreamObjs returns a slice of PDF objects containing the content
// streams of the page.
func (_bbfg *PdfPage) GetContentStreamObjs() []_bgd.PdfObject {
	if _bbfg.Contents == nil {
		return nil
	}
	_agecce := _bgd.TraceToDirectObject(_bbfg.Contents)
	if _ggcef, _gegeb := _agecce.(*_bgd.PdfObjectArray); _gegeb {
		return _ggcef.Elements()
	}
	return []_bgd.PdfObject{_agecce}
}

func _gabc(_bbdf []byte) bool {
	if len(_bbdf) < 4 {
		return true
	}
	for _cdcce := range _bbdf[:4] {
		_dbdaa := rune(_cdcce)
		if !_ag.Is(_ag.ASCII_Hex_Digit, _dbdaa) && !_ag.IsSpace(_dbdaa) {
			return true
		}
	}
	return false
}

// AddCerts adds certificates to DSS.
func (_adae *DSS) AddCerts(certs [][]byte) ([]*_bgd.PdfObjectStream, error) {
	return _adae.add(&_adae.Certs, _adae._gbed, certs)
}

// ColorToRGB converts gray -> rgb for a single color component.
func (_aadd *PdfColorspaceDeviceGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_edbf, _fbgbg := color.(*PdfColorDeviceGray)
	if !_fbgbg {
		_fg.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006fr\u0020\u006e\u006f\u0074\u0020\u0064\u0065v\u0069\u0063\u0065\u0020\u0067\u0072\u0061\u0079\u0020\u0025\u0054", color)
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return NewPdfColorDeviceRGB(float64(*_edbf), float64(*_edbf), float64(*_edbf)), nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_dbgf *PdfColorspaceDeviceGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bbfe := vals[0]
	if _bbfe < 0.0 || _bbfe > 1.0 {
		_fg.Log.Debug("\u0049\u006eco\u006d\u0070\u0061t\u0069\u0062\u0069\u006city\u003a R\u0061\u006e\u0067\u0065\u0020\u006f\u0075ts\u0069\u0064\u0065\u0020\u005b\u0030\u002c1\u005d")
	}
	if _bbfe < 0.0 {
		_bbfe = 0.0
	} else if _bbfe > 1.0 {
		_bbfe = 1.0
	}
	return NewPdfColorDeviceGray(_bbfe), nil
}

// PdfAnnotationSquare represents Square annotations.
// (Section 12.5.6.8).
type PdfAnnotationSquare struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _bgd.PdfObject
	IC _bgd.PdfObject
	BE _bgd.PdfObject
	RD _bgd.PdfObject
}

// SetNumCopies sets the value of the numCopies.
func (_daabe *ViewerPreferences) SetNumCopies(numCopies int) { _daabe._bcdg = numCopies }

// NewPdfAcroForm returns a new PdfAcroForm with an initialized container (indirect object).
func NewPdfAcroForm() *PdfAcroForm {
	return &PdfAcroForm{Fields: &[]*PdfField{}, _fecg: _bgd.MakeIndirectObject(_bgd.MakeDict())}
}

// PdfShadingType1 is a Function-based shading.
type PdfShadingType1 struct {
	*PdfShading
	Domain   *_bgd.PdfObjectArray
	Matrix   *_bgd.PdfObjectArray
	Function []PdfFunction
}

// GetFontByName gets the font specified by keyName. Returns the PdfObject which
// the entry refers to. Returns a bool value indicating whether or not the entry was found.
func (_dgbac *PdfPageResources) GetFontByName(keyName _bgd.PdfObjectName) (_bgd.PdfObject, bool) {
	if _dgbac.Font == nil {
		return nil, false
	}
	_fdbab, _dggaa := _bgd.TraceToDirectObject(_dgbac.Font).(*_bgd.PdfObjectDictionary)
	if !_dggaa {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _bgd.TraceToDirectObject(_dgbac.Font))
		return nil, false
	}
	if _begeb := _fdbab.Get(keyName); _begeb != nil {
		return _begeb, true
	}
	return nil, false
}

// CustomKeys returns all custom info keys as list.
func (_cbcc *PdfInfo) CustomKeys() []string {
	if _cbcc._dfeee == nil {
		return nil
	}
	_cefbc := make([]string, len(_cbcc._dfeee.Keys()))
	for _, _fdeda := range _cbcc._dfeee.Keys() {
		_cefbc = append(_cefbc, _fdeda.String())
	}
	return _cefbc
}

// GetSamples converts the raw byte slice into samples which are stored in a uint32 bit array.
// Each sample is represented by BitsPerComponent consecutive bits in the raw data.
// NOTE: The method resamples the image byte data before returning the result and
// this could lead to high memory usage, especially on large images. It should
// be avoided, when possible. It is recommended to access the Data field of the
// image directly or use the ColorAt method to extract individual pixels.
func (_afggf *Image) GetSamples() []uint32 {
	_bdedg := _eaa.ResampleBytes(_afggf.Data, int(_afggf.BitsPerComponent))
	if _afggf.BitsPerComponent < 8 {
		_bdedg = _afggf.samplesTrimPadding(_bdedg)
	}
	_edcg := int(_afggf.Width) * int(_afggf.Height) * _afggf.ColorComponents
	if len(_bdedg) < _edcg {
		_fg.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u0066\u0065\u0077\u0020\u0073a\u006d\u0070\u006c\u0065\u0073\u0020(\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078\u0070e\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064\u0029", len(_bdedg), _edcg)
		return _bdedg
	} else if len(_bdedg) > _edcg {
		_fg.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u006d\u0061\u006e\u0079\u0020s\u0061\u006d\u0070\u006c\u0065\u0073 \u0028\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078p\u0065\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064", len(_bdedg), _edcg)
		_bdedg = _bdedg[:_edcg]
	}
	return _bdedg
}

// AddExtGState add External Graphics State (GState). The gsDict can be specified
// either directly as a dictionary or an indirect object containing a dictionary.
func (_eecfd *PdfPageResources) AddExtGState(gsName _bgd.PdfObjectName, gsDict _bgd.PdfObject) error {
	if _eecfd.ExtGState == nil {
		_eecfd.ExtGState = _bgd.MakeDict()
	}
	_edgec := _eecfd.ExtGState
	_dffec, _dgad := _bgd.TraceToDirectObject(_edgec).(*_bgd.PdfObjectDictionary)
	if !_dgad {
		_fg.Log.Debug("\u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020e\u0072r\u006f\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u002f\u0025\u0054\u0029", _edgec, _bgd.TraceToDirectObject(_edgec))
		return _bgd.ErrTypeError
	}
	_dffec.Set(gsName, gsDict)
	return nil
}

func (_ggdec *PdfWriter) writeTrailer(_gbfgg int) {
	_ggdec.writeString("\u0078\u0072\u0065\u0066\u000d\u000a")
	for _ebbdg := 0; _ebbdg <= _gbfgg; {
		for ; _ebbdg <= _gbfgg; _ebbdg++ {
			_ggcgf, _gecba := _ggdec._bdfbdd[_ebbdg]
			if _gecba && (!_ggdec._fgaba || _ggdec._fgaba && (_ggcgf.Type == 1 && _ggcgf.Offset >= _ggdec._bdgag || _ggcgf.Type == 0)) {
				break
			}
		}
		var _gddbb int
		for _gddbb = _ebbdg + 1; _gddbb <= _gbfgg; _gddbb++ {
			_bfbef, _fcfc := _ggdec._bdfbdd[_gddbb]
			if _fcfc && (!_ggdec._fgaba || _ggdec._fgaba && (_bfbef.Type == 1 && _bfbef.Offset > _ggdec._bdgag)) {
				continue
			}
			break
		}
		_cdcead := _f.Sprintf("\u0025d\u0020\u0025\u0064\u000d\u000a", _ebbdg, _gddbb-_ebbdg)
		_ggdec.writeString(_cdcead)
		for _afgeb := _ebbdg; _afgeb < _gddbb; _afgeb++ {
			_gffba := _ggdec._bdfbdd[_afgeb]
			switch _gffba.Type {
			case 0:
				_cdcead = _f.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u0066\u000d\u000a", 0, 65535)
				_ggdec.writeString(_cdcead)
			case 1:
				_cdcead = _f.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u006e\u000d\u000a", _gffba.Offset, 0)
				_ggdec.writeString(_cdcead)
			}
		}
		_ebbdg = _gddbb + 1
	}
	_eabfc := _bgd.MakeDict()
	_eabfc.Set("\u0049\u006e\u0066\u006f", _ggdec._gefe)
	_eabfc.Set("\u0052\u006f\u006f\u0074", _ggdec._fcgc)
	_eabfc.Set("\u0053\u0069\u007a\u0065", _bgd.MakeInteger(int64(_gbfgg+1)))
	if _ggdec._fgaba && _ggdec._gebgb > 0 {
		_eabfc.Set("\u0050\u0072\u0065\u0076", _bgd.MakeInteger(_ggdec._gebgb))
	}
	if _ggdec._ddcee != nil {
		_eabfc.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _ggdec._abeb)
	}
	if _ggdec._beadb == nil && _ggdec._fedfb != "" && _ggdec._gdcfb != "" {
		_ggdec._beadb = _bgd.MakeArray(_bgd.MakeHexString(_ggdec._fedfb), _bgd.MakeHexString(_ggdec._gdcfb))
	}
	if _ggdec._beadb != nil {
		_eabfc.Set("\u0049\u0044", _ggdec._beadb)
		_fg.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _ggdec._beadb)
	}
	_ggdec.writeString("\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u000a")
	_ggdec.writeBytes(_eabfc.Write())
	_ggdec.writeString("\u000a")
}

// GetNumComponents returns the number of input color components, i.e. that are input to the tint transform.
func (_dbba *PdfColorspaceDeviceN) GetNumComponents() int { return _dbba.ColorantNames.Len() }

// GetKDict returns the KDict of the KValue.
func (_beeb *KValue) GetKDict() *KDict { return _beeb._fgcbd }

// GetNameDictionary returns the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_dfbbf *PdfReader) GetNameDictionary() (_bgd.PdfObject, error) {
	_eeebge := _bgd.ResolveReference(_dfbbf._ffabf.Get("\u004e\u0061\u006de\u0073"))
	if _eeebge == nil {
		return nil, nil
	}
	if !_dfbbf._ffce {
		_aebbc := _dfbbf.traverseObjectData(_eeebge)
		if _aebbc != nil {
			return nil, _aebbc
		}
	}
	return _eeebge, nil
}

// NewPdfColorspaceDeviceCMYK returns a new CMYK32 colorspace object.
func NewPdfColorspaceDeviceCMYK() *PdfColorspaceDeviceCMYK { return &PdfColorspaceDeviceCMYK{} }

// GetContainingPdfObject gets the primitive used to parse the color space.
func (_daeb *PdfColorspaceICCBased) GetContainingPdfObject() _bgd.PdfObject { return _daeb._cfde }

// SetPdfCreationDate sets the CreationDate attribute of the output PDF.
func SetPdfCreationDate(creationDate _ge.Time) {
	_adcf.Lock()
	defer _adcf.Unlock()
	_fcfbfa = creationDate
}

// RemoveChildAt removes a child at the specified index from the kChildren slice.
func (_fcead *KDict) RemoveChildAt(index int) bool {
	if index < 0 || index >= len(_fcead._fabbb) {
		return false
	}
	_fcead._fabbb = append(_fcead._fabbb[:index], _fcead._fabbb[index+1:]...)
	return true
}

// PageBoundary represents the name of the page boundary representing
// the visible area.
type PageBoundary string

// ColorToRGB converts a color in Separation colorspace to RGB colorspace.
func (_ddba *PdfColorspaceSpecialSeparation) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _ddba.AlternateSpace == nil {
		return nil, _gb.New("\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020c\u006f\u006c\u006f\u0072\u0073\u0070\u0061c\u0065\u0020\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	}
	return _ddba.AlternateSpace.ColorToRGB(color)
}

func (_ebadf *PdfPage) setContainer(_cebfd *_bgd.PdfIndirectObject) {
	_cebfd.PdfObject = _ebadf._cfdgca
	_ebadf._bbgfg = _cebfd
}

func (_ecccc SignatureValidationResult) String() string {
	var _adfb _ea.Buffer
	_adfb.WriteString(_f.Sprintf("\u004ea\u006d\u0065\u003a\u0020\u0025\u0073\n", _ecccc.Name))
	if _ecccc.Date._ccgca > 0 {
		_adfb.WriteString(_f.Sprintf("\u0044a\u0074\u0065\u003a\u0020\u0025\u0073\n", _ecccc.Date.ToGoTime().String()))
	} else {
		_adfb.WriteString("\u0044\u0061\u0074\u0065 n\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_ecccc.Reason) > 0 {
		_adfb.WriteString(_f.Sprintf("R\u0065\u0061\u0073\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _ecccc.Reason))
	} else {
		_adfb.WriteString("N\u006f \u0072\u0065\u0061\u0073\u006f\u006e\u0020\u0073p\u0065\u0063\u0069\u0066ie\u0064\u000a")
	}
	if len(_ecccc.Location) > 0 {
		_adfb.WriteString(_f.Sprintf("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _ecccc.Location))
	} else {
		_adfb.WriteString("\u004c\u006f\u0063at\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_ecccc.ContactInfo) > 0 {
		_adfb.WriteString(_f.Sprintf("\u0043\u006f\u006e\u0074\u0061\u0063\u0074\u0020\u0049\u006e\u0066\u006f:\u0020\u0025\u0073\u000a", _ecccc.ContactInfo))
	} else {
		_adfb.WriteString("C\u006f\u006e\u0074\u0061\u0063\u0074 \u0069\u006e\u0066\u006f\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063i\u0066i\u0065\u0064\u000a")
	}
	_adfb.WriteString(_f.Sprintf("F\u0069\u0065\u006c\u0064\u0073\u003a\u0020\u0025\u0064\u000a", len(_ecccc.Fields)))
	if _ecccc.IsSigned {
		_adfb.WriteString("S\u0069\u0067\u006e\u0065\u0064\u003a \u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073\u0020\u0073i\u0067n\u0065\u0064\u000a")
	} else {
		_adfb.WriteString("\u0053\u0069\u0067\u006eed\u003a\u0020\u004e\u006f\u0074\u0020\u0073\u0069\u0067\u006e\u0065\u0064\u000a")
	}
	if _ecccc.IsVerified {
		_adfb.WriteString("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0076\u0061\u006c\u0069\u0064\u0061t\u0069\u006f\u006e\u003a\u0020\u0049\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u000a")
	} else {
		_adfb.WriteString("\u0053\u0069\u0067\u006e\u0061\u0074u\u0072\u0065\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e:\u0020\u0049\u0073\u0020\u0069\u006e\u0076a\u006c\u0069\u0064\u000a")
	}
	if _ecccc.IsTrusted {
		_adfb.WriteString("\u0054\u0072\u0075\u0073\u0074\u0065\u0064\u003a\u0020\u0043\u0065\u0072\u0074\u0069\u0066i\u0063a\u0074\u0065\u0020\u0069\u0073\u0020\u0074\u0072\u0075\u0073\u0074\u0065\u0064\u000a")
	} else {
		_adfb.WriteString("\u0054\u0072\u0075s\u0074\u0065\u0064\u003a \u0055\u006e\u0074\u0072\u0075\u0073\u0074e\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u000a")
	}
	if !_ecccc.GeneralizedTime.IsZero() {
		_adfb.WriteString(_f.Sprintf("G\u0065n\u0065\u0072\u0061\u006c\u0069\u007a\u0065\u0064T\u0069\u006d\u0065\u003a %\u0073\u000a", _ecccc.GeneralizedTime.String()))
	}
	if _ecccc.DiffResults != nil {
		_adfb.WriteString(_f.Sprintf("\u0064\u0069\u0066\u0066 i\u0073\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064\u003a\u0020\u0025v\u000a", _ecccc.DiffResults.IsPermitted()))
		if len(_ecccc.DiffResults.Warnings) > 0 {
			_adfb.WriteString("\u004d\u0044\u0050\u0020\u0077\u0061\u0072\u006e\u0069n\u0067\u0073\u003a\u000a")
			for _, _afdde := range _ecccc.DiffResults.Warnings {
				_adfb.WriteString(_f.Sprintf("\u0009\u0025\u0073\u000a", _afdde))
			}
		}
		if len(_ecccc.DiffResults.Errors) > 0 {
			_adfb.WriteString("\u004d\u0044\u0050 \u0065\u0072\u0072\u006f\u0072\u0073\u003a\u000a")
			for _, _cdcfbe := range _ecccc.DiffResults.Errors {
				_adfb.WriteString(_f.Sprintf("\u0009\u0025\u0073\u000a", _cdcfbe))
			}
		}
	}
	if _ecccc.IsCrlFound {
		_adfb.WriteString("R\u0065\u0076\u006f\u0063\u0061\u0074i\u006f\u006e\u0020\u0064\u0061\u0074\u0061\u003a\u0020C\u0052\u004c\u0020f\u006fu\u006e\u0064\u000a")
	} else {
		_adfb.WriteString("\u0052\u0065\u0076o\u0063\u0061\u0074\u0069o\u006e\u0020\u0064\u0061\u0074\u0061\u003a \u0043\u0052\u004c\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u000a")
	}
	if _ecccc.IsOcspFound {
		_adfb.WriteString("\u0052\u0065\u0076\u006fc\u0061\u0074\u0069\u006f\u006e\u0020\u0064\u0061\u0074\u0061:\u0020O\u0043\u0053\u0050\u0020\u0066\u006f\u0075n\u0064\u000a")
	} else {
		_adfb.WriteString("\u0052\u0065\u0076\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u0020\u0064\u0061\u0074\u0061:\u0020O\u0043\u0053\u0050\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u000a")
	}
	return _adfb.String()
}

func (_abeaf *PdfColorspaceSpecialIndexed) String() string {
	return "\u0049n\u0064\u0065\u0078\u0065\u0064"
}

// String returns a string describing the font descriptor.
func (_dbeb *PdfFontDescriptor) String() string {
	var _aedf []string
	if _dbeb.FontName != nil {
		_aedf = append(_aedf, _dbeb.FontName.String())
	}
	if _dbeb.FontFamily != nil {
		_aedf = append(_aedf, _dbeb.FontFamily.String())
	}
	if _dbeb.fontFile != nil {
		_aedf = append(_aedf, _dbeb.fontFile.String())
	}
	if _dbeb._agdd != nil {
		_aedf = append(_aedf, _dbeb._agdd.String())
	}
	_aedf = append(_aedf, _f.Sprintf("\u0046\u006f\u006et\u0046\u0069\u006c\u0065\u0033\u003d\u0025\u0074", _dbeb.FontFile3 != nil))
	return _f.Sprintf("\u0046\u004f\u004e\u0054_D\u0045\u0053\u0043\u0052\u0049\u0050\u0054\u004f\u0052\u007b\u0025\u0073\u007d", _ef.Join(_aedf, "\u002c\u0020"))
}

// Subtype returns the font's "Subtype" field.
func (_fcea *PdfFont) Subtype() string {
	_cbcf := _fcea.baseFields()._gecd
	if _dageb, _cgad := _fcea._cbec.(*pdfFontType0); _cgad {
		_cbcf = _cbcf + "\u003a" + _dageb.DescendantFont.Subtype()
	}
	return _cbcf
}

// PdfBorderEffect represents a PDF border effect.
type PdfBorderEffect struct {
	S *BorderEffect
	I *float64
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_cagc *PdfColorspaceDeviceCMYK) ToPdfObject() _bgd.PdfObject {
	return _bgd.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b")
}

// SetXObjectImageByName adds the provided XObjectImage to the page resources.
// The added XObjectImage is identified by the specified name.
func (_cfdgg *PdfPageResources) SetXObjectImageByName(keyName _bgd.PdfObjectName, ximg *XObjectImage) error {
	_fbabe := ximg.ToPdfObject().(*_bgd.PdfObjectStream)
	_dccfd := _cfdgg.SetXObjectByName(keyName, _fbabe)
	return _dccfd
}

// PdfFieldSignature signature field represents digital signatures and optional data for authenticating
// the name of the signer and verifying document contents.
type PdfFieldSignature struct {
	*PdfField
	*PdfAnnotationWidget
	V    *PdfSignature
	Lock *_bgd.PdfIndirectObject
	SV   *_bgd.PdfIndirectObject
}

// Decrypt decrypts the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful,
// false otherwise.
func (_cfbea *PdfReader) Decrypt(password []byte) (bool, error) {
	_ebgb, _ebdb := _cfbea._ccade.Decrypt(password)
	if _ebdb != nil {
		return false, _ebdb
	}
	if !_ebgb {
		return false, nil
	}
	_ebdb = _cfbea.loadStructure()
	if _ebdb != nil {
		_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f \u006co\u0061d\u0020s\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029", _ebdb)
		return false, _ebdb
	}
	return true, nil
}

func _eeccg(_eccd StdFontName) (pdfFontSimple, error) {
	_dfgbc, _cbacg := _fe.NewStdFontByName(_eccd)
	if !_cbacg {
		return pdfFontSimple{}, ErrFontNotSupported
	}
	_bfdee := _gaccd(_dfgbc)
	return _bfdee, nil
}

// NewCompositePdfFontFromTTF loads a composite TTF font. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTF.
func NewCompositePdfFontFromTTF(r _ca.ReadSeeker) (*PdfFont, error) {
	_ddfdd, _ceeg := _ca.ReadAll(r)
	if _ceeg != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _ceeg)
		return nil, _ceeg
	}
	_cacaa, _ceeg := _fe.TtfParse(_ea.NewReader(_ddfdd))
	if _ceeg != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067 \u0074\u0074\u0066\u0020\u0066\u006f\u006et\u003a\u0020\u0025\u0076", _ceeg)
		return nil, _ceeg
	}
	_fdede := &pdfCIDFontType2{fontCommon: fontCommon{_gecd: "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032"}, CIDToGIDMap: _bgd.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079")}
	if len(_cacaa.Widths) <= 0 {
		return nil, _gb.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_abed := 1000.0 / float64(_cacaa.UnitsPerEm)
	_cfdgc := _abed * float64(_cacaa.Widths[0])
	_ccae := make(map[rune]int)
	_dcgdc := make(map[_fe.GID]int)
	_feef := _fe.GID(len(_cacaa.Widths))
	for _eagg, _egbc := range _cacaa.Chars {
		if _egbc > _feef-1 {
			continue
		}
		_ecbe := int(_abed * float64(_cacaa.Widths[_egbc]))
		_ccae[_eagg] = _ecbe
		_dcgdc[_egbc] = _ecbe
	}
	_fdede._gagea = _ccae
	_fdede.DW = _bgd.MakeInteger(int64(_cfdgc))
	_caea := _fafb(_dcgdc, uint16(_feef))
	_fdede.W = _bgd.MakeIndirectObject(_caea)
	_ddded := _bgd.MakeDict()
	_ddded.Set("\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067", _bgd.MakeString("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"))
	_ddded.Set("\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079", _bgd.MakeString("\u0041\u0064\u006fb\u0065"))
	_ddded.Set("\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074", _bgd.MakeInteger(0))
	_fdede.CIDSystemInfo = _ddded
	_cdbb := &PdfFontDescriptor{FontName: _bgd.MakeName(_cacaa.PostScriptName), Ascent: _bgd.MakeFloat(_abed * float64(_cacaa.TypoAscender)), Descent: _bgd.MakeFloat(_abed * float64(_cacaa.TypoDescender)), CapHeight: _bgd.MakeFloat(_abed * float64(_cacaa.CapHeight)), FontBBox: _bgd.MakeArrayFromFloats([]float64{_abed * float64(_cacaa.Xmin), _abed * float64(_cacaa.Ymin), _abed * float64(_cacaa.Xmax), _abed * float64(_cacaa.Ymax)}), ItalicAngle: _bgd.MakeFloat(_cacaa.ItalicAngle), MissingWidth: _bgd.MakeFloat(_cfdgc)}
	_gffe, _ceeg := _bgd.MakeStream(_ddfdd, _bgd.NewFlateEncoder())
	if _ceeg != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _ceeg)
		return nil, _ceeg
	}
	_gffe.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _bgd.MakeInteger(int64(len(_ddfdd))))
	_cdbb.FontFile2 = _gffe
	if _cacaa.Bold {
		_cdbb.StemV = _bgd.MakeInteger(120)
	} else {
		_cdbb.StemV = _bgd.MakeInteger(70)
	}
	_bccc := _gdegf
	if _cacaa.IsFixedPitch {
		_bccc |= _ecgf
	}
	if _cacaa.ItalicAngle != 0 {
		_bccc |= _dcgd
	}
	_cdbb.Flags = _bgd.MakeInteger(int64(_bccc))
	_fdede._eebe = _cacaa.PostScriptName
	_fdede._ggde = _cdbb
	_agbde := pdfFontType0{fontCommon: fontCommon{_gecd: "\u0054\u0079\u0070e\u0030", _eebe: _cacaa.PostScriptName}, DescendantFont: &PdfFont{_cbec: _fdede}, Encoding: _bgd.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048"), _dbcf: _cacaa.NewEncoder()}
	if len(_cacaa.Chars) > 0 {
		_gcead := make(map[_cf.CharCode]rune, len(_cacaa.Chars))
		for _eabd, _geffc := range _cacaa.Chars {
			_cbdff := _cf.CharCode(_geffc)
			if _dcgff, _aebe := _gcead[_cbdff]; !_aebe || (_aebe && _dcgff > _eabd) {
				_gcead[_cbdff] = _eabd
			}
		}
		_agbde._edab = _cf.NewToUnicodeCMap(_gcead)
	}
	_cbbe := PdfFont{_cbec: &_agbde}
	return &_cbbe, nil
}

func (_cbagg *pdfFontType0) subsetRegistered() error {
	_adeeb, _cgdaa := _cbagg.DescendantFont._cbec.(*pdfCIDFontType2)
	if !_cgdaa {
		_fg.Log.Debug("\u0046\u006fnt\u0020\u006e\u006ft\u0020\u0073\u0075\u0070por\u0074ed\u0020\u0066\u006f\u0072\u0020\u0073\u0075bs\u0065\u0074\u0074\u0069\u006e\u0067\u0020%\u0054", _cbagg.DescendantFont)
		return nil
	}
	if _adeeb == nil {
		return nil
	}
	if _adeeb._ggde == nil {
		_fg.Log.Debug("\u004d\u0069\u0073si\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u006f\u0072")
		return nil
	}
	if _cbagg._dbcf == nil {
		_fg.Log.Debug("\u004e\u006f\u0020e\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0073\u0075\u0062s\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u0067\u006e\u006f\u0072\u0065\u0064")
		return nil
	}
	_ebdfg, _cgdaa := _bgd.GetStream(_adeeb._ggde.FontFile2)
	if !_cgdaa {
		_fg.Log.Debug("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u002d\u002d\u0020\u0041\u0042\u004f\u0052T\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069\u006e\u0067")
		return _gb.New("\u0066\u006f\u006e\u0074fi\u006c\u0065\u0032\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_bfaea, _fagceb := _bgd.DecodeStream(_ebdfg)
	if _fagceb != nil {
		_fg.Log.Debug("\u0044\u0065c\u006f\u0064\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _fagceb)
		return _fagceb
	}
	_dgbcf, _fagceb := _dag.Parse(_ea.NewReader(_bfaea))
	if _fagceb != nil {
		_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0020f\u006f\u006e\u0074", len(_ebdfg.Stream))
		return _fagceb
	}
	var _eebec []rune
	var _gfgdb *_dag.Font
	switch _ddcf := _cbagg._dbcf.(type) {
	case *_dabf.TrueTypeFontEncoder:
		_eebec = _ddcf.RegisteredRunes()
		_gfgdb, _fagceb = _dgbcf.SubsetKeepRunes(_eebec)
		if _fagceb != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fagceb)
			return _fagceb
		}
		_ddcf.SubsetRegistered()
	case *_dabf.IdentityEncoder:
		_eebec = _ddcf.RegisteredRunes()
		_cece := make([]_dag.GlyphIndex, len(_eebec))
		for _eaff, _dggfe := range _eebec {
			_cece[_eaff] = _dag.GlyphIndex(_dggfe)
		}
		_gfgdb, _fagceb = _dgbcf.SubsetKeepIndices(_cece)
		if _fagceb != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fagceb)
			return _fagceb
		}
	case _dabf.SimpleEncoder:
		_cfbca := _ddcf.Charcodes()
		for _, _fgegg := range _cfbca {
			_bdag, _bbbeb := _ddcf.CharcodeToRune(_fgegg)
			if !_bbbeb {
				_fg.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0020\u0074\u006f \u0072\u0075\u006e\u0065\u003a\u0020\u0025\u0064", _fgegg)
				continue
			}
			_eebec = append(_eebec, _bdag)
		}
	default:
		return _f.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020s\u0075\u0062\u0073\u0065\u0074t\u0069\u006eg\u003a\u0020\u0025\u0054", _cbagg._dbcf)
	}
	var _cggf _ea.Buffer
	_fagceb = _gfgdb.Write(&_cggf)
	if _fagceb != nil {
		_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fagceb)
		return _fagceb
	}
	if _cbagg._edab != nil {
		_dgdc := make(map[_cf.CharCode]rune, len(_eebec))
		for _, _cagcd := range _eebec {
			_deaf, _gcdcf := _cbagg._dbcf.RuneToCharcode(_cagcd)
			if !_gcdcf {
				continue
			}
			_dgdc[_cf.CharCode(_deaf)] = _cagcd
		}
		_cbagg._edab = _cf.NewToUnicodeCMap(_dgdc)
	}
	_ebdfg, _fagceb = _bgd.MakeStream(_cggf.Bytes(), _bgd.NewFlateEncoder())
	if _fagceb != nil {
		_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fagceb)
		return _fagceb
	}
	_ebdfg.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _bgd.MakeInteger(int64(_cggf.Len())))
	if _eeggg, _edgef := _bgd.GetStream(_adeeb._ggde.FontFile2); _edgef {
		*_eeggg = *_ebdfg
	} else {
		_adeeb._ggde.FontFile2 = _ebdfg
	}
	_ffeeeb := _eeebd()
	if len(_cbagg._eebe) > 0 {
		_cbagg._eebe = _dbdac(_cbagg._eebe, _ffeeeb)
	}
	if len(_adeeb._eebe) > 0 {
		_adeeb._eebe = _dbdac(_adeeb._eebe, _ffeeeb)
	}
	if len(_cbagg._ggef) > 0 {
		_cbagg._ggef = _dbdac(_cbagg._ggef, _ffeeeb)
	}
	if _adeeb._ggde != nil {
		_eeec, _becg := _bgd.GetName(_adeeb._ggde.FontName)
		if _becg && len(_eeec.String()) > 0 {
			_ecbg := _dbdac(_eeec.String(), _ffeeeb)
			_adeeb._ggde.FontName = _bgd.MakeName(_ecbg)
		}
	}
	return nil
}

func _eddg(_gaaee _bgd.PdfObject) *Names {
	_dfgef := _ddbd()
	_ddfcb := _bgd.TraceToDirectObject(_gaaee).(*_bgd.PdfObjectDictionary)
	if _afgce := _ddfcb.Get("\u0044\u0065\u0073t\u0073"); _afgce != nil {
		_dfgef.Dests = _bgd.TraceToDirectObject(_afgce).(*_bgd.PdfObjectDictionary)
	}
	if _bfgfa := _ddfcb.Get("\u0041\u0050"); _bfgfa != nil {
		_dfgef.AP = _bgd.TraceToDirectObject(_bfgfa).(*_bgd.PdfObjectDictionary)
	}
	if _ggbd := _ddfcb.Get("\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"); _ggbd != nil {
		_dfgef.JavaScript = _bgd.TraceToDirectObject(_ggbd).(*_bgd.PdfObjectDictionary)
	}
	if _cccde := _ddfcb.Get("\u0050\u0061\u0067e\u0073"); _cccde != nil {
		_dfgef.Pages = _bgd.TraceToDirectObject(_cccde).(*_bgd.PdfObjectDictionary)
	}
	if _baca := _ddfcb.Get("\u0054e\u006d\u0070\u006c\u0061\u0074\u0065s"); _baca != nil {
		_dfgef.Templates = _bgd.TraceToDirectObject(_baca).(*_bgd.PdfObjectDictionary)
	}
	if _bbede := _ddfcb.Get("\u0049\u0044\u0053"); _bbede != nil {
		_dfgef.IDS = _bgd.TraceToDirectObject(_bbede).(*_bgd.PdfObjectDictionary)
	}
	if _fgaag := _ddfcb.Get("\u0055\u0052\u004c\u0053"); _fgaag != nil {
		_dfgef.URLS = _bgd.TraceToDirectObject(_fgaag).(*_bgd.PdfObjectDictionary)
	}
	if _aecdc := _ddfcb.Get("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0046\u0069\u006c\u0065\u0073"); _aecdc != nil {
		_dfgef.EmbeddedFiles = _bgd.TraceToDirectObject(_aecdc).(*_bgd.PdfObjectDictionary)
	}
	if _fbdfa := _ddfcb.Get("\u0041\u006c\u0074\u0065rn\u0061\u0074\u0065\u0050\u0072\u0065\u0073\u0065\u006e\u0074\u0061\u0074\u0069\u006fn\u0073"); _fbdfa != nil {
		_dfgef.AlternatePresentations = _bgd.TraceToDirectObject(_fbdfa).(*_bgd.PdfObjectDictionary)
	}
	if _bgged := _ddfcb.Get("\u0052\u0065\u006e\u0064\u0069\u0074\u0069\u006f\u006e\u0073"); _bgged != nil {
		_dfgef.Renditions = _bgd.TraceToDirectObject(_bgged).(*_bgd.PdfObjectDictionary)
	}
	return _dfgef
}

// NewPdfAnnotationPopup returns a new popup annotation.
func NewPdfAnnotationPopup() *PdfAnnotationPopup {
	_edee := NewPdfAnnotation()
	_caga := &PdfAnnotationPopup{}
	_caga.PdfAnnotation = _edee
	_edee.SetContext(_caga)
	return _caga
}

func _ageeg(_ccagb _bgd.PdfObject) (*fontFile, error) {
	_fg.Log.Trace("\u006e\u0065\u0077\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0046\u0072\u006f\u006dP\u0064f\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u006f\u0062\u006a\u003d\u0025\u0073", _ccagb)
	_eaef := &fontFile{}
	_ccagb = _bgd.TraceToDirectObject(_ccagb)
	_dbfc, _fcggg := _ccagb.(*_bgd.PdfObjectStream)
	if !_fcggg {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020F\u006f\u006et\u0046\u0069\u006c\u0065\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0028\u0025\u0054\u0029", _ccagb)
		return nil, _bgd.ErrTypeError
	}
	_cedc := _dbfc.PdfObjectDictionary
	_gdcb, _eabb := _bgd.DecodeStream(_dbfc)
	if _eabb != nil {
		return nil, _eabb
	}
	_cbdc, _fcggg := _bgd.GetNameVal(_cedc.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_fcggg {
		_eaef._accgf = _cbdc
		if _cbdc == "\u0054\u0079\u0070\u0065\u0031\u0043" {
			_fg.Log.Debug("T\u0079\u0070\u0065\u0031\u0043\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u0061\u0072\u0065\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u006e\u006f\u0074 s\u0075\u0070\u0070o\u0072t\u0065\u0064")
			return nil, ErrType1CFontNotSupported
		}
	}
	_cdcgb, _ := _bgd.GetIntVal(_cedc.Get("\u004ce\u006e\u0067\u0074\u0068\u0031"))
	_fgad, _ := _bgd.GetIntVal(_cedc.Get("\u004ce\u006e\u0067\u0074\u0068\u0032"))
	if _cdcgb > len(_gdcb) {
		_cdcgb = len(_gdcb)
	}
	if _cdcgb+_fgad > len(_gdcb) {
		_fgad = len(_gdcb) - _cdcgb
	}
	_ddgcc := _gdcb[:_cdcgb]
	var _fgcc []byte
	if _fgad > 0 {
		_fgcc = _gdcb[_cdcgb : _cdcgb+_fgad]
	}
	if _cdcgb > 0 && _fgad > 0 {
		_begda := _eaef.loadFromSegments(_ddgcc, _fgcc)
		if _begda != nil {
			return nil, _begda
		}
	}
	return _eaef, nil
}

// GetCerts returns the signature certificate chain.
func (_begec *PdfSignature) GetCerts() ([]*_cb.Certificate, error) {
	var _fbfba []func() ([]*_cb.Certificate, error)
	switch _fedgga, _ := _bgd.GetNameVal(_begec.SubFilter); _fedgga {
	case "\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064", "\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064":
		_fbfba = append(_fbfba, _begec.extractChainFromPKCS7, _begec.extractChainFromCert)
	case "\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031":
		_fbfba = append(_fbfba, _begec.extractChainFromCert)
	case "\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031":
		_fbfba = append(_fbfba, _begec.extractChainFromPKCS7)
	default:
		return nil, _f.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020S\u0075b\u0046i\u006c\u0074\u0065\u0072\u003a\u0020\u0025s", _fedgga)
	}
	for _, _deeff := range _fbfba {
		_bgadgb, _deaa := _deeff()
		if _deaa != nil {
			return nil, _deaa
		}
		if len(_bgadgb) > 0 {
			return _bgadgb, nil
		}
	}
	return nil, ErrSignNoCertificates
}

// PageProcessCallback callback function used in page loading
// that could be used to modify the page content.
//
// If an error is returned, the `ToWriter` process would fail.
//
// This callback, if defined, will take precedence over `PageCallback` callback.
type PageProcessCallback func(_cfag int, _addeb *PdfPage) error

// ToInteger convert to an integer format.
func (_eccc *PdfColorDeviceRGB) ToInteger(bits int) [3]uint32 {
	_adfc := _da.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_adfc * _eccc.R()), uint32(_adfc * _eccc.G()), uint32(_adfc * _eccc.B())}
}

// NewPdfColorspaceDeviceGray returns a new grayscale colorspace.
func NewPdfColorspaceDeviceGray() *PdfColorspaceDeviceGray { return &PdfColorspaceDeviceGray{} }

// multiFontEncoder implements a an Encoder that holds a list of fonts provided.
type MultipleFontEncoder struct {
	_acaed      []*PdfFont
	CurrentFont *PdfFont
}

// ImageToRGB converts Lab colorspace image to RGB and returns the result.
func (_edadb *PdfColorspaceLab) ImageToRGB(img Image) (Image, error) {
	_afbb := func(_bcdb float64) float64 {
		if _bcdb >= 6.0/29 {
			return _bcdb * _bcdb * _bcdb
		}
		return 108.0 / 841 * (_bcdb - 4.0/29.0)
	}
	_addfe := img._agcea
	if len(_addfe) != 6 {
		_fg.Log.Trace("\u0049\u006d\u0061\u0067\u0065\u0020\u002d\u0020\u004c\u0061\u0062\u0020\u0044e\u0063\u006f\u0064\u0065\u0020\u0072\u0061\u006e\u0067e\u0020\u0021\u003d\u0020\u0036\u002e\u002e\u002e\u0020\u0075\u0073\u0065\u0020\u005b0\u0020\u0031\u0030\u0030\u0020\u0061\u006d\u0069\u006e\u0020\u0061\u006d\u0061\u0078\u0020\u0062\u006d\u0069\u006e\u0020\u0062\u006d\u0061\u0078\u005d\u0020\u0064\u0065\u0066\u0061u\u006c\u0074\u0020\u0064\u0065\u0063\u006f\u0064\u0065 \u0061\u0072r\u0061\u0079")
		_addfe = _edadb.DecodeArray()
	}
	_cbac := _eaa.NewReader(img.getBase())
	_edbea := _daf.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, img._bdgdb, img._agcea)
	_ebgga := _eaa.NewWriter(_edbea)
	_cfgf := _da.Pow(2, float64(img.BitsPerComponent)) - 1
	_gcgfa := make([]uint32, 3)
	var (
		_dadg                                              error
		Ls, As, Bs, L, M, N, X, Y, Z, _ebaed, _cdcd, _gbag float64
	)
	for {
		_dadg = _cbac.ReadSamples(_gcgfa)
		if _dadg == _ca.EOF {
			break
		} else if _dadg != nil {
			return img, _dadg
		}
		Ls = float64(_gcgfa[0]) / _cfgf
		As = float64(_gcgfa[1]) / _cfgf
		Bs = float64(_gcgfa[2]) / _cfgf
		Ls = _daf.LinearInterpolate(Ls, 0.0, 1.0, _addfe[0], _addfe[1])
		As = _daf.LinearInterpolate(As, 0.0, 1.0, _addfe[2], _addfe[3])
		Bs = _daf.LinearInterpolate(Bs, 0.0, 1.0, _addfe[4], _addfe[5])
		L = (Ls+16)/116 + As/500
		M = (Ls + 16) / 116
		N = (Ls+16)/116 - Bs/200
		X = _edadb.WhitePoint[0] * _afbb(L)
		Y = _edadb.WhitePoint[1] * _afbb(M)
		Z = _edadb.WhitePoint[2] * _afbb(N)
		_ebaed = 3.240479*X + -1.537150*Y + -0.498535*Z
		_cdcd = -0.969256*X + 1.875992*Y + 0.041556*Z
		_gbag = 0.055648*X + -0.204043*Y + 1.057311*Z
		_ebaed = _da.Min(_da.Max(_ebaed, 0), 1.0)
		_cdcd = _da.Min(_da.Max(_cdcd, 0), 1.0)
		_gbag = _da.Min(_da.Max(_gbag, 0), 1.0)
		_gcgfa[0] = uint32(_ebaed * _cfgf)
		_gcgfa[1] = uint32(_cdcd * _cfgf)
		_gcgfa[2] = uint32(_gbag * _cfgf)
		if _dadg = _ebgga.WriteSamples(_gcgfa); _dadg != nil {
			return img, _dadg
		}
	}
	return _acfa(&_edbea), nil
}

// GetNumComponents returns the number of color components (3 for CalRGB).
func (_dccfb *PdfColorCalRGB) GetNumComponents() int { return 3 }

func (_cae *PdfReader) newPdfAnnotationMovieFromDict(_gdca *_bgd.PdfObjectDictionary) (*PdfAnnotationMovie, error) {
	_bdab := PdfAnnotationMovie{}
	_bdab.T = _gdca.Get("\u0054")
	_bdab.Movie = _gdca.Get("\u004d\u006f\u0076i\u0065")
	_bdab.A = _gdca.Get("\u0041")
	return &_bdab, nil
}

// NewPdfActionSound returns a new "sound" action.
func NewPdfActionSound() *PdfActionSound {
	_efac := NewPdfAction()
	_ad := &PdfActionSound{}
	_ad.PdfAction = _efac
	_efac.SetContext(_ad)
	return _ad
}

func (_cbcbe *Image) samplesAddPadding(_acdce []uint32) []uint32 {
	_eeggb := _daf.BytesPerLine(int(_cbcbe.Width), int(_cbcbe.BitsPerComponent), _cbcbe.ColorComponents) * (8 / int(_cbcbe.BitsPerComponent))
	_cgaae := _eeggb * int(_cbcbe.Height)
	if len(_acdce) == _cgaae {
		return _acdce
	}
	_bagc := make([]uint32, _cgaae)
	_dgfb := int(_cbcbe.Width) * _cbcbe.ColorComponents
	for _decca := 0; _decca < int(_cbcbe.Height); _decca++ {
		_eebde := _decca * int(_cbcbe.Width)
		_gcde := _decca * _eeggb
		for _bgbef := 0; _bgbef < _dgfb; _bgbef++ {
			_bagc[_gcde+_bgbef] = _acdce[_eebde+_bgbef]
		}
	}
	return _bagc
}

func (_gdbe *PdfPage) flattenFieldsWithOpts(_abga FieldAppearanceGenerator, _ebbd *FieldFlattenOpts, _bfaef map[*PdfAnnotation]bool) error {
	var _agaa []*PdfAnnotation
	if _abga != nil {
		if _feac := _abga.WrapContentStream(_gdbe); _feac != nil {
			return _feac
		}
	}
	_bbab, _dbddb := _gdbe.GetAnnotations()
	if _dbddb != nil {
		return _dbddb
	}
	for _, _affb := range _bbab {
		_edfca, _caec := _bfaef[_affb]
		if !_caec && _ebbd.AnnotFilterFunc != nil {
			if _, _gcea := _affb.GetContext().(*PdfAnnotationWidget); !_gcea {
				_caec = _ebbd.AnnotFilterFunc(_affb)
			}
		}
		if !_caec {
			_agaa = append(_agaa, _affb)
			continue
		}
		switch _affb.GetContext().(type) {
		case *PdfAnnotationPopup:
			continue
		case *PdfAnnotationLink:
			continue
		case *PdfAnnotationProjection:
			continue
		}
		_cgdba, _bedec, _ccagd := _cfgb(_affb)
		if _ccagd != nil {
			if !_edfca {
				_fg.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0056\u0020\u002d\u003e\u0020\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075t\u0020\u0061p\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065am\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072")
				continue
			}
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d,\u0020\u0065\u0072\u0072\u0020\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0073\u006bi\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072", _ccagd)
			continue
		}
		if _cgdba == nil {
			continue
		}
		_bgfa := _gdbe.Resources.GenerateXObjectName()
		_gdbe.Resources.SetXObjectFormByName(_bgfa, _cgdba)
		_cedae, _cbgbf, _ccagd := _egcbg(_cgdba)
		if _ccagd != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0061\u0070p\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u004d\u0061\u0074\u0072\u0069\u0078\u002c\u0020s\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0078\u0066\u006f\u0072\u006d\u0020\u0062\u0062\u006f\u0078\u0020\u0061\u0064\u006a\u0075\u0073t\u006d\u0065\u006e\u0074\u003a \u0025\u0076", _ccagd)
		} else {
			_cafcf := _ga.IdentityMatrix()
			_cafcf = _cafcf.Translate(-_cedae.Llx, -_cedae.Lly)
			if _cbgbf {
				_bfedc := 1.0
				if _cedae.Width() > 0 {
					_bfedc = _da.Round(_bedec.Width() / _cedae.Width())
				}
				_gedfc := 1.0
				if _cedae.Height() > 0 {
					_gedfc = _da.Round(_bedec.Height() / _cedae.Height())
				}
				_cafcf = _cafcf.Scale(_bfedc, _gedfc)
			}
			_bedec.Transform(_cafcf)
		}
		_egfff := _da.Min(_bedec.Llx, _bedec.Urx)
		_dbgb := _da.Min(_bedec.Lly, _bedec.Ury)
		var _abgdb []string
		_abgdb = append(_abgdb, "\u0071")
		_abgdb = append(_abgdb, _f.Sprintf("\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020%\u002e6\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0063\u006d", 1.0, 0.0, 0.0, 1.0, _egfff, _dbgb))
		_abgdb = append(_abgdb, _f.Sprintf("\u002f\u0025\u0073\u0020\u0044\u006f", _bgfa.String()))
		_abgdb = append(_abgdb, "\u0051")
		_adaf := _ef.Join(_abgdb, "\u000a")
		_ccagd = _gdbe.AppendContentStream(_adaf)
		if _ccagd != nil {
			return _ccagd
		}
		if _cgdba.Resources != nil {
			_efbab, _eebba := _bgd.GetDict(_cgdba.Resources.Font)
			if _eebba {
				for _, _fdfc := range _efbab.Keys() {
					if !_gdbe.Resources.HasFontByName(_fdfc) {
						_gdbe.Resources.SetFontByName(_fdfc, _efbab.Get(_fdfc))
					}
				}
			}
		}
	}
	if len(_agaa) > 0 {
		_gdbe._dffab = _agaa
	} else {
		_gdbe._dffab = []*PdfAnnotation{}
	}
	return nil
}

// PdfActionNamed represents a named action.
type PdfActionNamed struct {
	*PdfAction
	N _bgd.PdfObject
}

// Set applies flag fl to the flag's bitmask and returns the combined flag.
func (_daeabe FieldFlag) Set(fl FieldFlag) FieldFlag { return FieldFlag(_daeabe.Mask() | fl.Mask()) }

// HasExtGState checks whether a font is defined by the specified keyName.
func (_geagd *PdfPageResources) HasExtGState(keyName _bgd.PdfObjectName) bool {
	_, _beeee := _geagd.GetFontByName(keyName)
	return _beeee
}

// KValue is a wrapper object to hold various type of K's children objects.
type KValue struct {
	_fgcbd *KDict
	_bcdd  _bgd.PdfObject
	_ecdf  *int
}

// DecodeArray returns the component range values for the Indexed colorspace.
func (_gdef *PdfColorspaceSpecialIndexed) DecodeArray() []float64 {
	return []float64{0, float64(_gdef.HiVal)}
}

// ToPdfObject implements interface PdfModel.
func (_bgggf *PdfSignature) ToPdfObject() _bgd.PdfObject {
	_cffd := _bgggf._ddggd
	var _egggee *_bgd.PdfObjectDictionary
	if _cbabd, _ffgca := _cffd.PdfObject.(*pdfSignDictionary); _ffgca {
		_egggee = _cbabd.PdfObjectDictionary
	} else {
		_egggee = _cffd.PdfObject.(*_bgd.PdfObjectDictionary)
	}
	_egggee.SetIfNotNil("\u0054\u0079\u0070\u0065", _bgggf.Type)
	_egggee.SetIfNotNil("\u0046\u0069\u006c\u0074\u0065\u0072", _bgggf.Filter)
	_egggee.SetIfNotNil("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r", _bgggf.SubFilter)
	_egggee.SetIfNotNil("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _bgggf.ByteRange)
	_egggee.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _bgggf.Contents)
	_egggee.SetIfNotNil("\u0043\u0065\u0072\u0074", _bgggf.Cert)
	_egggee.SetIfNotNil("\u004e\u0061\u006d\u0065", _bgggf.Name)
	_egggee.SetIfNotNil("\u0052\u0065\u0061\u0073\u006f\u006e", _bgggf.Reason)
	_egggee.SetIfNotNil("\u004d", _bgggf.M)
	_egggee.SetIfNotNil("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e", _bgggf.Reference)
	_egggee.SetIfNotNil("\u0043h\u0061\u006e\u0067\u0065\u0073", _bgggf.Changes)
	_egggee.SetIfNotNil("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f", _bgggf.ContactInfo)
	_egggee.SetIfNotNil("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e", _bgggf.Location)
	return _cffd
}

func (_agbcce *pdfFontType3) getFontDescriptor() *PdfFontDescriptor { return _agbcce._ggde }

func (_cgbd *PdfReader) newPdfAnnotationMarkupFromDict(_dff *_bgd.PdfObjectDictionary) (*PdfAnnotationMarkup, error) {
	_fbe := &PdfAnnotationMarkup{}
	if _fdeb := _dff.Get("\u0054"); _fdeb != nil {
		_fbe.T = _fdeb
	}
	if _def := _dff.Get("\u0050\u006f\u0070u\u0070"); _def != nil {
		_faf, _cfge := _def.(*_bgd.PdfIndirectObject)
		if !_cfge {
			if _, _ffa := _def.(*_bgd.PdfObjectNull); !_ffa {
				return nil, _gb.New("p\u006f\u0070\u0075\u0070\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074\u0020t\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074")
			}
		} else {
			_bcde, _bbeg := _cgbd.newPdfAnnotationFromIndirectObject(_faf)
			if _bbeg != nil {
				return nil, _bbeg
			}
			if _bcde != nil {
				_fcbf, _fgc := _bcde._dabfb.(*PdfAnnotationPopup)
				if !_fgc {
					return nil, _gb.New("\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0072\u0065\u0066\u0065\u0072\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0020\u0070\u006f\u0070\u0075\u0070\u0020\u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e")
				}
				_fbe.Popup = _fcbf
			}
		}
	}
	if _gcd := _dff.Get("\u0043\u0041"); _gcd != nil {
		_fbe.CA = _gcd
	}
	if _eege := _dff.Get("\u0052\u0043"); _eege != nil {
		_fbe.RC = _eege
	}
	if _egf := _dff.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065"); _egf != nil {
		_fbe.CreationDate = _egf
	}
	if _dbb := _dff.Get("\u0049\u0052\u0054"); _dbb != nil {
		_fbe.IRT = _dbb
	}
	if _cgc := _dff.Get("\u0053\u0075\u0062\u006a"); _cgc != nil {
		_fbe.Subj = _cgc
	}
	if _efe := _dff.Get("\u0052\u0054"); _efe != nil {
		_fbe.RT = _efe
	}
	if _eca := _dff.Get("\u0049\u0054"); _eca != nil {
		_fbe.IT = _eca
	}
	if _bcb := _dff.Get("\u0045\u0078\u0044\u0061\u0074\u0061"); _bcb != nil {
		_fbe.ExData = _bcb
	}
	return _fbe, nil
}

// GetFontDescriptor returns the font descriptor for `font`.
func (_gdacd PdfFont) GetFontDescriptor() (*PdfFontDescriptor, error) {
	return _gdacd._cbec.getFontDescriptor(), nil
}

// Mask returns the uin32 bitmask for the specific flag.
func (_efcf FieldFlag) Mask() uint32 { return uint32(_efcf) }

// SetHideMenubar sets the value of the hideMenubar flag.
func (_cbagf *ViewerPreferences) SetHideMenubar(hideMenubar bool) { _cbagf._gfca = &hideMenubar }

// ToPdfObject converts the ID tree to a PDF object.
func (_cedfa *IDTree) ToPdfObject() _bgd.PdfObject {
	_cfaac := _bgd.MakeDict()
	if _cedfa.Names != nil && _cedfa.Names.Len() > 0 {
		_cfaac.Set("\u004e\u0061\u006de\u0073", _cedfa.Names)
		_cfaac.Set("\u004c\u0069\u006d\u0069\u0074\u0073", _cedfa.Limits)
	}
	if len(_cedfa.Kids) > 0 {
		_bdea := _bgd.MakeArray()
		for _, _bgdfa := range _cedfa.Kids {
			_bdea.Append(_bgdfa.ToPdfObject())
		}
		_bcade := _bgd.MakeDict()
		_bcade.Set("\u004b\u0069\u0064\u0073", _bdea)
		_cfaac.Set("\u004b\u0069\u0064\u0073", _bcade)
	}
	return _cfaac
}

var (
	StructureTypeUnknown       StructureType = ""
	StructureTypeDocument      StructureType = "\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074"
	StructureTypePart          StructureType = "\u0050\u0061\u0072\u0074"
	StructureTypeArticle       StructureType = "\u0041\u0072\u0074"
	StructureTypeSection       StructureType = "\u0053\u0065\u0063\u0074"
	StructureTypeDivision      StructureType = "\u0044\u0069\u0076"
	StructureTypeBlockQuote    StructureType = "\u0042\u006c\u006f\u0063\u006b\u0051\u0075\u006f\u0074\u0065"
	StructureTypeCaption       StructureType = "\u0043a\u0070\u0074\u0069\u006f\u006e"
	StructureTypeTOC           StructureType = "\u0054\u004f\u0043"
	StructureTypeTOCI          StructureType = "\u0054\u004f\u0043\u0049"
	StructureTypeIndex         StructureType = "\u0049\u006e\u0064e\u0078"
	StructureTypeNonStructural StructureType = "\u004eo\u006e\u0053\u0074\u0072\u0075\u0063t"
	StructureTypePrivate       StructureType = "\u0050r\u0069\u0076\u0061\u0074\u0065"
)

func (_defdg *PdfWriter) setDocInfo(_acgba _bgd.PdfObject) {
	if _defdg.hasObject(_defdg._gefe) {
		delete(_defdg._abccd, _defdg._gefe)
		delete(_defdg._accgae, _defdg._gefe)
		for _eedcd, _effee := range _defdg._edcbg {
			if _effee == _defdg._gefe {
				copy(_defdg._edcbg[_eedcd:], _defdg._edcbg[_eedcd+1:])
				_defdg._edcbg[len(_defdg._edcbg)-1] = nil
				_defdg._edcbg = _defdg._edcbg[:len(_defdg._edcbg)-1]
				break
			}
		}
	}
	_ffeed := _bgd.PdfIndirectObject{}
	_ffeed.PdfObject = _acgba
	_defdg._gefe = &_ffeed
	_defdg.addObject(&_ffeed)
}

// GetMediaBox gets the inheritable media box value, either from the page
// or a higher up page/pages struct.
func (_gcaa *PdfPage) GetMediaBox() (*PdfRectangle, error) {
	if _gcaa.MediaBox != nil {
		return _gcaa.MediaBox, nil
	}
	_fbca := _gcaa.Parent
	for _fbca != nil {
		_cggfe, _cebaa := _bgd.GetDict(_fbca)
		if !_cebaa {
			return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _fabgb := _cggfe.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _fabgb != nil {
			_gdfe, _acbba := _bgd.GetArray(_fabgb)
			if !_acbba {
				return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0064\u0069a\u0020\u0062\u006f\u0078")
			}
			_abad, _fceee := NewPdfRectangle(*_gdfe)
			if _fceee != nil {
				return nil, _fceee
			}
			return _abad, nil
		}
		_fbca = _cggfe.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, _gb.New("m\u0065\u0064\u0069\u0061 b\u006fx\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064")
}

// Items returns all children outline items.
func (_ggge *OutlineItem) Items() []*OutlineItem { return _ggge.Entries }

// AlphaMap performs mapping of alpha data for transformations. Allows custom filtering of alpha data etc.
func (_gfcec *Image) AlphaMap(mapFunc AlphaMapFunc) {
	for _gcagb, _aeae := range _gfcec._bdgdb {
		_gfcec._bdgdb[_gcagb] = mapFunc(_aeae)
	}
}

func (_dcc *PdfReader) newPdfActionNamedFromDict(_dfc *_bgd.PdfObjectDictionary) (*PdfActionNamed, error) {
	return &PdfActionNamed{N: _dfc.Get("\u004e")}, nil
}

// ToPdfObject sets the common field elements.
// Note: Call the more field context's ToPdfObject to set both the generic and
// non-generic information.
func (_ddcbe *PdfField) ToPdfObject() _bgd.PdfObject {
	_aefdef := _ddcbe._bcgde
	_fdfdg := _aefdef.PdfObject.(*_bgd.PdfObjectDictionary)
	_gfbf := _bgd.MakeArray()
	for _, _dege := range _ddcbe.Kids {
		_gfbf.Append(_dege.ToPdfObject())
	}
	for _, _feaf := range _ddcbe.Annotations {
		if _feaf._eag != _ddcbe._bcgde {
			_gfbf.Append(_feaf.GetContext().ToPdfObject())
		}
	}
	if _ddcbe.Parent != nil {
		_fdfdg.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _ddcbe.Parent.GetContainingPdfObject())
	}
	if _gfbf.Len() > 0 {
		_fdfdg.Set("\u004b\u0069\u0064\u0073", _gfbf)
	}
	_fdfdg.SetIfNotNil("\u0046\u0054", _ddcbe.FT)
	_fdfdg.SetIfNotNil("\u0054", _ddcbe.T)
	_fdfdg.SetIfNotNil("\u0054\u0055", _ddcbe.TU)
	_fdfdg.SetIfNotNil("\u0054\u004d", _ddcbe.TM)
	_fdfdg.SetIfNotNil("\u0046\u0066", _ddcbe.Ff)
	_fdfdg.SetIfNotNil("\u0056", _ddcbe.V)
	_fdfdg.SetIfNotNil("\u0044\u0056", _ddcbe.DV)
	_fdfdg.SetIfNotNil("\u0041\u0041", _ddcbe.AA)
	if _ddcbe.VariableText != nil {
		_fdfdg.SetIfNotNil("\u0044\u0041", _ddcbe.VariableText.DA)
		_fdfdg.SetIfNotNil("\u0051", _ddcbe.VariableText.Q)
		_fdfdg.SetIfNotNil("\u0044\u0053", _ddcbe.VariableText.DS)
		_fdfdg.SetIfNotNil("\u0052\u0056", _ddcbe.VariableText.RV)
	}
	return _aefdef
}

// PartialName returns the partial name of the field.
func (_aebc *PdfField) PartialName() string {
	_gafcd := ""
	if _aebc.T != nil {
		_gafcd = _aebc.T.Decoded()
	} else {
		_fg.Log.Debug("\u0046\u0069el\u0064\u0020\u006di\u0073\u0073\u0069\u006eg T\u0020fi\u0065\u006c\u0064\u0020\u0028\u0069\u006eco\u006d\u0070\u0061\u0074\u0069\u0062\u006ce\u0029")
	}
	return _gafcd
}

// FullName returns the full name of the field as in rootname.parentname.partialname.
func (_cfege *PdfField) FullName() (string, error) {
	var _cbfc _ea.Buffer
	_eafeb := []string{}
	if _cfege.T != nil {
		_eafeb = append(_eafeb, _cfege.T.Decoded())
	}
	_eacd := map[*PdfField]bool{}
	_eacd[_cfege] = true
	_eeaf := _cfege.Parent
	for _eeaf != nil {
		if _, _efd := _eacd[_eeaf]; _efd {
			return _cbfc.String(), _gb.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		if _eeaf.T == nil {
			return _cbfc.String(), _gb.New("\u0066\u0069el\u0064\u0020\u0070a\u0072\u0074\u0069\u0061l n\u0061me\u0020\u0028\u0054\u0029\u0020\u006e\u006ft \u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064")
		}
		_eafeb = append(_eafeb, _eeaf.T.Decoded())
		_eacd[_eeaf] = true
		_eeaf = _eeaf.Parent
	}
	for _fgbf := len(_eafeb) - 1; _fgbf >= 0; _fgbf-- {
		_cbfc.WriteString(_eafeb[_fgbf])
		if _fgbf > 0 {
			_cbfc.WriteString("\u002e")
		}
	}
	return _cbfc.String(), nil
}

// NewPdfActionRendition returns a new "rendition" action.
func NewPdfActionRendition() *PdfActionRendition {
	_bea := NewPdfAction()
	_dcg := &PdfActionRendition{}
	_dcg.PdfAction = _bea
	_bea.SetContext(_dcg)
	return _dcg
}

// GetContainingPdfObject implements model.PdfModel interface.
func (_bbcd *PdfOutputIntent) GetContainingPdfObject() _bgd.PdfObject { return _bbcd._gfcce }

// ToPdfOutline returns a low level PdfOutline object, based on the current
// instance.
func (_ccbafb *Outline) ToPdfOutline() *PdfOutline {
	_ceabc := NewPdfOutline()
	var _gdbf []*PdfOutlineItem
	var _dbcge int64
	var _dabdb *PdfOutlineItem
	for _, _eccdb := range _ccbafb.Entries {
		_bdbb, _bdded := _eccdb.ToPdfOutlineItem()
		_bdbb.Parent = &_ceabc.PdfOutlineTreeNode
		if _dabdb != nil {
			_dabdb.Next = &_bdbb.PdfOutlineTreeNode
			_bdbb.Prev = &_dabdb.PdfOutlineTreeNode
		}
		_gdbf = append(_gdbf, _bdbb)
		_dbcge += _bdded
		_dabdb = _bdbb
	}
	_gcga := int64(len(_gdbf))
	_dbcge += _gcga
	if _gcga > 0 {
		_ceabc.First = &_gdbf[0].PdfOutlineTreeNode
		_ceabc.Last = &_gdbf[_gcga-1].PdfOutlineTreeNode
		_ceabc.Count = &_dbcge
	}
	return _ceabc
}

// GetOptimizer returns current PDF optimizer.
func (_agaba *PdfWriter) GetOptimizer() Optimizer { return _agaba._acff }

// PdfShadingPattern is a Shading patterns that provide a smooth transition between colors across an area to be painted,
// i.e. color(x,y) = f(x,y) at each point.
// It is a type 2 pattern (PatternType = 2).
type PdfShadingPattern struct {
	*PdfPattern
	Shading   *PdfShading
	Matrix    *_bgd.PdfObjectArray
	ExtGState _bgd.PdfObject
}

// NewKDictFromPdfObject creates a new K dictionary object from a PDF object.
func NewKDictFromPdfObject(obj _bgd.PdfObject) (*KDict, error) {
	_gcfac := _bgd.ResolveReference(obj)
	if _gcfac == nil {
		return nil, _f.Errorf("\u004b \u006fb\u006a\u0065\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
	}
	_geffcc, _ddeeac := _bgd.GetDict(_gcfac)
	if !_ddeeac {
		return nil, _f.Errorf("\u004b\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072\u0079")
	}
	_eaagg := &KDict{}
	if _fgfbd := _geffcc.Get("\u0053"); _fgfbd != nil {
		_eaagg.S = _fgfbd
	}
	if _bfbga := _geffcc.Get("\u0050"); _bfbga != nil {
		_eaagg.P = _bfbga
	}
	if _cdfece := _geffcc.Get("\u0049\u0044"); _cdfece != nil {
		if _dcbed, _cggad := _bgd.GetString(_cdfece); _cggad {
			_eaagg.ID = _dcbed
		}
	}
	if _daabd := _geffcc.Get("\u0050\u0067"); _daabd != nil {
		_eaagg.Pg = _daabd
	}
	if _bebef := _geffcc.Get("\u004b"); _bebef != nil {
		_eaagg.K = _bebef
		switch _ebffe := _bebef.(type) {
		case *_bgd.PdfObjectArray:
			if _bfbb, _cddca := _bgd.GetArray(_bebef); _cddca {
				for _, _bgcae := range _bfbb.Elements() {
					switch _ggff := _bgcae.(type) {
					case *_bgd.PdfIndirectObject:
						_cagad, _ddfff := NewKDictFromPdfObject(_ggff)
						if _ddfff != nil {
							_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u004b\u0020\u0063\u0068\u0069\u006c\u0064:\u0020\u0025\u0076", _ddfff)
							continue
						}
						_eaagg._fabbb = append(_eaagg._fabbb, &KValue{_fgcbd: _cagad})
					case *_bgd.PdfObjectInteger:
						if _aeacc, _fcbbb := _bgd.GetIntVal(_bgcae); _fcbbb {
							_eaagg._fabbb = append(_eaagg._fabbb, &KValue{_ecdf: &_aeacc})
						}
					case *_bgd.PdfObjectDictionary:
						_eaagg._fabbb = append(_eaagg._fabbb, &KValue{_bcdd: _bgcae})
					}
				}
			}
		case *_bgd.PdfIndirectObject:
			_gebabf, _bdcaa := NewKDictFromPdfObject(_ebffe)
			if _bdcaa != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u004b\u0020\u0063\u0068\u0069\u006c\u0064:\u0020\u0025\u0076", _bdcaa)
			}
			if _gebabf != nil {
				_eaagg._fabbb = append(_eaagg._fabbb, &KValue{_fgcbd: _gebabf})
			}
		case *_bgd.PdfObjectDictionary:
			_eaagg._fabbb = append(_eaagg._fabbb, &KValue{_bcdd: _ebffe})
		case *_bgd.PdfObjectInteger:
			if _ecge, _ccdfe := _bgd.GetIntVal(_bebef); _ccdfe {
				_eaagg._fabbb = append(_eaagg._fabbb, &KValue{_ecdf: &_ecge})
			}
		}
	}
	if _cbfdg := _geffcc.Get("\u0041"); _cbfdg != nil {
		_eaagg.A = _cbfdg
	}
	if _eegbc := _geffcc.Get("\u0043"); _eegbc != nil {
		_eaagg.C = _eegbc
	}
	if _baefc := _geffcc.Get("\u0052"); _baefc != nil {
		if _agaagb, _cddad := _bgd.GetInt(_baefc); _cddad {
			_eaagg.R = _agaagb
		}
	}
	if _gefag := _geffcc.Get("\u0054"); _gefag != nil {
		if _afbgea, _bfegf := _bgd.GetString(_gefag); _bfegf {
			_eaagg.T = _afbgea
		}
	}
	if _fffec := _geffcc.Get("\u004c\u0061\u006e\u0067"); _fffec != nil {
		if _fddb, _bgcag := _bgd.GetString(_fffec); _bgcag {
			_eaagg.Lang = _fddb
		}
	}
	if _daegb := _geffcc.Get("\u0041\u006c\u0074"); _daegb != nil {
		if _gbgbf, _gfdge := _bgd.GetString(_daegb); _gfdge {
			_eaagg.Alt = _gbgbf
		}
	}
	if _agece := _geffcc.Get("\u0045"); _agece != nil {
		if _agab, _cfcee := _bgd.GetString(_agece); _cfcee {
			_eaagg.E = _agab
		}
	}
	if _decce := _geffcc.Get("\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074"); _decce != nil {
		if _gdbcb, _aebbca := _bgd.GetString(_decce); _aebbca {
			_eaagg.ActualText = _gdbcb
		}
	}
	return _eaagg, nil
}

// PickTrayByPDFSize returns the value of the pickTrayByPDFSize flag.
func (_bddec *ViewerPreferences) PickTrayByPDFSize() bool {
	if _bddec._babbb == nil {
		return false
	}
	return *_bddec._babbb
}

var ErrColorOutOfRange = _gb.New("\u0063o\u006co\u0072\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065")

// ToPdfObject implements interface PdfModel.
func (_ede *PdfActionSound) ToPdfObject() _bgd.PdfObject {
	_ede.PdfAction.ToPdfObject()
	_cbeb := _ede._fab
	_cga := _cbeb.PdfObject.(*_bgd.PdfObjectDictionary)
	_cga.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeSound)))
	_cga.SetIfNotNil("\u0053\u006f\u0075n\u0064", _ede.Sound)
	_cga.SetIfNotNil("\u0056\u006f\u006c\u0075\u006d\u0065", _ede.Volume)
	_cga.SetIfNotNil("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073", _ede.Synchronous)
	_cga.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _ede.Repeat)
	_cga.SetIfNotNil("\u004d\u0069\u0078", _ede.Mix)
	return _cbeb
}

// PdfDate represents a date, which is a PDF string of the form:
// (D:YYYYMMDDHHmmSSOHH'mm)
type PdfDate struct {
	_ccgca int64
	_agbb  int64
	_bdef  int64
	_ccdga int64
	_cfba  int64
	_cgde  int64
	_eceda byte
	_bgcab int64
	_dgbfg int64
}

// OutlineDest represents the destination of an outline item.
// It holds the page and the position on the page an outline item points to.
type OutlineDest struct {
	PageObj *_bgd.PdfIndirectObject `json:"-"`
	Page    int64                   `json:"page"`
	Mode    string                  `json:"mode"`
	X       float64                 `json:"x"`
	Y       float64                 `json:"y"`
	Zoom    float64                 `json:"zoom"`
}

// NewImageFromGoImage creates a new NRGBA32 unidoc Image from a golang Image.
// If `goimg` is grayscale (*goimage.Gray8) then calls NewGrayImageFromGoImage instead.
func (_ffac DefaultImageHandler) NewImageFromGoImage(goimg _fc.Image) (*Image, error) {
	_ffda, _affeg := _daf.FromGoImage(goimg)
	if _affeg != nil {
		return nil, _affeg
	}
	_gcdg := _acfa(_ffda.Base())
	return &_gcdg, nil
}

// ToPdfObject converts the font to a PDF representation.
func (_aedce *pdfFontType0) ToPdfObject() _bgd.PdfObject {
	if _aedce._gfcgdc == nil {
		_aedce._gfcgdc = &_bgd.PdfIndirectObject{}
	}
	_ddcg := _aedce.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0030")
	_aedce._gfcgdc.PdfObject = _ddcg
	if _aedce.Encoding != nil {
		_ddcg.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _aedce.Encoding)
	} else if _aedce._dbcf != nil {
		_ddcg.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _aedce._dbcf.ToPdfObject())
	}
	if _aedce.DescendantFont != nil {
		_ddcg.Set("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073", _bgd.MakeArray(_aedce.DescendantFont.ToPdfObject()))
	}
	return _aedce._gfcgdc
}

func _fggc(_ceabg *[]*PdfField, _eefgb FieldFilterFunc, _ddac bool) []*PdfField {
	if _ceabg == nil {
		return nil
	}
	_gdagc := *_ceabg
	if len(*_ceabg) == 0 {
		return nil
	}
	_bdfd := _gdagc[:0]
	if _eefgb == nil {
		_eefgb = func(*PdfField) bool { return true }
	}
	var _ecaf []*PdfField
	for _, _adff := range _gdagc {
		_gfdaa := _eefgb(_adff)
		if _gfdaa {
			_ecaf = append(_ecaf, _adff)
			if len(_adff.Kids) > 0 {
				_ecaf = append(_ecaf, _fggc(&_adff.Kids, _eefgb, _ddac)...)
			}
		}
		if !_ddac || !_gfdaa || len(_adff.Kids) > 0 {
			_bdfd = append(_bdfd, _adff)
		}
	}
	*_ceabg = _bdfd
	return _ecaf
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_dcfaf *PdfShading) ToPdfObject() _bgd.PdfObject {
	_cgfff := _dcfaf._gccfe
	_beegc, _aacfa := _dcfaf.getShadingDict()
	if _aacfa != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _dcfaf.ShadingType != nil {
		_beegc.Set("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _dcfaf.ShadingType)
	}
	if _dcfaf.ColorSpace != nil {
		_beegc.Set("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _dcfaf.ColorSpace.ToPdfObject())
	}
	if _dcfaf.Background != nil {
		_beegc.Set("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064", _dcfaf.Background)
	}
	if _dcfaf.BBox != nil {
		_beegc.Set("\u0042\u0042\u006f\u0078", _dcfaf.BBox.ToPdfObject())
	}
	if _dcfaf.AntiAlias != nil {
		_beegc.Set("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s", _dcfaf.AntiAlias)
	}
	return _cgfff
}

// GetCapHeight returns the CapHeight of the font `descriptor`.
func (_ecedd *PdfFontDescriptor) GetCapHeight() (float64, error) {
	return _bgd.GetNumberAsFloat(_ecedd.CapHeight)
}

func (_fabc *LTV) getCRLs(_aafcf []*_cb.Certificate) ([][]byte, error) {
	_ffcfg := make([][]byte, 0, len(_aafcf))
	for _, _dfdab := range _aafcf {
		for _, _aafaa := range _dfdab.CRLDistributionPoints {
			if _fabc.CertClient.IsCA(_dfdab) {
				continue
			}
			_abbd, _ddaeg := _fabc.CRLClient.MakeRequest(_aafaa, _dfdab)
			if _ddaeg != nil {
				_fg.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076", _ddaeg)
				continue
			}
			_ffcfg = append(_ffcfg, _abbd)
		}
	}
	return _ffcfg, nil
}

// EnableChain adds the specified certificate chain and validation data (OCSP
// and CRL information) for it to the global scope of the document DSS. The
// added data is used for validating any of the signatures present in the
// document. The LTV client attempts to build the certificate chain up to a
// trusted root by downloading any missing certificates.
func (_dfcbf *LTV) EnableChain(chain []*_cb.Certificate) error {
	return _dfcbf.enable(nil, chain, "")
}

func _gedd(_dbaabd *_bgd.PdfObjectDictionary, _acbed *fontCommon) (*pdfCIDFontType2, error) {
	if _acbed._gecd != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_fg.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0032\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _acbed)
		return nil, _bgd.ErrRangeError
	}
	_cecb := _fcegd(_acbed)
	_cefeg, _eegfc := _bgd.GetDict(_dbaabd.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_eegfc {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _acbed)
		return nil, ErrRequiredAttributeMissing
	}
	_cecb.CIDSystemInfo = _cefeg
	_cecb.DW = _dbaabd.Get("\u0044\u0057")
	_cecb.W = _dbaabd.Get("\u0057")
	_cecb.DW2 = _dbaabd.Get("\u0044\u0057\u0032")
	_cecb.W2 = _dbaabd.Get("\u0057\u0032")
	_cecb.CIDToGIDMap = _dbaabd.Get("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070")
	_cecb._addg = 1000.0
	if _bffea, _acacba := _bgd.GetNumberAsFloat(_cecb.DW); _acacba == nil {
		_cecb._addg = _bffea
	}
	_aabfb, _aggff := _ggcdcc(_cecb.W)
	if _aggff != nil {
		return nil, _aggff
	}
	if _aabfb == nil {
		_aabfb = map[_dabf.CharCode]float64{}
	}
	_cecb._adba = _aabfb
	return _cecb, nil
}

func (_ccdbc fontCommon) isCIDFont() bool {
	if _ccdbc._gecd == "" {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0069\u0073\u0043\u0049\u0044\u0046\u006f\u006e\u0074\u002e\u0020\u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _ccdbc)
	}
	_gfcgd := false
	switch _ccdbc._gecd {
	case "\u0054\u0079\u0070e\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_gfcgd = true
	}
	_fg.Log.Trace("i\u0073\u0043\u0049\u0044\u0046\u006fn\u0074\u003a\u0020\u0069\u0073\u0043\u0049\u0044\u003d%\u0074\u0020\u0066o\u006et\u003d\u0025\u0073", _gfcgd, _ccdbc)
	return _gfcgd
}

// PdfColorspaceSpecialIndexed is an indexed color space is a lookup table, where the input element
// is an index to the lookup table and the output is a color defined in the lookup table in the Base
// colorspace.
// [/Indexed base hival lookup]
type PdfColorspaceSpecialIndexed struct {
	Base   PdfColorspace
	HiVal  int
	Lookup _bgd.PdfObject
	_bcecd []byte
	_ccbaf *_bgd.PdfIndirectObject
}

// AddCRLs adds CRLs to DSS.
func (_eeba *DSS) AddCRLs(crls [][]byte) ([]*_bgd.PdfObjectStream, error) {
	return _eeba.add(&_eeba.CRLs, _eeba._agbcg, crls)
}

func (_bedee *PdfReader) buildNameNodes(_daffb *_bgd.PdfIndirectObject, _gbcf map[_bgd.PdfObject]struct{}) error {
	if _daffb == nil {
		return nil
	}
	if _, _edcd := _gbcf[_daffb]; _edcd {
		_fg.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _daffb.ObjectNumber)
		return nil
	}
	_gbcf[_daffb] = struct{}{}
	_agedg, _gcbf := _daffb.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_gcbf {
		return _gb.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if _gdbec, _baffe := _bgd.GetDict(_agedg.Get("\u0044\u0065\u0073t\u0073")); _baffe {
		_efbgc, _gcdeg := _bgd.GetArray(_gdbec.Get("\u004b\u0069\u0064\u0073"))
		if !_gcdeg {
			return _gb.New("\u0049n\u0076\u0061\u006c\u0069d\u0020\u004b\u0069\u0064\u0073 \u0061r\u0072a\u0079\u0020\u006f\u0062\u006a\u0065\u0063t")
		}
		_fg.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _efbgc)
		for _bebgd, _fdffa := range _efbgc.Elements() {
			_edegd, _bddcc := _bgd.GetIndirect(_fdffa)
			if !_bddcc {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u0068\u0069\u006c\u0064\u0020n\u006f\u0074\u0020\u0069\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002d \u0028\u0025\u0073\u0029", _edegd)
				return _gb.New("\u0063h\u0069\u006c\u0064\u0020n\u006f\u0074\u0020\u0069\u006ed\u0069r\u0065c\u0074\u0020\u006f\u0062\u006a\u0065\u0063t")
			}
			_efbgc.Set(_bebgd, _edegd)
			_eaagb := _bedee.buildNameNodes(_edegd, _gbcf)
			if _eaagb != nil {
				return _eaagb
			}
		}
	}
	if _eeddd, _gaceb := _bgd.GetDict(_agedg); _gaceb {
		if !_bgd.IsNullObject(_eeddd.Get("\u004b\u0069\u0064\u0073")) {
			if _edgdc, _egbg := _bgd.GetArray(_eeddd.Get("\u004b\u0069\u0064\u0073")); _egbg {
				for _fcegg, _cgcdc := range _edgdc.Elements() {
					if _ecgbe, _dcefe := _bgd.GetIndirect(_cgcdc); _dcefe {
						_edgdc.Set(_fcegg, _ecgbe)
						_dggda := _bedee.buildNameNodes(_ecgbe, _gbcf)
						if _dggda != nil {
							return _dggda
						}
					}
				}
			}
		}
	}
	return nil
}

// GetPdfVersion gets the version of the PDF used within this document.
func (_egbbc *PdfWriter) GetPdfVersion() string { return _egbbc.getPdfVersion() }

// ToPdfObject returns the PDF representation of the tiling pattern.
func (_eeacb *PdfTilingPattern) ToPdfObject() _bgd.PdfObject {
	_eeacb.PdfPattern.ToPdfObject()
	_bbdbd := _eeacb.getDict()
	if _eeacb.PaintType != nil {
		_bbdbd.Set("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e", _eeacb.PaintType)
	}
	if _eeacb.TilingType != nil {
		_bbdbd.Set("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _eeacb.TilingType)
	}
	if _eeacb.BBox != nil {
		_bbdbd.Set("\u0042\u0042\u006f\u0078", _eeacb.BBox.ToPdfObject())
	}
	if _eeacb.XStep != nil {
		_bbdbd.Set("\u0058\u0053\u0074e\u0070", _eeacb.XStep)
	}
	if _eeacb.YStep != nil {
		_bbdbd.Set("\u0059\u0053\u0074e\u0070", _eeacb.YStep)
	}
	if _eeacb.Resources != nil {
		_bbdbd.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _eeacb.Resources.ToPdfObject())
	}
	if _eeacb.Matrix != nil {
		_bbdbd.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _eeacb.Matrix)
	}
	return _eeacb._eaddb
}

// Compress is yet to be implemented.
// Should be able to compress in terms of JPEG quality parameter,
// and DPI threshold (need to know bounding area dimensions).
func (_gfacg DefaultImageHandler) Compress(input *Image, quality int64) (*Image, error) {
	return input, nil
}

func (_gbc *PdfReader) newPdfActionGotoRFromDict(_cfg *_bgd.PdfObjectDictionary) (*PdfActionGoToR, error) {
	_gaa, _efbg := _ada(_cfg.Get("\u0046"))
	if _efbg != nil {
		return nil, _efbg
	}
	return &PdfActionGoToR{D: _cfg.Get("\u0044"), NewWindow: _cfg.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _gaa}, nil
}

// PdfAnnotationTrapNet represents TrapNet annotations.
// (Section 12.5.6.21).
type PdfAnnotationTrapNet struct{ *PdfAnnotation }

// ToPdfObject implements interface PdfModel.
func (_gefg *PdfAnnotationText) ToPdfObject() _bgd.PdfObject {
	_gefg.PdfAnnotation.ToPdfObject()
	_bdde := _gefg._eag
	_aeda := _bdde.PdfObject.(*_bgd.PdfObjectDictionary)
	if _gefg.PdfAnnotationMarkup != nil {
		_gefg.appendToPdfDictionary(_aeda)
	}
	_aeda.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0054\u0065\u0078\u0074"))
	_aeda.SetIfNotNil("\u004f\u0070\u0065\u006e", _gefg.Open)
	_aeda.SetIfNotNil("\u004e\u0061\u006d\u0065", _gefg.Name)
	_aeda.SetIfNotNil("\u0053\u0074\u0061t\u0065", _gefg.State)
	_aeda.SetIfNotNil("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c", _gefg.StateModel)
	return _bdde
}

// NewPdfActionGoTo returns a new "go to" action.
func NewPdfActionGoTo() *PdfActionGoTo {
	_aff := NewPdfAction()
	_dc := &PdfActionGoTo{}
	_dc.PdfAction = _aff
	_aff.SetContext(_dc)
	return _dc
}

func (_efae *PdfColorspaceSpecialSeparation) String() string {
	return "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"
}

// SetShadingByName sets a shading resource specified by keyName.
func (_cfcfa *PdfPageResources) SetShadingByName(keyName _bgd.PdfObjectName, shadingObj _bgd.PdfObject) error {
	if _cfcfa.Shading == nil {
		_cfcfa.Shading = _bgd.MakeDict()
	}
	_gagecf, _ddbee := _bgd.GetDict(_cfcfa.Shading)
	if !_ddbee {
		return _bgd.ErrTypeError
	}
	_gagecf.Set(keyName, shadingObj)
	return nil
}

const (
	_ecgf  = 0x00001
	_afef  = 0x00002
	_gdegf = 0x00004
	_fcfb  = 0x00008
	_agfe  = 0x00020
	_dcgd  = 0x00040
	_gedb  = 0x10000
	_dcbf  = 0x20000
	_edafc = 0x40000
)

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a grayscale device.
func (_fbbg *PdfColorspaceDeviceGray) GetNumComponents() int { return 1 }

// GetContext returns a reference to the subshading entry as represented by PdfShadingType1-7.
func (_cbda *PdfShading) GetContext() PdfModel { return _cbda._gggga }

// GetContainingPdfObject returns the container of the image object (indirect object).
func (_bcgdda *XObjectImage) GetContainingPdfObject() _bgd.PdfObject { return _bcgdda._befec }

// AddOCSPs adds OCSPs to DSS.
func (_fdbce *DSS) AddOCSPs(ocsps [][]byte) ([]*_bgd.PdfObjectStream, error) {
	return _fdbce.add(&_fdbce.OCSPs, _fdbce._edecd, ocsps)
}

// GetCatalogMetadata gets the catalog defined XMP Metadata.
func (_ddadg *PdfReader) GetCatalogMetadata() (_bgd.PdfObject, bool) {
	if _ddadg._ffabf == nil {
		return nil, false
	}
	_dcbbd := _ddadg._ffabf.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	return _dcbbd, _dcbbd != nil
}

func (_ggbfg *PdfWriter) updateObjectNumbers() {
	_gggc := _ggbfg.ObjNumOffset
	_gddeg := 0
	for _, _cced := range _ggbfg._edcbg {
		_gfacgb := int64(_gddeg + 1 + _gggc)
		_fdcdb := true
		if _ggbfg._fgaba {
			if _efadb, _edaa := _ggbfg._gbcg[_cced]; _edaa {
				_gfacgb = _efadb
				_fdcdb = false
			}
		}
		switch _ffgcad := _cced.(type) {
		case *_bgd.PdfIndirectObject:
			_ffgcad.ObjectNumber = _gfacgb
			_ffgcad.GenerationNumber = 0
		case *_bgd.PdfObjectStream:
			_ffgcad.ObjectNumber = _gfacgb
			_ffgcad.GenerationNumber = 0
		case *_bgd.PdfObjectStreams:
			_ffgcad.ObjectNumber = _gfacgb
			_ffgcad.GenerationNumber = 0
		case *_bgd.PdfObjectReference:
			_ffgcad.ObjectNumber = _gfacgb
			_ffgcad.GenerationNumber = 0
		case *_bgd.PdfObjectDictionary, *_bgd.PdfObjectString:
		default:
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u0020%\u0054\u0020\u002d\u0020\u0073\u006b\u0069p\u0070\u0069\u006e\u0067", _ffgcad)
			continue
		}
		if _fdcdb {
			_gddeg++
		}
	}
	_cabcg := func(_geegcc _bgd.PdfObject) int64 {
		switch _gbfbb := _geegcc.(type) {
		case *_bgd.PdfIndirectObject:
			return _gbfbb.ObjectNumber
		case *_bgd.PdfObjectStream:
			return _gbfbb.ObjectNumber
		case *_bgd.PdfObjectStreams:
			return _gbfbb.ObjectNumber
		case *_bgd.PdfObjectReference:
			return _gbfbb.ObjectNumber
		}
		return 0
	}
	_bb.SliceStable(_ggbfg._edcbg, func(_beagb, _faacf int) bool { return _cabcg(_ggbfg._edcbg[_beagb]) < _cabcg(_ggbfg._edcbg[_faacf]) })
}

// NewPdfAnnotationRedact returns a new redact annotation.
func NewPdfAnnotationRedact() *PdfAnnotationRedact {
	_dec := NewPdfAnnotation()
	_gdd := &PdfAnnotationRedact{}
	_gdd.PdfAnnotation = _dec
	_gdd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_dec.SetContext(_gdd)
	return _gdd
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_bedd *PdfColorspaceSpecialPattern) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _bedd.UnderlyingCS == nil {
		return nil, _gb.New("u\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0043\u0053\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
	}
	return _bedd.UnderlyingCS.ColorFromFloats(vals)
}

// AddCustomInfo adds a custom info into document info dictionary.
func (_abfff *PdfInfo) AddCustomInfo(name string, value string) error {
	if _abfff._dfeee == nil {
		_abfff._dfeee = _bgd.MakeDict()
	}
	if _, _dcgca := _ddfab[name]; _dcgca {
		return _f.Errorf("\u0063\u0061\u006e\u006e\u006ft\u0020\u0075\u0073\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064 \u0069\u006e\u0066\u006f\u0020\u006b\u0065\u0079\u0020\u0025\u0073\u0020\u0061\u0073\u0020\u0063\u0075\u0073\u0074\u006f\u006d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u006b\u0065y", name)
	}
	_abfff._dfeee.SetIfNotNil(*_bgd.MakeName(name), _bgd.MakeString(value))
	return nil
}

// GetContext returns a reference to the subpattern entry: either PdfTilingPattern or PdfShadingPattern.
func (_dagec *PdfPattern) GetContext() PdfModel { return _dagec._ggafd }

// Val returns the color value.
func (_dfgd *PdfColorDeviceGray) Val() float64 { return float64(*_dfgd) }

// IsEncrypted returns true if the PDF file is encrypted.
func (_aedee *PdfReader) IsEncrypted() (bool, error) { return _aedee._ccade.IsEncrypted() }

// ImageToRGB returns the passed in image. Method exists in order to satisfy
// the PdfColorspace interface.
func (_afcc *PdfColorspaceDeviceRGB) ImageToRGB(img Image) (Image, error) { return img, nil }

// Encoder returns the font's text encoder.
func (_faeg pdfCIDFontType0) Encoder() _dabf.TextEncoder { return _faeg._gddac }

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_gbdb *PdfColorspaceCalGray) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_adfcc, _cbdb := _bgd.GetNumbersAsFloat(objects)
	if _cbdb != nil {
		return nil, _cbdb
	}
	return _gbdb.ColorFromFloats(_adfcc)
}

// NewPdfAnnotationWidget returns an initialized annotation widget.
func NewPdfAnnotationWidget() *PdfAnnotationWidget {
	_gcad := NewPdfAnnotation()
	_cagf := &PdfAnnotationWidget{}
	_cagf.PdfAnnotation = _gcad
	_gcad.SetContext(_cagf)
	return _cagf
}

// NewKDictionary creates a new K dictionary object.
func NewKDictionary() *KDict { return &KDict{_fabbb: make([]*KValue, 0), _eddd: -1} }

func _eagfbb(_cgcae *_bgd.PdfObjectDictionary) (*PdfShadingType1, error) {
	_fbda := PdfShadingType1{}
	if _fgcge := _cgcae.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _fgcge != nil {
		_fgcge = _bgd.TraceToDirectObject(_fgcge)
		_ebdbg, _efggb := _fgcge.(*_bgd.PdfObjectArray)
		if !_efggb {
			_fg.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _fgcge)
			return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fbda.Domain = _ebdbg
	}
	if _eafeg := _cgcae.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _eafeg != nil {
		_eafeg = _bgd.TraceToDirectObject(_eafeg)
		_gdcc, _bdfge := _eafeg.(*_bgd.PdfObjectArray)
		if !_bdfge {
			_fg.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _eafeg)
			return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fbda.Matrix = _gdcc
	}
	_eebg := _cgcae.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _eebg == nil {
		_fg.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_fbda.Function = []PdfFunction{}
	if _gdfac, _gdece := _eebg.(*_bgd.PdfObjectArray); _gdece {
		for _, _ggded := range _gdfac.Elements() {
			_dbfbf, _gcfga := _fbbb(_ggded)
			if _gcfga != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gcfga)
				return nil, _gcfga
			}
			_fbda.Function = append(_fbda.Function, _dbfbf)
		}
	} else {
		_bdcecb, _afdad := _fbbb(_eebg)
		if _afdad != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _afdad)
			return nil, _afdad
		}
		_fbda.Function = append(_fbda.Function, _bdcecb)
	}
	return &_fbda, nil
}

func _ebaag(_decd _bgd.PdfObject) (*PdfPageResourcesColorspaces, error) {
	_aefg := &PdfPageResourcesColorspaces{}
	if _ggedd, _ffead := _decd.(*_bgd.PdfIndirectObject); _ffead {
		_aefg._dggea = _ggedd
		_decd = _ggedd.PdfObject
	}
	_gafe, _dfab := _bgd.GetDict(_decd)
	if !_dfab {
		return nil, _gb.New("\u0043\u0053\u0020at\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_aefg.Names = []string{}
	_aefg.Colorspaces = map[string]PdfColorspace{}
	for _, _bbgbgb := range _gafe.Keys() {
		_cecd := _gafe.Get(_bbgbgb)
		_aefg.Names = append(_aefg.Names, string(_bbgbgb))
		_cdeed, _bcfdf := NewPdfColorspaceFromPdfObject(_cecd)
		if _bcfdf != nil {
			return nil, _bcfdf
		}
		_aefg.Colorspaces[string(_bbgbgb)] = _cdeed
	}
	return _aefg, nil
}

// NewPdfColorLab returns a new Lab color.
func NewPdfColorLab(l, a, b float64) *PdfColorLab { _egfg := PdfColorLab{l, a, b}; return &_egfg }

// String returns string value of output intent for given type
// ISO_19005-2 6.2.3: GTS_PDFA1 value should be used for PDF/A-1, A-2 and A-3 at least
func (_gaege PdfOutputIntentType) String() string {
	switch _gaege {
	case PdfOutputIntentTypeA1:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA2:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA3:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA4:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeX:
		return "\u0047\u0054\u0053\u005f\u0050\u0044\u0046\u0058"
	default:
		return "\u0055N\u0044\u0045\u0046\u0049\u004e\u0045D"
	}
}

var _ pdfFont = (*pdfFontType0)(nil)

// GetEncryptionMethod returns a descriptive information string about the encryption method used.
func (_dcfac *PdfReader) GetEncryptionMethod() string {
	_agaec := _dcfac._ccade.GetCrypter()
	return _agaec.String()
}

// ToPdfObject implements model.PdfModel interface.
func (_bgeg *PdfOutputIntent) ToPdfObject() _bgd.PdfObject {
	if _bgeg._gfcce == nil {
		_bgeg._gfcce = _bgd.MakeDict()
	}
	_fegdc := _bgeg._gfcce
	if _bgeg.Type != "" {
		_fegdc.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName(_bgeg.Type))
	}
	_fegdc.Set("\u0053", _bgd.MakeName(_bgeg.S.String()))
	if _bgeg.OutputCondition != "" {
		_fegdc.Set("\u004fu\u0074p\u0075\u0074\u0043\u006f\u006e\u0064\u0069\u0074\u0069\u006f\u006e", _bgd.MakeString(_bgeg.OutputCondition))
	}
	_fegdc.Set("\u004fu\u0074\u0070\u0075\u0074C\u006f\u006e\u0064\u0069\u0074i\u006fn\u0049d\u0065\u006e\u0074\u0069\u0066\u0069\u0065r", _bgd.MakeString(_bgeg.OutputConditionIdentifier))
	_fegdc.Set("\u0052\u0065\u0067i\u0073\u0074\u0072\u0079\u004e\u0061\u006d\u0065", _bgd.MakeString(_bgeg.RegistryName))
	if _bgeg.Info != "" {
		_fegdc.Set("\u0049\u006e\u0066\u006f", _bgd.MakeString(_bgeg.Info))
	}
	if len(_bgeg.DestOutputProfile) != 0 {
		_ddbbb, _fdfgd := _bgd.MakeStream(_bgeg.DestOutputProfile, _bgd.NewFlateEncoder())
		if _fdfgd != nil {
			_fg.Log.Error("\u004d\u0061\u006b\u0065\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0044\u0065s\u0074\u004f\u0075\u0074\u0070\u0075t\u0050\u0072\u006f\u0066\u0069\u006c\u0065\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076", _fdfgd)
		}
		_ddbbb.PdfObjectDictionary.Set("\u004e", _bgd.MakeInteger(int64(_bgeg.ColorComponents)))
		_fcdg := make([]float64, _bgeg.ColorComponents*2)
		for _gfcbf := 0; _gfcbf < _bgeg.ColorComponents*2; _gfcbf++ {
			_ddaaf := 0.0
			if _gfcbf%2 != 0 {
				_ddaaf = 1.0
			}
			_fcdg[_gfcbf] = _ddaaf
		}
		_ddbbb.PdfObjectDictionary.Set("\u0052\u0061\u006eg\u0065", _bgd.MakeArrayFromFloats(_fcdg))
		_fegdc.Set("\u0044\u0065\u0073\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0050\u0072o\u0066\u0069\u006c\u0065", _ddbbb)
	}
	return _fegdc
}

// GetPageDict converts the Page to a PDF object dictionary.
func (_eddgf *PdfPage) GetPageDict() *_bgd.PdfObjectDictionary {
	_gabgd := _eddgf._cfdgca
	_gabgd.Clear()
	_gabgd.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0050\u0061\u0067\u0065"))
	_gabgd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _eddgf.Parent)
	if _eddgf.LastModified != nil {
		_gabgd.Set("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _eddgf.LastModified.ToPdfObject())
	}
	if _eddgf.Resources != nil {
		_gabgd.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _eddgf.Resources.ToPdfObject())
	}
	if _eddgf.CropBox != nil {
		_gabgd.Set("\u0043r\u006f\u0070\u0042\u006f\u0078", _eddgf.CropBox.ToPdfObject())
	}
	if _eddgf.MediaBox != nil {
		_gabgd.Set("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", _eddgf.MediaBox.ToPdfObject())
	}
	if _eddgf.BleedBox != nil {
		_gabgd.Set("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078", _eddgf.BleedBox.ToPdfObject())
	}
	if _eddgf.TrimBox != nil {
		_gabgd.Set("\u0054r\u0069\u006d\u0042\u006f\u0078", _eddgf.TrimBox.ToPdfObject())
	}
	if _eddgf.ArtBox != nil {
		_gabgd.Set("\u0041\u0072\u0074\u0042\u006f\u0078", _eddgf.ArtBox.ToPdfObject())
	}
	_gabgd.SetIfNotNil("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f", _eddgf.BoxColorInfo)
	_gabgd.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _eddgf.Contents)
	if _eddgf.Rotate != nil {
		_gabgd.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _bgd.MakeInteger(*_eddgf.Rotate))
	}
	_gabgd.SetIfNotNil("\u0047\u0072\u006fu\u0070", _eddgf.Group)
	_gabgd.SetIfNotNil("\u0054\u0068\u0075m\u0062", _eddgf.Thumb)
	_gabgd.SetIfNotNil("\u0042", _eddgf.B)
	_gabgd.SetIfNotNil("\u0044\u0075\u0072", _eddgf.Dur)
	_gabgd.SetIfNotNil("\u0054\u0072\u0061n\u0073", _eddgf.Trans)
	_gabgd.SetIfNotNil("\u0041\u0041", _eddgf.AA)
	_gabgd.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _eddgf.Metadata)
	_gabgd.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _eddgf.PieceInfo)
	_gabgd.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _eddgf.StructParents)
	_gabgd.SetIfNotNil("\u0049\u0044", _eddgf.ID)
	_gabgd.SetIfNotNil("\u0050\u005a", _eddgf.PZ)
	_gabgd.SetIfNotNil("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f", _eddgf.SeparationInfo)
	_gabgd.SetIfNotNil("\u0054\u0061\u0062\u0073", _eddgf.Tabs)
	_gabgd.SetIfNotNil("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064", _eddgf.TemplateInstantiated)
	_gabgd.SetIfNotNil("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s", _eddgf.PresSteps)
	_gabgd.SetIfNotNil("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074", _eddgf.UserUnit)
	_gabgd.SetIfNotNil("\u0056\u0050", _eddgf.VP)
	if _eddgf._dffab != nil {
		_ebfgc := _bgd.MakeArray()
		for _, _eggfb := range _eddgf._dffab {
			if _fbbgg := _eggfb.GetContext(); _fbbgg != nil {
				_ebfgc.Append(_fbbgg.ToPdfObject())
			} else {
				_ebfgc.Append(_eggfb.ToPdfObject())
			}
		}
		if _ebfgc.Len() > 0 {
			_gabgd.Set("\u0041\u006e\u006e\u006f\u0074\u0073", _ebfgc)
		}
	} else if _eddgf.Annots != nil {
		_gabgd.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0073", _eddgf.Annots)
	}
	return _gabgd
}

// FieldValueProvider provides field values from a data source such as FDF, JSON or any other.
type FieldValueProvider interface {
	FieldValues() (map[string]_bgd.PdfObject, error)
}

// SubsetRegistered subsets the font to only the glyphs that have been registered by the encoder.
//
// NOTE: This only works on fonts that support subsetting. For unsupported fonts this is a no-op, although a debug
// message is emitted.  Currently supported fonts are embedded Truetype CID fonts (type 0).
//
// NOTE: Make sure to call this soon before writing (once all needed runes have been registered).
// If using package creator, use its EnableFontSubsetting method instead.
func (_eecca *PdfFont) SubsetRegistered() error {
	switch _aecgg := _eecca._cbec.(type) {
	case *pdfFontType0:
		_ggda := _aecgg.subsetRegistered()
		if _ggda != nil {
			_fg.Log.Debug("\u0053\u0075b\u0073\u0065\u0074 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _ggda)
			return _ggda
		}
		if _aecgg._gfcgdc != nil {
			if _aecgg._dbcf != nil {
				_aecgg._dbcf.ToPdfObject()
			}
			_aecgg.ToPdfObject()
		}
	default:
		_fg.Log.Debug("F\u006f\u006e\u0074\u0020\u0025\u0054 \u0064\u006f\u0065\u0073\u0020\u006eo\u0074\u0020\u0073\u0075\u0070\u0070\u006fr\u0074\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069n\u0067", _aecgg)
	}
	return nil
}

// GetStructParentsKey returns the StructParents key.
// If not set, returns -1.
func (_dfagd *PdfPage) GetStructParentsKey() int {
	if _dfcfc, _edbef := _bgd.GetIntVal(_dfagd.StructParents); _edbef {
		return _dfcfc
	}
	return -1
}

// GetAnnotations returns the list of page annotations for `page`. If not loaded attempts to load the
// annotations, otherwise returns the loaded list.
func (_dfbac *PdfPage) GetAnnotations() ([]*PdfAnnotation, error) {
	if _dfbac._dffab != nil {
		return _dfbac._dffab, nil
	}
	if _dfbac.Annots == nil {
		_dfbac._dffab = []*PdfAnnotation{}
		return nil, nil
	}
	if _dfbac._ccagbb == nil {
		_dfbac._dffab = []*PdfAnnotation{}
		return nil, nil
	}
	_egcef, _cdfbf := _dfbac._ccagbb.loadAnnotations(_dfbac.Annots)
	if _cdfbf != nil {
		return nil, _cdfbf
	}
	if _egcef == nil {
		_dfbac._dffab = []*PdfAnnotation{}
	}
	_dfbac._dffab = _egcef
	return _dfbac._dffab, nil
}

func (_ggeaf *PdfReader) loadOutlines() (*PdfOutlineTreeNode, error) {
	if _ggeaf._ccade.GetCrypter() != nil && !_ggeaf._ccade.IsAuthenticated() {
		return nil, _f.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_cgccc := _ggeaf._ffabf
	_badb := _cgccc.Get("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	if _badb == nil {
		return nil, nil
	}
	_fg.Log.Trace("\u002d\u0048\u0061\u0073\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	_bfgba := _bgd.ResolveReference(_badb)
	_fg.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0020\u0072\u006f\u006f\u0074\u003a\u0020\u0025\u0076", _bfgba)
	if _babe := _bgd.IsNullObject(_bfgba); _babe {
		_fg.Log.Trace("\u004f\u0075\u0074li\u006e\u0065\u0020\u0072\u006f\u006f\u0074\u0020\u0069s\u0020n\u0075l\u006c \u002d\u0020\u006e\u006f\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
		return nil, nil
	}
	_bbbdac, _cedef := _bfgba.(*_bgd.PdfIndirectObject)
	if !_cedef {
		if _, _ecadc := _bgd.GetDict(_bfgba); !_ecadc {
			_fg.Log.Debug("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067")
			return nil, nil
		}
		_fg.Log.Debug("\u004f\u0075t\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u0069s\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		_bbbdac = _bgd.MakeIndirectObject(_bfgba)
	}
	_gfeaf, _cedef := _bbbdac.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_cedef {
		return nil, _gb.New("\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072y")
	}
	_fg.Log.Trace("O\u0075\u0074\u006c\u0069ne\u0020r\u006f\u006f\u0074\u0020\u0064i\u0063\u0074\u003a\u0020\u0025\u0076", _gfeaf)
	_dffg, _, _egebg := _ggeaf.buildOutlineTree(_bbbdac, nil, nil, nil)
	if _egebg != nil {
		return nil, _egebg
	}
	_fg.Log.Trace("\u0052\u0065\u0073\u0075\u006c\u0074\u0069\u006e\u0067\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065:\u0020\u0025\u0076", _dffg)
	return _dffg, nil
}

func _eggfgd(_feagge string) (string, error) {
	var _ccdbcd _ea.Buffer
	_ccdbcd.WriteString(_feagge)
	_dcbgce := make([]byte, 8+16)
	_dbaba := _ge.Now().UTC().UnixNano()
	_ed.BigEndian.PutUint64(_dcbgce, uint64(_dbaba))
	_, _faacac := _be.Read(_dcbgce[8:])
	if _faacac != nil {
		return "", _faacac
	}
	_ccdbcd.WriteString(_bf.EncodeToString(_dcbgce))
	return _ccdbcd.String(), nil
}

// ToGray returns a PdfColorDeviceGray color based on the current RGB color.
func (_eadeg *PdfColorDeviceRGB) ToGray() *PdfColorDeviceGray {
	_agcfa := 0.3*_eadeg.R() + 0.59*_eadeg.G() + 0.11*_eadeg.B()
	_agcfa = _da.Min(_da.Max(_agcfa, 0.0), 1.0)
	return NewPdfColorDeviceGray(_agcfa)
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_afdg *PdfColorspaceICCBased) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _afdg.Alternate == nil {
		if _afdg.N == 1 {
			_cfabc := NewPdfColorspaceDeviceGray()
			return _cfabc.ColorFromFloats(vals)
		} else if _afdg.N == 3 {
			_ddee := NewPdfColorspaceDeviceRGB()
			return _ddee.ColorFromFloats(vals)
		} else if _afdg.N == 4 {
			_dccfbf := NewPdfColorspaceDeviceCMYK()
			return _dccfbf.ColorFromFloats(vals)
		} else {
			return nil, _gb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _afdg.Alternate.ColorFromFloats(vals)
}

// GetPageNumber returns the page number that has been assigned to the K object.
func (_egadfe *KDict) GetPageNumber() int64 { return _egadfe._eddd }

// PrintPageRange returns the value of the printPageRange.
func (_baggb *ViewerPreferences) PrintPageRange() []int { return _baggb._gdfab }

// NewStructTreeRootFromPdfObject creates a new structure tree root from a PDF object.
func NewStructTreeRootFromPdfObject(obj _bgd.PdfObject) (*StructTreeRoot, error) {
	_dfgcb := _bgd.ResolveReference(obj)
	_ceeaf, _fbcfea := _bgd.GetDict(_dfgcb)
	if !_fbcfea {
		return nil, _f.Errorf("\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067 \u0073\u0074\u0072uc\u0074\u0075\u0072\u0065\u0020\u0074r\u0065\u0065\u0020\u0072\u006f\u006f\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072\u0079")
	}
	_adebce := &StructTreeRoot{}
	_adebce._gagf = _bgd.MakeIndirectObject(_bgd.MakeDict())
	if _ceegc := _ceeaf.Get("\u004b"); _ceegc != nil {
		_bceaf := _bgd.ResolveReference(_ceegc)
		_efgae := _bgd.ResolveReferencesDeep(_bceaf, nil)
		if _efgae != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006fr\u0020\u0072\u0065\u0073\u006f\u006c\u0076\u0069\u006e\u0067 \u004b \u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0025\u0076", _efgae)
		}
		_adebce.K = []*KDict{}
		if _cacb, _gdbc := _bgd.GetArray(_bceaf); _gdbc {
			for _gaaga := 0; _gaaga < _cacb.Len(); _gaaga++ {
				_deag := _cacb.Get(_gaaga)
				_bdfbg, _gcccf := NewKDictFromPdfObject(_deag)
				if _gcccf != nil {
					return nil, _gcccf
				}
				_adebce.K = append(_adebce.K, _bdfbg)
			}
		} else {
			_cdage, _bcdcc := NewKDictFromPdfObject(_bceaf)
			if _bcdcc != nil {
				return nil, _bcdcc
			}
			_adebce.K = append(_adebce.K, _cdage)
		}
	}
	if _aefc := _ceeaf.Get("\u0049\u0044\u0054\u0072\u0065\u0065"); _aefc != nil {
		_adebce.IDTree = _gabcb(_aefc)
	}
	if _fffbe := _ceeaf.Get("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065"); _fffbe != nil {
		_egefa := _bgd.ResolveReference(_fffbe)
		if _gfec, _egggca := _bgd.GetDict(_egefa); _egggca {
			_adebce.ParentTree = _gfec
		}
	}
	if _ffbccc := _ceeaf.Get("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065\u004e\u0065x\u0074\u004b\u0065\u0079"); _ffbccc != nil {
		_, _abdg := _bgd.GetInt(_ffbccc)
		if _abdg {
			_fbecb, _debac := _bgd.GetNumberAsInt64(_ffbccc)
			if _debac != nil {
				return nil, _debac
			}
			_adebce.ParentTreeNextKey = _fbecb
		}
	}
	if _afbaa := _ceeaf.Get("\u0052o\u006c\u0065\u004d\u0061\u0070"); _afbaa != nil {
		switch _cddaf := _afbaa.(type) {
		case *_bgd.PdfIndirectObject:
			if _dbcag, _agdag := _bgd.GetDict(_cddaf.PdfObject); _agdag {
				_adebce.RoleMap = _dbcag
			}
		case *_bgd.PdfObjectDictionary:
			_adebce.RoleMap = _cddaf
		case *_bgd.PdfObjectString:
			_adebce.RoleMap = _cddaf
		}
	}
	if _aebgd := _ceeaf.Get("\u0043\u006c\u0061\u0073\u0073\u004d\u0061\u0070"); _aebgd != nil {
		if _dbeag, _fefadd := _bgd.GetDict(_aebgd); _fefadd {
			_adebce.ClassMap = _dbeag
		}
	}
	return _adebce, nil
}

func _befa(_gegebc []*_bgd.PdfObjectStream) *_bgd.PdfObjectArray {
	if len(_gegebc) == 0 {
		return nil
	}
	_aabga := make([]_bgd.PdfObject, 0, len(_gegebc))
	for _, _cgbcg := range _gegebc {
		_aabga = append(_aabga, _cgbcg)
	}
	return _bgd.MakeArray(_aabga...)
}

func _abbe(_bagfdb _bgd.PdfObject) (*PdfShading, error) {
	_dedae := &PdfShading{}
	var _fbdgb *_bgd.PdfObjectDictionary
	if _gggfb, _dfafd := _bgd.GetIndirect(_bagfdb); _dfafd {
		_dedae._gccfe = _gggfb
		_egcgf, _dbcgc := _gggfb.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_dbcgc {
			_fg.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _bgd.ErrTypeError
		}
		_fbdgb = _egcgf
	} else if _dbdgb, _faff := _bgd.GetStream(_bagfdb); _faff {
		_dedae._gccfe = _dbdgb
		_fbdgb = _dbdgb.PdfObjectDictionary
	} else if _gcddd, _eefc := _bgd.GetDict(_bagfdb); _eefc {
		_dedae._gccfe = _gcddd
		_fbdgb = _gcddd
	} else {
		_fg.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", _bagfdb)
		return nil, _bgd.ErrTypeError
	}
	if _fbdgb == nil {
		_fg.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _gb.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_bagfdb = _fbdgb.Get("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _bagfdb == nil {
		_fg.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073si\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bagfdb = _bgd.TraceToDirectObject(_bagfdb)
	_bbegdf, _edabd := _bagfdb.(*_bgd.PdfObjectInteger)
	if !_edabd {
		_fg.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066o\u0072 \u0073h\u0061d\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _bagfdb)
		return nil, _bgd.ErrTypeError
	}
	if *_bbegdf < 1 || *_bbegdf > 7 {
		_fg.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u002c\u0020\u006e\u006ft\u0020\u0031\u002d\u0037\u0020(\u0067\u006ft\u0020\u0025\u0064\u0029", *_bbegdf)
		return nil, _bgd.ErrTypeError
	}
	_dedae.ShadingType = _bbegdf
	_bagfdb = _fbdgb.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")
	if _bagfdb == nil {
		_fg.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0020\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065\u0020e\u006e\u0074\u0072\u0079\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_aeafc, _agdf := NewPdfColorspaceFromPdfObject(_bagfdb)
	if _agdf != nil {
		_fg.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065: \u0025\u0076", _agdf)
		return nil, _agdf
	}
	_dedae.ColorSpace = _aeafc
	_bagfdb = _fbdgb.Get("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064")
	if _bagfdb != nil {
		_bagfdb = _bgd.TraceToDirectObject(_bagfdb)
		_fbgfa, _eebfff := _bagfdb.(*_bgd.PdfObjectArray)
		if !_eebfff {
			_fg.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _bagfdb)
			return nil, _bgd.ErrTypeError
		}
		_dedae.Background = _fbgfa
	}
	_bagfdb = _fbdgb.Get("\u0042\u0042\u006f\u0078")
	if _bagfdb != nil {
		_bagfdb = _bgd.TraceToDirectObject(_bagfdb)
		_acgb, _bbegf := _bagfdb.(*_bgd.PdfObjectArray)
		if !_bbegf {
			_fg.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _bagfdb)
			return nil, _bgd.ErrTypeError
		}
		_cfgce, _aafdb := NewPdfRectangle(*_acgb)
		if _aafdb != nil {
			_fg.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _aafdb)
			return nil, _aafdb
		}
		_dedae.BBox = _cfgce
	}
	_bagfdb = _fbdgb.Get("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s")
	if _bagfdb != nil {
		_bagfdb = _bgd.TraceToDirectObject(_bagfdb)
		_eaca, _bcgag := _bagfdb.(*_bgd.PdfObjectBool)
		if !_bcgag {
			_fg.Log.Debug("A\u006e\u0074\u0069\u0041\u006c\u0069\u0061\u0073\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020ty\u0070\u0065\u002c\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020bo\u006f\u006c \u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bagfdb)
			return nil, _bgd.ErrTypeError
		}
		_dedae.AntiAlias = _eaca
	}
	switch *_bbegdf {
	case 1:
		_dgbcd, _abceb := _eagfbb(_fbdgb)
		if _abceb != nil {
			return nil, _abceb
		}
		_dgbcd.PdfShading = _dedae
		_dedae._gggga = _dgbcd
		return _dedae, nil
	case 2:
		_acgga, _ddef := _ebdc(_fbdgb)
		if _ddef != nil {
			return nil, _ddef
		}
		_acgga.PdfShading = _dedae
		_dedae._gggga = _acgga
		return _dedae, nil
	case 3:
		_ecebg, _ebfa := _ddfea(_fbdgb)
		if _ebfa != nil {
			return nil, _ebfa
		}
		_ecebg.PdfShading = _dedae
		_dedae._gggga = _ecebg
		return _dedae, nil
	case 4:
		_caaec, _cfgcb := _abcee(_fbdgb)
		if _cfgcb != nil {
			return nil, _cfgcb
		}
		_caaec.PdfShading = _dedae
		_dedae._gggga = _caaec
		return _dedae, nil
	case 5:
		_bgcad, _baffc := _ecbb(_fbdgb)
		if _baffc != nil {
			return nil, _baffc
		}
		_bgcad.PdfShading = _dedae
		_dedae._gggga = _bgcad
		return _dedae, nil
	case 6:
		_baebc, _ecfbe := _fgbfc(_fbdgb)
		if _ecfbe != nil {
			return nil, _ecfbe
		}
		_baebc.PdfShading = _dedae
		_dedae._gggga = _baebc
		return _dedae, nil
	case 7:
		_gdcec, _dggdf := _ebgcc(_fbdgb)
		if _dggdf != nil {
			return nil, _dggdf
		}
		_gdcec.PdfShading = _dedae
		_dedae._gggga = _gdcec
		return _dedae, nil
	}
	return nil, _gb.New("u\u006ek\u006e\u006f\u0077\u006e\u0020\u0073\u0068\u0061d\u0069\u006e\u0067\u0020ty\u0070\u0065")
}

func (_beac *PdfShading) getShadingDict() (*_bgd.PdfObjectDictionary, error) {
	_accc := _beac._gccfe
	if _babfe, _beae := _accc.(*_bgd.PdfIndirectObject); _beae {
		_ecda, _dbdgc := _babfe.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_dbdgc {
			return nil, _bgd.ErrTypeError
		}
		return _ecda, nil
	} else if _cedab, _agadb := _accc.(*_bgd.PdfObjectStream); _agadb {
		return _cedab.PdfObjectDictionary, nil
	} else if _ddbgcb, _afeb := _accc.(*_bgd.PdfObjectDictionary); _afeb {
		return _ddbgcb, nil
	} else {
		_fg.Log.Debug("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0063\u0063\u0065s\u0073\u0020\u0073\u0068\u0061\u0064\u0069n\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079")
		return nil, _bgd.ErrTypeError
	}
}

var _ pdfFont = (*pdfFontType3)(nil)

// GetRuneMetrics iterates through each font in the list of fonts the returns the fonts.CharMetrics from working font.
func (_cgaaf *MultipleFontEncoder) GetRuneMetrics(r rune) (_fe.CharMetrics, bool) {
	_bbfd := _cgaaf.CurrentFont
	_aefad, _debde := _bbfd.GetRuneMetrics(r)
	for _gecbc := 1; _gecbc < len(_cgaaf._acaed) && _aefad.Wx == 0; _gecbc++ {
		_bbfd = _cgaaf._acaed[_gecbc]
		_aefad, _debde = _bbfd.GetRuneMetrics(r)
	}
	return _aefad, _debde
}

// NewStandard14FontWithEncoding returns the standard 14 font named `basefont` as a *PdfFont and
// a TextEncoder that encodes all the runes in `alphabet`, or an error if this is not possible.
// An error can occur if `basefont` is not one the standard 14 font names.
func NewStandard14FontWithEncoding(basefont StdFontName, alphabet map[rune]int) (*PdfFont, _dabf.SimpleEncoder, error) {
	_aabe, _fgfb := _eeccg(basefont)
	if _fgfb != nil {
		return nil, nil, _fgfb
	}
	_bceb, _fdba := _aabe.Encoder().(_dabf.SimpleEncoder)
	if !_fdba {
		return nil, nil, _f.Errorf("\u006f\u006e\u006c\u0079\u0020s\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u0073\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u002c\u0020\u0067\u006f\u0074\u0020\u0025\u0054", _aabe.Encoder())
	}
	_cdbd := make(map[rune]_dabf.GlyphName)
	for _afcbb := range alphabet {
		if _, _fcafa := _bceb.RuneToCharcode(_afcbb); !_fcafa {
			_, _fbcbe := _aabe._dcbff.Read(_afcbb)
			if !_fbcbe {
				_fg.Log.Trace("r\u0075\u006e\u0065\u0020\u0025\u0023x\u003d\u0025\u0071\u0020\u006e\u006f\u0074\u0020\u0069n\u0020\u0074\u0068e\u0020f\u006f\u006e\u0074", _afcbb, _afcbb)
				continue
			}
			_badca, _fbcbe := _dabf.RuneToGlyph(_afcbb)
			if !_fbcbe {
				_fg.Log.Debug("\u006eo\u0020\u0067\u006c\u0079\u0070\u0068\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u0020\u0025\u0023\u0078\u003d\u0025\u0071", _afcbb, _afcbb)
				continue
			}
			if len(_cdbd) >= 255 {
				return nil, nil, _gb.New("\u0074\u006f\u006f\u0020\u006d\u0061\u006e\u0079\u0020\u0063\u0068\u0061\u0072a\u0063\u0074\u0065\u0072\u0073\u0020f\u006f\u0072\u0020\u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067")
			}
			_cdbd[_afcbb] = _badca
		}
	}
	var (
		_eaee []_dabf.CharCode
		_bdbc []_dabf.CharCode
	)
	for _bcff := _dabf.CharCode(1); _bcff <= 0xff; _bcff++ {
		_cged, _dccab := _bceb.CharcodeToRune(_bcff)
		if !_dccab {
			_eaee = append(_eaee, _bcff)
			continue
		}
		if _, _dccab = alphabet[_cged]; !_dccab {
			_bdbc = append(_bdbc, _bcff)
		}
	}
	_eadb := append(_eaee, _bdbc...)
	if len(_eadb) < len(_cdbd) {
		return nil, nil, _f.Errorf("n\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u006ec\u006f\u0064\u0065\u0020\u0025\u0064\u0020ru\u006e\u0065\u0073\u002c \u0062\u0075\u0074\u0020\u0068\u0061\u0076\u0065\u0020on\u006c\u0079 \u0025\u0064\u0020\u0073\u006c\u006f\u0074\u0073", len(_cdbd), len(_eadb))
	}
	_bdcf := make([]rune, 0, len(_cdbd))
	for _abef := range _cdbd {
		_bdcf = append(_bdcf, _abef)
	}
	_bb.Slice(_bdcf, func(_fbgf, _fbgcb int) bool { return _bdcf[_fbgf] < _bdcf[_fbgcb] })
	_abca := make(map[_dabf.CharCode]_dabf.GlyphName, len(_bdcf))
	for _, _geca := range _bdcf {
		_baab := _eadb[0]
		_eadb = _eadb[1:]
		_abca[_baab] = _cdbd[_geca]
	}
	_bceb = _dabf.ApplyDifferences(_bceb, _abca)
	_aabe.SetEncoder(_bceb)
	return &PdfFont{_cbec: &_aabe}, _bceb, nil
}

// AddExtGState adds a graphics state to the XObject resources.
func (_dgggd *PdfPage) AddExtGState(name _bgd.PdfObjectName, egs *_bgd.PdfObjectDictionary) error {
	if _dgggd.Resources == nil {
		_dgggd.Resources = NewPdfPageResources()
	}
	if _dgggd.Resources.ExtGState == nil {
		_dgggd.Resources.ExtGState = _bgd.MakeDict()
	}
	_cffgg, _edfea := _bgd.TraceToDirectObject(_dgggd.Resources.ExtGState).(*_bgd.PdfObjectDictionary)
	if !_edfea {
		_fg.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _bgd.TraceToDirectObject(_dgggd.Resources.ExtGState))
		return _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cffgg.Set(name, egs)
	return nil
}

func (_ddff *PdfFont) baseFields() *fontCommon {
	if _ddff._cbec == nil {
		_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0062\u0061\u0073\u0065\u0046\u0069\u0065l\u0064s\u002e \u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e")
		return nil
	}
	return _ddff._cbec.baseFields()
}

func (_gdffb *PdfWriter) checkPendingObjects() {
	for _afffb, _bbdbf := range _gdffb._fedfa {
		if !_gdffb.hasObject(_afffb) {
			_fg.Log.Debug("\u0057\u0041\u0052\u004e\u0020\u0050\u0065n\u0064\u0069\u006eg\u0020\u006f\u0062j\u0065\u0063t\u0020\u0025\u002b\u0076\u0020\u0025T\u0020(%\u0070\u0029\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0061\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0077\u0072\u0069\u0074\u0069\u006e\u0067", _afffb, _afffb, _afffb)
			for _, _egbde := range _bbdbf {
				for _, _fgdag := range _egbde.Keys() {
					_edag := _egbde.Get(_fgdag)
					if _edag == _afffb {
						_fg.Log.Debug("\u0050e\u006e\u0064i\u006e\u0067\u0020\u006fb\u006a\u0065\u0063t\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0061nd\u0020\u0072\u0065p\u006c\u0061c\u0065\u0064\u0020\u0077\u0069\u0074h\u0020\u006eu\u006c\u006c")
						_egbde.Set(_fgdag, _bgd.MakeNull())
						break
					}
				}
			}
		}
	}
}

// GetContainingPdfObject returns the container of the outline (indirect object).
func (_gbca *PdfOutline) GetContainingPdfObject() _bgd.PdfObject { return _gbca._edgaf }

// WriteToFile writes the Appender output to file specified by path.
func (_aade *PdfAppender) WriteToFile(outputPath string) error {
	_bfdc, _fgec := _gc.Create(outputPath)
	if _fgec != nil {
		return _fgec
	}
	defer _bfdc.Close()
	return _aade.Write(_bfdc)
}

// Size returns the width and the height of the page. The method reports
// the page dimensions as displayed by a PDF viewer (i.e. page rotation is
// taken into account).
func (_dcceb *PdfPage) Size() (float64, float64, error) {
	_daaa, _efdff := _dcceb.GetMediaBox()
	if _efdff != nil {
		return 0, 0, _efdff
	}
	_decaa, _fcdbb := _daaa.Width(), _daaa.Height()
	_eeea, _efdff := _dcceb.GetRotate()
	if _efdff != nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a", _efdff.Error())
	}
	if _deaba := _eeea; _deaba%360 != 0 && _deaba%90 == 0 {
		if _efaba := (360 + _deaba%360) % 360; _efaba == 90 || _efaba == 270 {
			_decaa, _fcdbb = _fcdbb, _decaa
		}
	}
	return _decaa, _fcdbb, nil
}

// PdfField contains the common attributes of a form field. The context object contains the specific field data
// which can represent a button, text, choice or signature.
// The PdfField is typically not used directly, but is encapsulated by the more specific field types such as
// PdfFieldButton etc (i.e. the context attribute).
type PdfField struct {
	_babbg       PdfModel
	_bcgde       *_bgd.PdfIndirectObject
	Parent       *PdfField
	Annotations  []*PdfAnnotationWidget
	Kids         []*PdfField
	FT           *_bgd.PdfObjectName
	T            *_bgd.PdfObjectString
	TU           *_bgd.PdfObjectString
	TM           *_bgd.PdfObjectString
	Ff           *_bgd.PdfObjectInteger
	V            _bgd.PdfObject
	DV           _bgd.PdfObject
	AA           _bgd.PdfObject
	VariableText *VariableText
}

// ToPdfObject implements interface PdfModel.
func (_efc *PdfAnnotationWatermark) ToPdfObject() _bgd.PdfObject {
	_efc.PdfAnnotation.ToPdfObject()
	_aecc := _efc._eag
	_bgg := _aecc.PdfObject.(*_bgd.PdfObjectDictionary)
	_bgg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k"))
	_bgg.SetIfNotNil("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074", _efc.FixedPrint)
	return _aecc
}

// RunesToCharcodeBytes maps the provided runes to charcode bytes and it
// returns the resulting slice of bytes, along with the number of runes which
// could not be converted. If the number of misses is 0, all runes were
// successfully converted.
func (_cefg *PdfFont) RunesToCharcodeBytes(data []rune) ([]byte, int) {
	var _cdcfd []_dabf.TextEncoder
	var _bagf _dabf.CMapEncoder
	if _dfgdc := _cefg.baseFields()._edab; _dfgdc != nil {
		_bagf = _dabf.NewCMapEncoder("", nil, _dfgdc)
	}
	_gegbc := _cefg.Encoder()
	if _gegbc != nil {
		switch _bdabd := _gegbc.(type) {
		case _dabf.SimpleEncoder:
			_cdbeb := _bdabd.BaseName()
			if _, _bddb := _eaaga[_cdbeb]; _bddb {
				_cdcfd = append(_cdcfd, _gegbc)
			}
		}
	}
	if len(_cdcfd) == 0 {
		if _cefg.baseFields()._edab != nil {
			_cdcfd = append(_cdcfd, _bagf)
		}
		if _gegbc != nil {
			_cdcfd = append(_cdcfd, _gegbc)
		}
	}
	var _afae _ea.Buffer
	var _dffce int
	for _, _gfaga := range data {
		var _egfdb bool
		for _, _acae := range _cdcfd {
			if _gfcgf := _acae.Encode(string(_gfaga)); len(_gfcgf) > 0 {
				_afae.Write(_gfcgf)
				_egfdb = true
				break
			}
		}
		if !_egfdb {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020f\u0061\u0069\u006ce\u0064\u0020\u0074\u006f \u006d\u0061\u0070\u0020\u0072\u0075\u006e\u0065\u0020\u0060\u0025\u002b\u0071\u0060\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065", _gfaga)
			_dffce++
		}
	}
	if _dffce != 0 {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0061\u006cl\u0020\u0072\u0075\u006e\u0065\u0073\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072c\u006fd\u0065\u0073\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0052\u0075\u006e\u0065\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073 \u0065\u006e\u0063\u006f\u0064e\u0072\u0073\u003d\u0025\u002b\u0076", len(data), _dffce, _cefg, _cdcfd)
	}
	return _afae.Bytes(), _dffce
}

// Image interface is a basic representation of an image used in PDF.
// The colorspace is not specified, but must be known when handling the image.
type Image struct {
	Width            int64
	Height           int64
	BitsPerComponent int64
	ColorComponents  int
	Data             []byte
	_bdgdb           []byte
	_agcea           []float64
}

// RemveTabOrder removes the tab order for the page.
func (_bgbadg *PdfPage) RemoveTabOrder() { _bgbadg.Tabs = nil }

// ReaderOpts defines options for creating PdfReader instances.
type ReaderOpts struct {

	// Password password of the PDF file encryption.
	// Default: empty ("").
	Password string

	// LazyLoad set if the PDF file would be loaded using lazy-loading mode.
	// Default: true.
	LazyLoad bool

	// ComplianceMode set if parsed PDF file should contain meta information for the verifiers of the compliance standards like PDF/A.
	ComplianceMode bool

	// RelaxedMode indicates whether the parser should operate in a relaxed mode, ignoring certain insignificant errors and continuing to parse the PDF file.
	// For example, it skips AcroForm loading errors and proceeds with the rest of the file if no form-related processing is required.
	RelaxedMode bool
}

// ToPdfObject implements interface PdfModel.
func (_abd *PdfAnnotationFreeText) ToPdfObject() _bgd.PdfObject {
	_abd.PdfAnnotation.ToPdfObject()
	_efacd := _abd._eag
	_bba := _efacd.PdfObject.(*_bgd.PdfObjectDictionary)
	_abd.appendToPdfDictionary(_bba)
	_bba.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074"))
	_bba.SetIfNotNil("\u0044\u0041", _abd.DA)
	_bba.SetIfNotNil("\u0051", _abd.Q)
	_bba.SetIfNotNil("\u0052\u0043", _abd.RC)
	_bba.SetIfNotNil("\u0044\u0053", _abd.DS)
	_bba.SetIfNotNil("\u0043\u004c", _abd.CL)
	_bba.SetIfNotNil("\u0049\u0054", _abd.IT)
	_bba.SetIfNotNil("\u0042\u0045", _abd.BE)
	_bba.SetIfNotNil("\u0052\u0044", _abd.RD)
	_bba.SetIfNotNil("\u0042\u0053", _abd.BS)
	_bba.SetIfNotNil("\u004c\u0045", _abd.LE)
	return _efacd
}

func (_gebd *PdfReader) newPdfAnnotationRichMediaFromDict(_dccb *_bgd.PdfObjectDictionary) (*PdfAnnotationRichMedia, error) {
	_dfbag := &PdfAnnotationRichMedia{}
	_dfbag.RichMediaSettings = _dccb.Get("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073")
	_dfbag.RichMediaContent = _dccb.Get("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074")
	return _dfbag, nil
}

func (_eggf *PdfReader) newPdfAnnotationFreeTextFromDict(_cac *_bgd.PdfObjectDictionary) (*PdfAnnotationFreeText, error) {
	_gfge := PdfAnnotationFreeText{}
	_aac, _eab := _eggf.newPdfAnnotationMarkupFromDict(_cac)
	if _eab != nil {
		return nil, _eab
	}
	_gfge.PdfAnnotationMarkup = _aac
	_gfge.DA = _cac.Get("\u0044\u0041")
	_gfge.Q = _cac.Get("\u0051")
	_gfge.RC = _cac.Get("\u0052\u0043")
	_gfge.DS = _cac.Get("\u0044\u0053")
	_gfge.CL = _cac.Get("\u0043\u004c")
	_gfge.IT = _cac.Get("\u0049\u0054")
	_gfge.BE = _cac.Get("\u0042\u0045")
	_gfge.RD = _cac.Get("\u0052\u0044")
	_gfge.BS = _cac.Get("\u0042\u0053")
	_gfge.LE = _cac.Get("\u004c\u0045")
	return &_gfge, nil
}

// ReplaceAcroForm replaces the acrobat form. It appends a new form to the Pdf which
// replaces the original AcroForm.
func (_gdab *PdfAppender) ReplaceAcroForm(acroForm *PdfAcroForm) {
	if acroForm != nil {
		_gdab.updateObjectsDeep(acroForm.ToPdfObject(), nil)
	}
	_gdab._cabc = acroForm
}

// ToPdfObject implements interface PdfModel.
func (_de *PdfActionThread) ToPdfObject() _bgd.PdfObject {
	_de.PdfAction.ToPdfObject()
	_cbe := _de._fab
	_dde := _cbe.PdfObject.(*_bgd.PdfObjectDictionary)
	_dde.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeThread)))
	if _de.F != nil {
		_dde.Set("\u0046", _de.F.ToPdfObject())
	}
	_dde.SetIfNotNil("\u0044", _de.D)
	_dde.SetIfNotNil("\u0042", _de.B)
	return _cbe
}

// NewViewerPreferences returns a new ViewerPreferences object with
// default empty values.
func NewViewerPreferences() *ViewerPreferences { return &ViewerPreferences{} }

// PdfFieldText represents a text field where user can enter text.
type PdfFieldText struct {
	*PdfField
	DA     *_bgd.PdfObjectString
	Q      *_bgd.PdfObjectInteger
	DS     *_bgd.PdfObjectString
	RV     _bgd.PdfObject
	MaxLen *_bgd.PdfObjectInteger
}

func _egddb() string { return _fg.Version }

var _ pdfFont = (*pdfFontSimple)(nil)

// GetContentStreamWithEncoder returns the pattern cell's content stream and its encoder
func (_dbfbg *PdfTilingPattern) GetContentStreamWithEncoder() ([]byte, _bgd.StreamEncoder, error) {
	_ggbf, _gcbbc := _dbfbg._eaddb.(*_bgd.PdfObjectStream)
	if !_gcbbc {
		_fg.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dbfbg._eaddb)
		return nil, nil, _bgd.ErrTypeError
	}
	_dbebd, _cfbce := _bgd.DecodeStream(_ggbf)
	if _cfbce != nil {
		_fg.Log.Debug("\u0046\u0061\u0069l\u0065\u0064\u0020\u0064e\u0063\u006f\u0064\u0069\u006e\u0067\u0020s\u0074\u0072\u0065\u0061\u006d\u002c\u0020\u0065\u0072\u0072\u003a\u0020\u0025\u0076", _cfbce)
		return nil, nil, _cfbce
	}
	_caef, _cfbce := _bgd.NewEncoderFromStream(_ggbf)
	if _cfbce != nil {
		_fg.Log.Debug("F\u0061\u0069\u006c\u0065\u0064\u0020f\u0069\u006e\u0064\u0069\u006e\u0067 \u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020%\u0076", _cfbce)
		return nil, nil, _cfbce
	}
	return _dbebd, _caef, nil
}

// DecodeArray returns the range of color component values in DeviceCMYK colorspace.
func (_ecea *PdfColorspaceDeviceCMYK) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// NewPdfReaderLazy creates a new PdfReader for `rs` in lazy-loading mode. The difference
// from NewPdfReader is that in lazy-loading mode, objects are only loaded into memory when needed
// rather than entire structure being loaded into memory on reader creation.
// Note that it may make sense to use the lazy-load reader when processing only parts of files,
// rather than loading entire file into memory. Example: splitting a few pages from a large PDF file.
func NewPdfReaderLazy(rs _ca.ReadSeeker) (*PdfReader, error) {
	const _aedef = "\u006d\u006f\u0064\u0065l:\u004e\u0065\u0077\u0050\u0064\u0066\u0052\u0065\u0061\u0064\u0065\u0072\u004c\u0061z\u0079"
	return _acbcg(rs, &ReaderOpts{LazyLoad: true}, false, _aedef)
}

// ToPdfObject returns an indirect object containing the signature field dictionary.
func (_ebaf *PdfFieldSignature) ToPdfObject() _bgd.PdfObject {
	if _ebaf.PdfAnnotationWidget != nil {
		_ebaf.PdfAnnotationWidget.ToPdfObject()
	}
	_ebaf.PdfField.ToPdfObject()
	_gfabe := _ebaf._bcgde
	_bccf := _gfabe.PdfObject.(*_bgd.PdfObjectDictionary)
	_bccf.SetIfNotNil("\u0046\u0054", _bgd.MakeName("\u0053\u0069\u0067"))
	_bccf.SetIfNotNil("\u004c\u006f\u0063\u006b", _ebaf.Lock)
	_bccf.SetIfNotNil("\u0053\u0056", _ebaf.SV)
	if _ebaf.V != nil {
		_bccf.SetIfNotNil("\u0056", _ebaf.V.ToPdfObject())
	}
	return _gfabe
}

// NewPdfFontFromTTFFile loads a TTF font file and returns a PdfFont type
// that can be used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTFFile.
func NewPdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_afbf, _dgdfa := _gc.Open(filePath)
	if _dgdfa != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020T\u0054F\u0020\u0066\u006f\u006e\u0074\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _dgdfa)
		return nil, _dgdfa
	}
	defer _afbf.Close()
	return NewPdfFontFromTTF(_afbf)
}

// UpdateXObjectImageFromImage creates a new XObject Image from an
// Image object `img` and default masks from xobjIn.
// The default masks are overridden if img.hasAlpha
// If `encoder` is nil, uses raw encoding (none).
func UpdateXObjectImageFromImage(xobjIn *XObjectImage, img *Image, cs PdfColorspace, encoder _bgd.StreamEncoder) (*XObjectImage, error) {
	if encoder == nil {
		var _baebga error
		encoder, _baebga = img.getSuitableEncoder()
		if _baebga != nil {
			_fg.Log.Debug("F\u0061\u0069l\u0075\u0072\u0065\u0020\u006f\u006e\u0020\u0066\u0069\u006e\u0064\u0069\u006e\u0067\u0020\u0073\u0075\u0069\u0074\u0061b\u006c\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072,\u0020\u0066\u0061\u006c\u006c\u0062\u0061\u0063\u006b\u0020\u0074\u006f\u0020R\u0061\u0077\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020%\u0076", _baebga)
			encoder = _bgd.NewRawEncoder()
		}
	}
	encoder.UpdateParams(img.GetParamsDict())
	_fddfd, _dcbdce := encoder.EncodeBytes(img.Data)
	if _dcbdce != nil {
		_fg.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _dcbdce)
		return nil, _dcbdce
	}
	_dacec := NewXObjectImage()
	_bgdbc := img.Width
	_ggfag := img.Height
	_dacec.Width = &_bgdbc
	_dacec.Height = &_ggfag
	_dafga := img.BitsPerComponent
	_dacec.BitsPerComponent = &_dafga
	_dacec.Filter = encoder
	_dacec.Stream = _fddfd
	if cs == nil {
		if img.ColorComponents == 1 {
			_dacec.ColorSpace = NewPdfColorspaceDeviceGray()
			if img.BitsPerComponent == 16 {
				switch encoder.(type) {
				case *_bgd.DCTEncoder:
					_dacec.ColorSpace = NewPdfColorspaceDeviceRGB()
					_dafga = 8
					_dacec.BitsPerComponent = &_dafga
				}
			}
		} else if img.ColorComponents == 3 {
			_dacec.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			switch encoder.(type) {
			case *_bgd.DCTEncoder:
				_dacec.ColorSpace = NewPdfColorspaceDeviceRGB()
			default:
				_dacec.ColorSpace = NewPdfColorspaceDeviceCMYK()
			}
		} else {
			return nil, _gb.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_dacec.ColorSpace = cs
	}
	if len(img._bdgdb) != 0 {
		_bdcef := NewXObjectImage()
		_bdcef.Filter = encoder
		_debfb, _bdfeg := encoder.EncodeBytes(img._bdgdb)
		if _bdfeg != nil {
			_fg.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _bdfeg)
			return nil, _bdfeg
		}
		_bdcef.Stream = _debfb
		_bdcef.BitsPerComponent = _dacec.BitsPerComponent
		_bdcef.Width = &img.Width
		_bdcef.Height = &img.Height
		_bdcef.ColorSpace = NewPdfColorspaceDeviceGray()
		_dacec.SMask = _bdcef.ToPdfObject()
	} else {
		_dacec.SMask = xobjIn.SMask
		_dacec.ImageMask = xobjIn.ImageMask
		if _dacec.ColorSpace.GetNumComponents() == 1 {
			_bdadd(_dacec)
		}
	}
	return _dacec, nil
}

func (_bedfg *PdfSignature) extractChainFromPKCS7() ([]*_cb.Certificate, error) {
	_cbgbfb, _gdaga := _edf.Parse(_bedfg.Contents.Bytes())
	if _gdaga != nil {
		return nil, _gdaga
	}
	return _cbgbfb.Certificates, nil
}

// GetPageAsIndirectObject returns the page as a dictionary within an PdfIndirectObject.
func (_cedfg *PdfPage) GetPageAsIndirectObject() *_bgd.PdfIndirectObject { return _cedfg._bbgfg }

// GetCharMetrics returns the char metrics for character code `code`.
// How it works:
//  1. It calls the GetCharMetrics function for the underlying font, either a simple font or
//     a Type0 font. The underlying font GetCharMetrics() functions do direct charcode ➞  metrics
//     mappings.
//  2. If the underlying font's GetCharMetrics() doesn't have a CharMetrics for `code` then a
//     a CharMetrics with the FontDescriptor's /MissingWidth is returned.
//  3. If there is no /MissingWidth then a failure is returned.
//
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
// well give them 0 width. There is no need for the bool return.
//
// TODO(gunnsth): Reconsider whether needed or if can map via GlyphName.
func (_acgf *PdfFont) GetCharMetrics(code _dabf.CharCode) (CharMetrics, bool) {
	var _fbefa _fe.CharMetrics
	switch _gada := _acgf._cbec.(type) {
	case *pdfFontSimple:
		if _eegee, _egffg := _gada.GetCharMetrics(code); _egffg {
			return _eegee, _egffg
		}
	case *pdfFontType0:
		if _bfbge, _efce := _gada.GetCharMetrics(code); _efce {
			return _bfbge, _efce
		}
	case *pdfCIDFontType0:
		if _addd, _eabc := _gada.GetCharMetrics(code); _eabc {
			return _addd, _eabc
		}
	case *pdfCIDFontType2:
		if _bgfb, _ebcgd := _gada.GetCharMetrics(code); _ebcgd {
			return _bgfb, _ebcgd
		}
	case *pdfFontType3:
		if _ggbe, _gdfc := _gada.GetCharMetrics(code); _gdfc {
			return _ggbe, _gdfc
		}
	default:
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020G\u0065\u0074\u0043h\u0061\u0072\u004de\u0074\u0072i\u0063\u0073\u0020\u006e\u006f\u0074 \u0069mp\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d\u0025\u0054\u002e", _acgf._cbec)
		return _fbefa, false
	}
	if _aaec, _bfef := _acgf.GetFontDescriptor(); _bfef == nil && _aaec != nil {
		return _fe.CharMetrics{Wx: _aaec._aeee}, true
	}
	_fg.Log.Debug("\u0047\u0065\u0074\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069c\u0073\u0020\u0066\u006f\u0072 \u0066\u006fn\u0074\u003d\u0025\u0073", _acgf)
	return _fbefa, false
}

// PageFromIndirectObject returns the PdfPage and page number for a given indirect object.
func (_gfddd *PdfReader) PageFromIndirectObject(ind *_bgd.PdfIndirectObject) (*PdfPage, int, error) {
	if len(_gfddd.PageList) != len(_gfddd._gfggf) {
		return nil, 0, _gb.New("\u0070\u0061\u0067\u0065\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	for _gfdeg, _ecdge := range _gfddd._gfggf {
		if _ecdge == ind {
			return _gfddd.PageList[_gfdeg], _gfdeg + 1, nil
		}
	}
	return nil, 0, _gb.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// EncryptionAlgorithm is used in EncryptOptions to change the default algorithm used to encrypt the document.
type EncryptionAlgorithm int

// PdfColorPatternType2 represents a color shading pattern type 2 (Axial).
type PdfColorPatternType2 struct {
	Color       PdfColor
	PatternName _bgd.PdfObjectName
}

func _dbdac(_cbade, _bagd string) string {
	if _ef.Contains(_cbade, "\u002b") {
		_fecca := _ef.Split(_cbade, "\u002b")
		if len(_fecca) == 2 {
			_cbade = _fecca[1]
		}
	}
	return _bagd + "\u002b" + _cbade
}

func (_fad *PdfReader) newPdfActionGoTo3DViewFromDict(_aga *_bgd.PdfObjectDictionary) (*PdfActionGoTo3DView, error) {
	return &PdfActionGoTo3DView{TA: _aga.Get("\u0054\u0041"), V: _aga.Get("\u0056")}, nil
}

// BytesToCharcodes converts the bytes in a PDF string to character codes.
func (_afddg *PdfFont) BytesToCharcodes(data []byte) []_dabf.CharCode {
	_fg.Log.Trace("\u0042\u0079\u0074es\u0054\u006f\u0043\u0068\u0061\u0072\u0063\u006f\u0064e\u0073:\u0020d\u0061t\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d\u003d\u0025\u0023\u0071", data, data)
	if _dbgea, _cebf := _afddg._cbec.(*pdfFontType0); _cebf && _dbgea._afad != nil {
		if _dcdg, _abcd := _dbgea.bytesToCharcodes(data); _abcd {
			return _dcdg
		}
	}
	var (
		_cgeb = make([]_dabf.CharCode, 0, len(data)+len(data)%2)
		_gefb = _afddg.baseFields()
	)
	if _gefb._edab != nil {
		if _edgda, _cbecg := _gefb._edab.BytesToCharcodes(data); _cbecg {
			for _, _gadea := range _edgda {
				_cgeb = append(_cgeb, _dabf.CharCode(_gadea))
			}
			return _cgeb
		}
	}
	if _gefb.isCIDFont() {
		if len(data) == 1 {
			data = []byte{0, data[0]}
		}
		if len(data)%2 != 0 {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0064\u0061\u0074\u0061\u003d\u0025\u002b\u0076\u0020t\u006f\u0020\u0065\u0076\u0065n\u0020\u006ce\u006e\u0067\u0074\u0068", data)
			data = append(data, 0)
		}
		for _eace := 0; _eace < len(data); _eace += 2 {
			_cdebg := uint16(data[_eace])<<8 | uint16(data[_eace+1])
			_cgeb = append(_cgeb, _dabf.CharCode(_cdebg))
		}
	} else {
		for _, _aaaa := range data {
			_cgeb = append(_cgeb, _dabf.CharCode(_aaaa))
		}
	}
	return _cgeb
}

// NewPdfAnnotationLink returns a new link annotation.
func NewPdfAnnotationLink() *PdfAnnotationLink {
	_cad := NewPdfAnnotation()
	_dgf := &PdfAnnotationLink{}
	_dgf.PdfAnnotation = _cad
	_cad.SetContext(_dgf)
	return _dgf
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_acef *PdfColorspaceCalRGB) ToPdfObject() _bgd.PdfObject {
	_cddef := &_bgd.PdfObjectArray{}
	_cddef.Append(_bgd.MakeName("\u0043\u0061\u006c\u0052\u0047\u0042"))
	_aaceb := _bgd.MakeDict()
	if _acef.WhitePoint != nil {
		_cgdaec := _bgd.MakeArray(_bgd.MakeFloat(_acef.WhitePoint[0]), _bgd.MakeFloat(_acef.WhitePoint[1]), _bgd.MakeFloat(_acef.WhitePoint[2]))
		_aaceb.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _cgdaec)
	} else {
		_fg.Log.Error("\u0043\u0061l\u0052\u0047\u0042\u003a \u004d\u0069s\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _acef.BlackPoint != nil {
		_bgbgf := _bgd.MakeArray(_bgd.MakeFloat(_acef.BlackPoint[0]), _bgd.MakeFloat(_acef.BlackPoint[1]), _bgd.MakeFloat(_acef.BlackPoint[2]))
		_aaceb.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _bgbgf)
	}
	if _acef.Gamma != nil {
		_acgc := _bgd.MakeArray(_bgd.MakeFloat(_acef.Gamma[0]), _bgd.MakeFloat(_acef.Gamma[1]), _bgd.MakeFloat(_acef.Gamma[2]))
		_aaceb.Set("\u0047\u0061\u006dm\u0061", _acgc)
	}
	if _acef.Matrix != nil {
		_cdgbc := _bgd.MakeArray(_bgd.MakeFloat(_acef.Matrix[0]), _bgd.MakeFloat(_acef.Matrix[1]), _bgd.MakeFloat(_acef.Matrix[2]), _bgd.MakeFloat(_acef.Matrix[3]), _bgd.MakeFloat(_acef.Matrix[4]), _bgd.MakeFloat(_acef.Matrix[5]), _bgd.MakeFloat(_acef.Matrix[6]), _bgd.MakeFloat(_acef.Matrix[7]), _bgd.MakeFloat(_acef.Matrix[8]))
		_aaceb.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _cdgbc)
	}
	_cddef.Append(_aaceb)
	if _acef._afdd != nil {
		_acef._afdd.PdfObject = _cddef
		return _acef._afdd
	}
	return _cddef
}

// PdfOutlineTreeNode contains common fields used by the outline and outline
// item objects.
type PdfOutlineTreeNode struct {
	_bfff interface{}
	First *PdfOutlineTreeNode
	Last  *PdfOutlineTreeNode
}

// HasShadingByName checks whether a shading is defined by the specified keyName.
func (_ecddc *PdfPageResources) HasShadingByName(keyName _bgd.PdfObjectName) bool {
	_, _cega := _ecddc.GetShadingByName(keyName)
	return _cega
}

const (
	ActionTypeGoTo        PdfActionType = "\u0047\u006f\u0054\u006f"
	ActionTypeGoTo3DView  PdfActionType = "\u0047\u006f\u0054\u006f\u0033\u0044\u0056\u0069\u0065\u0077"
	ActionTypeGoToE       PdfActionType = "\u0047\u006f\u0054o\u0045"
	ActionTypeGoToR       PdfActionType = "\u0047\u006f\u0054o\u0052"
	ActionTypeHide        PdfActionType = "\u0048\u0069\u0064\u0065"
	ActionTypeImportData  PdfActionType = "\u0049\u006d\u0070\u006f\u0072\u0074\u0044\u0061\u0074\u0061"
	ActionTypeJavaScript  PdfActionType = "\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"
	ActionTypeLaunch      PdfActionType = "\u004c\u0061\u0075\u006e\u0063\u0068"
	ActionTypeMovie       PdfActionType = "\u004d\u006f\u0076i\u0065"
	ActionTypeNamed       PdfActionType = "\u004e\u0061\u006de\u0064"
	ActionTypeRendition   PdfActionType = "\u0052e\u006e\u0064\u0069\u0074\u0069\u006fn"
	ActionTypeResetForm   PdfActionType = "\u0052e\u0073\u0065\u0074\u0046\u006f\u0072m"
	ActionTypeSetOCGState PdfActionType = "S\u0065\u0074\u004f\u0043\u0047\u0053\u0074\u0061\u0074\u0065"
	ActionTypeSound       PdfActionType = "\u0053\u006f\u0075n\u0064"
	ActionTypeSubmitForm  PdfActionType = "\u0053\u0075\u0062\u006d\u0069\u0074\u0046\u006f\u0072\u006d"
	ActionTypeThread      PdfActionType = "\u0054\u0068\u0072\u0065\u0061\u0064"
	ActionTypeTrans       PdfActionType = "\u0054\u0072\u0061n\u0073"
	ActionTypeURI         PdfActionType = "\u0055\u0052\u0049"
)

func _fadfa(_acaag *fontCommon) *pdfFontType0 { return &pdfFontType0{fontCommon: *_acaag} }

func _eddcg(_fgbg []byte) (_cgfeg, _dbddba string, _gaabe error) {
	_fg.Log.Trace("g\u0065\u0074\u0041\u0053CI\u0049S\u0065\u0063\u0074\u0069\u006fn\u0073\u003a\u0020\u0025\u0064\u0020", len(_fgbg))
	_dadgc := _fgfa.FindIndex(_fgbg)
	if _dadgc == nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0067\u0065\u0074\u0041\u0053\u0043\u0049\u0049\u0053\u0065\u0063\u0074\u0069o\u006e\u0073\u002e\u0020\u004e\u006f\u0020d\u0069\u0063\u0074\u002e")
		return "", "", _bgd.ErrTypeError
	}
	_decbe := _dadgc[1]
	_fecdcc := _ef.Index(string(_fgbg[_decbe:]), _gbefb)
	if _fecdcc < 0 {
		_cgfeg = string(_fgbg[_decbe:])
		return _cgfeg, "", nil
	}
	_bdagb := _decbe + _fecdcc
	_cgfeg = string(_fgbg[_decbe:_bdagb])
	_aadee := _bdagb
	_fecdcc = _ef.Index(string(_fgbg[_aadee:]), _dabc)
	if _fecdcc < 0 {
		_fg.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0067e\u0074\u0041\u0053\u0043\u0049\u0049\u0053e\u0063\u0074\u0069\u006f\u006e\u0073\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gaabe)
		return "", "", _bgd.ErrTypeError
	}
	_ebgc := _aadee + _fecdcc
	_dbddba = string(_fgbg[_aadee:_ebgc])
	return _cgfeg, _dbddba, nil
}

// SetPdfKeywords sets the Keywords attribute of the output PDF.
func SetPdfKeywords(keywords string) { _adcf.Lock(); defer _adcf.Unlock(); _agbbd = keywords }

// SetTabOrder sets the tab order for the page.
func (_beed *PdfPage) SetTabOrder(order TabOrderType) { _beed.Tabs = _bgd.MakeName(string(order)) }

// PdfOutputIntent provides a means for matching the color characteristics of a PDF document with
// those of a target output device.
// Multiple PdfOutputIntents allows the production process to be customized to the expected workflow and the specific
// tools available.
type PdfOutputIntent struct {

	// Type is an optional PDF object that this dictionary describes.
	// If present, must be OutputIntent for an output intent dictionary.
	Type string

	// S defines the OutputIntent subtype which should match the standard used in given document i.e:
	// for PDF/X use PdfOutputIntentTypeX.
	S PdfOutputIntentType

	// OutputCondition is an optional field that is identifying the intended output device or production condition in
	// human-readable form. This is preferred method of defining such a string for presentation to the user.
	OutputCondition string

	// OutputConditionIdentifier is a required field identifying the intended output device or production condition in
	// human or machine-readable form. If human-readable, this string may be used
	// in lieu of an OutputCondition for presentation to the user.
	// A typical value for this entry would be the name of a production condition  maintained
	// in  an  industry-standard registry such  as the ICC Characterization Data Registry
	// If the intended production condition is not a recognized standard, the value Custom is recommended for this entry.
	// the DestOutputProfile entry defines the ICC profile, and the Info entry is used for further
	// human-readable identification.
	OutputConditionIdentifier string

	// RegistryName is an optional string field (conventionally URI) identifying the registry in which the condition
	// designated by OutputConditionIdentifier is defined.
	RegistryName string

	// Info is a required field if OutputConditionIdentifier does not specify a standard production condition.
	// A human-readable text string containing additional information  or comments about intended
	// target device or production condition.
	Info string

	// DestOutputProfile is required if OutputConditionIdentifier does not specify a standard production condition.
	// It is an ICC profile stream defining the transformation from the PDF document's source colors to output device colorants.
	DestOutputProfile []byte

	// ColorComponents is the number of color components supported by given output profile.
	ColorComponents int
	_gfcce          *_bgd.PdfObjectDictionary
}

// Direction represents the predominant reading order for text.
type Direction string

// ToPdfObject implements interface PdfModel.
func (_ccfe *PdfAnnotationFileAttachment) ToPdfObject() _bgd.PdfObject {
	_ccfe.PdfAnnotation.ToPdfObject()
	_ecf := _ccfe._eag
	_fae := _ecf.PdfObject.(*_bgd.PdfObjectDictionary)
	_ccfe.appendToPdfDictionary(_fae)
	_fae.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074"))
	_fae.SetIfNotNil("\u0046\u0053", _ccfe.FS)
	_fae.SetIfNotNil("\u004e\u0061\u006d\u0065", _ccfe.Name)
	return _ecf
}

// ToPdfObject returns a stream object.
func (_ccgb *XObjectForm) ToPdfObject() _bgd.PdfObject {
	_cfcce := _ccgb._aagg
	_bcbb := _cfcce.PdfObjectDictionary
	if _ccgb.Filter != nil {
		_bcbb = _ccgb.Filter.MakeStreamDict()
		_cfcce.PdfObjectDictionary = _bcbb
	}
	_bcbb.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_bcbb.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0046\u006f\u0072\u006d"))
	_bcbb.SetIfNotNil("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065", _ccgb.FormType)
	_bcbb.SetIfNotNil("\u0042\u0042\u006f\u0078", _ccgb.BBox)
	_bcbb.SetIfNotNil("\u004d\u0061\u0074\u0072\u0069\u0078", _ccgb.Matrix)
	if _ccgb.Resources != nil {
		_bcbb.SetIfNotNil("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _ccgb.Resources.ToPdfObject())
	}
	_bcbb.SetIfNotNil("\u0047\u0072\u006fu\u0070", _ccgb.Group)
	_bcbb.SetIfNotNil("\u0052\u0065\u0066", _ccgb.Ref)
	_bcbb.SetIfNotNil("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061", _ccgb.MetaData)
	_bcbb.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _ccgb.PieceInfo)
	_bcbb.SetIfNotNil("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _ccgb.LastModified)
	_bcbb.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _ccgb.StructParent)
	_bcbb.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _ccgb.StructParents)
	_bcbb.SetIfNotNil("\u004f\u0050\u0049", _ccgb.OPI)
	_bcbb.SetIfNotNil("\u004f\u0043", _ccgb.OC)
	_bcbb.SetIfNotNil("\u004e\u0061\u006d\u0065", _ccgb.Name)
	_bcbb.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_ccgb.Stream))))
	_cfcce.Stream = _ccgb.Stream
	return _cfcce
}

// PdfFunctionType4 is a Postscript calculator functions.
type PdfFunctionType4 struct {
	Domain  []float64
	Range   []float64
	Program *_af.PSProgram
	_dbdg   *_af.PSExecutor
	_bbbdd  []byte
	_baegf  *_bgd.PdfObjectStream
}

// ToPdfObject returns the text field dictionary within an indirect object (container).
func (_dcbg *PdfFieldText) ToPdfObject() _bgd.PdfObject {
	_dcbg.PdfField.ToPdfObject()
	_feafg := _dcbg._bcgde
	_geegc := _feafg.PdfObject.(*_bgd.PdfObjectDictionary)
	_geegc.Set("\u0046\u0054", _bgd.MakeName("\u0054\u0078"))
	if _dcbg.DA != nil {
		_geegc.Set("\u0044\u0041", _dcbg.DA)
	}
	if _dcbg.Q != nil {
		_geegc.Set("\u0051", _dcbg.Q)
	}
	if _dcbg.DS != nil {
		_geegc.Set("\u0044\u0053", _dcbg.DS)
	}
	if _dcbg.RV != nil {
		_geegc.Set("\u0052\u0056", _dcbg.RV)
	}
	if _dcbg.MaxLen != nil {
		_geegc.Set("\u004d\u0061\u0078\u004c\u0065\u006e", _dcbg.MaxLen)
	}
	return _feafg
}

// PdfFieldChoice represents a choice field which includes scrollable list boxes and combo boxes.
type PdfFieldChoice struct {
	*PdfField
	Opt *_bgd.PdfObjectArray
	TI  *_bgd.PdfObjectInteger
	I   *_bgd.PdfObjectArray
}

func _acfa(_aafa *_daf.ImageBase) (_ggab Image) {
	_ggab.Width = int64(_aafa.Width)
	_ggab.Height = int64(_aafa.Height)
	_ggab.BitsPerComponent = int64(_aafa.BitsPerComponent)
	_ggab.ColorComponents = _aafa.ColorComponents
	_ggab.Data = _aafa.Data
	_ggab._agcea = _aafa.Decode
	_ggab._bdgdb = _aafa.Alpha
	return _ggab
}

func (_abdb *pdfFontType0) getFontDescriptor() *PdfFontDescriptor {
	if _abdb._ggde == nil && _abdb.DescendantFont != nil {
		return _abdb.DescendantFont.FontDescriptor()
	}
	return _abdb._ggde
}

// SetDocInfo sets the document /Info metadata.
// This will overwrite any globally declared document info.
func (_geeg *PdfAppender) SetDocInfo(info *PdfInfo) { _geeg._ggag = info }

func _effd(_geed *_bgd.PdfObjectDictionary) bool {
	for _, _eeebf := range _geed.Keys() {
		if _, _eeac := _ebad[_eeebf.String()]; _eeac {
			return true
		}
	}
	return false
}

func (_aefaa *LTV) validateSig(_bcdae *PdfSignature) error {
	if _bcdae == nil || _bcdae.Contents == nil || len(_bcdae.Contents.Bytes()) == 0 {
		return _f.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0066\u0069\u0065l\u0064:\u0020\u0025\u0076", _bcdae)
	}
	return nil
}

// PdfActionGoTo3DView represents a GoTo3DView action.
type PdfActionGoTo3DView struct {
	*PdfAction
	TA _bgd.PdfObject
	V  _bgd.PdfObject
}

func _cfgb(_fadcf *PdfAnnotation) (*XObjectForm, *PdfRectangle, error) {
	_caegc, _efaeb := _bgd.GetDict(_fadcf.AP)
	if !_efaeb {
		return nil, nil, _gb.New("f\u0069\u0065\u006c\u0064\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0041\u0050\u0020d\u0069\u0063\u0074i\u006fn\u0061\u0072\u0079")
	}
	if _caegc == nil {
		return nil, nil, nil
	}
	_dadgd, _efaeb := _bgd.GetArray(_fadcf.Rect)
	if !_efaeb || _dadgd.Len() != 4 {
		return nil, nil, _gb.New("\u0072\u0065\u0063t\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_cgbf, _egdf := NewPdfRectangle(*_dadgd)
	if _egdf != nil {
		return nil, nil, _egdf
	}
	_aafda := _bgd.TraceToDirectObject(_caegc.Get("\u004e"))
	switch _fagb := _aafda.(type) {
	case *_bgd.PdfObjectStream:
		_cdacg := _fagb
		_fdcf, _egeff := NewXObjectFormFromStream(_cdacg)
		return _fdcf, _cgbf, _egeff
	case *_bgd.PdfObjectDictionary:
		_cfbbc := _fagb
		if _cfbbc == nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067e\u0074\u0020\u0061\u0070\u0070\u0065\u0061r\u0061\u006e\u0063\u0065\u002e\u0020\u0044\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
			return nil, nil, nil
		}
		var _dgga _bgd.PdfObject
		_gbfa, _cacaf := _bgd.GetName(_fadcf.AS)
		if _cacaf {
			_dgga = _cfbbc.Get(*_gbfa)
		} else {
			_cagabg := _fadcf._eag.PdfObject.(*_bgd.PdfObjectDictionary)
			if _cagabg == nil {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020F\u0061\u0069\u006ce\u0064\u0020\u0074\u006f \u0067\u0065\u0074\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u0076\u0061\u006c\u0075\u0065\u002e")
				return nil, nil, nil
			}
			if _fcegf := _cagabg.Get("\u0056"); _fcegf != nil {
				_dgga = _cfbbc.Get(_bgd.PdfObjectName(_fcegf.String()))
			}
		}
		if _dgga == nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0041\u0053\u0020\u0073\u0074\u0061\u0074\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0069\u006e\u0020\u0041\u0050\u0020\u0064\u0069\u0063\u0074\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006eg")
			return nil, nil, nil
		}
		_bbdc, _cacaf := _bgd.GetStream(_dgga)
		if !_cacaf {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006ce \u0074\u006f\u0020\u0061\u0063\u0063e\u0073\u0073\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0066\u006f\u0072 \u0025\u0076", _gbfa)
			return nil, nil, _gb.New("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		}
		_gfed, _eecf := NewXObjectFormFromStream(_bbdc)
		return _gfed, _cgbf, _eecf
	}
	_fg.Log.Debug("\u0049\u006e\u0076\u0061li\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u004e\u003a\u0020%\u0054", _aafda)
	return nil, nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
}

// AddChild adds a child object.
func (_edefb *KDict) AddChild(kv *KValue) { _edefb._fabbb = append(_edefb._fabbb, kv) }

// Y returns the value of the yellow component of the color.
func (_bgfg *PdfColorDeviceCMYK) Y() float64 { return _bgfg[2] }

// PdfActionImportData represents a importData action.
type PdfActionImportData struct {
	*PdfAction
	F *PdfFilespec
}

// XObjectForm (Table 95 in 8.10.2).
type XObjectForm struct {
	Filter        _bgd.StreamEncoder
	FormType      _bgd.PdfObject
	BBox          _bgd.PdfObject
	Matrix        _bgd.PdfObject
	Resources     *PdfPageResources
	Group         _bgd.PdfObject
	Ref           _bgd.PdfObject
	MetaData      _bgd.PdfObject
	PieceInfo     _bgd.PdfObject
	LastModified  _bgd.PdfObject
	StructParent  _bgd.PdfObject
	StructParents _bgd.PdfObject
	OPI           _bgd.PdfObject
	OC            _bgd.PdfObject
	Name          _bgd.PdfObject

	// Stream data.
	Stream []byte
	_aagg  *_bgd.PdfObjectStream
}

// Outline represents a PDF outline dictionary (Table 152 - p. 376).
// Currently, the Outline object can only be used to construct PDF outlines.
type Outline struct {
	Entries []*OutlineItem `json:"entries,omitempty"`
}

func (_ffbbd *PdfWriter) addObjects(_efdeg _bgd.PdfObject) error {
	_fg.Log.Trace("\u0041d\u0064i\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0073\u0021")
	if _abgeg, _fbaba := _efdeg.(*_bgd.PdfIndirectObject); _fbaba {
		_fg.Log.Trace("\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074")
		_fg.Log.Trace("\u002d \u0025\u0073\u0020\u0028\u0025\u0070)", _efdeg, _abgeg)
		_fg.Log.Trace("\u002d\u0020\u0025\u0073", _abgeg.PdfObject)
		if _ffbbd.addObject(_abgeg) {
			_eebdb := _ffbbd.addObjects(_abgeg.PdfObject)
			if _eebdb != nil {
				return _eebdb
			}
		}
		return nil
	}
	if _baead, _badbe := _efdeg.(*_bgd.PdfObjectStream); _badbe {
		_fg.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d")
		_fg.Log.Trace("\u002d \u0025\u0073\u0020\u0025\u0070", _efdeg, _efdeg)
		if _ffbbd.addObject(_baead) {
			_dfaaeg := _ffbbd.addObjects(_baead.PdfObjectDictionary)
			if _dfaaeg != nil {
				return _dfaaeg
			}
		}
		return nil
	}
	if _cbafa, _cdddd := _efdeg.(*_bgd.PdfObjectDictionary); _cdddd {
		_fg.Log.Trace("\u0044\u0069\u0063\u0074")
		_fg.Log.Trace("\u002d\u0020\u0025\u0073", _efdeg)
		for _, _effec := range _cbafa.Keys() {
			_eddcd := _cbafa.Get(_effec)
			if _dfacb, _fgcbb := _eddcd.(*_bgd.PdfObjectReference); _fgcbb {
				_eddcd = _dfacb.Resolve()
				_cbafa.Set(_effec, _eddcd)
			}
			if _effec != "\u0050\u0061\u0072\u0065\u006e\u0074" {
				if _bgbfdf := _ffbbd.addObjects(_eddcd); _bgbfdf != nil {
					return _bgbfdf
				}
			} else {
				if _, _cfbgg := _eddcd.(*_bgd.PdfObjectNull); _cfbgg {
					continue
				}
				if _abfegd := _ffbbd.hasObject(_eddcd); !_abfegd {
					_fg.Log.Debug("P\u0061\u0072\u0065\u006e\u0074\u0020o\u0062\u006a\u0020\u006e\u006f\u0074 \u0061\u0064\u0064\u0065\u0064\u0020\u0079e\u0074\u0021\u0021\u0020\u0025\u0054\u0020\u0025\u0070\u0020%\u0076", _eddcd, _eddcd, _eddcd)
					_ffbbd._fedfa[_eddcd] = append(_ffbbd._fedfa[_eddcd], _cbafa)
				}
			}
		}
		return nil
	}
	if _gabd, _gdbdb := _efdeg.(*_bgd.PdfObjectArray); _gdbdb {
		_fg.Log.Trace("\u0041\u0072\u0072a\u0079")
		_fg.Log.Trace("\u002d\u0020\u0025\u0073", _efdeg)
		if _gabd == nil {
			return _gb.New("\u0061\u0072\u0072a\u0079\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		for _bfeag, _addbd := range _gabd.Elements() {
			if _eadbf, _caegfd := _addbd.(*_bgd.PdfObjectReference); _caegfd {
				_addbd = _eadbf.Resolve()
				_gabd.Set(_bfeag, _addbd)
			}
			if _eefd := _ffbbd.addObjects(_addbd); _eefd != nil {
				return _eefd
			}
		}
		return nil
	}
	if _, _fbacfd := _efdeg.(*_bgd.PdfObjectReference); _fbacfd {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0062\u0065\u0020\u0061\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u002d\u0020\u0067\u006f\u0074 \u0025\u0023\u0076\u0021", _efdeg)
		return _gb.New("r\u0065\u0066\u0065\u0072en\u0063e\u0020\u006e\u006f\u0074\u0020a\u006c\u006c\u006f\u0077\u0065\u0064")
	}
	return nil
}

// ArtifactSubtype represents the subtype of an artifact in a PDF document.
type ArtifactSubtype string

// ToPdfObject returns the PDF representation of the function.
func (_egee *PdfFunctionType2) ToPdfObject() _bgd.PdfObject {
	_geda := _bgd.MakeDict()
	_geda.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _bgd.MakeInteger(2))
	_dgdbd := &_bgd.PdfObjectArray{}
	for _, _fgfgaa := range _egee.Domain {
		_dgdbd.Append(_bgd.MakeFloat(_fgfgaa))
	}
	_geda.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _dgdbd)
	if _egee.Range != nil {
		_ddfg := &_bgd.PdfObjectArray{}
		for _, _ebcfa := range _egee.Range {
			_ddfg.Append(_bgd.MakeFloat(_ebcfa))
		}
		_geda.Set("\u0052\u0061\u006eg\u0065", _ddfg)
	}
	if _egee.C0 != nil {
		_ddeae := &_bgd.PdfObjectArray{}
		for _, _ecceg := range _egee.C0 {
			_ddeae.Append(_bgd.MakeFloat(_ecceg))
		}
		_geda.Set("\u0043\u0030", _ddeae)
	}
	if _egee.C1 != nil {
		_bbgbd := &_bgd.PdfObjectArray{}
		for _, _gebf := range _egee.C1 {
			_bbgbd.Append(_bgd.MakeFloat(_gebf))
		}
		_geda.Set("\u0043\u0031", _bbgbd)
	}
	_geda.Set("\u004e", _bgd.MakeFloat(_egee.N))
	if _egee._edeg != nil {
		_egee._edeg.PdfObject = _geda
		return _egee._edeg
	}
	return _geda
}

func _fbbb(_fcee _bgd.PdfObject) (PdfFunction, error) {
	_fcee = _bgd.ResolveReference(_fcee)
	if _ebed, _ggccd := _fcee.(*_bgd.PdfObjectStream); _ggccd {
		_gbcc := _ebed.PdfObjectDictionary
		_fbcba, _eaefe := _gbcc.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_bgd.PdfObjectInteger)
		if !_eaefe {
			_fg.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_fbcba == 0 {
			return _dcbeb(_ebed)
		} else if *_fbcba == 4 {
			return _gbaba(_ebed)
		} else {
			return nil, _gb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _fdgec, _faaccf := _fcee.(*_bgd.PdfIndirectObject); _faaccf {
		_abda, _baaeg := _fdgec.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_baaeg {
			_fg.Log.Error("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006eg\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		_gbae, _baaeg := _abda.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_bgd.PdfObjectInteger)
		if !_baaeg {
			_fg.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_gbae == 2 {
			return _dffff(_fdgec)
		} else if *_gbae == 3 {
			return _dfef(_fdgec)
		} else {
			return nil, _gb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _agfbd, _fgaa := _fcee.(*_bgd.PdfObjectDictionary); _fgaa {
		_adcc, _cdfea := _agfbd.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_bgd.PdfObjectInteger)
		if !_cdfea {
			_fg.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_adcc == 2 {
			return _dffff(_agfbd)
		} else if *_adcc == 3 {
			return _dfef(_agfbd)
		} else {
			return nil, _gb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else {
		_fg.Log.Debug("\u0046u\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0054\u0079\u0070\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0023\u0076", _fcee)
		return nil, _gb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
}

// PdfColorCalGray represents a CalGray colorspace.
type PdfColorCalGray float64

// GetContainingPdfObject implements interface PdfModel.
func (_edgca *PdfSignatureReference) GetContainingPdfObject() _bgd.PdfObject { return _edgca._ceca }

func _afec(_ebcb *fontCommon) *pdfFontType3 { return &pdfFontType3{fontCommon: *_ebcb} }

func _ggcdcc(_bggfe _bgd.PdfObject) (map[_dabf.CharCode]float64, error) {
	if _bggfe == nil {
		return nil, nil
	}
	_efgde, _fefag := _bgd.GetArray(_bggfe)
	if !_fefag {
		return nil, nil
	}
	_baafb := map[_dabf.CharCode]float64{}
	_aadgf := _efgde.Len()
	for _cdcbf := 0; _cdcbf < _aadgf-1; _cdcbf++ {
		_egaf := _bgd.TraceToDirectObject(_efgde.Get(_cdcbf))
		_gfgea, _cbca := _bgd.GetIntVal(_egaf)
		if !_cbca {
			return nil, _f.Errorf("\u0062a\u0064\u0020\u0066\u006fn\u0074\u0020\u0057\u0020\u006fb\u006a0\u003a \u0069\u003d\u0025\u0064\u0020\u0025\u0023v", _cdcbf, _egaf)
		}
		_cdcbf++
		if _cdcbf > _aadgf-1 {
			return nil, _f.Errorf("\u0062\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _efgde)
		}
		_afce := _bgd.TraceToDirectObject(_efgde.Get(_cdcbf))
		switch _afce.(type) {
		case *_bgd.PdfObjectArray:
			_daabbd, _ := _bgd.GetArray(_afce)
			if _cgdcb, _adbf := _daabbd.ToFloat64Array(); _adbf == nil {
				for _fdega := 0; _fdega < len(_cgdcb); _fdega++ {
					_baafb[_dabf.CharCode(_gfgea+_fdega)] = _cgdcb[_fdega]
				}
			} else {
				return nil, _f.Errorf("\u0062\u0061\u0064 \u0066\u006f\u006e\u0074 \u0057\u0020\u0061\u0072\u0072\u0061\u0079 \u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _cdcbf, _afce)
			}
		case *_bgd.PdfObjectInteger:
			_dbfba, _ffag := _bgd.GetIntVal(_afce)
			if !_ffag {
				return nil, _f.Errorf("\u0062\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _cdcbf, _afce)
			}
			_cdcbf++
			if _cdcbf > _aadgf-1 {
				return nil, _f.Errorf("\u0062\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _efgde)
			}
			_gefgc := _efgde.Get(_cdcbf)
			_cgfba, _cbdfe := _bgd.GetNumberAsFloat(_gefgc)
			if _cbdfe != nil {
				return nil, _f.Errorf("\u0062\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0032\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _cdcbf, _gefgc)
			}
			for _fbfe := _gfgea; _fbfe <= _dbfba; _fbfe++ {
				_baafb[_dabf.CharCode(_fbfe)] = _cgfba
			}
		default:
			return nil, _f.Errorf("\u0062\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057 \u006f\u0062\u006a\u0031\u0020\u0074\u0079p\u0065\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _cdcbf, _afce)
		}
	}
	return _baafb, nil
}

func (_fbabcg *PdfWriter) getPdfVersion() string {
	return _f.Sprintf("\u0025\u0064\u002e%\u0064", _fbabcg._egbga.Major, _fbabcg._egbga.Minor)
}

func _ebea() string { _adcf.Lock(); defer _adcf.Unlock(); return _ebgca }

// XObjectType represents the type of an XObject.
type XObjectType int

// SetCenterWindow sets the value of the centerWindow flag.
func (_agddg *ViewerPreferences) SetCenterWindow(centerWindow bool) { _agddg._bbfdf = &centerWindow }

// PdfColorspaceLab is a L*, a*, b* 3 component colorspace.
type PdfColorspaceLab struct {
	WhitePoint []float64
	BlackPoint []float64
	Range      []float64
	_dccfbb    *_bgd.PdfIndirectObject
}

// ColorToRGB only converts color used with uncolored patterns (defined in underlying colorspace).  Does not go into the
// pattern objects and convert those.  If that is desired, needs to be done separately.  See for example
// grayscale conversion example in unidoc-examples repo.
func (_acad *PdfColorspaceSpecialPattern) ColorToRGB(color PdfColor) (PdfColor, error) {
	_acdc, _dfea := color.(*PdfColorPattern)
	if !_dfea {
		_fg.Log.Debug("\u0043\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0070a\u0074\u0074\u0065\u0072\u006e\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", color)
		return nil, ErrTypeCheck
	}
	if _acdc.Color == nil {
		return color, nil
	}
	if _acad.UnderlyingCS == nil {
		return nil, _gb.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
	}
	return _acad.UnderlyingCS.ColorToRGB(_acdc.Color)
}

var _eaaga = map[string]struct{}{"\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061c\u0052\u006f\u006da\u006e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061\u0063\u0045\u0078\u0070\u0065\u0072\u0074\u0045\u006e\u0063o\u0064\u0069\u006e\u0067": {}, "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}}

// NewPdfRectangle creates a PDF rectangle object based on an input array of 4 integers.
// Defining the lower left (LL) and upper right (UR) corners with
// floating point numbers.
func NewPdfRectangle(arr _bgd.PdfObjectArray) (*PdfRectangle, error) {
	_egdda := PdfRectangle{}
	if arr.Len() != 4 {
		return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0072\u0065\u0063\u0074\u0061\u006e\u0067\u006c\u0065\u0020\u0061\u0072r\u0061\u0079\u002c\u0020\u006c\u0065\u006e \u0021\u003d\u0020\u0034")
	}
	var _ggbde error
	_egdda.Llx, _ggbde = _bgd.GetNumberAsFloat(arr.Get(0))
	if _ggbde != nil {
		return nil, _ggbde
	}
	_egdda.Lly, _ggbde = _bgd.GetNumberAsFloat(arr.Get(1))
	if _ggbde != nil {
		return nil, _ggbde
	}
	_egdda.Urx, _ggbde = _bgd.GetNumberAsFloat(arr.Get(2))
	if _ggbde != nil {
		return nil, _ggbde
	}
	_egdda.Ury, _ggbde = _bgd.GetNumberAsFloat(arr.Get(3))
	if _ggbde != nil {
		return nil, _ggbde
	}
	return &_egdda, nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_abace *PdfColorspaceDeviceGray) ToPdfObject() _bgd.PdfObject {
	return _bgd.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079")
}

func (_faec *pdfCIDFontType2) baseFields() *fontCommon { return &_faec.fontCommon }

// PdfColorPattern represents a pattern color.
type PdfColorPattern struct {
	Color       PdfColor
	PatternName _bgd.PdfObjectName
}

func (_efca *PdfReader) loadPerms() (*Permissions, error) {
	if _aegba := _efca._ffabf.Get("\u0050\u0065\u0072m\u0073"); _aegba != nil {
		if _bcbdc, _deedd := _bgd.GetDict(_aegba); _deedd {
			_cbgac := _bcbdc.Get("\u0044\u006f\u0063\u004d\u0044\u0050")
			if _cbgac == nil {
				return nil, nil
			}
			if _daff, _bbgae := _bgd.GetIndirect(_cbgac); _bbgae {
				_ccecd, _fecde := _efca.newPdfSignatureFromIndirect(_daff)
				if _fecde != nil {
					return nil, _fecde
				}
				return NewPermissions(_ccecd), nil
			}
			return nil, _f.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u006f\u0063M\u0044\u0050\u0020\u0065nt\u0072\u0079")
		}
		return nil, _f.Errorf("\u0069\u006e\u0076\u0061li\u0064\u0020\u0050\u0065\u0072\u006d\u0073\u0020\u0065\u006e\u0074\u0072\u0079")
	}
	return nil, nil
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_egd *PdfColorspaceSpecialIndexed) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_daabb, _cbbb := _bgd.GetNumbersAsFloat(objects)
	if _cbbb != nil {
		return nil, _cbbb
	}
	return _egd.ColorFromFloats(_daabb)
}

// NewPdfWriter initializes a new PdfWriter.
func NewPdfWriter() PdfWriter {
	_bggac := PdfWriter{}
	_bggac._abccd = map[_bgd.PdfObject]struct{}{}
	_bggac._edcbg = []_bgd.PdfObject{}
	_bggac._fedfa = map[_bgd.PdfObject][]*_bgd.PdfObjectDictionary{}
	_bggac._accgae = map[_bgd.PdfObject]struct{}{}
	_bggac._egbga.Major = 1
	_bggac._egbga.Minor = 3
	_fbegc := _bgd.MakeDict()
	_cdfbfd := []struct {
		_cbdga _bgd.PdfObjectName
		_febaf string
	}{{"\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _abgec()}, {"\u0043r\u0065\u0061\u0074\u006f\u0072", _gaebc()}, {"\u0041\u0075\u0074\u0068\u006f\u0072", _debb()}, {"\u0053u\u0062\u006a\u0065\u0063\u0074", _ebea()}, {"\u0054\u0069\u0074l\u0065", _gbdea()}, {"\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _fafbb()}}
	for _, _bccae := range _cdfbfd {
		if _bccae._febaf != "" {
			_fbegc.Set(_bccae._cbdga, _bgd.MakeString(_bccae._febaf))
		}
	}
	if _dbega := _gcdfc(); !_dbega.IsZero() {
		if _gaedef, _bgada := NewPdfDateFromTime(_dbega); _bgada == nil {
			_fbegc.Set("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _gaedef.ToPdfObject())
		}
	}
	if _accdb := _gede(); !_accdb.IsZero() {
		if _gffgg, _bebc := NewPdfDateFromTime(_accdb); _bebc == nil {
			_fbegc.Set("\u004do\u0064\u0044\u0061\u0074\u0065", _gffgg.ToPdfObject())
		}
	}
	_baaba := _bgd.PdfIndirectObject{}
	_baaba.PdfObject = _fbegc
	_bggac._gefe = &_baaba
	_bggac.addObject(&_baaba)
	_ddaae := _bgd.PdfIndirectObject{}
	_eedcf := _bgd.MakeDict()
	_eedcf.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0043a\u0074\u0061\u006c\u006f\u0067"))
	_ddaae.PdfObject = _eedcf
	_bggac._fcgc = &_ddaae
	_bggac.addObject(_bggac._fcgc)
	_ecagd, _fgcdd := _eggfgd("\u0077")
	if _fgcdd != nil {
		_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fgcdd)
	}
	_bggac._caaf = _ecagd
	_fedee := _bgd.PdfIndirectObject{}
	_efddg := _bgd.MakeDict()
	_efddg.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0050\u0061\u0067e\u0073"))
	_cgegeg := _bgd.PdfObjectArray{}
	_efddg.Set("\u004b\u0069\u0064\u0073", &_cgegeg)
	_efddg.Set("\u0043\u006f\u0075n\u0074", _bgd.MakeInteger(0))
	_fedee.PdfObject = _efddg
	_bggac._cfaee = &_fedee
	_bggac._bbcec = map[_bgd.PdfObject]struct{}{}
	_bggac._bgbga = []*_bgd.PdfIndirectObject{}
	_bggac.addObject(_bggac._cfaee)
	_eedcf.Set("\u0050\u0061\u0067e\u0073", &_fedee)
	_bggac._aaea = _eedcf
	_fg.Log.Trace("\u0043\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0025\u0073", _ddaae)
	return _bggac
}

// UpdateObject marks `obj` as updated and to be included in the following revision.
func (_cgcf *PdfAppender) UpdateObject(obj _bgd.PdfObject) {
	_cgcf.replaceObject(obj, obj)
	if _, _bbgc := _cgcf._dgae[obj]; !_bbgc {
		_cgcf._ddce = append(_cgcf._ddce, obj)
		_cgcf._dgae[obj] = struct{}{}
	}
}

// SetViewClip sets the value of the viewClip.
func (_bbfgc *ViewerPreferences) SetViewClip(viewClip PageBoundary) { _bbfgc._bedce = viewClip }

// NewPdfAnnotationText returns a new text annotation.
func NewPdfAnnotationText() *PdfAnnotationText {
	_aggf := NewPdfAnnotation()
	_gbd := &PdfAnnotationText{}
	_gbd.PdfAnnotation = _aggf
	_gbd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_aggf.SetContext(_gbd)
	return _gbd
}

// ColorToRGB converts a CalRGB color to an RGB color.
func (_ggad *PdfColorspaceCalRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_aaca, _bdce := color.(*PdfColorCalRGB)
	if !_bdce {
		_fg.Log.Debug("\u0049\u006e\u0070ut\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0063\u0061\u006c\u0020\u0072\u0067\u0062")
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_adde := _aaca.A()
	_deea := _aaca.B()
	_cdged := _aaca.C()
	X := _ggad.Matrix[0]*_da.Pow(_adde, _ggad.Gamma[0]) + _ggad.Matrix[3]*_da.Pow(_deea, _ggad.Gamma[1]) + _ggad.Matrix[6]*_da.Pow(_cdged, _ggad.Gamma[2])
	Y := _ggad.Matrix[1]*_da.Pow(_adde, _ggad.Gamma[0]) + _ggad.Matrix[4]*_da.Pow(_deea, _ggad.Gamma[1]) + _ggad.Matrix[7]*_da.Pow(_cdged, _ggad.Gamma[2])
	Z := _ggad.Matrix[2]*_da.Pow(_adde, _ggad.Gamma[0]) + _ggad.Matrix[5]*_da.Pow(_deea, _ggad.Gamma[1]) + _ggad.Matrix[8]*_da.Pow(_cdged, _ggad.Gamma[2])
	_cegd := 3.240479*X + -1.537150*Y + -0.498535*Z
	_ededa := -0.969256*X + 1.875992*Y + 0.041556*Z
	_bcad := 0.055648*X + -0.204043*Y + 1.057311*Z
	_cegd = _da.Min(_da.Max(_cegd, 0), 1.0)
	_ededa = _da.Min(_da.Max(_ededa, 0), 1.0)
	_bcad = _da.Min(_da.Max(_bcad, 0), 1.0)
	return NewPdfColorDeviceRGB(_cegd, _ededa, _bcad), nil
}

// GetPdfName returns the PDF name used to indicate the border style.
// (Table 166 p. 395).
func (_ecba *BorderStyle) GetPdfName() string {
	switch *_ecba {
	case BorderStyleSolid:
		return "\u0053"
	case BorderStyleDashed:
		return "\u0044"
	case BorderStyleBeveled:
		return "\u0042"
	case BorderStyleInset:
		return "\u0049"
	case BorderStyleUnderline:
		return "\u0055"
	}
	return ""
}

// SetFitWindow sets the value of the fitWindow flag.
func (_gaafab *ViewerPreferences) SetFitWindow(fitWindow bool) { _gaafab._faccc = &fitWindow }

func _abcda(_bcfe *fontCommon) *pdfCIDFontType0 { return &pdfCIDFontType0{fontCommon: *_bcfe} }

// ToPdfObject converts the PdfFont object to its PDF representation.
func (_bega *PdfFont) ToPdfObject() _bgd.PdfObject {
	if _bega._cbec == nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0066\u006f\u006e\u0074 \u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073 \u006e\u0069\u006c")
		return _bgd.MakeNull()
	}
	return _bega._cbec.ToPdfObject()
}

// NewPdfColorPatternType3 returns an empty color shading pattern type 3 (Radial).
func NewPdfColorPatternType3() *PdfColorPatternType3 { _bgdd := &PdfColorPatternType3{}; return _bgdd }

// SignatureHandlerDocMDP extends SignatureHandler with the ValidateWithOpts method for checking the DocMDP policy.
type SignatureHandlerDocMDP interface {
	SignatureHandler

	// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser
	// ValidateWithOpts shall contain Validate call
	ValidateWithOpts(_fdfbf *PdfSignature, _efgad Hasher, _bbbbc SignatureHandlerDocMDPParams) (SignatureValidationResult, error)
}

func _afacg(_eccf *_bgd.PdfObjectDictionary) *VRI {
	_bcaa, _ := _bgd.GetString(_eccf.Get("\u0054\u0055"))
	_eegge, _ := _bgd.GetString(_eccf.Get("\u0054\u0053"))
	return &VRI{Cert: _gcbc(_eccf.Get("\u0043\u0065\u0072\u0074")), OCSP: _gcbc(_eccf.Get("\u004f\u0043\u0053\u0050")), CRL: _gcbc(_eccf.Get("\u0043\u0052\u004c")), TU: _bcaa, TS: _eegge}
}

func (_dfgdf *PdfWriter) hasObject(_caefa _bgd.PdfObject) bool {
	_, _edggd := _dfgdf._abccd[_caefa]
	return _edggd
}

// UpdatePage updates the `page` in the new revision if it has changed.
func (_fdgf *PdfAppender) UpdatePage(page *PdfPage) {
	_fdgf.updateObjectsDeep(page.ToPdfObject(), nil)
}

// ToPdfObject returns colorspace in a PDF object format [name stream]
func (_cfbeb *PdfColorspaceICCBased) ToPdfObject() _bgd.PdfObject {
	_bcab := &_bgd.PdfObjectArray{}
	_bcab.Append(_bgd.MakeName("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"))
	var _ebbc *_bgd.PdfObjectStream
	if _cfbeb._cfde != nil {
		_ebbc = _cfbeb._cfde
	} else {
		_ebbc = &_bgd.PdfObjectStream{}
	}
	_gagge := _bgd.MakeDict()
	_gagge.Set("\u004e", _bgd.MakeInteger(int64(_cfbeb.N)))
	if _cfbeb.Alternate != nil {
		_gagge.Set("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e", _cfbeb.Alternate.ToPdfObject())
	}
	if _cfbeb.Metadata != nil {
		_gagge.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _cfbeb.Metadata)
	}
	if _cfbeb.Range != nil {
		var _fafe []_bgd.PdfObject
		for _, _bccgf := range _cfbeb.Range {
			_fafe = append(_fafe, _bgd.MakeFloat(_bccgf))
		}
		_gagge.Set("\u0052\u0061\u006eg\u0065", _bgd.MakeArray(_fafe...))
	}
	_gagge.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_cfbeb.Data))))
	_ebbc.Stream = _cfbeb.Data
	_ebbc.PdfObjectDictionary = _gagge
	_bcab.Append(_ebbc)
	if _cfbeb._efgaf != nil {
		_cfbeb._efgaf.PdfObject = _bcab
		return _cfbeb._efgaf
	}
	return _bcab
}

// VRI represents a Validation-Related Information dictionary.
// The VRI dictionary contains validation data in the form of
// certificates, OCSP and CRL information, for a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type VRI struct {
	Cert []*_bgd.PdfObjectStream
	OCSP []*_bgd.PdfObjectStream
	CRL  []*_bgd.PdfObjectStream
	TU   *_bgd.PdfObjectString
	TS   *_bgd.PdfObjectString
}

// NewPdfAnnotationPolygon returns a new polygon annotation.
func NewPdfAnnotationPolygon() *PdfAnnotationPolygon {
	_ecef := NewPdfAnnotation()
	_afdf := &PdfAnnotationPolygon{}
	_afdf.PdfAnnotation = _ecef
	_afdf.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ecef.SetContext(_afdf)
	return _afdf
}

func (_fdga *PdfReader) newPdfAnnotationCircleFromDict(_afba *_bgd.PdfObjectDictionary) (*PdfAnnotationCircle, error) {
	_dffc := PdfAnnotationCircle{}
	_afg, _gcgc := _fdga.newPdfAnnotationMarkupFromDict(_afba)
	if _gcgc != nil {
		return nil, _gcgc
	}
	_dffc.PdfAnnotationMarkup = _afg
	_dffc.BS = _afba.Get("\u0042\u0053")
	_dffc.IC = _afba.Get("\u0049\u0043")
	_dffc.BE = _afba.Get("\u0042\u0045")
	_dffc.RD = _afba.Get("\u0052\u0044")
	return &_dffc, nil
}

const (
	FieldFlagClear             FieldFlag = 0
	FieldFlagReadOnly          FieldFlag = 1
	FieldFlagRequired          FieldFlag = (1 << 1)
	FieldFlagNoExport          FieldFlag = (2 << 1)
	FieldFlagNoToggleToOff     FieldFlag = (1 << 14)
	FieldFlagRadio             FieldFlag = (1 << 15)
	FieldFlagPushbutton        FieldFlag = (1 << 16)
	FieldFlagRadiosInUnision   FieldFlag = (1 << 25)
	FieldFlagMultiline         FieldFlag = (1 << 12)
	FieldFlagPassword          FieldFlag = (1 << 13)
	FieldFlagFileSelect        FieldFlag = (1 << 20)
	FieldFlagDoNotScroll       FieldFlag = (1 << 23)
	FieldFlagComb              FieldFlag = (1 << 24)
	FieldFlagRichText          FieldFlag = (1 << 26)
	FieldFlagDoNotSpellCheck   FieldFlag = (1 << 22)
	FieldFlagCombo             FieldFlag = (1 << 17)
	FieldFlagEdit              FieldFlag = (1 << 18)
	FieldFlagSort              FieldFlag = (1 << 19)
	FieldFlagMultiSelect       FieldFlag = (1 << 21)
	FieldFlagCommitOnSelChange FieldFlag = (1 << 27)
)

// SetReason sets the `Reason` field of the signature.
func (_ecdbe *PdfSignature) SetReason(reason string) {
	_ecdbe.Reason = _bgd.MakeEncodedString(reason, true)
}

func _acfb(_gfcdd *_bgd.PdfObjectDictionary, _efegc *fontCommon, _bgccb _dabf.TextEncoder) (*pdfFontSimple, error) {
	_bcfed := _ccaa(_efegc)
	_bcfed._dfagc = _bgccb
	if _bgccb == nil {
		_fegcd := _gfcdd.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
		if _fegcd == nil {
			_fegcd = _bgd.MakeInteger(0)
		}
		_bcfed.FirstChar = _fegcd
		_cbbda, _fcfbf := _bgd.GetIntVal(_fegcd)
		if !_fcfbf {
			_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _fegcd)
			return nil, _bgd.ErrTypeError
		}
		_egec := _dabf.CharCode(_cbbda)
		_fegcd = _gfcdd.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
		if _fegcd == nil {
			_fegcd = _bgd.MakeInteger(255)
		}
		_bcfed.LastChar = _fegcd
		_cbbda, _fcfbf = _bgd.GetIntVal(_fegcd)
		if !_fcfbf {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _fegcd)
			return nil, _bgd.ErrTypeError
		}
		_cafad := _dabf.CharCode(_cbbda)
		_bcfed._ffagd = make(map[_dabf.CharCode]float64)
		_fegcd = _gfcdd.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
		if _fegcd != nil {
			_bcfed.Widths = _fegcd
			_cebgd, _aebcb := _bgd.GetArray(_fegcd)
			if !_aebcb {
				_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _fegcd)
				return nil, _bgd.ErrTypeError
			}
			_gegfd, _dggg := _cebgd.ToFloat64Array()
			if _dggg != nil {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
				return nil, _dggg
			}
			if len(_gegfd) != int(_cafad-_egec+1) {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _cafad-_egec+1, len(_gegfd))
				return nil, _bgd.ErrRangeError
			}
			for _aadfd, _bfgae := range _gegfd {
				_bcfed._ffagd[_egec+_dabf.CharCode(_aadfd)] = _bfgae
			}
		}
	}
	_bcfed.Encoding = _bgd.TraceToDirectObject(_gfcdd.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	return _bcfed, nil
}

// NewPdfAnnotationStamp returns a new stamp annotation.
func NewPdfAnnotationStamp() *PdfAnnotationStamp {
	_gbef := NewPdfAnnotation()
	_fbaf := &PdfAnnotationStamp{}
	_fbaf.PdfAnnotation = _gbef
	_fbaf.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gbef.SetContext(_fbaf)
	return _fbaf
}

// ToPdfObject implements interface PdfModel.
func (_dcae *PdfAnnotationSound) ToPdfObject() _bgd.PdfObject {
	_dcae.PdfAnnotation.ToPdfObject()
	_edc := _dcae._eag
	_gbf := _edc.PdfObject.(*_bgd.PdfObjectDictionary)
	_dcae.appendToPdfDictionary(_gbf)
	_gbf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0053\u006f\u0075n\u0064"))
	_gbf.SetIfNotNil("\u0053\u006f\u0075n\u0064", _dcae.Sound)
	_gbf.SetIfNotNil("\u004e\u0061\u006d\u0065", _dcae.Name)
	return _edc
}

// GetDescent returns the Descent of the font `descriptor`.
func (_bbbfg *PdfFontDescriptor) GetDescent() (float64, error) {
	return _bgd.GetNumberAsFloat(_bbbfg.Descent)
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_cbada pdfFontType0) GetCharMetrics(code _dabf.CharCode) (_fe.CharMetrics, bool) {
	if _cbada.DescendantFont == nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _cbada)
		return _fe.CharMetrics{}, false
	}
	return _cbada.DescendantFont.GetCharMetrics(code)
}

// ToPdfObject implements interface PdfModel.
func (_fefa *PdfAnnotationHighlight) ToPdfObject() _bgd.PdfObject {
	_fefa.PdfAnnotation.ToPdfObject()
	_fefaa := _fefa._eag
	_ecc := _fefaa.PdfObject.(*_bgd.PdfObjectDictionary)
	_fefa.appendToPdfDictionary(_ecc)
	_ecc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t"))
	_ecc.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _fefa.QuadPoints)
	return _fefaa
}

// GetAscent returns the Ascent of the font `descriptor`.
func (_efabf *PdfFontDescriptor) GetAscent() (float64, error) {
	return _bgd.GetNumberAsFloat(_efabf.Ascent)
}

func _fbcc(_gdffe *_bgd.PdfObjectDictionary) (*PdfShadingPattern, error) {
	_eaage := &PdfShadingPattern{}
	_fbdgf := _gdffe.Get("\u0053h\u0061\u0064\u0069\u006e\u0067")
	if _fbdgf == nil {
		_fg.Log.Debug("\u0053h\u0061d\u0069\u006e\u0067\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cefd, _bfce := _abbe(_fbdgf)
	if _bfce != nil {
		_fg.Log.Debug("\u0045r\u0072\u006f\u0072\u0020l\u006f\u0061\u0064\u0069\u006eg\u0020s\u0068a\u0064\u0069\u006e\u0067\u003a\u0020\u0025v", _bfce)
		return nil, _bfce
	}
	_eaage.Shading = _cefd
	if _afagda := _gdffe.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _afagda != nil {
		_ebfbe, _eaba := _afagda.(*_bgd.PdfObjectArray)
		if !_eaba {
			_fg.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _afagda)
			return nil, _bgd.ErrTypeError
		}
		_eaage.Matrix = _ebfbe
	}
	if _bdggde := _gdffe.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _bdggde != nil {
		_eaage.ExtGState = _bdggde
	}
	return _eaage, nil
}

// PdfModel is a higher level PDF construct which can be collapsed into a PdfObject.
// Each PdfModel has an underlying PdfObject and vice versa (one-to-one).
// Under normal circumstances there should only be one copy of each.
// Copies can be made, but care must be taken to do it properly.
type PdfModel interface {
	ToPdfObject() _bgd.PdfObject
	GetContainingPdfObject() _bgd.PdfObject
}

func _debb() string { _adcf.Lock(); defer _adcf.Unlock(); return _eadea }

// IsTerminal returns true for terminal fields, false otherwise.
// Terminal fields are fields whose descendants are only widget annotations.
func (_bgfce *PdfField) IsTerminal() bool { return len(_bgfce.Kids) == 0 }

// CopyFrom copies all the fields from another PdfAnnotation
func (_daee *PdfAnnotation) CopyFrom(another *PdfAnnotation) {
	if another == nil {
		return
	}
	_daee.Rect = another.Rect
	_daee.Contents = another.Contents
	_daee.P = another.P
	_daee.NM = another.NM
	_daee.M = another.M
	_daee.F = another.F
	_daee.AP = another.AP
	_daee.AS = another.AS
	_daee.Border = another.Border
	_daee.C = another.C
	_daee.StructParent = another.StructParent
	_daee.OC = another.OC
}

func _cecee(_fcdfd *_bgd.PdfObjectDictionary, _fgdb *fontCommon) (*pdfFontType3, error) {
	_cacd := _afec(_fgdb)
	_dcaed := _fcdfd.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
	if _dcaed == nil {
		_dcaed = _bgd.MakeInteger(0)
	}
	_cacd.FirstChar = _dcaed
	_abge, _gdgdb := _bgd.GetIntVal(_dcaed)
	if !_gdgdb {
		_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _dcaed)
		return nil, _bgd.ErrTypeError
	}
	_cdeae := _dabf.CharCode(_abge)
	_dcaed = _fcdfd.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
	if _dcaed == nil {
		_dcaed = _bgd.MakeInteger(255)
	}
	_cacd.LastChar = _dcaed
	_abge, _gdgdb = _bgd.GetIntVal(_dcaed)
	if !_gdgdb {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _dcaed)
		return nil, _bgd.ErrTypeError
	}
	_geae := _dabf.CharCode(_abge)
	_dcaed = _fcdfd.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _dcaed != nil {
		_cacd.Resources = _dcaed
	}
	_dcaed = _fcdfd.Get("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s")
	if _dcaed == nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0068\u0061\u0072\u0050\u0072\u006f\u0063\u0073\u0020(%\u0076\u0029", _dcaed)
		return nil, _bgd.ErrNotSupported
	}
	_cacd.CharProcs = _dcaed
	_dcaed = _fcdfd.Get("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078")
	if _dcaed == nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0046\u006f\u006et\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0028\u0025\u0076\u0029", _dcaed)
		return nil, _bgd.ErrNotSupported
	}
	_cacd.FontMatrix = _dcaed
	_cacd._defbd = make(map[_dabf.CharCode]float64)
	_dcaed = _fcdfd.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
	if _dcaed != nil {
		_cacd.Widths = _dcaed
		_fadbe, _edgg := _bgd.GetArray(_dcaed)
		if !_edgg {
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _dcaed)
			return nil, _bgd.ErrTypeError
		}
		_gccf, _abacc := _fadbe.ToFloat64Array()
		if _abacc != nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _abacc
		}
		if len(_gccf) != int(_geae-_cdeae+1) {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _geae-_cdeae+1, len(_gccf))
			return nil, _bgd.ErrRangeError
		}
		_fgde, _edgg := _bgd.GetArray(_cacd.FontMatrix)
		if !_edgg {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _fgde)
			return nil, _abacc
		}
		_afeac, _abacc := _fgde.ToFloat64Array()
		if _abacc != nil {
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020c\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0046o\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _abacc
		}
		_abcg := _ga.NewMatrix(_afeac[0], _afeac[1], _afeac[2], _afeac[3], _afeac[4], _afeac[5])
		for _efdd, _ceedc := range _gccf {
			_dgcfb, _ := _abcg.Transform(_ceedc, _ceedc)
			_cacd._defbd[_cdeae+_dabf.CharCode(_efdd)] = _dgcfb
		}
	}
	_cacd.Encoding = _bgd.TraceToDirectObject(_fcdfd.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	_abgda := _fcdfd.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _abgda != nil {
		_cacd._cagce = _bgd.TraceToDirectObject(_abgda)
		_gcgcg, _edgae := _edbge(_cacd._cagce, &_cacd.fontCommon)
		if _edgae != nil {
			return nil, _edgae
		}
		_cacd._edab = _gcgcg
	}
	if _ecaef := _cacd._edab; _ecaef != nil {
		_cacd._fafcge = _dabf.NewCMapEncoder("", nil, _ecaef)
	} else {
		_cacd._fafcge = _dabf.NewPdfDocEncoder()
	}
	return _cacd, nil
}

// GenerateKDict generates a K dictionary object from the StructureTagInfo.
func (_gbgg *StructureTagInfo) GenerateKDict() *KDict {
	_befdc := &KDict{S: _bgd.MakeName(string(_gbgg.StructureType))}
	if len(_gbgg.AnnotObjs) == 0 {
		_befdc.K = _bgd.MakeInteger(_gbgg.Mcid)
		return _befdc
	}
	_fbeea := _bgd.MakeArray()
	_fbeea.Append(_bgd.MakeInteger(_gbgg.Mcid))
	for _, _dgfe := range _gbgg.AnnotObjs {
		_adcdf := _bgd.MakeDict()
		_adcdf.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u004f\u0042\u004a\u0052"))
		_adcdf.Set("\u004f\u0062\u006a", _dgfe)
		_fbeea.Append(_adcdf)
	}
	_befdc.K = _fbeea
	return _befdc
}

// NewPdfActionSubmitForm returns a new "submit form" action.
func NewPdfActionSubmitForm() *PdfActionSubmitForm {
	_aef := NewPdfAction()
	_ade := &PdfActionSubmitForm{}
	_ade.PdfAction = _aef
	_aef.SetContext(_ade)
	return _ade
}

// ToPdfObject converts colorspace to a PDF object. [/Indexed base hival lookup]
func (_gabeg *PdfColorspaceSpecialIndexed) ToPdfObject() _bgd.PdfObject {
	_eeee := _bgd.MakeArray(_bgd.MakeName("\u0049n\u0064\u0065\u0078\u0065\u0064"))
	_eeee.Append(_gabeg.Base.ToPdfObject())
	_eeee.Append(_bgd.MakeInteger(int64(_gabeg.HiVal)))
	_eeee.Append(_gabeg.Lookup)
	if _gabeg._ccbaf != nil {
		_gabeg._ccbaf.PdfObject = _eeee
		return _gabeg._ccbaf
	}
	return _eeee
}

// PdfColorspaceDeviceCMYK represents a CMYK32 colorspace.
type PdfColorspaceDeviceCMYK struct{}

// NewPdfReaderWithOpts creates a new PdfReader for an input io.ReadSeeker interface
// with a ReaderOpts.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderWithOpts(rs _ca.ReadSeeker, opts *ReaderOpts) (*PdfReader, error) {
	const _aeefd = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0057\u0069\u0074\u0068O\u0070\u0074\u0073"
	return _acbcg(rs, opts, true, _aeefd)
}

// PdfFunctionType0 uses a sequence of sample values (contained in a stream) to provide an approximation
// for functions whose domains and ranges are bounded. The samples are organized as an m-dimensional
// table in which each entry has n components
type PdfFunctionType0 struct {
	Domain        []float64
	Range         []float64
	NumInputs     int
	NumOutputs    int
	Size          []int
	BitsPerSample int
	Order         int
	Encode        []float64
	Decode        []float64
	_eggg         []byte
	_bbfbe        []uint32
	_fgeeg        *_bgd.PdfObjectStream
}

// GetTrailer returns the PDF's trailer dictionary.
func (_effbe *PdfReader) GetTrailer() (*_bgd.PdfObjectDictionary, error) {
	_gebfc := _effbe._ccade.GetTrailer()
	if _gebfc == nil {
		return nil, _gb.New("\u0074r\u0061i\u006c\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	return _gebfc, nil
}

// PdfActionMovie represents a movie action.
type PdfActionMovie struct {
	*PdfAction
	Annotation _bgd.PdfObject
	T          _bgd.PdfObject
	Operation  _bgd.PdfObject
}

type pdfFontType0 struct {
	fontCommon
	_gfcgdc        *_bgd.PdfIndirectObject
	_dbcf          _dabf.TextEncoder
	Encoding       _bgd.PdfObject
	DescendantFont *PdfFont
	_afad          *_cf.CMap
}

// SetPickTrayByPDFSize sets the value of the pickTrayByPDFSize flag.
func (_gecf *ViewerPreferences) SetPickTrayByPDFSize(pickTrayByPDFSize bool) {
	_gecf._babbb = &pickTrayByPDFSize
}

// PdfTilingPattern is a Tiling pattern that consists of repetitions of a pattern cell with defined intervals.
// It is a type 1 pattern. (PatternType = 1).
// A tiling pattern is represented by a stream object, where the stream content is
// a content stream that describes the pattern cell.
type PdfTilingPattern struct {
	*PdfPattern
	PaintType  *_bgd.PdfObjectInteger
	TilingType *_bgd.PdfObjectInteger
	BBox       *PdfRectangle
	XStep      *_bgd.PdfObjectFloat
	YStep      *_bgd.PdfObjectFloat
	Resources  *PdfPageResources
	Matrix     *_bgd.PdfObjectArray
}

// SetStructParentsKey sets the StructParents key.
func (_gccae *PdfPage) SetStructParentsKey(key int) {
	if key == -1 {
		_gccae.StructParents = nil
	} else {
		_gccae.StructParents = _bgd.MakeInteger(int64(key))
	}
}

// AppendContentStream adds content stream by string.  Appends to the last
// contentstream instance if many.
func (_ffccg *PdfPage) AppendContentStream(contentStr string) error {
	_faebf, _fafeg := _ffccg.GetContentStreams()
	if _fafeg != nil {
		return _fafeg
	}
	if len(_faebf) == 0 {
		_faebf = []string{contentStr}
		return _ffccg.SetContentStreams(_faebf, _bgd.NewFlateEncoder())
	}
	var _gfaec _ea.Buffer
	_gfaec.WriteString(_faebf[len(_faebf)-1])
	_gfaec.WriteString("\u000a")
	_gfaec.WriteString(contentStr)
	_faebf[len(_faebf)-1] = _gfaec.String()
	return _ffccg.SetContentStreams(_faebf, _bgd.NewFlateEncoder())
}

// SignatureHandlerDocMDPParams describe the specific parameters for the SignatureHandlerEx
// These parameters describe how to check the difference between revisions.
// Revisions of the document get from the PdfParser.
type SignatureHandlerDocMDPParams struct {
	Parser     *_bgd.PdfParser
	DiffPolicy _fa.DiffPolicy
}

func (_dbbaf *PdfWriter) addObject(_cccfe _bgd.PdfObject) bool {
	_aeddg := _dbbaf.hasObject(_cccfe)
	if !_aeddg {
		_baegg := _bgd.ResolveReferencesDeep(_cccfe, _dbbaf._accgae)
		if _baegg != nil {
			_fg.Log.Debug("E\u0052R\u004f\u0052\u003a\u0020\u0025\u0076\u0020\u002d \u0073\u006b\u0069\u0070pi\u006e\u0067", _baegg)
		}
		_dbbaf._edcbg = append(_dbbaf._edcbg, _cccfe)
		_dbbaf._abccd[_cccfe] = struct{}{}
		return true
	}
	return false
}

func (_aeeea *Image) resampleLowBits(_feafe []uint32) {
	_bcgffe := _daf.BytesPerLine(int(_aeeea.Width), int(_aeeea.BitsPerComponent), _aeeea.ColorComponents)
	_ecccb := make([]byte, _aeeea.ColorComponents*_bcgffe*int(_aeeea.Height))
	_decc := int(_aeeea.BitsPerComponent) * _aeeea.ColorComponents * int(_aeeea.Width)
	_gfaae := uint8(8)
	var (
		_fddec, _cadeg int
		_bagaaa        uint32
	)
	for _dcace := 0; _dcace < int(_aeeea.Height); _dcace++ {
		_cadeg = _dcace * _bcgffe
		for _dfefe := 0; _dfefe < _decc; _dfefe++ {
			_bagaaa = _feafe[_fddec]
			_gfaae -= uint8(_aeeea.BitsPerComponent)
			_ecccb[_cadeg] |= byte(_bagaaa) << _gfaae
			if _gfaae == 0 {
				_gfaae = 8
				_cadeg++
			}
			_fddec++
		}
	}
	_aeeea.Data = _ecccb
}

// GetContainingPdfObject returns the containing object for the PdfField, i.e. an indirect object
// containing the field dictionary.
func (_dada *PdfField) GetContainingPdfObject() _bgd.PdfObject { return _dada._bcgde }

var _geced = false

// StandardValidator is the interface that is used for the PDF StandardImplementer validation for the PDF document.
// It is using a CompliancePdfReader which is expected to give more Metadata during reading process.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardValidator interface {

	// ValidateStandard checks if the input reader
	ValidateStandard(_eedfg *CompliancePdfReader) error
}

func (_fgfga *PdfColorspaceSpecialPattern) String() string {
	return "\u0050a\u0074\u0074\u0065\u0072\u006e"
}

// PdfColorDeviceRGB represents a color in DeviceRGB colorspace with R, G, B components, where component is
// defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceRGB [3]float64

// SetFlag sets the flag for the field.
func (_efbd *PdfField) SetFlag(flag FieldFlag) { _efbd.Ff = _bgd.MakeInteger(int64(flag)) }

// ImageToRGB converts CalRGB colorspace image to RGB and returns the result.
func (_bfeg *PdfColorspaceCalRGB) ImageToRGB(img Image) (Image, error) {
	_egcf := _eaa.NewReader(img.getBase())
	_cfadc := _daf.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_gdcga := _eaa.NewWriter(_cfadc)
	_febb := _da.Pow(2, float64(img.BitsPerComponent)) - 1
	_afgf := make([]uint32, 3)
	var (
		_gbee                                     error
		_afac, _fabd, _cefb, _cbbg, _eebfe, _cgbe float64
	)
	for {
		_gbee = _egcf.ReadSamples(_afgf)
		if _gbee == _ca.EOF {
			break
		} else if _gbee != nil {
			return img, _gbee
		}
		_afac = float64(_afgf[0]) / _febb
		_fabd = float64(_afgf[1]) / _febb
		_cefb = float64(_afgf[2]) / _febb
		_cbbg = _bfeg.Matrix[0]*_da.Pow(_afac, _bfeg.Gamma[0]) + _bfeg.Matrix[3]*_da.Pow(_fabd, _bfeg.Gamma[1]) + _bfeg.Matrix[6]*_da.Pow(_cefb, _bfeg.Gamma[2])
		_eebfe = _bfeg.Matrix[1]*_da.Pow(_afac, _bfeg.Gamma[0]) + _bfeg.Matrix[4]*_da.Pow(_fabd, _bfeg.Gamma[1]) + _bfeg.Matrix[7]*_da.Pow(_cefb, _bfeg.Gamma[2])
		_cgbe = _bfeg.Matrix[2]*_da.Pow(_afac, _bfeg.Gamma[0]) + _bfeg.Matrix[5]*_da.Pow(_fabd, _bfeg.Gamma[1]) + _bfeg.Matrix[8]*_da.Pow(_cefb, _bfeg.Gamma[2])
		_afac = 3.240479*_cbbg + -1.537150*_eebfe + -0.498535*_cgbe
		_fabd = -0.969256*_cbbg + 1.875992*_eebfe + 0.041556*_cgbe
		_cefb = 0.055648*_cbbg + -0.204043*_eebfe + 1.057311*_cgbe
		_afac = _da.Min(_da.Max(_afac, 0), 1.0)
		_fabd = _da.Min(_da.Max(_fabd, 0), 1.0)
		_cefb = _da.Min(_da.Max(_cefb, 0), 1.0)
		_afgf[0] = uint32(_afac * _febb)
		_afgf[1] = uint32(_fabd * _febb)
		_afgf[2] = uint32(_cefb * _febb)
		if _gbee = _gdcga.WriteSamples(_afgf); _gbee != nil {
			return img, _gbee
		}
	}
	return _acfa(&_cfadc), nil
}

// NonFullScreenPageMode represents the document’s page mode when exiting
// full-screen mode.
type NonFullScreenPageMode string

// SetOpenAction sets the OpenAction in the PDF catalog.
// The value shall be either an array defining a destination (12.3.2 "Destinations" PDF32000_2008),
// or an action dictionary representing an action (12.6 "Actions" PDF32000_2008).
func (_fffafg *PdfWriter) SetOpenAction(dest _bgd.PdfObject) error {
	if dest == nil || _bgd.IsNullObject(dest) {
		return nil
	}
	_fffafg._aaea.Set("\u004f\u0070\u0065\u006e\u0041\u0063\u0074\u0069\u006f\u006e", dest)
	return _fffafg.addObjects(dest)
}

type pdfFontType3 struct {
	fontCommon
	_bafb *_bgd.PdfIndirectObject

	// These fields are specific to Type 3 fonts.
	CharProcs  _bgd.PdfObject
	Encoding   _bgd.PdfObject
	FontBBox   _bgd.PdfObject
	FontMatrix _bgd.PdfObject
	FirstChar  _bgd.PdfObject
	LastChar   _bgd.PdfObject
	Widths     _bgd.PdfObject
	Resources  _bgd.PdfObject
	_defbd     map[_dabf.CharCode]float64
	_fafcge    _dabf.TextEncoder
}

// PdfAnnotationHighlight represents Highlight annotations.
// (Section 12.5.6.10).
type PdfAnnotationHighlight struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _bgd.PdfObject
}

// PdfAnnotationMarkup represents additional fields for mark-up annotations.
// (Section 12.5.6.2 p. 399).
type PdfAnnotationMarkup struct {
	T            _bgd.PdfObject
	Popup        *PdfAnnotationPopup
	CA           _bgd.PdfObject
	RC           _bgd.PdfObject
	CreationDate _bgd.PdfObject
	IRT          _bgd.PdfObject
	Subj         _bgd.PdfObject
	RT           _bgd.PdfObject
	IT           _bgd.PdfObject
	ExData       _bgd.PdfObject
}

// PdfAnnotationCircle represents Circle annotations.
// (Section 12.5.6.8).
type PdfAnnotationCircle struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _bgd.PdfObject
	IC _bgd.PdfObject
	BE _bgd.PdfObject
	RD _bgd.PdfObject
}

// GetContext returns the action context which contains the specific type-dependent context.
// The context represents the subaction.
func (_dg *PdfAction) GetContext() PdfModel {
	if _dg == nil {
		return nil
	}
	return _dg._df
}

// Encoder iterates through the list of fonts and returns a working encoder
func (_aaecg *MultipleFontEncoder) Encoder(rn rune) (_dabf.TextEncoder, bool) {
	_addgb := _aaecg.CurrentFont
	_cadbe := _addgb.Encoder()
	_, _cfbdab := _cadbe.RuneToCharcode(rn)
	for _gfeg := 1; _gfeg < len(_aaecg._acaed) && !_cfbdab; _gfeg++ {
		_addgb = _aaecg._acaed[_gfeg]
		_cadbe = _addgb.Encoder()
		_, _cfbdab = _cadbe.RuneToCharcode(rn)
		_aaecg.CurrentFont = _addgb
	}
	return _cadbe, _cfbdab
}

// PdfShadingType7 is a Tensor-product patch mesh.
type PdfShadingType7 struct {
	*PdfShading
	BitsPerCoordinate *_bgd.PdfObjectInteger
	BitsPerComponent  *_bgd.PdfObjectInteger
	BitsPerFlag       *_bgd.PdfObjectInteger
	Decode            *_bgd.PdfObjectArray
	Function          []PdfFunction
}

// ValidateSignatures validates digital signatures in the document.
func (_fafcc *PdfReader) ValidateSignatures(handlers []SignatureHandler) ([]SignatureValidationResult, error) {
	if _fafcc.AcroForm == nil {
		return nil, nil
	}
	if _fafcc.AcroForm.Fields == nil {
		return nil, nil
	}
	type sigFieldPair struct {
		_ebbeb  *PdfSignature
		_dedfae *PdfField
		_eedff  SignatureHandler
	}
	var _dbdadd []*sigFieldPair
	for _, _fbbcd := range _fafcc.AcroForm.AllFields() {
		if _fbbcd.V == nil {
			continue
		}
		if _gbccc, _ffecg := _bgd.GetDict(_fbbcd.V); _ffecg {
			if _ecab, _eeae := _bgd.GetNameVal(_gbccc.Get("\u0054\u0079\u0070\u0065")); _eeae && (_ecab == "\u0053\u0069\u0067" || _ecab == "\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070") {
				_begab, _cfefd := _bgd.GetIndirect(_fbbcd.V)
				if !_cfefd {
					_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0020\u0069s\u0020\u006e\u0069\u006c")
					return nil, ErrTypeCheck
				}
				_dfcfe, _efgaaa := _fafcc.newPdfSignatureFromIndirect(_begab)
				if _efgaaa != nil {
					return nil, _efgaaa
				}
				var _dbcdd SignatureHandler
				for _, _deadf := range handlers {
					if _deadf.IsApplicable(_dfcfe) {
						_dbcdd = _deadf
						break
					}
				}
				_dbdadd = append(_dbdadd, &sigFieldPair{_ebbeb: _dfcfe, _dedfae: _fbbcd, _eedff: _dbcdd})
			}
		}
	}
	var _adfeg []SignatureValidationResult
	for _, _bgfdba := range _dbdadd {
		_eacbeb := SignatureValidationResult{IsSigned: true, Fields: []*PdfField{_bgfdba._dedfae}}
		if _bgfdba._eedff == nil {
			_eacbeb.Errors = append(_eacbeb.Errors, "\u0068a\u006ed\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074")
			_adfeg = append(_adfeg, _eacbeb)
			continue
		}
		_feff, _egdfa := _bgfdba._eedff.NewDigest(_bgfdba._ebbeb)
		if _egdfa != nil {
			_eacbeb.Errors = append(_eacbeb.Errors, "\u0064\u0069\u0067e\u0073\u0074\u0020\u0065\u0072\u0072\u006f\u0072", _egdfa.Error())
			_adfeg = append(_adfeg, _eacbeb)
			continue
		}
		_fbacc := _bgfdba._ebbeb.ByteRange
		if _fbacc == nil {
			_eacbeb.Errors = append(_eacbeb.Errors, "\u0042\u0079\u0074\u0065\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0073\u0065\u0074")
			_adfeg = append(_adfeg, _eacbeb)
			continue
		}
		for _ebadfd := 0; _ebadfd < _fbacc.Len(); _ebadfd = _ebadfd + 2 {
			_cfcg, _ := _bgd.GetNumberAsInt64(_fbacc.Get(_ebadfd))
			_egge, _ := _bgd.GetIntVal(_fbacc.Get(_ebadfd + 1))
			if _, _agdde := _fafcc._cfebb.Seek(_cfcg, _ca.SeekStart); _agdde != nil {
				return nil, _agdde
			}
			_cagd := make([]byte, _egge)
			if _, _ecege := _fafcc._cfebb.Read(_cagd); _ecege != nil {
				return nil, _ecege
			}
			_feff.Write(_cagd)
		}
		var _abgag SignatureValidationResult
		if _deeed, _bfbcc := _bgfdba._eedff.(SignatureHandlerDocMDP); _bfbcc {
			_abgag, _egdfa = _deeed.ValidateWithOpts(_bgfdba._ebbeb, _feff, SignatureHandlerDocMDPParams{Parser: _fafcc._ccade})
		} else {
			_abgag, _egdfa = _bgfdba._eedff.Validate(_bgfdba._ebbeb, _feff)
		}
		if _egdfa != nil {
			_fg.Log.Debug("E\u0052\u0052\u004f\u0052: \u0025v\u0020\u0028\u0025\u0054\u0029 \u002d\u0020\u0073\u006b\u0069\u0070", _egdfa, _bgfdba._eedff)
			_abgag.Errors = append(_abgag.Errors, _egdfa.Error())
		}
		_abgag.Name = _bgfdba._ebbeb.Name.Decoded()
		_abgag.Reason = _bgfdba._ebbeb.Reason.Decoded()
		if _bgfdba._ebbeb.M != nil {
			_gfaag, _fbcde := NewPdfDate(_bgfdba._ebbeb.M.String())
			if _fbcde != nil {
				_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fbcde)
				_abgag.Errors = append(_abgag.Errors, _fbcde.Error())
				continue
			}
			_abgag.Date = _gfaag
		}
		_abgag.ContactInfo = _bgfdba._ebbeb.ContactInfo.Decoded()
		_abgag.Location = _bgfdba._ebbeb.Location.Decoded()
		_abgag.Fields = _eacbeb.Fields
		_adfeg = append(_adfeg, _abgag)
	}
	return _adfeg, nil
}

func (_abgg *PdfReader) newPdfActionMovieFromDict(_agf *_bgd.PdfObjectDictionary) (*PdfActionMovie, error) {
	return &PdfActionMovie{Annotation: _agf.Get("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e"), T: _agf.Get("\u0054"), Operation: _agf.Get("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn")}, nil
}

func (_bedbe *PdfReader) newPdfAcroFormFromDict(_ddgca *_bgd.PdfIndirectObject, _gacaf *_bgd.PdfObjectDictionary) (*PdfAcroForm, error) {
	_faad := NewPdfAcroForm()
	if _ddgca != nil {
		_faad._fecg = _ddgca
		_ddgca.PdfObject = _bgd.MakeDict()
	}
	if _eacee := _gacaf.Get("\u0046\u0069\u0065\u006c\u0064\u0073"); _eacee != nil && !_bgd.IsNullObject(_eacee) {
		_ddgdb, _afdff := _bgd.GetArray(_eacee)
		if !_afdff {
			return nil, _f.Errorf("\u0066i\u0065\u006c\u0064\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e \u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _eacee)
		}
		var _gggab []*PdfField
		for _, _cgfed := range _ddgdb.Elements() {
			_gecad, _aeccd := _bgd.GetIndirect(_cgfed)
			if !_aeccd {
				if _, _bagfd := _cgfed.(*_bgd.PdfObjectNull); _bagfd {
					_fg.Log.Trace("\u0053k\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006f\u0076\u0065\u0072 \u006e\u0075\u006c\u006c\u0020\u0066\u0069\u0065\u006c\u0064")
					continue
				}
				_fg.Log.Debug("\u0046\u0069\u0065\u006c\u0064 \u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0064 \u0069\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _cgfed)
				return nil, _f.Errorf("\u0066\u0069\u0065l\u0064\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
			}
			_bcage, _aeedg := _bedbe.newPdfFieldFromIndirectObject(_gecad, nil)
			if _aeedg != nil {
				return nil, _aeedg
			}
			_fg.Log.Trace("\u0041\u0063\u0072\u006fFo\u0072\u006d\u0020\u0046\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u002b\u0076", *_bcage)
			_gggab = append(_gggab, _bcage)
		}
		_faad.Fields = &_gggab
	}
	if _ecaed := _gacaf.Get("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073"); _ecaed != nil {
		_ebagf, _cecc := _bgd.GetBool(_ecaed)
		if _cecc {
			_faad.NeedAppearances = _ebagf
		} else {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u0065\u0065\u0064\u0041\u0070p\u0065\u0061\u0072\u0061\u006e\u0063e\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _ecaed)
		}
	}
	if _fffe := _gacaf.Get("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073"); _fffe != nil {
		_fbabc, _bafa := _bgd.GetInt(_fffe)
		if _bafa {
			_faad.SigFlags = _fbabc
		} else {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073 \u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _fffe)
		}
	}
	if _ceec := _gacaf.Get("\u0043\u004f"); _ceec != nil {
		_aabgc, _cedca := _bgd.GetArray(_ceec)
		if _cedca {
			_faad.CO = _aabgc
		} else {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u004f\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _ceec)
		}
	}
	if _accgfb := _gacaf.Get("\u0044\u0052"); _accgfb != nil {
		if _gdfba, _dfeec := _bgd.GetDict(_accgfb); _dfeec {
			_adbac, _ffdf := NewPdfPageResourcesFromDict(_gdfba)
			if _ffdf != nil {
				_fg.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0044R\u003a\u0020\u0025\u0076", _ffdf)
				return nil, _ffdf
			}
			_faad.DR = _adbac
		} else {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0052\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _accgfb)
		}
	}
	if _cddgf := _gacaf.Get("\u0044\u0041"); _cddgf != nil {
		_ffafc, _ecgdf := _bgd.GetString(_cddgf)
		if _ecgdf {
			_faad.DA = _ffafc
		} else {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0041\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _cddgf)
		}
	}
	if _gffd := _gacaf.Get("\u0051"); _gffd != nil {
		_gfccg, _cegce := _bgd.GetInt(_gffd)
		if _cegce {
			_faad.Q = _gfccg
		} else {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0051\u0020\u0069\u006e\u0076a\u006ci\u0064 \u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _gffd)
		}
	}
	if _cccc := _gacaf.Get("\u0058\u0046\u0041"); _cccc != nil {
		_faad.XFA = _cccc
	}
	if _cggee := _gacaf.Get("\u0041\u0044\u0042\u0045\u005f\u0045\u0063\u0068\u006f\u0053\u0069\u0067\u006e"); _cggee != nil {
		_faad.ADBEEchoSign = _cggee
	}
	_faad.ToPdfObject()
	return _faad, nil
}

// GetRevisionNumber returns the version of the current Pdf document
func (_fgcde *PdfReader) GetRevisionNumber() int { return _fgcde._ccade.GetRevisionNumber() }

type pdfCIDFontType2 struct {
	fontCommon
	_bcabg *_bgd.PdfIndirectObject
	_bgadg _dabf.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// Dictionary that defines the character collection of the CIDFont (required).
	// See Table 116.
	CIDSystemInfo *_bgd.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW  _bgd.PdfObject
	W   _bgd.PdfObject
	DW2 _bgd.PdfObject
	W2  _bgd.PdfObject

	// CIDs to glyph indices mapping (optional).
	CIDToGIDMap _bgd.PdfObject
	_adba       map[_dabf.CharCode]float64
	_addg       float64
	_gagea      map[rune]int
}

// GetContainingPdfObject returns the XObject Form's containing object (indirect object).
func (_bfagg *XObjectForm) GetContainingPdfObject() _bgd.PdfObject { return _bfagg._aagg }

// NewPdfAnnotationLine returns a new line annotation.
func NewPdfAnnotationLine() *PdfAnnotationLine {
	_bfgf := NewPdfAnnotation()
	_adea := &PdfAnnotationLine{}
	_adea.PdfAnnotation = _bfgf
	_adea.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_bfgf.SetContext(_adea)
	return _adea
}

// GetNumComponents returns the number of color components (1 for Indexed).
func (_bbacg *PdfColorspaceSpecialIndexed) GetNumComponents() int { return 1 }

// GetAction returns the PDF action for the annotation link.
func (_bcfa *PdfAnnotationLink) GetAction() (*PdfAction, error) {
	if _bcfa._ecb != nil {
		return _bcfa._ecb, nil
	}
	if _bcfa.A == nil {
		return nil, nil
	}
	if _bcfa._adf == nil {
		return nil, nil
	}
	_cfd, _dggfd := _bcfa._adf.loadAction(_bcfa.A)
	if _dggfd != nil {
		return nil, _dggfd
	}
	_bcfa._ecb = _cfd
	return _bcfa._ecb, nil
}

// NewReaderOpts generates a default `ReaderOpts` instance.
func NewReaderOpts() *ReaderOpts { return &ReaderOpts{Password: "", LazyLoad: true} }

// PdfColor interface represents a generic color in PDF.
type PdfColor interface{}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_caca *PdfColorspaceSpecialIndexed) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	N := _caca.Base.GetNumComponents()
	_aeaf := int(vals[0]) * N
	if _aeaf < 0 || (_aeaf+N-1) >= len(_caca._bcecd) {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _aeaf)
		return nil, ErrColorOutOfRange
	}
	_cagg := _caca._bcecd[_aeaf : _aeaf+N]
	var _bggb []float64
	for _, _gece := range _cagg {
		_bggb = append(_bggb, float64(_gece)/255.0)
	}
	_ebagb, _acace := _caca.Base.ColorFromFloats(_bggb)
	if _acace != nil {
		return nil, _acace
	}
	return _ebagb, nil
}

// K returns the value of the key component of the color.
func (_cdgb *PdfColorDeviceCMYK) K() float64 { return _cdgb[3] }

func (_dgda *PdfReader) newPdfAnnotationScreenFromDict(_beded *_bgd.PdfObjectDictionary) (*PdfAnnotationScreen, error) {
	_baba := PdfAnnotationScreen{}
	_baba.T = _beded.Get("\u0054")
	_baba.MK = _beded.Get("\u004d\u004b")
	_baba.A = _beded.Get("\u0041")
	_baba.AA = _beded.Get("\u0041\u0041")
	return &_baba, nil
}

// SetCatalogLanguage sets the catalog language.
func (_fgfbe *PdfWriter) SetCatalogLanguage(lang _bgd.PdfObject) error {
	if lang == nil {
		_fgfbe._aaea.Remove("\u004c\u0061\u006e\u0067")
		return nil
	}
	if _, _fefee := lang.(*_bgd.PdfIndirectObject); _fefee {
		_fgfbe.addObject(lang)
	}
	_fgfbe._aaea.Set("\u004c\u0061\u006e\u0067", lang)
	return nil
}

func (_adef *PdfReader) newPdfAnnotationTextFromDict(_bfa *_bgd.PdfObjectDictionary) (*PdfAnnotationText, error) {
	_dfa := PdfAnnotationText{}
	_bebf, _cafb := _adef.newPdfAnnotationMarkupFromDict(_bfa)
	if _cafb != nil {
		return nil, _cafb
	}
	_dfa.PdfAnnotationMarkup = _bebf
	_dfa.Open = _bfa.Get("\u004f\u0070\u0065\u006e")
	_dfa.Name = _bfa.Get("\u004e\u0061\u006d\u0065")
	_dfa.State = _bfa.Get("\u0053\u0074\u0061t\u0065")
	_dfa.StateModel = _bfa.Get("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c")
	return &_dfa, nil
}

// ColorToRGB converts a ICCBased color to an RGB color.
func (_ecga *PdfColorspaceICCBased) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _ecga.Alternate == nil {
		_fg.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _ecga.N == 1 {
			_fg.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_egcec := NewPdfColorspaceDeviceGray()
			return _egcec.ColorToRGB(color)
		} else if _ecga.N == 3 {
			_fg.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return color, nil
		} else if _ecga.N == 4 {
			_fg.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_cacg := NewPdfColorspaceDeviceCMYK()
			return _cacg.ColorToRGB(color)
		} else {
			return nil, _gb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_fg.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _ecga)
	return _ecga.Alternate.ColorToRGB(color)
}

// PdfActionThread represents a thread action.
type PdfActionThread struct {
	*PdfAction
	F *PdfFilespec
	D _bgd.PdfObject
	B _bgd.PdfObject
}

// SetPage directly sets the page object.
func (_edgcg *KDict) SetPage(page *_bgd.PdfIndirectObject) { _edgcg.Pg = page }

// GetCharMetrics returns the char metrics for character code `code`.
func (_bccgb pdfCIDFontType0) GetCharMetrics(code _dabf.CharCode) (_fe.CharMetrics, bool) {
	_ggadg := _bccgb._bfgb
	if _gdcda, _beffb := _bccgb._ddbab[code]; _beffb {
		_ggadg = _gdcda
	}
	return _fe.CharMetrics{Wx: _ggadg}, true
}

// StandardImplementer is an interface that defines specified PDF standards like PDF/A-1A (pdfa.Profile1A)
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardImplementer interface {
	StandardValidator
	StandardApplier

	// StandardName gets the human-readable name of the standard.
	StandardName() string
}

// PdfAnnotationWidget represents Widget annotations.
// Note: Widget annotations are used to display form fields.
// (Section 12.5.6.19).
type PdfAnnotationWidget struct {
	*PdfAnnotation
	H      _bgd.PdfObject
	MK     _bgd.PdfObject
	A      _bgd.PdfObject
	AA     _bgd.PdfObject
	BS     _bgd.PdfObject
	Parent _bgd.PdfObject
	_eded  *PdfField
	_abf   bool
}

// FillWithAppearance populates `form` with values provided by `provider`.
// If not nil, `appGen` is used to generate appearance dictionaries for the
// field annotations, based on the specified settings. Otherwise, appearance
// generation is skipped.
// e.g.: appGen := annotator.FieldAppearance{OnlyIfMissing: true, RegenerateTextFields: true}
// NOTE: In next major version this functionality will be part of Fill. (v4)
func (_faea *PdfAcroForm) FillWithAppearance(provider FieldValueProvider, appGen FieldAppearanceGenerator) error {
	_dggd := _faea.fill(provider, appGen)
	if _dggd != nil {
		return _dggd
	}
	if _, _efbdc := provider.(FieldImageProvider); _efbdc {
		_dggd = _faea.fillImageWithAppearance(provider.(FieldImageProvider), appGen)
	}
	return _dggd
}

// ToPdfObject implements interface PdfModel.
func (_bfe *PdfActionGoTo) ToPdfObject() _bgd.PdfObject {
	_bfe.PdfAction.ToPdfObject()
	_ffd := _bfe._fab
	_afe := _ffd.PdfObject.(*_bgd.PdfObjectDictionary)
	_afe.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeGoTo)))
	_afe.SetIfNotNil("\u0044", _bfe.D)
	return _ffd
}

func _ebdc(_accfc *_bgd.PdfObjectDictionary) (*PdfShadingType2, error) {
	_baaag := PdfShadingType2{}
	_cdacc := _accfc.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _cdacc == nil {
		_fg.Log.Debug("R\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u003a\u0020\u0020\u0043\u006f\u006f\u0072d\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_cegbc, _fadfab := _cdacc.(*_bgd.PdfObjectArray)
	if !_fadfab {
		_fg.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cdacc)
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _cegbc.Len() != 4 {
		_fg.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0034\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _cegbc.Len())
		return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	}
	_baaag.Coords = _cegbc
	if _dgfg := _accfc.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _dgfg != nil {
		_dgfg = _bgd.TraceToDirectObject(_dgfg)
		_dega, _dfdac := _dgfg.(*_bgd.PdfObjectArray)
		if !_dfdac {
			_fg.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _dgfg)
			return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_baaag.Domain = _dega
	}
	_cdacc = _accfc.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _cdacc == nil {
		_fg.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_baaag.Function = []PdfFunction{}
	if _bfgfc, _bfebb := _cdacc.(*_bgd.PdfObjectArray); _bfebb {
		for _, _feafb := range _bfgfc.Elements() {
			_cbddf, _beaee := _fbbb(_feafb)
			if _beaee != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _beaee)
				return nil, _beaee
			}
			_baaag.Function = append(_baaag.Function, _cbddf)
		}
	} else {
		_babdd, _ceedf := _fbbb(_cdacc)
		if _ceedf != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ceedf)
			return nil, _ceedf
		}
		_baaag.Function = append(_baaag.Function, _babdd)
	}
	if _efaf := _accfc.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _efaf != nil {
		_efaf = _bgd.TraceToDirectObject(_efaf)
		_cddcd, _dffcf := _efaf.(*_bgd.PdfObjectArray)
		if !_dffcf {
			_fg.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _efaf)
			return nil, _bgd.ErrTypeError
		}
		if _cddcd.Len() != 2 {
			_fg.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _cddcd.Len())
			return nil, ErrInvalidAttribute
		}
		_baaag.Extend = _cddcd
	}
	return &_baaag, nil
}

// NewXObjectImageFromImageLazy creates a new XObject Image from an image object
// with default options. If encoder is nil, uses raw encoding (none).
// If lazy is true, then lazy mode is enabled for XObject.
// Lazy mode allows to reduce memory usage with the help of temporary files.
func NewXObjectImageFromImageLazy(img *Image, cs PdfColorspace, encoder _bgd.StreamEncoder, lazy bool) (*XObjectImage, error) {
	_cdeag := NewXObjectImage()
	if lazy {
		_dfbg, _fcgbd := UpdateXObjectImageFromImage(_cdeag, img, cs, encoder)
		if _fcgbd != nil {
			return nil, _fcgbd
		}
		_dfbg.ToPdfObject()
		_fcgbd = _dfbg._befec.MakeLazy()
		if _fcgbd != nil {
			return nil, _fcgbd
		}
		_dfbg.Stream = nil
		return _dfbg, nil
	}
	return UpdateXObjectImageFromImage(_cdeag, img, cs, encoder)
}

// SetPdfModifiedDate sets the ModDate attribute of the output PDF.
func SetPdfModifiedDate(modifiedDate _ge.Time) {
	_adcf.Lock()
	defer _adcf.Unlock()
	_eccfcf = modifiedDate
}

// EmbeddedFile represents an embedded file.
type EmbeddedFile struct {
	Name         string
	Content      []byte
	FileType     string
	Description  string
	Relationship FileRelationship
	Hash         string
	CreationTime _ge.Time
	ModTime      _ge.Time
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_fegcg pdfCIDFontType0) GetRuneMetrics(r rune) (_fe.CharMetrics, bool) {
	return _fe.CharMetrics{Wx: _fegcg._bfgb}, true
}

// GetCustomInfo returns a custom info value for the specified name.
func (_bcdbd *PdfInfo) GetCustomInfo(name string) *_bgd.PdfObjectString {
	var _fcef *_bgd.PdfObjectString
	if _bcdbd._dfeee == nil {
		return _fcef
	}
	if _eccca, _aagff := _bcdbd._dfeee.Get(*_bgd.MakeName(name)).(*_bgd.PdfObjectString); _aagff {
		_fcef = _eccca
	}
	return _fcef
}

// ToPdfObject returns the PDF representation of the page resources.
func (_babfg *PdfPageResources) ToPdfObject() _bgd.PdfObject {
	_dedfa := _babfg._bdaf
	_dedfa.SetIfNotNil("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _babfg.ExtGState)
	if _babfg._fabf != nil {
		_babfg.ColorSpace = _babfg._fabf.ToPdfObject()
	}
	_dedfa.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _babfg.ColorSpace)
	_dedfa.SetIfNotNil("\u0050a\u0074\u0074\u0065\u0072\u006e", _babfg.Pattern)
	_dedfa.SetIfNotNil("\u0053h\u0061\u0064\u0069\u006e\u0067", _babfg.Shading)
	_dedfa.SetIfNotNil("\u0058O\u0062\u006a\u0065\u0063\u0074", _babfg.XObject)
	_dedfa.SetIfNotNil("\u0046\u006f\u006e\u0074", _babfg.Font)
	_dedfa.SetIfNotNil("\u0050r\u006f\u0063\u0053\u0065\u0074", _babfg.ProcSet)
	_dedfa.SetIfNotNil("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", _babfg.Properties)
	return _dedfa
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_eaea pdfCIDFontType2) GetCharMetrics(code _dabf.CharCode) (_fe.CharMetrics, bool) {
	if _cfeaf, _afade := _eaea._adba[code]; _afade {
		return _fe.CharMetrics{Wx: _cfeaf}, true
	}
	_adaa := rune(code)
	_aeeba, _aadcd := _eaea._gagea[_adaa]
	if !_aadcd {
		_aeeba = int(_eaea._addg)
	}
	return _fe.CharMetrics{Wx: float64(_aeeba)}, true
}

func (_edgad *PdfReader) buildPageList(_babag *_bgd.PdfIndirectObject, _cdgfe *_bgd.PdfIndirectObject, _ffeaf map[_bgd.PdfObject]struct{}) error {
	if _babag == nil {
		return nil
	}
	if _, _dfaae := _ffeaf[_babag]; _dfaae {
		_fg.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _babag.ObjectNumber)
		return nil
	}
	_ffeaf[_babag] = struct{}{}
	_dccbe, _adggd := _babag.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_adggd {
		return _gb.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_dgbgf, _adggd := (*_dccbe).Get("\u0054\u0079\u0070\u0065").(*_bgd.PdfObjectName)
	if !_adggd {
		if _dccbe.Get("\u004b\u0069\u0064\u0073") == nil {
			return _gb.New("\u006e\u006f\u0064\u0065 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0054\u0079p\u0065 \u0028\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0029")
		}
		_fg.Log.Debug("ER\u0052\u004fR\u003a\u0020\u006e\u006f\u0064\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067\u0020\u0054\u0079\u0070\u0065\u002c\u0020\u0062\u0075\u0074\u0020\u0068\u0061\u0073\u0020\u004b\u0069\u0064\u0073\u002e\u0020\u0041\u0073\u0073u\u006di\u006e\u0067\u0020\u0050\u0061\u0067\u0065\u0073 \u006eo\u0064\u0065.")
		_dgbgf = _bgd.MakeName("\u0050\u0061\u0067e\u0073")
		_dccbe.Set("\u0054\u0079\u0070\u0065", _dgbgf)
	}
	_fg.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0050a\u0067\u0065\u004c\u0069\u0073\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0074y\u0070\u0065\u003a\u0020\u0025\u0073\u0020(\u0025\u002b\u0076\u0029", *_dgbgf, _babag)
	if *_dgbgf == "\u0050\u0061\u0067\u0065" {
		_ffcce, _gccff := _edgad.newPdfPageFromDict(_dccbe)
		if _gccff != nil {
			return _gccff
		}
		_ffcce.setContainer(_babag)
		if _cdgfe != nil {
			_dccbe.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _cdgfe)
		}
		_edgad._gfggf = append(_edgad._gfggf, _babag)
		_edgad.PageList = append(_edgad.PageList, _ffcce)
		return nil
	}
	if *_dgbgf != "\u0050\u0061\u0067e\u0073" {
		if _edgad._ccade.Opts != nil && _edgad._ccade.Opts.RelaxedMode {
			_fg.Log.Warning("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066 \u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u006fn\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050a\u0067\u0065\u0073\u0020\u006f\u0062j\u0065\u0063t\u0021\u0020(\u0025s\u0029", _dgbgf)
			return nil
		}
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0063\u006fnt\u0065n\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u0021\u0020\u0028\u0025\u0073\u0029", _dgbgf)
		return _gb.New("\u0074\u0061\u0062\u006c\u0065\u0020o\u0066\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073 \u006fb\u006a\u0065\u0063\u0074")
	}
	if _cdgfe != nil {
		_dccbe.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _cdgfe)
	}
	if !_edgad._ffce {
		_afbgd := _edgad.traverseObjectData(_babag)
		if _afbgd != nil {
			return _afbgd
		}
	}
	_geged, _bbdaf := _edgad._ccade.Resolve(_dccbe.Get("\u004b\u0069\u0064\u0073"))
	if _bbdaf != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u004b\u0069\u0064\u0073\u0020\u006fb\u006a\u0065\u0063\u0074")
		return _bbdaf
	}
	var _fababb *_bgd.PdfObjectArray
	_fababb, _adggd = _geged.(*_bgd.PdfObjectArray)
	if !_adggd {
		_cfceg, _baeee := _geged.(*_bgd.PdfIndirectObject)
		if !_baeee {
			return _gb.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_fababb, _adggd = _cfceg.PdfObject.(*_bgd.PdfObjectArray)
		if !_adggd {
			return _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u0069\u006ed\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074")
		}
	}
	_fg.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _fababb)
	for _eccdf, _acbf := range _fababb.Elements() {
		_gbadb, _cecg := _bgd.GetIndirect(_acbf)
		if !_cecg {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 \u006f\u0062\u006a\u0065\u0063t\u0020\u002d \u0028\u0025\u0073\u0029", _gbadb)
			return _gb.New("\u0070a\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_fababb.Set(_eccdf, _gbadb)
		_bbdaf = _edgad.buildPageList(_gbadb, _babag, _ffeaf)
		if _bbdaf != nil {
			return _bbdaf
		}
	}
	return nil
}

// SetContentStreams sets the content streams based on a string array. Will make
// 1 object stream for each string and reference from the page Contents.
// Each stream will be encoded using the encoding specified by the StreamEncoder,
// if empty, will use identity encoding (raw data).
func (_bcbce *PdfPage) SetContentStreams(cStreams []string, encoder _bgd.StreamEncoder) error {
	if len(cStreams) == 0 {
		_bcbce.Contents = nil
		return nil
	}
	if encoder == nil {
		encoder = _bgd.NewRawEncoder()
	}
	var _bbddg []*_bgd.PdfObjectStream
	for _, _fcbb := range cStreams {
		_eebff := &_bgd.PdfObjectStream{}
		_gdgf := encoder.MakeStreamDict()
		_fdef, _deba := encoder.EncodeBytes([]byte(_fcbb))
		if _deba != nil {
			return _deba
		}
		_gdgf.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_fdef))))
		_eebff.PdfObjectDictionary = _gdgf
		_eebff.Stream = _fdef
		_bbddg = append(_bbddg, _eebff)
	}
	if len(_bbddg) == 1 {
		_bcbce.Contents = _bbddg[0]
	} else {
		_dgbg := _bgd.MakeArray()
		for _, _gfadc := range _bbddg {
			_dgbg.Append(_gfadc)
		}
		_bcbce.Contents = _dgbg
	}
	return nil
}

// C returns the value of the cyan component of the color.
func (_ebaa *PdfColorDeviceCMYK) C() float64 { return _ebaa[0] }

func (_daagg *PdfWriter) writeDocumentVersion() {
	if _daagg._fgaba {
		_daagg.writeString("\u000a")
	} else {
		_daagg.writeString(_f.Sprintf("\u0025\u0025\u0050D\u0046\u002d\u0025\u0064\u002e\u0025\u0064\u000a", _daagg._egbga.Major, _daagg._egbga.Minor))
		_daagg.writeString("\u0025\u00e2\u00e3\u00cf\u00d3\u000a")
	}
}

func (_ebfc *fontFile) loadFromSegments(_acfe, _fdcc []byte) error {
	_fg.Log.Trace("\u006c\u006f\u0061dF\u0072\u006f\u006d\u0053\u0065\u0067\u006d\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u0020\u0025\u0064", len(_acfe), len(_fdcc))
	_ccab := _ebfc.parseASCIIPart(_acfe)
	if _ccab != nil {
		return _ccab
	}
	_fg.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _ebfc)
	if len(_fdcc) == 0 {
		return nil
	}
	_fg.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _ebfc)
	return nil
}

// NewPdfOutlineTree returns an initialized PdfOutline tree.
func NewPdfOutlineTree() *PdfOutline {
	_dcfae := NewPdfOutline()
	_dcfae._bfff = &_dcfae
	return _dcfae
}

// ToPdfObject implements interface PdfModel.
func (_bcec *PdfAnnotationInk) ToPdfObject() _bgd.PdfObject {
	_bcec.PdfAnnotation.ToPdfObject()
	_eae := _bcec._eag
	_aefe := _eae.PdfObject.(*_bgd.PdfObjectDictionary)
	_bcec.appendToPdfDictionary(_aefe)
	_aefe.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0049\u006e\u006b"))
	_aefe.SetIfNotNil("\u0049n\u006b\u004c\u0069\u0073\u0074", _bcec.InkList)
	_aefe.SetIfNotNil("\u0042\u0053", _bcec.BS)
	return _eae
}

// NewOutlineBookmark returns an initialized PdfOutlineItem for a given bookmark title and page.
func NewOutlineBookmark(title string, page *_bgd.PdfIndirectObject) *PdfOutlineItem {
	_eaffe := PdfOutlineItem{}
	_eaffe._bfff = &_eaffe
	_eaffe.Title = _bgd.MakeString(title)
	_cdbba := _bgd.MakeArray()
	_cdbba.Append(page)
	_cdbba.Append(_bgd.MakeName("\u0046\u0069\u0074"))
	_eaffe.Dest = _cdbba
	return &_eaffe
}

// AddWatermarkText adds a text watermark to the page.
func (_bgca *PdfPage) AddWatermarkText(text string, opt WatermarkTextOptions) error {
	if text == "" {
		return _gb.New("n\u006f\u0020\u0074\u0065\u0078\u0074\u0020\u0073\u0065\u0074")
	}
	if opt.FontPath == "" {
		return _gb.New("\u006e\u006f \u0066\u006f\u006et\u0020\u0070\u0061\u0074\u0068\u0020\u0073\u0065\u0074")
	}
	if opt.Alpha == 0 {
		opt.Alpha = 0.5
	}
	if opt.FontSize == 0 {
		opt.FontSize = 20.0
	}
	if opt.FontColor == nil {
		opt.FontColor = _e.Black
	}
	_agfbb, _gfbff := _bgca.generateImage(text, opt.FontSize, opt.FontPath, opt.FontColor)
	if _gfbff != nil {
		return _gfbff
	}
	_ebca, _, _gfbff := _fc.Decode(_ea.NewReader(_agfbb))
	if _gfbff != nil {
		return _gfbff
	}
	_ceefd, _gfbff := ImageHandling.NewImageFromGoImage(_ebca)
	if _gfbff != nil {
		return _gfbff
	}
	_adcga, _gfbff := NewXObjectImageFromImage(_ceefd, nil, _bgd.NewFlateEncoder())
	if _gfbff != nil {
		return _gfbff
	}
	_fggad := WatermarkImageOptions{Alpha: opt.Alpha, FitToWidth: false, PreserveAspectRatio: true, Angle: opt.Angle}
	return _bgca.AddWatermarkImage(_adcga, _fggad)
}

// AddPages adds pages to be appended to the end of the source PDF.
func (_gfab *PdfAppender) AddPages(pages ...*PdfPage) {
	for _, _gcbd := range pages {
		_gcbd = _gcbd.Duplicate()
		_fdbfd(_gcbd)
		_gfab._ffcf = append(_gfab._ffcf, _gcbd)
	}
}

// String returns a human readable description of `fontfile`.
func (_agfa *fontFile) String() string {
	_cdbedf := "\u005b\u004e\u006f\u006e\u0065\u005d"
	if _agfa._edef != nil {
		_cdbedf = _agfa._edef.String()
	}
	return _f.Sprintf("\u0046O\u004e\u0054\u0046\u0049\u004c\u0045\u007b\u0025\u0023\u0071\u0020e\u006e\u0063\u006f\u0064\u0065\u0072\u003d\u0025\u0073\u007d", _agfa._ffeeef, _cdbedf)
}

// GetPerms returns the Permissions dictionary
func (_fdage *PdfReader) GetPerms() *Permissions { return _fdage._cfdf }

// GetObjectNums returns the object numbers of the PDF objects in the file
// Numbered objects are either indirect objects or stream objects.
// e.g. objNums := pdfReader.GetObjectNums()
// The underlying objects can then be accessed with
// pdfReader.GetIndirectObjectByNumber(objNums[0]) for the first available object.
func (_dfgag *PdfReader) GetObjectNums() []int { return _dfgag._ccade.GetObjectNums() }

// PdfActionSubmitForm represents a submitForm action.
type PdfActionSubmitForm struct {
	*PdfAction
	F      *PdfFilespec
	Fields _bgd.PdfObject
	Flags  _bgd.PdfObject
}

// Field returns the parent form field of the widget annotation, if one exists.
// NOTE: the method returns nil if the parent form field has not been parsed.
func (_baa *PdfAnnotationWidget) Field() *PdfField { return _baa._eded }

const (
	XObjectTypeUndefined XObjectType = iota
	XObjectTypeImage
	XObjectTypeForm
	XObjectTypePS
	XObjectTypeUnknown
)

// PdfBorderStyle represents a border style dictionary (12.5.4 Border Styles p. 394).
type PdfBorderStyle struct {
	W    *float64
	S    *BorderStyle
	D    *[]int
	_ffc _bgd.PdfObject
}

func (_cdc *PdfReader) newPdfActionTransFromDict(_fdbg *_bgd.PdfObjectDictionary) (*PdfActionTrans, error) {
	return &PdfActionTrans{Trans: _fdbg.Get("\u0054\u0072\u0061n\u0073")}, nil
}

func (_ebcfg *PdfPage) loadFont(_bdbec string) (*_eda.Font, error) {
	_cfae, _gfagb := _gc.ReadFile(_bdbec)
	if _gfagb != nil {
		return nil, _gfagb
	}
	_gaefe, _gfagb := _fga.ParseFont(_cfae)
	if _gfagb != nil {
		return nil, _gfagb
	}
	return _gaefe, nil
}

// GetIndirectObjectByNumber retrieves and returns a specific PdfObject by object number.
func (_ddbaf *PdfReader) GetIndirectObjectByNumber(number int) (_bgd.PdfObject, error) {
	_fgggd, _bbegd := _ddbaf._ccade.LookupByNumber(number)
	return _fgggd, _bbegd
}

// Items returns all children outline items.
func (_fgdc *Outline) Items() []*OutlineItem { return _fgdc.Entries }

// SetPdfProducer sets the Producer attribute of the output PDF.
func SetPdfProducer(producer string) { _adcf.Lock(); defer _adcf.Unlock(); _edbfc = producer }

func (_fegg *PdfAppender) addNewObject(_ffbc _bgd.PdfObject) {
	if _, _gebdg := _fegg._dgae[_ffbc]; !_gebdg {
		_fegg._ddce = append(_fegg._ddce, _ffbc)
		_fegg._dgae[_ffbc] = struct{}{}
	}
}

func (_fgeb *XObjectImage) getParamsDict() *_bgd.PdfObjectDictionary {
	_cbaaf := _bgd.MakeDict()
	_cbaaf.Set("\u0057\u0069\u0064t\u0068", _bgd.MakeInteger(*_fgeb.Width))
	_cbaaf.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _bgd.MakeInteger(*_fgeb.Height))
	_cbaaf.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _bgd.MakeInteger(int64(_fgeb.ColorSpace.GetNumComponents())))
	_cbaaf.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _bgd.MakeInteger(*_fgeb.BitsPerComponent))
	return _cbaaf
}

// NewKValue creates a new K value object.
func NewKValue() *KValue { return &KValue{} }

// NewPdfActionMovie returns a new "movie" action.
func NewPdfActionMovie() *PdfActionMovie {
	_dfb := NewPdfAction()
	_fd := &PdfActionMovie{}
	_fd.PdfAction = _dfb
	_dfb.SetContext(_fd)
	return _fd
}

func _beaa(_dcfge _bgd.PdfObject) (*PdfColorspaceICCBased, error) {
	_abfd := &PdfColorspaceICCBased{}
	if _dfbd, _bfgea := _dcfge.(*_bgd.PdfIndirectObject); _bfgea {
		_abfd._efgaf = _dfbd
	}
	_dcfge = _bgd.TraceToDirectObject(_dcfge)
	_dcde, _baeac := _dcfge.(*_bgd.PdfObjectArray)
	if !_baeac {
		return nil, _f.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _dcde.Len() != 2 {
		return nil, _f.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020c\u006f\u006c\u006fr\u0073p\u0061\u0063\u0065")
	}
	_dcfge = _bgd.TraceToDirectObject(_dcde.Get(0))
	_eadc, _baeac := _dcfge.(*_bgd.PdfObjectName)
	if !_baeac {
		return nil, _f.Errorf("\u0049\u0043\u0043B\u0061\u0073\u0065\u0064 \u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_eadc != "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064" {
		return nil, _f.Errorf("\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0049\u0043\u0043\u0042a\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_dcfge = _dcde.Get(1)
	_dbge, _baeac := _bgd.GetStream(_dcfge)
	if !_baeac {
		_fg.Log.Error("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006e\u006f\u0074\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067\u0020t\u006f\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020%\u0054", _dcfge)
		return nil, _f.Errorf("\u0049\u0043\u0043Ba\u0073\u0065\u0064\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_ddgb := _dbge.PdfObjectDictionary
	_gdgde, _baeac := _ddgb.Get("\u004e").(*_bgd.PdfObjectInteger)
	if !_baeac {
		return nil, _f.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006d\u0069\u0073\u0073\u0069n\u0067\u0020\u004e\u0020\u0066\u0072\u006fm\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074")
	}
	if *_gdgde != 1 && *_gdgde != 3 && *_gdgde != 4 {
		return nil, _f.Errorf("\u0049\u0043\u0043\u0042\u0061s\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u006e\u006f\u0074\u0020\u0031\u002c\u0033\u002c\u0034\u0029")
	}
	_abfd.N = int(*_gdgde)
	if _dcbd := _ddgb.Get("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e"); _dcbd != nil {
		_bgbb, _cead := NewPdfColorspaceFromPdfObject(_dcbd)
		if _cead != nil {
			return nil, _cead
		}
		_abfd.Alternate = _bgbb
	}
	if _feee := _ddgb.Get("\u0052\u0061\u006eg\u0065"); _feee != nil {
		_feee = _bgd.TraceToDirectObject(_feee)
		_eede, _dbda := _feee.(*_bgd.PdfObjectArray)
		if !_dbda {
			return nil, _f.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0061\u006e \u0061r\u0072\u0061\u0079")
		}
		if _eede.Len() != 2*_abfd.N {
			return nil, _f.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u0052\u0061\u006e\u0067e\u0020\u0077\u0072\u006f\u006e\u0067 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0065\u006c\u0065m\u0065\u006e\u0074\u0073")
		}
		_cbacc, _dddc := _eede.GetAsFloat64Slice()
		if _dddc != nil {
			return nil, _dddc
		}
		_abfd.Range = _cbacc
	} else {
		_abfd.Range = make([]float64, 2*_abfd.N)
		for _egad := 0; _egad < _abfd.N; _egad++ {
			_abfd.Range[2*_egad] = 0.0
			_abfd.Range[2*_egad+1] = 1.0
		}
	}
	if _bebb := _ddgb.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _bebb != nil {
		_gbbb, _fgca := _bebb.(*_bgd.PdfObjectStream)
		if !_fgca {
			return nil, _f.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u004de\u0074\u0061\u0064\u0061\u0074\u0061\u0020n\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
		}
		_abfd.Metadata = _gbbb
	}
	_ffde, _aafbg := _bgd.DecodeStream(_dbge)
	if _aafbg != nil {
		return nil, _aafbg
	}
	_abfd.Data = _ffde
	_abfd._cfde = _dbge
	return _abfd, nil
}

// ToPdfObject implements interface PdfModel.
func (_dgb *PdfAnnotationTrapNet) ToPdfObject() _bgd.PdfObject {
	_dgb.PdfAnnotation.ToPdfObject()
	_cdcg := _dgb._eag
	_ccba := _cdcg.PdfObject.(*_bgd.PdfObjectDictionary)
	_ccba.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0054r\u0061\u0070\u004e\u0065\u0074"))
	return _cdcg
}

// SetType sets the field button's type.  Can be one of:
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
// This sets the field's flag appropriately.
func (_babfc *PdfFieldButton) SetType(btype ButtonType) {
	_gcab := uint32(0)
	if _babfc.Ff != nil {
		_gcab = uint32(*_babfc.Ff)
	}
	switch btype {
	case ButtonTypePush:
		_gcab |= FieldFlagPushbutton.Mask()
	case ButtonTypeRadio:
		_gcab |= FieldFlagRadio.Mask()
	}
	_babfc.Ff = _bgd.MakeInteger(int64(_gcab))
}

// FlattenFieldsWithOpts flattens the AcroForm fields of the page using the
// provided field appearance generator and the specified options. If no options
// are specified, all form fields are flattened for the page.
// If a filter function is provided using the opts parameter, only the filtered
// fields are flattened. Otherwise, all form fields are flattened.
func (_dfca *PdfPage) FlattenFieldsWithOpts(appgen FieldAppearanceGenerator, opts *FieldFlattenOpts) error {
	_fdafd := map[*PdfAnnotation]bool{}
	_deefg, _ddbe := _dfca.GetAnnotations()
	if _ddbe != nil {
		return _ddbe
	}
	_gceb := false
	for _, _gdad := range _deefg {
		if opts.AnnotFilterFunc != nil {
			_fdafd[_gdad] = opts.AnnotFilterFunc(_gdad)
		} else {
			_fdafd[_gdad] = true
		}
		if _fdafd[_gdad] {
			_gceb = true
		}
	}
	if !_gceb {
		return nil
	}
	return _dfca.flattenFieldsWithOpts(appgen, opts, _fdafd)
}

// NewPdfColorspaceSpecialSeparation returns a new separation color.
func NewPdfColorspaceSpecialSeparation() *PdfColorspaceSpecialSeparation {
	_cgfdb := &PdfColorspaceSpecialSeparation{}
	return _cgfdb
}

func (_adace *PdfWriter) AttachFile(file *EmbeddedFile) error {
	_efcca := _adace._dcfdfdg
	if _efcca == nil {
		_efcca = _ddbd()
	}
	_bgfbfg := _efcca.addEmbeddedFile(file)
	if _bgfbfg != nil {
		return _bgfbfg
	}
	_adace._dcfdfdg = _efcca
	return nil
}

func _egcbg(_befdb *XObjectForm) (*PdfRectangle, bool, error) {
	if _cgeg, _cfaa := _befdb.BBox.(*_bgd.PdfObjectArray); _cfaa {
		_fgagg, _eaabc := NewPdfRectangle(*_cgeg)
		if _eaabc != nil {
			return nil, false, _eaabc
		}
		if _dbgfe, _gegf := _befdb.Matrix.(*_bgd.PdfObjectArray); _gegf {
			_gcadc, _aada := _dbgfe.ToFloat64Array()
			if _aada != nil {
				return nil, false, _aada
			}
			_cfdgd := _ga.IdentityMatrix()
			if len(_gcadc) == 6 {
				_cfdgd = _ga.NewMatrix(_gcadc[0], _gcadc[1], _gcadc[2], _gcadc[3], _gcadc[4], _gcadc[5])
			}
			_fgagg.Transform(_cfdgd)
			return _fgagg, true, nil
		}
		return _fgagg, false, nil
	}
	return nil, false, _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061n\u0063e\u0020\u0042\u0042\u006f\u0078\u0020\u0074y\u0070\u0065")
}

func _faccg(_aecf *_bgd.PdfObjectDictionary, _fafaf *fontCommon) (*pdfFontType0, error) {
	_bafd, _ebbg := _bgd.GetArray(_aecf.Get("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073"))
	if !_ebbg {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006cid\u0020\u0044\u0065\u0073\u0063\u0065n\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073\u0020\u002d\u0020\u006e\u006f\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079 \u0025\u0073", _fafaf)
		return nil, _bgd.ErrRangeError
	}
	if _bafd.Len() != 1 {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0041\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020(%\u0064\u0029", _bafd.Len())
		return nil, _bgd.ErrRangeError
	}
	_fdebc, _gabgc := _eafebe(_bafd.Get(0), false)
	if _gabgc != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046a\u0069\u006c\u0065d \u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u0020\u0066\u006f\u006et\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076 \u0025\u0073", _gabgc, _fafaf)
		return nil, _gabgc
	}
	_addbe := _aecf.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
	_cffe := ""
	_ggac := _fadfa(_fafaf)
	_ggac.DescendantFont = _fdebc
	switch _fbefc := _addbe.(type) {
	case *_bgd.PdfObjectName:
		_cffe, _ebbg = _bgd.GetNameVal(_addbe)
		if _ebbg {
			if _cffe == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048" || _cffe == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0056" {
				_ggac._dbcf = _dabf.NewIdentityTextEncoder(_cffe)
			} else if _cf.IsPredefinedCMap(_cffe) {
				_ggac._afad, _gabgc = _cf.LoadPredefinedCMap(_cffe)
				if _gabgc != nil {
					_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _cffe, _gabgc)
				}
			} else {
				_fg.Log.Debug("\u0055\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0063\u006da\u0070\u0020\u0025\u0071", _cffe)
			}
		}
	case *_bgd.PdfObjectStream:
		if _ggac._cagce == nil {
			_daeaa, _cafd := _cf.NewCIDSystemInfo(_fbefc.PdfObjectDictionary.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
			if _cafd != nil {
				_fg.Log.Debug("\u0055\u006e\u0061b\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0043\u0049D\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f\u003a\u0020\u0025\u0076", _cafd)
			}
			_gafg := _f.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0055\u0043\u0053\u0032", _daeaa.Registry, _daeaa.Ordering)
			if _cf.IsPredefinedCMap(_gafg) {
				_ggac._afad, _cafd = _cf.LoadPredefinedCMap(_gafg)
				if _cafd != nil {
					_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _gafg, _cafd)
				}
			} else {
				_gafg = _fbefc.PdfObjectDictionary.Get("\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065").String()
				_deefcg, _fdgg := _bgd.DecodeStream(_fbefc)
				if _fdgg != nil {
					_fg.Log.Debug("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0064\u0065\u0063\u006f\u0064\u0065\u0020s\u0074\u0072\u0065a\u006d:\u0020\u0025\u0076", _fdgg)
					return _ggac, _fdgg
				}
				if _bfga := _gafg == "\u004f\u006ee\u0042\u0079\u0074e\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u0048" || _gafg == "\u004f\u006ee\u0042\u0079\u0074e\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u0056"; _bfga {
					_ggac._afad, _fdgg = _cf.LoadCmapFromData(_deefcg, _bfga)
					if _fdgg != nil {
						_fg.Log.Debug("\u0055\u006e\u0061\u0062\u006ce\u0020\u0074\u006f\u0020\u006c\u006f\u0061\u0064\u0020\u0043\u004d\u0061\u0070 \u0066\u0072\u006f\u006d\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076\u0020\u002d\u002d\u0020\u0025\u0076", _fdgg, string(_deefcg))
						return _ggac, _fdgg
					}
					_bdbg := make(map[_cf.CharCode]rune, 256)
					for _cede := 0x00; _cede <= 0xFF; _cede++ {
						_bdbg[_cf.CharCode(_cede)] = rune(_cede)
					}
					_ggac._edab = _cf.NewToUnicodeCMap(_bdbg)
				}
			}
		}
	}
	if _efgabg := _fdebc.baseFields()._edab; _efgabg != nil {
		if _bgga := _efgabg.Name(); _bgga == "\u0041d\u006fb\u0065\u002d\u0043\u004e\u0053\u0031\u002d\u0055\u0043\u0053\u0032" || _bgga == "\u0041\u0064\u006f\u0062\u0065\u002d\u0047\u0042\u0031-\u0055\u0043\u0053\u0032" || _bgga == "\u0041\u0064\u006f\u0062\u0065\u002d\u004a\u0061\u0070\u0061\u006e\u0031-\u0055\u0043\u0053\u0032" || _bgga == "\u0041\u0064\u006f\u0062\u0065\u002d\u004b\u006f\u0072\u0065\u0061\u0031-\u0055\u0043\u0053\u0032" {
			_ggac._dbcf = _dabf.NewCMapEncoder(_cffe, _ggac._afad, _efgabg)
		}
	}
	return _ggac, nil
}

func (_eabac *PdfWriter) copyObjects() {
	_dbdee := make(map[_bgd.PdfObject]_bgd.PdfObject)
	_dbbda := make([]_bgd.PdfObject, 0, len(_eabac._edcbg))
	_ebfgf := make(map[_bgd.PdfObject]struct{}, len(_eabac._edcbg))
	_fbegd := make(map[_bgd.PdfObject]struct{})
	for _, _bcfae := range _eabac._edcbg {
		_beceb := _eabac.copyObject(_bcfae, _dbdee, _fbegd, false)
		if _, _caffb := _fbegd[_bcfae]; _caffb {
			continue
		}
		_dbbda = append(_dbbda, _beceb)
		_ebfgf[_beceb] = struct{}{}
	}
	_eabac._edcbg = _dbbda
	_eabac._abccd = _ebfgf
	_eabac._gefe = _eabac.copyObject(_eabac._gefe, _dbdee, nil, false).(*_bgd.PdfIndirectObject)
	_eabac._fcgc = _eabac.copyObject(_eabac._fcgc, _dbdee, nil, false).(*_bgd.PdfIndirectObject)
	if _eabac._abeb != nil {
		_eabac._abeb = _eabac.copyObject(_eabac._abeb, _dbdee, nil, false).(*_bgd.PdfIndirectObject)
	}
	if _eabac._fgaba {
		_dbedb := make(map[_bgd.PdfObject]int64)
		for _ebac, _bbbbb := range _eabac._gbcg {
			if _adgaca, _bfcb := _dbdee[_ebac]; _bfcb {
				_dbedb[_adgaca] = _bbbbb
			} else {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020a\u0070\u0070\u0065n\u0064\u0020\u006d\u006fd\u0065\u0020\u002d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0063\u006f\u0070\u0079\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0020\u006d\u0061\u0070")
			}
		}
		_eabac._gbcg = _dbedb
	}
}

// FlattenFieldsWithOpts flattens the AcroForm fields of the reader using the
// provided field appearance generator and the specified options. If no options
// are specified, all form fields are flattened.
// If a filter function is provided using the opts parameter, only the filtered
// fields are flattened. Otherwise, all form fields are flattened.
// At the end of the process, the AcroForm contains all the fields which were
// not flattened. If all fields are flattened, the reader's AcroForm field
// is set to nil.
func (_ecage *PdfReader) FlattenFieldsWithOpts(appgen FieldAppearanceGenerator, opts *FieldFlattenOpts) error {
	return _ecage.flattenFieldsWithOpts(false, appgen, opts)
}

func (_gfcd *PdfReader) newPdfActionSetOCGStateFromDict(_fdb *_bgd.PdfObjectDictionary) (*PdfActionSetOCGState, error) {
	return &PdfActionSetOCGState{State: _fdb.Get("\u0053\u0074\u0061t\u0065"), PreserveRB: _fdb.Get("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042")}, nil
}

// SetXObjectImageByNameLazy adds the provided XObjectImage to the page resources.
// The added XObjectImage is identified by the specified name.
func (_dfagbe *PdfPageResources) SetXObjectImageByNameLazy(keyName _bgd.PdfObjectName, ximg *XObjectImage, lazy bool) error {
	_ebedb := ximg.ToPdfObject().(*_bgd.PdfObjectStream)
	if lazy {
		_ebedb.MakeLazy()
	}
	_fgba := _dfagbe.SetXObjectByName(keyName, _ebedb)
	return _fgba
}

func _eafebe(_faaca _bgd.PdfObject, _ecbf bool) (*PdfFont, error) {
	_ecacf, _gade, _gecec := _fbbf(_faaca)
	if _ecacf != nil {
		_eagb(_ecacf)
	}
	if _gecec != nil {
		if _gecec == ErrType1CFontNotSupported {
			_bedg, _dccc := _acfb(_ecacf, _gade, nil)
			if _dccc != nil {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _gade, _dccc)
				return nil, _gecec
			}
			return &PdfFont{_cbec: _bedg}, _gecec
		}
		return nil, _gecec
	}
	_gacc := &PdfFont{}
	switch _gade._gecd {
	case "\u0054\u0079\u0070e\u0030":
		if !_ecbf {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u004c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u00650\u0020\u006e\u006f\u0074\u0020\u0061\u006c\u006c\u006f\u0077\u0065\u0064\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gade)
			return nil, _gb.New("\u0063\u0079\u0063\u006cic\u0061\u006c\u0020\u0074\u0079\u0070\u0065\u0030\u0020\u006c\u006f\u0061\u0064\u0069n\u0067")
		}
		_bcdcg, _agge := _faccg(_ecacf, _gade)
		if _agge != nil {
			_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0057\u0068\u0069l\u0065\u0020\u006c\u006f\u0061\u0064\u0069ng\u0020\u0054\u0079\u0070e\u0030\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066on\u0074\u003d%\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gade, _agge)
			return nil, _agge
		}
		_gacc._cbec = _bcdcg
	case "\u0054\u0079\u0070e\u0031", "\u004dM\u0054\u0079\u0070\u0065\u0031", "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
		var _dfdbc *pdfFontSimple
		_dbgc, _cbbf := _fe.NewStdFontByName(_fe.StdFontName(_gade._eebe))
		if _cbbf {
			_edca := _gaccd(_dbgc)
			_gacc._cbec = &_edca
			_dfcgf := _bgd.TraceToDirectObject(_edca.ToPdfObject())
			_fegc, _adfge, _dbecc := _fbbf(_dfcgf)
			if _dbecc != nil {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _gade, _edca)
				return nil, _dbecc
			}
			for _, _ffdgg := range _ecacf.Keys() {
				_fegc.Set(_ffdgg, _ecacf.Get(_ffdgg))
			}
			_dfdbc, _dbecc = _acfb(_fegc, _adfge, _edca._dfagc)
			if _dbecc != nil {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _gade, _edca)
				return nil, _dbecc
			}
			_dfdbc._ffagd = _edca._ffagd
			_dfdbc._dcbff = _edca._dcbff
			if _dfdbc._aegbd == nil {
				_dfdbc._aegbd = _edca._aegbd
			}
		} else {
			_dfdbc, _gecec = _acfb(_ecacf, _gade, nil)
			if _gecec != nil {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _gade, _gecec)
				return nil, _gecec
			}
		}
		_gecec = _dfdbc.addEncoding()
		if _gecec != nil {
			return nil, _gecec
		}
		if _cbbf {
			_dfdbc.updateStandard14Font()
		}
		if _cbbf && _dfdbc._dcfdfd == nil && _dfdbc._dfagc == nil {
			_fg.Log.Error("\u0073\u0069\u006d\u0070\u006c\u0065\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _dfdbc)
			_fg.Log.Error("\u0066n\u0074\u003d\u0025\u002b\u0076", _dbgc)
		}
		if len(_dfdbc._ffagd) == 0 {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u004e\u006f\u0020\u0077\u0069d\u0074h\u0073.\u0020\u0066\u006f\u006e\u0074\u003d\u0025s", _dfdbc)
		}
		_gacc._cbec = _dfdbc
	case "\u0054\u0079\u0070e\u0033":
		_effdf, _gdfa := _cecee(_ecacf, _gade)
		if _gdfa != nil {
			_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020W\u0068\u0069\u006c\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0074y\u0070\u0065\u0033\u0020\u0066\u006f\u006e\u0074\u003a\u0020%\u0076", _gdfa)
			return nil, _gdfa
		}
		_gacc._cbec = _effdf
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030":
		_gdda, _ccfgc := _fade(_ecacf, _gade)
		if _ccfgc != nil {
			_fg.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0057\u0068i\u006c\u0065\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069d \u0066\u006f\u006et\u0020\u0074y\u0070\u0065\u0030\u0020\u0066\u006fn\u0074\u003a \u0025\u0076", _ccfgc)
			return nil, _ccfgc
		}
		_gacc._cbec = _gdda
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_gbga, _gfabeb := _gedd(_ecacf, _gade)
		if _gfabeb != nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0057\u0068\u0069l\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069\u0064\u0020f\u006f\u006e\u0074\u0020\u0074yp\u0065\u0032\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gade, _gfabeb)
			return nil, _gfabeb
		}
		_gacc._cbec = _gbga
	default:
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020f\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073", _gade)
		return nil, _f.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0066\u006f\u006e\u0074\u0020\u0074y\u0070\u0065\u003a\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gade)
	}
	return _gacc, nil
}

func (_ddge *PdfReader) loadStructure() error {
	if _ddge._ccade.GetCrypter() != nil && !_ddge._ccade.IsAuthenticated() {
		return _f.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_aebfb := _ddge._ccade.GetTrailer()
	if _aebfb == nil {
		return _f.Errorf("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_fdfbdc, _efdg := _aebfb.Get("\u0052\u006f\u006f\u0074").(*_bgd.PdfObjectReference)
	if !_efdg {
		return _f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052\u006f\u006ft\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u003a \u0025\u0073\u0029", _aebfb)
	}
	_caae, _adbgg := _ddge._ccade.LookupByReference(*_fdfbdc)
	if _adbgg != nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0072\u006f\u006f\u0074\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _adbgg)
		return _adbgg
	}
	_cdeba, _efdg := _caae.(*_bgd.PdfIndirectObject)
	if !_efdg {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _caae, *_aebfb)
		return _gb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_acbce, _efdg := (*_cdeba).PdfObject.(*_bgd.PdfObjectDictionary)
	if !_efdg {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020I\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u0061t\u0061\u006c\u006fg\u0020(\u0025\u0073\u0029", _cdeba.PdfObject)
		return _gb.New("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_fg.Log.Trace("C\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _acbce)
	_faaab, _efdg := _acbce.Get("\u0050\u0061\u0067e\u0073").(*_bgd.PdfObjectReference)
	if !_efdg {
		return _gb.New("\u0070\u0061\u0067\u0065\u0073\u0020\u0069\u006e\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020b\u0065\u0020\u0061\u0020\u0072e\u0066\u0065r\u0065\u006e\u0063\u0065")
	}
	_bdeg, _adbgg := _ddge._ccade.LookupByReference(*_faaab)
	if _adbgg != nil {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020r\u0065\u0061\u0064 \u0070a\u0067\u0065\u0073")
		return _adbgg
	}
	_eedf, _efdg := _bdeg.(*_bgd.PdfIndirectObject)
	if !_efdg {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020P\u0061\u0067\u0065\u0073\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0069n\u0076a\u006c\u0069\u0064")
		_fg.Log.Debug("\u006f\u0070\u003a\u0020\u0025\u0070", _eedf)
		return _gb.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_fdad, _efdg := _eedf.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_efdg {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065c\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0073\u0029", _eedf)
		return _gb.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_cfafb, _efdg := _bgd.GetInt(_fdad.Get("\u0043\u006f\u0075n\u0074"))
	if !_efdg {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0050\u0061\u0067\u0065\u0073\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return _gb.New("\u0070\u0061\u0067\u0065s \u0063\u006f\u0075\u006e\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	if _, _efdg = _bgd.GetName(_fdad.Get("\u0054\u0079\u0070\u0065")); !_efdg {
		_fg.Log.Debug("\u0050\u0061\u0067\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020T\u0079\u0070\u0065\u0020\u0066\u0069\u0065\u006cd\u0020n\u006f\u0074\u0020\u0073\u0065\u0074\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0054\u0079p\u0065\u0020\u0074\u006f\u0020\u0050\u0061\u0067\u0065\u0073\u002e")
		_fdad.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0050\u0061\u0067e\u0073"))
	}
	if _fccef, _gdgg := _bgd.GetInt(_fdad.Get("\u0052\u006f\u0074\u0061\u0074\u0065")); _gdgg {
		_facde := int64(*_fccef)
		_ddge.Rotate = &_facde
	}
	_ddge._fdcbfb = _fdfbdc
	_ddge._ffabf = _acbce
	_ddge._gdea = _fdad
	_ddge._bbfde = _eedf
	_ddge._dbgd = int(*_cfafb)
	_ddge._gfggf = []*_bgd.PdfIndirectObject{}
	_aaeec := map[_bgd.PdfObject]struct{}{}
	_adbgg = _ddge.buildPageList(_eedf, nil, _aaeec)
	if _adbgg != nil {
		return _adbgg
	}
	_fg.Log.Trace("\u002d\u002d\u002d")
	_fg.Log.Trace("\u0054\u004f\u0043")
	_fg.Log.Trace("\u0050\u0061\u0067e\u0073")
	_fg.Log.Trace("\u0025\u0064\u003a\u0020\u0025\u0073", len(_ddge._gfggf), _ddge._gfggf)
	_ddge._gfbcg, _adbgg = _ddge.loadOutlines()
	if _adbgg != nil {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075i\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 t\u0072\u0065\u0065 \u0028%\u0073\u0029", _adbgg)
		return _adbgg
	}
	_ddge.AcroForm, _adbgg = _ddge.loadForms()
	if _adbgg != nil {
		return _adbgg
	}
	_ddge.DSS, _adbgg = _ddge.loadDSS()
	if _adbgg != nil {
		return _adbgg
	}
	_ddge._cfdf, _adbgg = _ddge.loadPerms()
	if _adbgg != nil {
		return _adbgg
	}
	return nil
}

// ColorFromPdfObjects gets the color from a series of pdf objects (3 for rgb).
func (_ceed *PdfColorspaceDeviceRGB) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_beff, _cdfg := _bgd.GetNumbersAsFloat(objects)
	if _cdfg != nil {
		return nil, _cdfg
	}
	return _ceed.ColorFromFloats(_beff)
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 4 for a CMYK32 device.
func (_efbb *PdfColorspaceDeviceCMYK) GetNumComponents() int { return 4 }

// NewPdfAnnotationPrinterMark returns a new printermark annotation.
func NewPdfAnnotationPrinterMark() *PdfAnnotationPrinterMark {
	_agfd := NewPdfAnnotation()
	_gdge := &PdfAnnotationPrinterMark{}
	_gdge.PdfAnnotation = _agfd
	_agfd.SetContext(_gdge)
	return _gdge
}

// PdfColorspace interface defines the common methods of a PDF colorspace.
// The colorspace defines the data storage format for each color and color representation.
//
// Device based colorspace, specified by name
// - /DeviceGray
// - /DeviceRGB
// - /DeviceCMYK
//
// CIE based colorspace specified by [name, dictionary]
// - [/CalGray dict]
// - [/CalRGB dict]
// - [/Lab dict]
// - [/ICCBased dict]
//
// Special colorspaces
// - /Pattern
// - /Indexed
// - /Separation
// - /DeviceN
//
// Work is in progress to support all colorspaces. At the moment ICCBased color spaces fall back to the alternate
// colorspace which works OK in most cases. For full color support, will need fully featured ICC support.
type PdfColorspace interface {

	// String returns the PdfColorspace's name.
	String() string

	// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
	ImageToRGB(Image) (Image, error)

	// ColorToRGB converts a single color in a given PdfColorspace to an RGB color.
	ColorToRGB(_cbaa PdfColor) (PdfColor, error)

	// GetNumComponents returns the number of components in the PdfColorspace.
	GetNumComponents() int

	// ToPdfObject returns a PdfObject representation of the PdfColorspace.
	ToPdfObject() _bgd.PdfObject

	// ColorFromPdfObjects returns a PdfColor in the given PdfColorspace from an array of PdfObject where each
	// PdfObject represents a numeric value.
	ColorFromPdfObjects(_cagab []_bgd.PdfObject) (PdfColor, error)

	// ColorFromFloats returns a new PdfColor based on input color components for a given PdfColorspace.
	ColorFromFloats(_aaga []float64) (PdfColor, error)

	// DecodeArray returns the Decode array for the PdfColorSpace, i.e. the range of each component.
	DecodeArray() []float64
}

// ToPdfObject implements interface PdfModel.
func (_dgg *PdfActionNamed) ToPdfObject() _bgd.PdfObject {
	_dgg.PdfAction.ToPdfObject()
	_ce := _dgg._fab
	_cgf := _ce.PdfObject.(*_bgd.PdfObjectDictionary)
	_cgf.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeNamed)))
	_cgf.SetIfNotNil("\u004e", _dgg.N)
	return _ce
}

func (_cgcef *PdfWriter) setDocumentIDs(_gbbad, _ffgdg string) {
	_cgcef._beadb = _bgd.MakeArray(_bgd.MakeHexString(_gbbad), _bgd.MakeHexString(_ffgdg))
}

// PdfFunctionType2 defines an exponential interpolation of one input value and n
// output values:
//
//	f(x) = y_0, ..., y_(n-1)
//
// y_j = C0_j + x^N * (C1_j - C0_j); for 0 <= j < n
// When N=1 ; linear interpolation between C0 and C1.
type PdfFunctionType2 struct {
	Domain []float64
	Range  []float64
	C0     []float64
	C1     []float64
	N      float64
	_edeg  *_bgd.PdfIndirectObject
}

// GetShadingByName gets the shading specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_feeba *PdfPageResources) GetShadingByName(keyName _bgd.PdfObjectName) (*PdfShading, bool) {
	if _feeba.Shading == nil {
		return nil, false
	}
	_fedga, _ccca := _bgd.TraceToDirectObject(_feeba.Shading).(*_bgd.PdfObjectDictionary)
	if !_ccca {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0068\u0061d\u0069\u006e\u0067\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _feeba.Shading)
		return nil, false
	}
	if _acgcgb := _fedga.Get(keyName); _acgcgb != nil {
		_bgegb, _faegb := _abbe(_acgcgb)
		if _faegb != nil {
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0073\u0068\u0061\u0064\u0069\u006eg\u003a\u0020\u0025\u0076", _faegb)
			return nil, false
		}
		return _bgegb, true
	}
	return nil, false
}

func (_dbaab *PdfColorspaceICCBased) String() string {
	return "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"
}

// Flags returns the field flags for the field accounting for any inherited flags.
func (_cgeeb *PdfField) Flags() FieldFlag {
	var _fead FieldFlag
	_cafce, _fcefg := _cgeeb.inherit(func(_bfed *PdfField) bool {
		if _bfed.Ff != nil {
			_fead = FieldFlag(*_bfed.Ff)
			return true
		}
		return false
	})
	if _fcefg != nil {
		_fg.Log.Debug("\u0045\u0072\u0072o\u0072\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0069\u006e\u0067\u0020\u0066\u006c\u0061\u0067\u0073\u0020\u0076\u0069\u0061\u0020\u0069\u006e\u0068\u0065\u0072\u0069t\u0061\u006e\u0063\u0065\u003a\u0020\u0025\u0076", _fcefg)
	}
	if !_cafce {
		_fg.Log.Trace("N\u006f\u0020\u0066\u0069\u0065\u006cd\u0020\u0066\u006c\u0061\u0067\u0073 \u0066\u006f\u0075\u006e\u0064\u0020\u002d \u0061\u0073\u0073\u0075\u006d\u0065\u0020\u0063\u006c\u0065a\u0072")
	}
	return _fead
}

// CheckAccessRights checks access rights and permissions for a specified password.  If either user/owner
// password is specified,  full rights are granted, otherwise the access rights are specified by the
// Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_aeaa *PdfReader) CheckAccessRights(password []byte) (bool, _dab.Permissions, error) {
	return _aeaa._ccade.CheckAccessRights(password)
}

const (
	_ PdfOutputIntentType = iota
	PdfOutputIntentTypeA1
	PdfOutputIntentTypeA2
	PdfOutputIntentTypeA3
	PdfOutputIntentTypeA4
	PdfOutputIntentTypeX
)

// IsRadio returns true if the button field represents a radio button, false otherwise.
func (_cbdf *PdfFieldButton) IsRadio() bool { return _cbdf.GetType() == ButtonTypeRadio }

func _egcbe(_dgea _bgd.PdfObject) (*PdfFontDescriptor, error) {
	_fffbc := &PdfFontDescriptor{}
	_dgea = _bgd.ResolveReference(_dgea)
	if _bffegf, _ggcg := _dgea.(*_bgd.PdfIndirectObject); _ggcg {
		_fffbc._gfgee = _bffegf
		_dgea = _bffegf.PdfObject
	}
	_ceaeg, _adce := _bgd.GetDict(_dgea)
	if !_adce {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0044\u0065\u0073c\u0072\u0069\u0070\u0074\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _dgea)
		return nil, _bgd.ErrTypeError
	}
	if _ccdg := _ceaeg.Get("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"); _ccdg != nil {
		_fffbc.FontName = _ccdg
	} else {
		_fg.Log.Debug("\u0049n\u0063\u006fm\u0070\u0061\u0074\u0069b\u0069\u006c\u0069t\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u004e\u0061me\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029\u0020\u006di\u0073\u0073i\u006e\u0067")
	}
	_dfagf, _ := _bgd.GetName(_fffbc.FontName)
	if _bgbfd := _ceaeg.Get("\u0054\u0079\u0070\u0065"); _bgbfd != nil {
		_dgbf, _ecccf := _bgbfd.(*_bgd.PdfObjectName)
		if !_ecccf || string(*_dgbf) != "\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072" {
			_fg.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072i\u0070t\u006f\u0072\u0020\u0054y\u0070\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0054\u0029\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _bgbfd, _dfagf, _fffbc.FontName)
		}
	} else {
		_fg.Log.Trace("\u0049\u006ec\u006f\u006d\u0070\u0061\u0074i\u0062\u0069\u006c\u0069\u0074y\u003a\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _dfagf, _fffbc.FontName)
	}
	_fffbc.FontFamily = _ceaeg.Get("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079")
	_fffbc.FontStretch = _ceaeg.Get("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068")
	_fffbc.FontWeight = _ceaeg.Get("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074")
	_fffbc.Flags = _ceaeg.Get("\u0046\u006c\u0061g\u0073")
	_fffbc.FontBBox = _ceaeg.Get("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078")
	_fffbc.ItalicAngle = _ceaeg.Get("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065")
	_fffbc.Ascent = _ceaeg.Get("\u0041\u0073\u0063\u0065\u006e\u0074")
	_fffbc.Descent = _ceaeg.Get("\u0044e\u0073\u0063\u0065\u006e\u0074")
	_fffbc.Leading = _ceaeg.Get("\u004ce\u0061\u0064\u0069\u006e\u0067")
	_fffbc.CapHeight = _ceaeg.Get("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t")
	_fffbc.XHeight = _ceaeg.Get("\u0058H\u0065\u0069\u0067\u0068\u0074")
	_fffbc.StemV = _ceaeg.Get("\u0053\u0074\u0065m\u0056")
	_fffbc.StemH = _ceaeg.Get("\u0053\u0074\u0065m\u0048")
	_fffbc.AvgWidth = _ceaeg.Get("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068")
	_fffbc.MaxWidth = _ceaeg.Get("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068")
	_fffbc.MissingWidth = _ceaeg.Get("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068")
	_fffbc.FontFile = _ceaeg.Get("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065")
	_fffbc.FontFile2 = _ceaeg.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652")
	_fffbc.FontFile3 = _ceaeg.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653")
	_fffbc.CharSet = _ceaeg.Get("\u0043h\u0061\u0072\u0053\u0065\u0074")
	_fffbc.Style = _ceaeg.Get("\u0053\u0074\u0079l\u0065")
	_fffbc.Lang = _ceaeg.Get("\u004c\u0061\u006e\u0067")
	_fffbc.FD = _ceaeg.Get("\u0046\u0044")
	_fffbc.CIDSet = _ceaeg.Get("\u0043\u0049\u0044\u0053\u0065\u0074")
	if _fffbc.Flags != nil {
		if _cdcdf, _acag := _bgd.GetIntVal(_fffbc.Flags); _acag {
			_fffbc._bfgdg = _cdcdf
		}
	}
	if _fffbc.MissingWidth != nil {
		if _gdae, _cabe := _bgd.GetNumberAsFloat(_fffbc.MissingWidth); _cabe == nil {
			_fffbc._aeee = _gdae
		}
	}
	if _fffbc.FontFile != nil {
		_fcag, _aecge := _ageeg(_fffbc.FontFile)
		if _aecge != nil {
			return _fffbc, _aecge
		}
		_fg.Log.Trace("f\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u003d\u0025\u0073", _fcag)
		_fffbc.fontFile = _fcag
	}
	if _fffbc.FontFile2 != nil {
		_aadda, _aecggg := _fe.NewFontFile2FromPdfObject(_fffbc.FontFile2)
		if _aecggg != nil {
			return _fffbc, _aecggg
		}
		_fg.Log.Trace("\u0066\u006f\u006et\u0046\u0069\u006c\u0065\u0032\u003d\u0025\u0073", _aadda.String())
		_fffbc._agdd = &_aadda
	}
	return _fffbc, nil
}

// SetDate sets the `M` field of the signature.
func (_dbdf *PdfSignature) SetDate(date _ge.Time, format string) {
	if format == "" {
		format = "\u0044\u003a\u003200\u0036\u0030\u0031\u0030\u0032\u0031\u0035\u0030\u0034\u0030\u0035\u002d\u0030\u0037\u0027\u0030\u0030\u0027"
	}
	_dbdf.M = _bgd.MakeString(date.Format(format))
}

// ToPdfObject converts the K dictionary to a PDF object.
func (_cdggc *KValue) ToPdfObject() _bgd.PdfObject {
	if _cdggc._fgcbd != nil {
		return _bgd.MakeIndirectObject(_cdggc._fgcbd.ToPdfObject())
	}
	if _cdggc._bcdd != nil {
		return _cdggc._bcdd
	}
	if _cdggc._ecdf != nil {
		return _bgd.MakeInteger(int64(*_cdggc._ecdf))
	}
	return nil
}

// HasPatternByName checks whether a pattern object is defined by the specified keyName.
func (_fafbg *PdfPageResources) HasPatternByName(keyName _bgd.PdfObjectName) bool {
	_, _cafcfe := _fafbg.GetPatternByName(keyName)
	return _cafcfe
}

func (_cbee *PdfAcroForm) fill(_ecdgb FieldValueProvider, _ggcb FieldAppearanceGenerator) error {
	if _cbee == nil {
		return nil
	}
	_cdaag, _gbede := _ecdgb.FieldValues()
	if _gbede != nil {
		return _gbede
	}
	for _, _egfb := range _cbee.AllFields() {
		_fdde := _egfb.PartialName()
		_bfbd, _caegg := _cdaag[_fdde]
		if !_caegg {
			if _bebeb, _fefgd := _egfb.FullName(); _fefgd == nil {
				_bfbd, _caegg = _cdaag[_bebeb]
			}
		}
		if !_caegg {
			_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _fdde)
			continue
		}
		if _bgfba := _afagd(_egfb, _bfbd); _bgfba != nil {
			return _bgfba
		}
		if _ggcb == nil {
			continue
		}
		for _, _aaab := range _egfb.Annotations {
			_bfcf, _bdfbd := _ggcb.GenerateAppearanceDict(_cbee, _egfb, _aaab)
			if _bdfbd != nil {
				return _bdfbd
			}
			_aaab.AP = _bfcf
			_aaab.ToPdfObject()
		}
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_dbbg *PdfAnnotationPrinterMark) ToPdfObject() _bgd.PdfObject {
	_dbbg.PdfAnnotation.ToPdfObject()
	_ggb := _dbbg._eag
	_dcgf := _ggb.PdfObject.(*_bgd.PdfObjectDictionary)
	_dcgf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b"))
	_dcgf.SetIfNotNil("\u004d\u004e", _dbbg.MN)
	return _ggb
}

func (_fafgfa *Names) addEmbeddedFile(_bgec *EmbeddedFile) error {
	if _fafgfa.EmbeddedFiles == nil {
		_fafgfa.EmbeddedFiles = _bgd.MakeDict()
		_fafgfa.EmbeddedFiles.Set("\u004e\u0061\u006de\u0073", _bgd.MakeArray())
	}
	_ebfe := NewPdfFileSpecFromEmbeddedFile(_bgec)
	_ddgdg := _fafgfa.EmbeddedFiles.Get("\u004e\u0061\u006de\u0073")
	_cfgba, _cdfd := _ddgdg.(*_bgd.PdfObjectArray)
	if !_cdfd {
		return _gb.New("\u0049\u006e\u0076\u0061li\u0064\u0020\u004e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	type FileSpecMap struct {
		_fcfgg string
		_gdcef *PdfFilespec
	}
	_ccaad := []FileSpecMap{}
	for _gaded := 0; _gaded < len(_cfgba.Elements()); _gaded += 2 {
		if _gaded%2 == 0 {
			_cgede := _cfgba.Get(_gaded)
			if _cgede != nil {
				_gefc := _cgede.(*_bgd.PdfObjectString)
				_agade := _cfgba.Get(_gaded + 1)
				_bfeac, _cacgd := NewPdfFilespecFromObj(_agade)
				if _cacgd != nil {
					return _cacgd
				}
				_ccaad = append(_ccaad, FileSpecMap{_fcfgg: _gefc.String(), _gdcef: _bfeac})
			}
		}
	}
	_ccaad = append(_ccaad, FileSpecMap{_fcfgg: _bgec.Name, _gdcef: _ebfe})
	_bb.Slice(_ccaad, func(_cadff, _bddf int) bool { return _ccaad[_cadff]._fcfgg < _ccaad[_bddf]._fcfgg })
	_cfgba = _bgd.MakeArray()
	for _, _feaa := range _ccaad {
		_cfgba.Append(_bgd.MakeString(_feaa._fcfgg))
		_cfgba.Append(_feaa._gdcef.ToPdfObject())
	}
	_fafgfa.EmbeddedFiles.Set("\u004e\u0061\u006de\u0073", _cfgba)
	return nil
}

// NewPdfColorDeviceCMYK returns a new CMYK32 color.
func NewPdfColorDeviceCMYK(c, m, y, k float64) *PdfColorDeviceCMYK {
	_fgdd := PdfColorDeviceCMYK{c, m, y, k}
	return &_fgdd
}

// ToPdfObject returns a stream object.
func (_aacecd *XObjectImage) ToPdfObject() _bgd.PdfObject {
	_dbaec := _aacecd._befec
	if _aacecd._fgbcb {
		return _dbaec
	}
	_abggfg := _dbaec.PdfObjectDictionary
	if _aacecd.Filter != nil {
		_abggfg = _aacecd.Filter.MakeStreamDict()
		_dbaec.PdfObjectDictionary = _abggfg
	}
	_abggfg.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_abggfg.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0049\u006d\u0061g\u0065"))
	_abggfg.Set("\u0057\u0069\u0064t\u0068", _bgd.MakeInteger(*(_aacecd.Width)))
	_abggfg.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _bgd.MakeInteger(*(_aacecd.Height)))
	if _aacecd.BitsPerComponent != nil {
		_abggfg.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _bgd.MakeInteger(*(_aacecd.BitsPerComponent)))
	}
	if _aacecd.ColorSpace != nil {
		_abggfg.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _aacecd.ColorSpace.ToPdfObject())
	}
	_abggfg.SetIfNotNil("\u0049\u006e\u0074\u0065\u006e\u0074", _aacecd.Intent)
	_abggfg.SetIfNotNil("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k", _aacecd.ImageMask)
	_abggfg.SetIfNotNil("\u004d\u0061\u0073\u006b", _aacecd.Mask)
	_egcbec := _abggfg.Get("\u0044\u0065\u0063\u006f\u0064\u0065") != nil
	if _aacecd.Decode == nil && _egcbec {
		_abggfg.Remove("\u0044\u0065\u0063\u006f\u0064\u0065")
	} else if _aacecd.Decode != nil {
		_abggfg.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _aacecd.Decode)
	}
	_abggfg.SetIfNotNil("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065", _aacecd.Interpolate)
	_abggfg.SetIfNotNil("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073", _aacecd.Alternatives)
	_abggfg.SetIfNotNil("\u0053\u004d\u0061s\u006b", _aacecd.SMask)
	_abggfg.SetIfNotNil("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061", _aacecd.SMaskInData)
	_abggfg.SetIfNotNil("\u004d\u0061\u0074t\u0065", _aacecd.Matte)
	_abggfg.SetIfNotNil("\u004e\u0061\u006d\u0065", _aacecd.Name)
	_abggfg.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _aacecd.StructParent)
	_abggfg.SetIfNotNil("\u0049\u0044", _aacecd.ID)
	_abggfg.SetIfNotNil("\u004f\u0050\u0049", _aacecd.OPI)
	_abggfg.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _aacecd.Metadata)
	_abggfg.SetIfNotNil("\u004f\u0043", _aacecd.OC)
	_abggfg.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_aacecd.Stream))))
	_dbaec.Stream = _aacecd.Stream
	_aacecd._fgbcb = true
	return _dbaec
}

// GetNumComponents returns the number of color components (3 for RGB).
func (_geab *PdfColorDeviceRGB) GetNumComponents() int { return 3 }

func (_gegee *pdfFontType0) bytesToCharcodes(_dgaeee []byte) ([]_dabf.CharCode, bool) {
	if _gegee._afad == nil {
		return nil, false
	}
	_bbbab, _bcaf := _gegee._afad.BytesToCharcodes(_dgaeee)
	if !_bcaf {
		return nil, false
	}
	_gbefg := make([]_dabf.CharCode, len(_bbbab))
	for _ebcee, _bgdab := range _bbbab {
		_gbefg[_ebcee] = _dabf.CharCode(_bgdab)
	}
	return _gbefg, true
}

// PdfInfo holds document information that will overwrite
// document information global variables defined above.
type PdfInfo struct {
	Title        *_bgd.PdfObjectString
	Author       *_bgd.PdfObjectString
	Subject      *_bgd.PdfObjectString
	Keywords     *_bgd.PdfObjectString
	Creator      *_bgd.PdfObjectString
	Producer     *_bgd.PdfObjectString
	CreationDate *PdfDate
	ModifiedDate *PdfDate
	Trapped      *_bgd.PdfObjectName
	_dfeee       *_bgd.PdfObjectDictionary
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_gbdcg pdfCIDFontType2) GetRuneMetrics(r rune) (_fe.CharMetrics, bool) {
	_egaa, _bbbgf := _gbdcg._gagea[r]
	if !_bbbgf {
		_fggf, _defd := _bgd.GetInt(_gbdcg.DW)
		if !_defd {
			return _fe.CharMetrics{}, false
		}
		_egaa = int(*_fggf)
	}
	return _fe.CharMetrics{Wx: float64(_egaa)}, true
}

// IsFitWindow returns the value of the fitWindow flag.
func (_fgbgb *ViewerPreferences) IsFitWindow() bool {
	if _fgbgb._faccc == nil {
		return false
	}
	return *_fgbgb._faccc
}

// GetContainingPdfObject returns the container of the pattern object (indirect object).
func (_eacbee *PdfPattern) GetContainingPdfObject() _bgd.PdfObject { return _eacbee._eaddb }

// NewPdfFileSpecFromEmbeddedFile construct a new PdfFileSpec that contains an embedded file.
func NewPdfFileSpecFromEmbeddedFile(file *EmbeddedFile) *PdfFilespec {
	_bdcg := &PdfFilespec{}
	_bdcg._bbbfb = _bgd.MakeIndirectObject(_bgd.MakeDict())
	_bdcg.Desc = _bgd.MakeString(file.Description)
	_bdcg.EF = file.ToPdfObject()
	_bdcg.F = _bgd.MakeString(file.Name)
	_bdcg.UF = _bgd.MakeEncodedString(file.Name, true)
	_febf := "U\u006e\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064"
	switch file.Relationship {
	case RelationshipSource:
		_febf = "\u0053\u006f\u0075\u0072\u0063\u0065"
	case RelationshipData:
		_febf = "\u0044\u0061\u0074\u0061"
	case RelationshipAlternative:
		_febf = "A\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065"
	case RelationshipSupplement:
		_febf = "\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074"
	}
	_bdcg.AFRelationship = _bgd.MakeName(_febf)
	return _bdcg
}

// SetXObjectFormByName adds the provided XObjectForm to the page resources.
// The added XObjectForm is identified by the specified name.
func (_fbge *PdfPageResources) SetXObjectFormByName(keyName _bgd.PdfObjectName, xform *XObjectForm) error {
	_gcdegg := xform.ToPdfObject().(*_bgd.PdfObjectStream)
	_dccd := _fbge.SetXObjectByName(keyName, _gcdegg)
	return _dccd
}

func (_aeca *PdfColorspaceLab) String() string { return "\u004c\u0061\u0062" }

// GetType returns the button field type which returns one of the following
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
func (_fbcb *PdfFieldButton) GetType() ButtonType {
	_cbga := ButtonTypeCheckbox
	if _fbcb.Ff != nil {
		if (uint32(*_fbcb.Ff) & FieldFlagPushbutton.Mask()) > 0 {
			_cbga = ButtonTypePush
		} else if (uint32(*_fbcb.Ff) & FieldFlagRadio.Mask()) > 0 {
			_cbga = ButtonTypeRadio
		}
	}
	return _cbga
}

func (_gfaa *PdfReader) newPdfAnnotationPolyLineFromDict(_afde *_bgd.PdfObjectDictionary) (*PdfAnnotationPolyLine, error) {
	_aedb := PdfAnnotationPolyLine{}
	_bcc, _ddc := _gfaa.newPdfAnnotationMarkupFromDict(_afde)
	if _ddc != nil {
		return nil, _ddc
	}
	_aedb.PdfAnnotationMarkup = _bcc
	_aedb.Vertices = _afde.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_aedb.LE = _afde.Get("\u004c\u0045")
	_aedb.BS = _afde.Get("\u0042\u0053")
	_aedb.IC = _afde.Get("\u0049\u0043")
	_aedb.BE = _afde.Get("\u0042\u0045")
	_aedb.IT = _afde.Get("\u0049\u0054")
	_aedb.Measure = _afde.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_aedb, nil
}

// GetPrimitiveFromModel returns the primitive object corresponding to the input `model`.
func (_dbbebe *modelManager) GetPrimitiveFromModel(model PdfModel) _bgd.PdfObject {
	_dbbebe._cegbb.RLock()
	defer _dbbebe._cegbb.RUnlock()
	_aaac, _eacbe := _dbbebe._dagg[model]
	if !_eacbe {
		return nil
	}
	return _aaac
}

func _fdgb(_dcgc _bgd.PdfObject) (*PdfColorspaceCalRGB, error) {
	_bgfc := NewPdfColorspaceCalRGB()
	if _baaa, _fbeaa := _dcgc.(*_bgd.PdfIndirectObject); _fbeaa {
		_bgfc._afdd = _baaa
	}
	_dcgc = _bgd.TraceToDirectObject(_dcgc)
	_edbe, _afdec := _dcgc.(*_bgd.PdfObjectArray)
	if !_afdec {
		return nil, _f.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _edbe.Len() != 2 {
		return nil, _f.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_dcgc = _bgd.TraceToDirectObject(_edbe.Get(0))
	_gfcc, _afdec := _dcgc.(*_bgd.PdfObjectName)
	if !_afdec {
		return nil, _f.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	if *_gfcc != "\u0043\u0061\u006c\u0052\u0047\u0042" {
		return nil, _f.Errorf("\u006e\u006f\u0074 a\u0020\u0043\u0061\u006c\u0052\u0047\u0042\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_dcgc = _bgd.TraceToDirectObject(_edbe.Get(1))
	_aagb, _afdec := _dcgc.(*_bgd.PdfObjectDictionary)
	if !_afdec {
		return nil, _f.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	_dcgc = _aagb.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_dcgc = _bgd.TraceToDirectObject(_dcgc)
	_bde, _afdec := _dcgc.(*_bgd.PdfObjectArray)
	if !_afdec {
		return nil, _f.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050o\u0069\u006e\u0074")
	}
	if _bde.Len() != 3 {
		return nil, _f.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0057h\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bbbf, _dfee := _bde.GetAsFloat64Slice()
	if _dfee != nil {
		return nil, _dfee
	}
	_bgfc.WhitePoint = _bbbf
	_dcgc = _aagb.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _dcgc != nil {
		_dcgc = _bgd.TraceToDirectObject(_dcgc)
		_caab, _eeeb := _dcgc.(*_bgd.PdfObjectArray)
		if !_eeeb {
			return nil, _f.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050o\u0069\u006e\u0074")
		}
		if _caab.Len() != 3 {
			return nil, _f.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0042l\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		_egcd, _efef := _caab.GetAsFloat64Slice()
		if _efef != nil {
			return nil, _efef
		}
		_bgfc.BlackPoint = _egcd
	}
	_dcgc = _aagb.Get("\u0047\u0061\u006dm\u0061")
	if _dcgc != nil {
		_dcgc = _bgd.TraceToDirectObject(_dcgc)
		_bgdbf, _gaaef := _dcgc.(*_bgd.PdfObjectArray)
		if !_gaaef {
			return nil, _f.Errorf("C\u0061\u006c\u0052\u0047B:\u0020I\u006e\u0076\u0061\u006c\u0069d\u0020\u0047\u0061\u006d\u006d\u0061")
		}
		if _bgdbf.Len() != 3 {
			return nil, _f.Errorf("C\u0061\u006c\u0052\u0047\u0042\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0047a\u006d\u006d\u0061 \u0061r\u0072\u0061\u0079")
		}
		_aafcb, _dbcd := _bgdbf.GetAsFloat64Slice()
		if _dbcd != nil {
			return nil, _dbcd
		}
		_bgfc.Gamma = _aafcb
	}
	_dcgc = _aagb.Get("\u004d\u0061\u0074\u0072\u0069\u0078")
	if _dcgc != nil {
		_dcgc = _bgd.TraceToDirectObject(_dcgc)
		_dccgg, _ffea := _dcgc.(*_bgd.PdfObjectArray)
		if !_ffea {
			return nil, _f.Errorf("\u0043\u0061\u006c\u0052GB\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004d\u0061\u0074\u0072i\u0078")
		}
		if _dccgg.Len() != 9 {
			_fg.Log.Error("\u004d\u0061t\u0072\u0069\u0078 \u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073", _dccgg.String())
			return nil, _f.Errorf("\u0043\u0061\u006c\u0052G\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u004da\u0074\u0072\u0069\u0078\u0020\u0061\u0072r\u0061\u0079")
		}
		_aafea, _feea := _dccgg.GetAsFloat64Slice()
		if _feea != nil {
			return nil, _feea
		}
		_bgfc.Matrix = _aafea
	}
	return _bgfc, nil
}

// NewEmbeddedFileFromContent construct a new EmbeddedFile from supplied file content.
func NewEmbeddedFileFromContent(content []byte) (*EmbeddedFile, error) {
	_agef, _cdbad := _gd.Match(content)
	if _cdbad != nil {
		_fg.Log.Debug("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020d\u0065\u0074\u0065\u0063\u0074\u0020\u0066i\u006c\u0065\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0076", _cdbad)
	}
	_dcdfff := _ff.Sum(content)
	_cgfde := &EmbeddedFile{Name: "\u0061\u0074\u0074\u0061\u0063\u0068\u006d\u0065\u006e\u0074", Content: content, FileType: _agef.MIME.Type, Hash: _bf.EncodeToString(_dcdfff[:])}
	return _cgfde, nil
}

func (_eaacc *PdfWriter) setWriter(_gdaaa _ca.Writer) {
	_eaacc._bcfba = _eaacc._dceeb
	_eaacc._ggaff = _a.NewWriter(_gdaaa)
}

// Evaluate runs the function. Input is [x1 x2 x3].
func (_cafaf *PdfFunctionType4) Evaluate(xVec []float64) ([]float64, error) {
	if _cafaf._dbdg == nil {
		_cafaf._dbdg = _af.NewPSExecutor(_cafaf.Program)
	}
	var _ccfae []_af.PSObject
	for _, _bgfec := range xVec {
		_ccfae = append(_ccfae, _af.MakeReal(_bgfec))
	}
	_fecdae, _egdg := _cafaf._dbdg.Execute(_ccfae)
	if _egdg != nil {
		return nil, _egdg
	}
	_fefd, _egdg := _af.PSObjectArrayToFloat64Array(_fecdae)
	if _egdg != nil {
		return nil, _egdg
	}
	return _fefd, nil
}

// B returns the value of the blue component of the color.
func (_efcb *PdfColorDeviceRGB) B() float64 { return _efcb[2] }

func (_bcead *PdfReader) newPdfOutlineItemFromIndirectObject(_bdge *_bgd.PdfIndirectObject) (*PdfOutlineItem, error) {
	_adebc, _ffbbg := _bdge.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_ffbbg {
		return nil, _f.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_dcdb := NewPdfOutlineItem()
	_dgcac := _adebc.Get("\u0054\u0069\u0074l\u0065")
	if _dgcac == nil {
		return nil, _f.Errorf("\u006d\u0069\u0073s\u0069\u006e\u0067\u0020\u0054\u0069\u0074\u006c\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0049\u0074\u0065\u006d\u0020\u0028r\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	_acga, _ddfdb := _bgd.GetString(_dgcac)
	if !_ddfdb {
		return nil, _f.Errorf("\u0074\u0069\u0074le\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0028\u0025\u0054\u0029", _dgcac)
	}
	_dcdb.Title = _acga
	if _gabcd := _adebc.Get("\u0043\u006f\u0075n\u0074"); _gabcd != nil {
		_ffgcf, _bgbgc := _gabcd.(*_bgd.PdfObjectInteger)
		if !_bgbgc {
			return nil, _f.Errorf("\u0063o\u0075\u006e\u0074\u0020n\u006f\u0074\u0020\u0061\u006e \u0069n\u0074e\u0067\u0065\u0072\u0020\u0028\u0025\u0054)", _gabcd)
		}
		_aaabf := int64(*_ffgcf)
		_dcdb.Count = &_aaabf
	}
	if _afgd := _adebc.Get("\u0044\u0065\u0073\u0074"); _afgd != nil {
		_dcdb.Dest = _bgd.ResolveReference(_afgd)
		if !_bcead._ffce {
			_gdbadf := _bcead.traverseObjectData(_dcdb.Dest)
			if _gdbadf != nil {
				return nil, _gdbadf
			}
		}
	}
	if _fdbd := _adebc.Get("\u0041"); _fdbd != nil {
		_dcdb.A = _bgd.ResolveReference(_fdbd)
		if !_bcead._ffce {
			_bgabd := _bcead.traverseObjectData(_dcdb.A)
			if _bgabd != nil {
				return nil, _bgabd
			}
		}
	}
	if _gfafe := _adebc.Get("\u0053\u0045"); _gfafe != nil {
		_dcdb.SE = nil
	}
	if _gafgad := _adebc.Get("\u0043"); _gafgad != nil {
		_dcdb.C = _bgd.ResolveReference(_gafgad)
	}
	if _eeag := _adebc.Get("\u0046"); _eeag != nil {
		_dcdb.F = _bgd.ResolveReference(_eeag)
	}
	return _dcdb, nil
}

func (_cgfg *DSS) generateHashMap(_ecfc []*_bgd.PdfObjectStream) (map[string]*_bgd.PdfObjectStream, error) {
	_gfae := map[string]*_bgd.PdfObjectStream{}
	for _, _fcgb := range _ecfc {
		_bfac, _efad := _bgd.DecodeStream(_fcgb)
		if _efad != nil {
			return nil, _efad
		}
		_bgfed, _efad := _deagf(_bfac)
		if _efad != nil {
			return nil, _efad
		}
		_gfae[string(_bgfed)] = _fcgb
	}
	return _gfae, nil
}

// ToPdfObject implements interface PdfModel.
func (_cgcg *PdfAnnotationWidget) ToPdfObject() _bgd.PdfObject {
	_cgcg.PdfAnnotation.ToPdfObject()
	_efab := _cgcg._eag
	_geccf := _efab.PdfObject.(*_bgd.PdfObjectDictionary)
	if _cgcg._abf {
		return _efab
	}
	_cgcg._abf = true
	_geccf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0057\u0069\u0064\u0067\u0065\u0074"))
	_geccf.SetIfNotNil("\u0048", _cgcg.H)
	_geccf.SetIfNotNil("\u004d\u004b", _cgcg.MK)
	_geccf.SetIfNotNil("\u0041", _cgcg.A)
	_geccf.SetIfNotNil("\u0041\u0041", _cgcg.AA)
	_geccf.SetIfNotNil("\u0042\u0053", _cgcg.BS)
	_bfae := _cgcg.Parent
	if _cgcg._eded != nil {
		if _cgcg._eded._bcgde == _cgcg._eag {
			_cgcg._eded.ToPdfObject()
		}
		_bfae = _cgcg._eded.GetContainingPdfObject()
	}
	if _bfae != _efab {
		_geccf.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _bfae)
	}
	_cgcg._abf = false
	return _efab
}

// SetCatalogViewerPreferences sets the catalog ViewerPreferences dictionary.
func (_gdbff *PdfWriter) SetCatalogViewerPreferences(pref _bgd.PdfObject) error {
	if pref == nil {
		_gdbff._aaea.Remove("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073")
		return nil
	}
	if _acbgf, _bbacd := pref.(*_bgd.PdfObjectReference); _bbacd {
		pref = _acbgf.Resolve()
		if pref == nil {
			_gdbff._aaea.Remove("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073")
			return nil
		}
	}
	if _, _bddgc := pref.(*_bgd.PdfIndirectObject); _bddgc {
		_gdbff.addObject(pref)
	}
	_gdbff._aaea.Set("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073", pref)
	return nil
}

var _ebad = map[string]struct{}{"\u0046\u0054": {}, "\u004b\u0069\u0064\u0073": {}, "\u0054": {}, "\u0054\u0055": {}, "\u0054\u004d": {}, "\u0046\u0066": {}, "\u0056": {}, "\u0044\u0056": {}, "\u0041\u0041": {}, "\u0044\u0041": {}, "\u0051": {}, "\u0044\u0053": {}, "\u0052\u0056": {}}

func (_afddc *PdfAcroForm) signatureFields() []*PdfFieldSignature {
	var _abfc []*PdfFieldSignature
	for _, _fbeaaa := range _afddc.AllFields() {
		switch _effaaf := _fbeaaa.GetContext().(type) {
		case *PdfFieldSignature:
			_afbge := _effaaf
			_abfc = append(_abfc, _afbge)
		}
	}
	return _abfc
}

// AddKChild adds a child K dictionary object.
func (_bafdc *KDict) AddKChild(kChild *KDict) {
	_bafdc._fabbb = append(_bafdc._fabbb, &KValue{_fgcbd: kChild})
}

const (
	ButtonTypeCheckbox ButtonType = iota
	ButtonTypePush     ButtonType = iota
	ButtonTypeRadio    ButtonType = iota
)

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// red, green and blue components of the color. The values of the elements
// should be between 0 and 1.
func (_abecd *PdfColorspaceDeviceRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eafc := vals[0]
	if _eafc < 0.0 || _eafc > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eafc)
		return nil, ErrColorOutOfRange
	}
	_affe := vals[1]
	if _affe < 0.0 || _affe > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eafc)
		return nil, ErrColorOutOfRange
	}
	_gaf := vals[2]
	if _gaf < 0.0 || _gaf > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eafc)
		return nil, ErrColorOutOfRange
	}
	_gggae := NewPdfColorDeviceRGB(_eafc, _affe, _gaf)
	return _gggae, nil
}

// Optimizer is the interface that performs optimization of PDF object structure for output writing.
//
// Optimize receives a slice of input `objects`, performs optimization, including removing, replacing objects and
// output the optimized slice of objects.
type Optimizer interface {
	Optimize(_cdgf []_bgd.PdfObject) ([]_bgd.PdfObject, error)
}

// ColorFromFloats returns a new PdfColor based on input color components.
func (_dadd *PdfColorspaceDeviceN) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != _dadd.GetNumComponents() {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dcff, _gbfb := _dadd.TintTransform.Evaluate(vals)
	if _gbfb != nil {
		return nil, _gbfb
	}
	_gce, _gbfb := _dadd.AlternateSpace.ColorFromFloats(_dcff)
	if _gbfb != nil {
		return nil, _gbfb
	}
	return _gce, nil
}

func _abcee(_efbe *_bgd.PdfObjectDictionary) (*PdfShadingType4, error) {
	_aeefcc := PdfShadingType4{}
	_cfgec := _efbe.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _cfgec == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_dgdcee, _eefad := _cfgec.(*_bgd.PdfObjectInteger)
	if !_eefad {
		_fg.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _cfgec)
		return nil, _bgd.ErrTypeError
	}
	_aeefcc.BitsPerCoordinate = _dgdcee
	_cfgec = _efbe.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _cfgec == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_dgdcee, _eefad = _cfgec.(*_bgd.PdfObjectInteger)
	if !_eefad {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _cfgec)
		return nil, _bgd.ErrTypeError
	}
	_aeefcc.BitsPerComponent = _dgdcee
	_cfgec = _efbe.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _cfgec == nil {
		_fg.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dgdcee, _eefad = _cfgec.(*_bgd.PdfObjectInteger)
	if !_eefad {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _cfgec)
		return nil, _bgd.ErrTypeError
	}
	_aeefcc.BitsPerComponent = _dgdcee
	_cfgec = _efbe.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _cfgec == nil {
		_fg.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_babdc, _eefad := _cfgec.(*_bgd.PdfObjectArray)
	if !_eefad {
		_fg.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cfgec)
		return nil, _bgd.ErrTypeError
	}
	_aeefcc.Decode = _babdc
	_cfgec = _efbe.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _cfgec == nil {
		_fg.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_aeefcc.Function = []PdfFunction{}
	if _edfdd, _abgc := _cfgec.(*_bgd.PdfObjectArray); _abgc {
		for _, _dcfaa := range _edfdd.Elements() {
			_fdgfe, _agfbe := _fbbb(_dcfaa)
			if _agfbe != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _agfbe)
				return nil, _agfbe
			}
			_aeefcc.Function = append(_aeefcc.Function, _fdgfe)
		}
	} else {
		_ddbcd, _egfgd := _fbbb(_cfgec)
		if _egfgd != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _egfgd)
			return nil, _egfgd
		}
		_aeefcc.Function = append(_aeefcc.Function, _ddbcd)
	}
	return &_aeefcc, nil
}

// ToJBIG2Image converts current image to the core.JBIG2Image.
func (_eeddc *Image) ToJBIG2Image() (*_bgd.JBIG2Image, error) {
	_agdb, _aecfb := _eeddc.ToGoImage()
	if _aecfb != nil {
		return nil, _aecfb
	}
	return _bgd.GoImageToJBIG2(_agdb, _bgd.JB2ImageAutoThreshold)
}

func (_bcfd *PdfReader) newPdfActionResetFormFromDict(_edad *_bgd.PdfObjectDictionary) (*PdfActionResetForm, error) {
	return &PdfActionResetForm{Fields: _edad.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _edad.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_aegbc *PdfOutline) ToPdfObject() _bgd.PdfObject {
	_cggbe := _aegbc._edgaf
	_deae := _cggbe.PdfObject.(*_bgd.PdfObjectDictionary)
	_deae.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073"))
	if _aegbc.First != nil {
		_deae.Set("\u0046\u0069\u0072s\u0074", _aegbc.First.ToPdfObject())
	}
	if _aegbc.Last != nil {
		_deae.Set("\u004c\u0061\u0073\u0074", _aegbc.Last.GetContext().GetContainingPdfObject())
	}
	if _aegbc.Parent != nil {
		_deae.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _aegbc.Parent.GetContext().GetContainingPdfObject())
	}
	if _aegbc.Count != nil {
		_deae.Set("\u0043\u006f\u0075n\u0074", _bgd.MakeInteger(*_aegbc.Count))
	}
	return _cggbe
}

// NewPdfActionGoTo3DView returns a new "goTo3DView" action.
func NewPdfActionGoTo3DView() *PdfActionGoTo3DView {
	_cba := NewPdfAction()
	_ggc := &PdfActionGoTo3DView{}
	_ggc.PdfAction = _cba
	_cba.SetContext(_ggc)
	return _ggc
}

// PdfShadingType2 is an Axial shading.
type PdfShadingType2 struct {
	*PdfShading
	Coords   *_bgd.PdfObjectArray
	Domain   *_bgd.PdfObjectArray
	Function []PdfFunction
	Extend   *_bgd.PdfObjectArray
}

// SetNameDictionary sets the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_edfde *PdfWriter) SetNameDictionary(names _bgd.PdfObject) error {
	if names == nil {
		return nil
	}
	_edfde._dcfdfdg = _eddg(names)
	_fg.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u004e\u0061\u006d\u0065\u0073\u002e\u002e\u002e")
	_edfde._aaea.Set("\u004e\u0061\u006de\u0073", names)
	return _edfde.addObjects(names)
}

// ApplyStandard is used to apply changes required on the document to match the rules required by the input standard.
// The writer's content would be changed after all the document parts are already established during the Write method.
// A good example of the StandardApplier could be a PDF/A Profile (i.e.: pdfa.Profile1A). In such a case PdfWriter would
// set up all rules required by that Profile.
func (_agfde *PdfWriter) ApplyStandard(optimizer StandardApplier) { _agfde._egbb = optimizer }

// StructureTagInfo represents a tagged structure in a PDF document that used by Drawable components.
type StructureTagInfo struct {

	// Marked Content ID, if applicable.
	Mcid int64

	// Structure type, a name object identifying the nature of the object and its role within the document.
	StructureType StructureType

	// AnnotObjs is used to reference annotation objects in structure elements
	AnnotObjs []_bgd.PdfObject

	// Whether the component that has StructureTagInfo is tagged for accessibility.
	ApplyTag bool

	// Parent K object for the component structure that also act as a parent node.
	ParentKObj *KDict

	// K object for the component.
	ComponentKObj *KDict
}

// ReaderToWriterOpts options used to generate a PdfWriter.
type ReaderToWriterOpts struct {
	SkipAcroForm          bool
	SkipInfo              bool
	SkipNameDictionary    bool
	SkipNamedDests        bool
	SkipOCProperties      bool
	SkipOutlines          bool
	SkipPageLabels        bool
	SkipRotation          bool
	SkipMetadata          bool
	SkipMarkInfo          bool
	SkipViewerPreferences bool
	SkipLanguage          bool
	PageProcessCallback   PageProcessCallback

	// Deprecated: will be removed in v4. Use PageProcessCallback instead.
	PageCallback PageCallback
}

// Artifact represents a PDF artifact, which is a non-visual element
// that provides additional information about the document structure or content.
type Artifact struct {

	// Type of the artifact.
	Type ArtifactType

	// BBox of the artifact.
	//
	// Optional; required for background artifacts.
	//
	// An array of four numbers in default user space units giving the coordinates
	// of the left, bottom, right, and top edges, respectively, of the artifact’s
	// bounding box (the rectangle that completely encloses its visible extent).
	BBox *PdfRectangle

	// Attached positions for the artifact.
	//
	// Optional; pagination and full-page background artifacts only)
	//
	// An array of name objects containing one to four of the names Top, Bottom, Left, and
	// Right, specifying the edges of the page, if any, to which the artifact is
	// logically attached. Page edges shall be defined by the page’s crop box.
	// The ordering of names within the array is immaterial. Including both Left and Right or both Top and Bottom
	// indicates a full-width or full-height artifact, respectively.
	//
	// Use of this entry for background artifacts shall be limited to full-page artifacts.
	// Background artifacts that are not full-page take their dimensions from their parent structural element.
	AttachPositions []ArtifactAttachPosition

	// Subtype of the artifact, if applicable.
	//
	// The subtype of the artifact. This entry should appear
	// only when the Type entry has a value of Pagination.
	//
	// Several standard values are defined in `model.ArtifactSubtype` type.
	//
	// Additional values may be specified for this entry.
	Subtype string
}

func _bcdcf(_dfagdf _bgd.PdfObject, _gecdb _bgd.PdfObject, _cfbg map[_bgd.PdfObject][]_bgd.PdfObject, _added map[string]_bgd.PdfObject, _ggdbb *[]_bgd.PdfObject) {
	var _cegbcd *_bgd.PdfIndirectObject
	if _ggccb, _ebcc := _bgd.GetIndirect(_dfagdf); _ebcc {
		_cegbcd = _ggccb
		_dfagdf = _ggccb.PdfObject
	}
	switch _ecabf := _dfagdf.(type) {
	case *_bgd.PdfObjectDictionary:
		if _ecabf.Get("\u0053") == nil {
			return
		}
		_ecabf.Set("\u0050", _gecdb)
		if _gcbe := _ecabf.Get("\u0050\u0067"); _gcbe != nil {
			if _feeaf, _bacag := _bgd.GetIndirect(_gcbe); _bacag && _feeaf != nil && _feeaf.PdfObject != nil {
				_cfbg[_gcbe] = append(_cfbg[_gcbe], _cegbcd)
			}
		}
		if _cdfca := _ecabf.Get("\u0053"); _cdfca != nil {
			if _bbef, _gagaa := _bgd.GetNameVal(_cdfca); _gagaa {
				if _bbef == string(StructureTypeLink) || _bbef == string(StructureTypeAnnot) {
					if _eefcf := _ecabf.Get("\u004b"); _eefcf != nil {
						if _bcfga, _agcgd := _bgd.GetArray(_eefcf); _agcgd && _bcfga.Len() == 2 {
							_gfbea := false
							_dafec := false
							for _, _egfga := range _bcfga.Elements() {
								if _bbbdg, _afgfe := _bgd.GetDict(_egfga); _afgfe {
									if _, _aegc := _bgd.GetName(_bbbdg.Get("\u0054\u0079\u0070\u0065")); _aegc {
										_dafec = true
									}
								} else if _, _eddaa := _bgd.GetInt(_egfga); _eddaa {
									_gfbea = true
								}
							}
							if _gfbea && _dafec {
								*_ggdbb = append(*_ggdbb, _cegbcd)
							}
						} else if _dgbec, _gddacf := _bgd.GetDict(_eefcf); _gddacf {
							if _, _fbbbd := _bgd.GetName(_dgbec.Get("\u0054\u0079\u0070\u0065")); _fbbbd {
								*_ggdbb = append(*_ggdbb, _cegbcd)
							}
						}
					}
				}
			}
		}
		if _gggff := _ecabf.Get("\u0049\u0044"); _gggff != nil {
			_added[_gggff.String()] = _dfagdf
		}
		if _dbaea := _ecabf.Get("\u004b"); _dbaea != nil {
			_bcdcf(_dbaea, _cegbcd, _cfbg, _added, _ggdbb)
		}
	case *_bgd.PdfObjectArray:
		for _, _cefdc := range _ecabf.Elements() {
			_bcdcf(_cefdc, _gecdb, _cfbg, _added, _ggdbb)
		}
	default:
	}
}

// ColorFromPdfObjects loads the color from PDF objects.
// The first objects (if present) represent the color in underlying colorspace.  The last one represents
// the name of the pattern.
func (_bdac *PdfColorspaceSpecialPattern) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) < 1 {
		return nil, _gb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072\u0073")
	}
	_eaab := &PdfColorPattern{}
	_ddde, _dcab := objects[len(objects)-1].(*_bgd.PdfObjectName)
	if !_dcab {
		_fg.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020a\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", objects[len(objects)-1])
		return nil, ErrTypeCheck
	}
	_eaab.PatternName = *_ddde
	if len(objects) > 1 {
		_aced := objects[0 : len(objects)-1]
		if _bdac.UnderlyingCS == nil {
			_fg.Log.Debug("P\u0061\u0074t\u0065\u0072\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0077\u0069\u0074\u0068\u0020\u0064\u0065\u0066\u0069\u006ee\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u0020\u0062\u0075\u0074\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0063\u0073\u0020\u006d\u0069\u0073\u0073\u0069n\u0067")
			return nil, _gb.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
		}
		_ceedg, _cdfgg := _bdac.UnderlyingCS.ColorFromPdfObjects(_aced)
		if _cdfgg != nil {
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0076\u0069\u0061\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079\u0069\u006e\u0067\u0020\u0063\u0073\u003a\u0020\u0025\u0076", _cdfgg)
			return nil, _cdfgg
		}
		_eaab.Color = _ceedg
	}
	return _eaab, nil
}

var _ pdfFont = (*pdfCIDFontType0)(nil)

// NewPdfAnnotationSquare returns a new square annotation.
func NewPdfAnnotationSquare() *PdfAnnotationSquare {
	_aafc := NewPdfAnnotation()
	_ffgg := &PdfAnnotationSquare{}
	_ffgg.PdfAnnotation = _aafc
	_ffgg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_aafc.SetContext(_ffgg)
	return _ffgg
}

func (_caff *Image) samplesTrimPadding(_eada []uint32) []uint32 {
	_gecdg := _caff.ColorComponents * int(_caff.Width) * int(_caff.Height)
	if len(_eada) == _gecdg {
		return _eada
	}
	_cbfga := make([]uint32, _gecdg)
	_ffae := int(_caff.Width) * _caff.ColorComponents
	var _fbfd, _afefd, _bgbad, _egca int
	_ggba := _daf.BytesPerLine(int(_caff.Width), int(_caff.BitsPerComponent), _caff.ColorComponents)
	for _fbfd = 0; _fbfd < int(_caff.Height); _fbfd++ {
		_afefd = _fbfd * int(_caff.Width)
		_bgbad = _fbfd * _ggba
		for _egca = 0; _egca < _ffae; _egca++ {
			_cbfga[_afefd+_egca] = _eada[_bgbad+_egca]
		}
	}
	return _cbfga
}

// PdfColorspaceCalRGB stores A, B, C components
type PdfColorspaceCalRGB struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      []float64
	Matrix     []float64
	_fggg      *_bgd.PdfObjectDictionary
	_afdd      *_bgd.PdfIndirectObject
}

// DecodeArray returns the component range values for the Separation colorspace.
func (_eagfb *PdfColorspaceSpecialSeparation) DecodeArray() []float64 { return []float64{0, 1.0} }

// NewPdfShadingPatternType3 creates an empty shading pattern type 3 object.
func NewPdfShadingPatternType3() *PdfShadingPatternType3 {
	_dcgeg := &PdfShadingPatternType3{}
	_dcgeg.Matrix = _bgd.MakeArrayFromIntegers([]int{1, 0, 0, 1, 0, 0})
	_dcgeg.PdfPattern = &PdfPattern{}
	_dcgeg.PdfPattern.PatternType = int64(*_bgd.MakeInteger(2))
	_dcgeg.PdfPattern._ggafd = _dcgeg
	_dcgeg.PdfPattern._eaddb = _bgd.MakeIndirectObject(_bgd.MakeDict())
	return _dcgeg
}

// GetContainingPdfObject returns the page as a dictionary within an PdfIndirectObject.
func (_ageb *PdfPage) GetContainingPdfObject() _bgd.PdfObject { return _ageb._bbgfg }

type pdfSignDictionary struct {
	*_bgd.PdfObjectDictionary
	_bcdbef *SignatureHandler
	_egebe  *PdfSignature
	_becbf  int64
	_gcgged int
	_feefb  int
	_bdbga  int
	_gfagd  int
}

// NewDSS returns a new DSS dictionary.
func NewDSS() *DSS {
	return &DSS{_bdbe: _bgd.MakeIndirectObject(_bgd.MakeDict()), VRI: map[string]*VRI{}}
}

// NewPdfFieldSignature returns an initialized signature field.
func NewPdfFieldSignature(signature *PdfSignature) *PdfFieldSignature {
	_aaff := &PdfFieldSignature{}
	_aaff.PdfField = NewPdfField()
	_aaff.SetContext(_aaff)
	_aaff.PdfAnnotationWidget = NewPdfAnnotationWidget()
	_aaff.PdfAnnotationWidget.SetContext(_aaff)
	_aaff.PdfAnnotationWidget._eag = _aaff._bcgde
	_aaff.T = _bgd.MakeString("")
	_aaff.F = _bgd.MakeInteger(132)
	_aaff.V = signature
	return _aaff
}

// ToPdfObject implements interface PdfModel.
func (_bbc *PdfActionMovie) ToPdfObject() _bgd.PdfObject {
	_bbc.PdfAction.ToPdfObject()
	_geg := _bbc._fab
	_fbg := _geg.PdfObject.(*_bgd.PdfObjectDictionary)
	_fbg.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeMovie)))
	_fbg.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e", _bbc.Annotation)
	_fbg.SetIfNotNil("\u0054", _bbc.T)
	_fbg.SetIfNotNil("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn", _bbc.Operation)
	return _geg
}

// Write writes out the PDF.
func (_afegb *PdfWriter) Write(writer _ca.Writer) error {
	_fg.Log.Trace("\u0057r\u0069\u0074\u0065\u0028\u0029")
	if _fgcfd, _fcbd := writer.(*_gc.File); _fcbd {
		_afegb.SetFileName(_fgcfd.Name())
	}
	_bbgff := _afegb.checkLicense()
	if _bbgff != nil {
		return _bbgff
	}
	if _bbgff = _afegb.writeOutlines(); _bbgff != nil {
		return _bbgff
	}
	if _bbgff = _afegb.writeAcroFormFields(); _bbgff != nil {
		return _bbgff
	}
	if _bbgff = _afegb.writeNamesDictionary(); _bbgff != nil {
		return _bbgff
	}
	_afegb.checkPendingObjects()
	if _bbgff = _afegb.writeOutputIntents(); _bbgff != nil {
		return _bbgff
	}
	_afegb.setCatalogVersion()
	_afegb.copyObjects()
	if _bbgff = _afegb.optimize(); _bbgff != nil {
		return _bbgff
	}
	if _bbgff = _afegb.optimizeDocument(); _bbgff != nil {
		return _bbgff
	}
	var _egaed _d.Hash
	if _afegb._gdgceg {
		_egaed = _ff.New()
		writer = _ca.MultiWriter(_egaed, writer)
	}
	_afegb.setWriter(writer)
	_ddbec := _afegb.checkCrossReferenceStream()
	_egbgc, _ddbec := _afegb.mapObjectStreams(_ddbec)
	_afegb.adjustXRefAffectedVersion(_ddbec)
	_afegb.writeDocumentVersion()
	_afegb.updateObjectNumbers()
	_afegb.writeObjects()
	if _bbgff = _afegb.writeObjectsInStreams(_egbgc); _bbgff != nil {
		return _bbgff
	}
	_dbagg := _afegb._bcfba
	var _dcbaa int
	for _dafcg := range _afegb._bdfbdd {
		if _dafcg > _dcbaa {
			_dcbaa = _dafcg
		}
	}
	if _afegb._gdgceg {
		if _bbgff = _afegb.setHashIDs(_egaed); _bbgff != nil {
			return _bbgff
		}
	}
	if _ddbec {
		if _bbgff = _afegb.writeXRefStreams(_dcbaa, _dbagg); _bbgff != nil {
			return _bbgff
		}
	} else {
		_afegb.writeTrailer(_dcbaa)
	}
	_afegb.makeOffSetReference(_dbagg)
	if _bbgff = _afegb.flushWriter(); _bbgff != nil {
		return _bbgff
	}
	return nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_cgdcgg *PdfShadingType5) ToPdfObject() _bgd.PdfObject {
	_cgdcgg.PdfShading.ToPdfObject()
	_affd, _afga := _cgdcgg.getShadingDict()
	if _afga != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _cgdcgg.BitsPerCoordinate != nil {
		_affd.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _cgdcgg.BitsPerCoordinate)
	}
	if _cgdcgg.BitsPerComponent != nil {
		_affd.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _cgdcgg.BitsPerComponent)
	}
	if _cgdcgg.VerticesPerRow != nil {
		_affd.Set("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077", _cgdcgg.VerticesPerRow)
	}
	if _cgdcgg.Decode != nil {
		_affd.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _cgdcgg.Decode)
	}
	if _cgdcgg.Function != nil {
		if len(_cgdcgg.Function) == 1 {
			_affd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _cgdcgg.Function[0].ToPdfObject())
		} else {
			_aeebe := _bgd.MakeArray()
			for _, _fecef := range _cgdcgg.Function {
				_aeebe.Append(_fecef.ToPdfObject())
			}
			_affd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _aeebe)
		}
	}
	return _cgdcgg._gccfe
}

// PdfAnnotationUnderline represents Underline annotations.
// (Section 12.5.6.10).
type PdfAnnotationUnderline struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _bgd.PdfObject
}

var (
	ArtifactTypeNone       ArtifactType = ""
	ArtifactTypePagination ArtifactType = "\u0050\u0061\u0067\u0069\u006e\u0061\u0074\u0069\u006f\u006e"
	ArtifactTypeLayout     ArtifactType = "\u004c\u0061\u0079\u006f\u0075\u0074"
	ArtifactTypePage       ArtifactType = "\u0050\u0061\u0067\u0065"
	ArtifactTypeBackground ArtifactType = "\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064"
)

const (
	NonFullScreenPageModeUseNone     NonFullScreenPageMode = "\u0055s\u0065\u004e\u006f\u006e\u0065"
	NonFullScreenPageModeUseOutlines NonFullScreenPageMode = "U\u0073\u0065\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073"
	NonFullScreenPageModeUseThumbs   NonFullScreenPageMode = "\u0055s\u0065\u0054\u0068\u0075\u006d\u0062s"
	NonFullScreenPageModeUseOC       NonFullScreenPageMode = "\u0055\u0073\u0065O\u0043"
	DirectionL2R                     Direction             = "\u004c\u0032\u0052"
	DirectionR2L                     Direction             = "\u0052\u0032\u004c"
	PageBoundaryMediaBox             PageBoundary          = "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"
	PageBoundaryCropBox              PageBoundary          = "\u0043r\u006f\u0070\u0042\u006f\u0078"
	PageBoundaryBleedBox             PageBoundary          = "\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078"
	PageBoundaryTrimBox              PageBoundary          = "\u0054r\u0069\u006d\u0042\u006f\u0078"
	PageBoundaryArtBox               PageBoundary          = "\u0041\u0072\u0074\u0042\u006f\u0078"
	PrintScalingNone                 PrintScaling          = "\u004e\u006f\u006e\u0065"
	PrintScalingAppDefault           PrintScaling          = "\u0041\u0070\u0070\u0044\u0065\u0066\u0061\u0075\u006c\u0074"
	DuplexNone                       Duplex                = "\u006e\u006f\u006e\u0065"
	DuplexSimplex                    Duplex                = "\u0053i\u006d\u0070\u006c\u0065\u0078"
	DuplexFlipShortEdge              Duplex                = "\u0044\u0075\u0070\u006cex\u0046\u006c\u0069\u0070\u0053\u0068\u006f\u0072\u0074\u0045\u0064\u0067\u0065"
	DuplexFlipLongEdge               Duplex                = "\u0044u\u0070l\u0065\u0078\u0046\u006c\u0069p\u004c\u006fn\u0067\u0045\u0064\u0067\u0065"
)

func (_cceb *PdfReader) loadAnnotations(_bbcce _bgd.PdfObject) ([]*PdfAnnotation, error) {
	_bbbfgd, _fadd := _bgd.GetArray(_bbcce)
	if !_fadd {
		return nil, _f.Errorf("\u0041\u006e\u006e\u006fts\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	var _fccd []*PdfAnnotation
	for _, _bfabd := range _bbbfgd.Elements() {
		_bfabd = _bgd.ResolveReference(_bfabd)
		if _, _adcac := _bfabd.(*_bgd.PdfObjectNull); _adcac {
			continue
		}
		_ddbgab, _bdfa := _bfabd.(*_bgd.PdfObjectDictionary)
		_bggec, _eedea := _bfabd.(*_bgd.PdfIndirectObject)
		if _bdfa {
			_bggec = &_bgd.PdfIndirectObject{}
			_bggec.PdfObject = _ddbgab
		} else {
			if !_eedea {
				return nil, _f.Errorf("\u0061\u006eno\u0074\u0061\u0074i\u006f\u006e\u0020\u006eot \u0069n \u0061\u006e\u0020\u0069\u006e\u0064\u0069re\u0063\u0074\u0020\u006f\u0062\u006a\u0065c\u0074")
			}
		}
		_gefdg, _ecdcg := _cceb.newPdfAnnotationFromIndirectObject(_bggec)
		if _ecdcg != nil {
			return nil, _ecdcg
		}
		switch _gdgcb := _gefdg.GetContext().(type) {
		case *PdfAnnotationWidget:
			for _, _eaddd := range _cceb.AcroForm.AllFields() {
				if _eaddd._bcgde == _gdgcb.Parent {
					_gdgcb._eded = _eaddd
					break
				}
			}
		}
		if _gefdg != nil {
			_fccd = append(_fccd, _gefdg)
		}
	}
	return _fccd, nil
}

func _ccaa(_bbadb *fontCommon) *pdfFontSimple { return &pdfFontSimple{fontCommon: *_bbadb} }

func _aegbe(_gbfgf *PdfField, _cbggg _bgd.PdfObject) {
	for _, _cgfad := range _gbfgf.Annotations {
		_cgfad.AS = _cbggg
		_cgfad.ToPdfObject()
	}
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// A, B and C components of the color. The values of the elements should be
// between 0 and 1.
func (_fggd *PdfColorspaceCalRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dafaa := vals[0]
	if _dafaa < 0.0 || _dafaa > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _dafaa)
		return nil, ErrColorOutOfRange
	}
	_gdgef := vals[1]
	if _gdgef < 0.0 || _gdgef > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _gdgef)
		return nil, ErrColorOutOfRange
	}
	_afcbf := vals[2]
	if _afcbf < 0.0 || _afcbf > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _afcbf)
		return nil, ErrColorOutOfRange
	}
	_gbcb := NewPdfColorCalRGB(_dafaa, _gdgef, _afcbf)
	return _gbcb, nil
}

// Height returns the height of `rect`.
func (_fceea *PdfRectangle) Height() float64 { return _da.Abs(_fceea.Ury - _fceea.Lly) }

// NewEmbeddedFile constructs a new EmbeddedFile object from supplied file.
// The file type of the file would be detected automatically.
func NewEmbeddedFile(path string) (*EmbeddedFile, error) {
	_bbgbg, _deac := _gc.ReadFile(path)
	if _deac != nil {
		return nil, _deac
	}
	_dcbde, _deac := _gd.Match(_bbgbg)
	if _deac != nil {
		_fg.Log.Debug("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020d\u0065\u0074\u0065\u0063\u0074\u0020\u0066i\u006c\u0065\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0076", _deac)
	}
	_aagaa := _ff.Sum(_bbgbg)
	_cadg := &EmbeddedFile{Name: _ee.Base(path), Content: _bbgbg, FileType: _dcbde.MIME.Value, Hash: _bf.EncodeToString(_aagaa[:])}
	return _cadg, nil
}

// NewPdfOutline returns an initialized PdfOutline.
func NewPdfOutline() *PdfOutline {
	_bage := &PdfOutline{_edgaf: _bgd.MakeIndirectObject(_bgd.MakeDict())}
	_bage._bfff = _bage
	return _bage
}

type fontCommon struct {
	_eebe  string
	_gecd  string
	_ggef  string
	_cagce _bgd.PdfObject
	_edab  *_cf.CMap
	_ggde  *PdfFontDescriptor
	_eaaec int64
}

type pdfFont interface {
	_fe.Font

	// ToPdfObject returns a PDF representation of the font and implements interface Model.
	ToPdfObject() _bgd.PdfObject
	getFontDescriptor() *PdfFontDescriptor
	baseFields() *fontCommon
}

// PdfShadingType3 is a Radial shading.
type PdfShadingType3 struct {
	*PdfShading
	Coords   *_bgd.PdfObjectArray
	Domain   *_bgd.PdfObjectArray
	Function []PdfFunction
	Extend   *_bgd.PdfObjectArray
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// component PDF objects.
func (_dceae *PdfColorspaceICCBased) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if _dceae.Alternate == nil {
		if _dceae.N == 1 {
			_aafdg := NewPdfColorspaceDeviceGray()
			return _aafdg.ColorFromPdfObjects(objects)
		} else if _dceae.N == 3 {
			_afda := NewPdfColorspaceDeviceRGB()
			return _afda.ColorFromPdfObjects(objects)
		} else if _dceae.N == 4 {
			_adgd := NewPdfColorspaceDeviceCMYK()
			return _adgd.ColorFromPdfObjects(objects)
		} else {
			return nil, _gb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _dceae.Alternate.ColorFromPdfObjects(objects)
}

func (_bcag *PdfAppender) updateObjectsDeep(_cfeb _bgd.PdfObject, _cgab map[_bgd.PdfObject]struct{}) {
	if _cgab == nil {
		_cgab = map[_bgd.PdfObject]struct{}{}
	}
	if _, _edgf := _cgab[_cfeb]; _edgf || _cfeb == nil {
		return
	}
	_cgab[_cfeb] = struct{}{}
	_bcea := _bgd.ResolveReferencesDeep(_cfeb, _bcag._fdbga)
	if _bcea != nil {
		_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bcea)
	}
	switch _fefe := _cfeb.(type) {
	case *_bgd.PdfIndirectObject:
		switch {
		case _fefe.GetParser() == _bcag._gdf._ccade:
			return
		case _fefe.GetParser() == _bcag.Reader._ccade:
			_fged, _ := _bcag._gdf.GetIndirectObjectByNumber(int(_fefe.ObjectNumber))
			_deeg, _daada := _fged.(*_bgd.PdfIndirectObject)
			if _daada && _deeg != nil {
				_abb := string(_fefe.PdfObject.Write())
				if _deeg.PdfObject != _fefe.PdfObject && string(_deeg.PdfObject.Write()) != _abb {
					if _ef.Contains(_abb, "\u002f\u0053\u0069\u0067") && _ef.Contains(_abb, "\u002f\u0053\u0075\u0062\u0074\u0079\u0070\u0065") {
						return
					}
					_bcag.addNewObject(_cfeb)
					_bcag._baae[_cfeb] = _fefe.ObjectNumber
				}
			}
		default:
			_bcag.addNewObject(_cfeb)
		}
		_bcag.updateObjectsDeep(_fefe.PdfObject, _cgab)
	case *_bgd.PdfObjectArray:
		for _, _fgedd := range _fefe.Elements() {
			_bcag.updateObjectsDeep(_fgedd, _cgab)
		}
	case *_bgd.PdfObjectDictionary:
		for _, _cddba := range _fefe.Keys() {
			_bcag.updateObjectsDeep(_fefe.Get(_cddba), _cgab)
		}
	case *_bgd.PdfObjectStreams:
		if _fefe.GetParser() != _bcag._gdf._ccade {
			for _, _cfbde := range _fefe.Elements() {
				_bcag.updateObjectsDeep(_cfbde, _cgab)
			}
		}
	case *_bgd.PdfObjectStream:
		switch {
		case _fefe.GetParser() == _bcag._gdf._ccade:
			return
		case _fefe.GetParser() == _bcag.Reader._ccade:
			if _dfff, _gecg := _bcag._gdf._ccade.LookupByReference(_fefe.PdfObjectReference); _gecg == nil {
				var _faaa bool
				if _fbecc, _agga := _bgd.GetStream(_dfff); _agga && _ea.Equal(_fbecc.Stream, _fefe.Stream) {
					_faaa = true
				}
				if _ceab, _caeg := _bgd.GetDict(_dfff); _faaa && _caeg {
					_faaa = string(_ceab.Write()) == string(_fefe.PdfObjectDictionary.Write())
				}
				if _faaa {
					return
				}
			}
			if _fefe.ObjectNumber != 0 {
				_bcag._baae[_cfeb] = _fefe.ObjectNumber
			}
		default:
			if _, _ggcdc := _bcag._dgae[_cfeb]; !_ggcdc {
				_bcag.addNewObject(_cfeb)
			}
		}
		_bcag.updateObjectsDeep(_fefe.PdfObjectDictionary, _cgab)
	}
}

// GetStructRoot gets the StructTreeRoot object
func (_ffbbe *PdfPage) GetStructTreeRoot() (*_bgd.PdfObject, bool) {
	_ggaaf, _abbaec := _ffbbe._ccagbb.GetCatalogStructTreeRoot()
	return &_ggaaf, _abbaec
}

// GetXObjectFormByName returns the XObjectForm with the specified name from the
// page resources, if it exists.
func (_gcfbf *PdfPageResources) GetXObjectFormByName(keyName _bgd.PdfObjectName) (*XObjectForm, error) {
	_geeae, _eabf := _gcfbf.GetXObjectByName(keyName)
	if _geeae == nil {
		return nil, nil
	}
	if _eabf != XObjectTypeForm {
		return nil, _gb.New("\u006e\u006f\u0074\u0020\u0061\u0020\u0066\u006f\u0072\u006d")
	}
	_bdggdef, _cfgfgf := NewXObjectFormFromStream(_geeae)
	if _cfgfgf != nil {
		return nil, _cfgfgf
	}
	return _bdggdef, nil
}

// Direction returns the value of the direction.
func (_addee *ViewerPreferences) Direction() Direction { return _addee._fdcge }

// Clear clears flag fl from the flag and returns the resulting flag.
func (_cgdbc FieldFlag) Clear(fl FieldFlag) FieldFlag {
	return FieldFlag(_cgdbc.Mask() &^ fl.Mask())
}

// ToPdfObject implements interface PdfModel.
func (_fffa *PdfAnnotation3D) ToPdfObject() _bgd.PdfObject {
	_fffa.PdfAnnotation.ToPdfObject()
	_deeb := _fffa._eag
	_aggd := _deeb.PdfObject.(*_bgd.PdfObjectDictionary)
	_aggd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0033\u0044"))
	_aggd.SetIfNotNil("\u0033\u0044\u0044", _fffa.T3DD)
	_aggd.SetIfNotNil("\u0033\u0044\u0056", _fffa.T3DV)
	_aggd.SetIfNotNil("\u0033\u0044\u0041", _fffa.T3DA)
	_aggd.SetIfNotNil("\u0033\u0044\u0049", _fffa.T3DI)
	_aggd.SetIfNotNil("\u0033\u0044\u0042", _fffa.T3DB)
	return _deeb
}

func (_gbbag *PdfAcroForm) fillImageWithAppearance(_decbg FieldImageProvider, _egfgf FieldAppearanceGenerator) error {
	if _gbbag == nil {
		return nil
	}
	_daabg, _begdc := _decbg.FieldImageValues()
	if _begdc != nil {
		return _begdc
	}
	for _, _ecgc := range _gbbag.AllFields() {
		_bcgeb := _ecgc.PartialName()
		_geegcb, _fgbgd := _daabg[_bcgeb]
		if !_fgbgd {
			if _ccdee, _cfggdg := _ecgc.FullName(); _cfggdg == nil {
				_geegcb, _fgbgd = _daabg[_ccdee]
			}
		}
		if !_fgbgd {
			_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _bcgeb)
			continue
		}
		switch _fgdde := _ecgc.GetContext().(type) {
		case *PdfFieldButton:
			if _fgdde.IsPush() {
				_fgdde.SetFillImage(_geegcb)
			}
		}
		if _egfgf == nil {
			continue
		}
		for _, _dfgbg := range _ecgc.Annotations {
			_befcf, _ffdge := _egfgf.GenerateAppearanceDict(_gbbag, _ecgc, _dfgbg)
			if _ffdge != nil {
				return _ffdge
			}
			_dfgbg.AP = _befcf
			_dfgbg.ToPdfObject()
		}
	}
	return nil
}

func (_fffdec *PdfPage) generateImage(_dced string, _agfda float64, _abfcg string, _debe _e.Color) ([]byte, error) {
	_dfde, _dceaa, _acfbd, _ := _debe.RGBA()
	_ecgbf := _e.RGBA{uint8(_dfde >> 8), uint8(_dceaa >> 8), uint8(_acfbd >> 8), 255}
	_abfg := _e.RGBA{0xff, 0xff, 0xff, 0x00}
	_bfag, _efde := _fffdec.loadFont(_abfcg)
	if _efde != nil {
		return nil, _efde
	}
	_feccg := _ef.Replace(_dced, "\u0009", "\u0020\u0020\u0020\u0020", -1)
	_ccbb := _ef.Split(_feccg, "\u000a")
	_cgdag := 1.0
	for _, _feaaa := range _ccbb {
		if float64(len(_feaaa))*_agfda > _cgdag {
			_cgdag = float64(len(_feaaa)) * _agfda
		}
	}
	if _cgdag > _fffdec.MediaBox.Width() {
		_cgdag = _fffdec.MediaBox.Width()
	}
	_acba := _fc.NewUniform(_ecgbf)
	_bdagbb := _fc.NewUniform(_abfg)
	_dfaec := _fc.NewRGBA(_fc.Rect(0, 0, int(_cgdag), int(_agfda*1.5*float64(len(_ccbb)))))
	_eb.Draw(_dfaec, _dfaec.Bounds(), _bdagbb, _fc.Pt(0, 0), _eb.Src)
	_deee := _fga.NewContext()
	_deee.SetDPI(72)
	_deee.SetFont(_bfag)
	_deee.SetFontSize(_agfda)
	_deee.SetHinting(_efb.HintingNone)
	_deee.SetClip(_dfaec.Bounds())
	_deee.SetDst(_dfaec)
	_deee.SetSrc(_acba)
	_gcbdb := 50
	_debf := 10 + int(_deee.PointToFixed(_agfda)>>6)
	_degf := _fga.Pt(_gcbdb, _debf)
	for _, _gfdcf := range _ccbb {
		_, _efde = _deee.DrawString(_ef.Replace(_gfdcf, "\u000d", "", -1), _degf)
		if _efde != nil {
			return nil, _efde
		}
		_degf.Y += _deee.PointToFixed(_agfda * 1.5)
	}
	_becbb := new(_ea.Buffer)
	if _ecbfcd := _gf.Encode(_becbb, _dfaec); _ecbfcd != nil {
		return nil, _ecbfcd
	}
	return _becbb.Bytes(), nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_bdda *PdfShadingType7) ToPdfObject() _bgd.PdfObject {
	_bdda.PdfShading.ToPdfObject()
	_becba, _gaacg := _bdda.getShadingDict()
	if _gaacg != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bdda.BitsPerCoordinate != nil {
		_becba.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _bdda.BitsPerCoordinate)
	}
	if _bdda.BitsPerComponent != nil {
		_becba.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _bdda.BitsPerComponent)
	}
	if _bdda.BitsPerFlag != nil {
		_becba.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _bdda.BitsPerFlag)
	}
	if _bdda.Decode != nil {
		_becba.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _bdda.Decode)
	}
	if _bdda.Function != nil {
		if len(_bdda.Function) == 1 {
			_becba.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bdda.Function[0].ToPdfObject())
		} else {
			_fdgbe := _bgd.MakeArray()
			for _, _ccgfe := range _bdda.Function {
				_fdgbe.Append(_ccgfe.ToPdfObject())
			}
			_becba.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fdgbe)
		}
	}
	return _bdda._gccfe
}

func (_bgde *PdfReader) newPdfAnnotationUnderlineFromDict(_ggg *_bgd.PdfObjectDictionary) (*PdfAnnotationUnderline, error) {
	_dedd := PdfAnnotationUnderline{}
	_fbd, _aecd := _bgde.newPdfAnnotationMarkupFromDict(_ggg)
	if _aecd != nil {
		return nil, _aecd
	}
	_dedd.PdfAnnotationMarkup = _fbd
	_dedd.QuadPoints = _ggg.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_dedd, nil
}

// SetPdfAuthor sets the Author attribute of the output PDF.
func SetPdfAuthor(author string) { _adcf.Lock(); defer _adcf.Unlock(); _eadea = author }

// ToPdfObject returns the PDF representation of the function.
func (_dcaca *PdfFunctionType3) ToPdfObject() _bgd.PdfObject {
	_dfcec := _bgd.MakeDict()
	_dfcec.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _bgd.MakeInteger(3))
	_fdfad := &_bgd.PdfObjectArray{}
	for _, _ecbc := range _dcaca.Domain {
		_fdfad.Append(_bgd.MakeFloat(_ecbc))
	}
	_dfcec.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _fdfad)
	if _dcaca.Range != nil {
		_cgfgg := &_bgd.PdfObjectArray{}
		for _, _eaebf := range _dcaca.Range {
			_cgfgg.Append(_bgd.MakeFloat(_eaebf))
		}
		_dfcec.Set("\u0052\u0061\u006eg\u0065", _cgfgg)
	}
	if _dcaca.Functions != nil {
		_fecda := &_bgd.PdfObjectArray{}
		for _, _fddc := range _dcaca.Functions {
			_fecda.Append(_fddc.ToPdfObject())
		}
		_dfcec.Set("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es", _fecda)
	}
	if _dcaca.Bounds != nil {
		_cbdcf := &_bgd.PdfObjectArray{}
		for _, _egcgd := range _dcaca.Bounds {
			_cbdcf.Append(_bgd.MakeFloat(_egcgd))
		}
		_dfcec.Set("\u0042\u006f\u0075\u006e\u0064\u0073", _cbdcf)
	}
	if _dcaca.Encode != nil {
		_abbc := &_bgd.PdfObjectArray{}
		for _, _fdbgc := range _dcaca.Encode {
			_abbc.Append(_bgd.MakeFloat(_fdbgc))
		}
		_dfcec.Set("\u0045\u006e\u0063\u006f\u0064\u0065", _abbc)
	}
	if _dcaca._ccdd != nil {
		_dcaca._ccdd.PdfObject = _dfcec
		return _dcaca._ccdd
	}
	return _dfcec
}

// ToPdfObject implements interface PdfModel.
func (_caa *PdfAnnotationStrikeOut) ToPdfObject() _bgd.PdfObject {
	_caa.PdfAnnotation.ToPdfObject()
	_dcge := _caa._eag
	_cfdg := _dcge.PdfObject.(*_bgd.PdfObjectDictionary)
	_caa.appendToPdfDictionary(_cfdg)
	_cfdg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t"))
	_cfdg.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _caa.QuadPoints)
	return _dcge
}

func (_accff *PdfReader) lookupPageByObject(_dabfe _bgd.PdfObject) (*PdfPage, error) {
	return nil, _gb.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// GetContainingPdfObject returns the container of the resources object (indirect object).
func (_dede *PdfPageResources) GetContainingPdfObject() _bgd.PdfObject { return _dede._bdaf }

// SetColorspaceByName adds the provided colorspace to the page resources.
func (_gfdcc *PdfPageResources) SetColorspaceByName(keyName _bgd.PdfObjectName, cs PdfColorspace) error {
	_ccbae, _ddga := _gfdcc.GetColorspaces()
	if _ddga != nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _ddga)
		return _ddga
	}
	if _ccbae == nil {
		_ccbae = NewPdfPageResourcesColorspaces()
		_gfdcc.SetColorSpace(_ccbae)
	}
	_ccbae.Set(keyName, cs)
	return nil
}

// NewPdfSignatureReferenceDocMDP returns PdfSignatureReference for the transformParams.
func NewPdfSignatureReferenceDocMDP(transformParams *PdfTransformParamsDocMDP) *PdfSignatureReference {
	return &PdfSignatureReference{Type: _bgd.MakeName("\u0053\u0069\u0067\u0052\u0065\u0066"), TransformMethod: _bgd.MakeName("\u0044\u006f\u0063\u004d\u0044\u0050"), TransformParams: transformParams.ToPdfObject()}
}

// SetContentStream updates the content stream with specified encoding.
// If encoding is null, will use the xform.Filter object or Raw encoding if not set.
func (_abdfb *XObjectForm) SetContentStream(content []byte, encoder _bgd.StreamEncoder) error {
	_gccee := content
	if encoder == nil {
		if _abdfb.Filter != nil {
			encoder = _abdfb.Filter
		} else {
			encoder = _bgd.NewRawEncoder()
		}
	}
	_ecaa, _gcdcba := encoder.EncodeBytes(_gccee)
	if _gcdcba != nil {
		return _gcdcba
	}
	_gccee = _ecaa
	_abdfb.Stream = _gccee
	_abdfb.Filter = encoder
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_acd *PdfActionURI) ToPdfObject() _bgd.PdfObject {
	_acd.PdfAction.ToPdfObject()
	_dfba := _acd._fab
	_fce := _dfba.PdfObject.(*_bgd.PdfObjectDictionary)
	_fce.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeURI)))
	_fce.SetIfNotNil("\u0055\u0052\u0049", _acd.URI)
	_fce.SetIfNotNil("\u0049\u0073\u004da\u0070", _acd.IsMap)
	return _dfba
}

// FieldFlag represents form field flags. Some of the flags can apply to all types of fields whereas other
// flags are specific.
type FieldFlag uint32

// ToPdfOutlineItem returns a low level PdfOutlineItem object,
// based on the current instance.
func (_agecb *OutlineItem) ToPdfOutlineItem() (*PdfOutlineItem, int64) {
	_eddae := NewPdfOutlineItem()
	_eddae.Title = _bgd.MakeEncodedString(_agecb.Title, true)
	_eddae.Dest = _agecb.Dest.ToPdfObject()
	var _edabea []*PdfOutlineItem
	var _efccf int64
	var _ffcbc *PdfOutlineItem
	for _, _bbaaa := range _agecb.Entries {
		_agecc, _dabgd := _bbaaa.ToPdfOutlineItem()
		_agecc.Parent = &_eddae.PdfOutlineTreeNode
		if _ffcbc != nil {
			_ffcbc.Next = &_agecc.PdfOutlineTreeNode
			_agecc.Prev = &_ffcbc.PdfOutlineTreeNode
		}
		_edabea = append(_edabea, _agecc)
		_efccf += _dabgd
		_ffcbc = _agecc
	}
	_gegef := len(_edabea)
	_efccf += int64(_gegef)
	if _gegef > 0 {
		_eddae.First = &_edabea[0].PdfOutlineTreeNode
		_eddae.Last = &_edabea[_gegef-1].PdfOutlineTreeNode
		_eddae.Count = &_efccf
	}
	return _eddae, _efccf
}

// AddKDict adds a K dictionary object to the structure tree root.
func (_eafdc *StructTreeRoot) AddKDict(k *KDict) { _eafdc.K = append(_eafdc.K, k) }

// GetCharMetrics returns the char metrics for character code `code`.
func (_defga pdfFontType3) GetCharMetrics(code _dabf.CharCode) (_fe.CharMetrics, bool) {
	if _gdbad, _bddg := _defga._defbd[code]; _bddg {
		return _fe.CharMetrics{Wx: _gdbad}, true
	}
	if _fe.IsStdFont(_fe.StdFontName(_defga._eebe)) {
		return _fe.CharMetrics{Wx: 250}, true
	}
	return _fe.CharMetrics{}, false
}

// NewPdfAnnotationMovie returns a new movie annotation.
func NewPdfAnnotationMovie() *PdfAnnotationMovie {
	_dca := NewPdfAnnotation()
	_bbgb := &PdfAnnotationMovie{}
	_bbgb.PdfAnnotation = _dca
	_dca.SetContext(_bbgb)
	return _bbgb
}

func (_fgdee *PdfWriter) writeNamesDictionary() error {
	if _fgdee._dcfdfdg == nil {
		return nil
	}
	_efddf := _fgdee._dcfdfdg.ToPdfObject()
	_fgdee._aaea.Set("\u004e\u0061\u006de\u0073", _efddf)
	_edbeb := _fgdee.addObjects(_efddf)
	if _edbeb != nil {
		return _edbeb
	}
	return nil
}

// PdfAnnotationStrikeOut represents StrikeOut annotations.
// (Section 12.5.6.10).
type PdfAnnotationStrikeOut struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _bgd.PdfObject
}

// PdfShadingType5 is a Lattice-form Gouraud-shaded triangle mesh.
type PdfShadingType5 struct {
	*PdfShading
	BitsPerCoordinate *_bgd.PdfObjectInteger
	BitsPerComponent  *_bgd.PdfObjectInteger
	VerticesPerRow    *_bgd.PdfObjectInteger
	Decode            *_bgd.PdfObjectArray
	Function          []PdfFunction
}

func (_bbaad *PdfWriter) writeBytes(_fbde []byte) {
	if _bbaad._fgegc != nil {
		return
	}
	_ggbb, _gcce := _bbaad._ggaff.Write(_fbde)
	_bbaad._bcfba += int64(_ggbb)
	_bbaad._fgegc = _gcce
}

// R returns the value of the red component of the color.
func (_dbe *PdfColorDeviceRGB) R() float64 { return _dbe[0] }

// PdfActionGoToE represents a GoToE action.
type PdfActionGoToE struct {
	*PdfAction
	F         *PdfFilespec
	D         _bgd.PdfObject
	NewWindow _bgd.PdfObject
	T         _bgd.PdfObject
}

// Enable LTV enables the specified signature. The signing certificate
// chain is extracted from the signature dictionary. Optionally, additional
// certificates can be specified through the `extraCerts` parameter.
// The LTV client attempts to build the certificate chain up to a trusted root
// by downloading any missing certificates.
func (_gcac *LTV) Enable(sig *PdfSignature, extraCerts []*_cb.Certificate) error {
	if _ddfb := _gcac.validateSig(sig); _ddfb != nil {
		return _ddfb
	}
	_ggebg, _gggag := _gcac.generateVRIKey(sig)
	if _gggag != nil {
		return _gggag
	}
	if _, _cgfae := _gcac._bfafg.VRI[_ggebg]; _cgfae && _gcac.SkipExisting {
		return nil
	}
	_cbgfgb, _gggag := sig.GetCerts()
	if _gggag != nil {
		return _gggag
	}
	return _gcac.enable(_cbgfgb, extraCerts, _ggebg)
}

func (_eecbf fontCommon) asPdfObjectDictionary(_aagag string) *_bgd.PdfObjectDictionary {
	if _aagag != "" && _eecbf._gecd != "" && _aagag != _eecbf._gecd {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061\u0073\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u002e\u0020O\u0076\u0065\u0072\u0072\u0069\u0064\u0069\u006e\u0067\u0020\u0073\u0075\u0062t\u0079\u0070\u0065\u0020\u0074\u006f \u0025\u0023\u0071 \u0025\u0073", _aagag, _eecbf)
	} else if _aagag == "" && _eecbf._gecd == "" {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061s\u0050\u0064\u0066Ob\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074y\u0070\u0065\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _eecbf)
	} else if _eecbf._gecd == "" {
		_eecbf._gecd = _aagag
	}
	_eegfb := _bgd.MakeDict()
	_eegfb.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0046\u006f\u006e\u0074"))
	_eegfb.Set("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074", _bgd.MakeName(_eecbf._eebe))
	_eegfb.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName(_eecbf._gecd))
	if _eecbf._ggde != nil {
		_eegfb.Set("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072", _eecbf._ggde.ToPdfObject())
	}
	if _eecbf._cagce != nil {
		_eegfb.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _eecbf._cagce)
	} else if _eecbf._edab != nil {
		_gafce, _defg := _eecbf._edab.Stream()
		if _defg != nil {
			_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0067\u0065\u0074\u0020C\u004d\u0061\u0070\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0065r\u0072\u003d\u0025\u0076", _defg)
		} else {
			_eegfb.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _gafce)
		}
	}
	return _eegfb
}

// Resample resamples the image data converting from current BitsPerComponent to a target BitsPerComponent
// value.  Sets the image's BitsPerComponent to the target value following resampling.
//
// For example, converting an 8-bit RGB image to 1-bit grayscale (common for scanned images):
//
//	// Convert RGB image to grayscale.
//	rgbColorSpace := pdf.NewPdfColorspaceDeviceRGB()
//	grayImage, err := rgbColorSpace.ImageToGray(rgbImage)
//	if err != nil {
//	  return err
//	}
//	// Resample as 1 bit.
//	grayImage.Resample(1)
func (_dfdf *Image) Resample(targetBitsPerComponent int64) {
	if _dfdf.BitsPerComponent == targetBitsPerComponent {
		return
	}
	_gfgcg := _dfdf.GetSamples()
	if targetBitsPerComponent < _dfdf.BitsPerComponent {
		_adcgc := _dfdf.BitsPerComponent - targetBitsPerComponent
		for _bcgcd := range _gfgcg {
			_gfgcg[_bcgcd] >>= uint(_adcgc)
		}
	} else if targetBitsPerComponent > _dfdf.BitsPerComponent {
		_aedg := targetBitsPerComponent - _dfdf.BitsPerComponent
		for _bgbab := range _gfgcg {
			_gfgcg[_bgbab] <<= uint(_aedg)
		}
	}
	_dfdf.BitsPerComponent = targetBitsPerComponent
	if _dfdf.BitsPerComponent < 8 {
		_dfdf.resampleLowBits(_gfgcg)
		return
	}
	_cdfbc := _daf.BytesPerLine(int(_dfdf.Width), int(_dfdf.BitsPerComponent), _dfdf.ColorComponents)
	_fecdcf := make([]byte, _cdfbc*int(_dfdf.Height))
	var (
		_cgdcge, _bfbff, _dcbgf, _gccb int
		_badaa                         uint32
	)
	for _dcbgf = 0; _dcbgf < int(_dfdf.Height); _dcbgf++ {
		_cgdcge = _dcbgf * _cdfbc
		_bfbff = (_dcbgf+1)*_cdfbc - 1
		_cfdca := _eaa.ResampleUint32(_gfgcg[_cgdcge:_bfbff], int(targetBitsPerComponent), 8)
		for _gccb, _badaa = range _cfdca {
			_fecdcf[_gccb+_cgdcge] = byte(_badaa)
		}
	}
	_dfdf.Data = _fecdcf
}

// SetContext sets the sub annotation (context).
func (_edge *PdfAnnotation) SetContext(ctx PdfModel) { _edge._dabfb = ctx }

func (_fbdb PdfFont) actualFont() pdfFont {
	if _fbdb._cbec == nil {
		_fg.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0061\u0063\u0074\u0075\u0061\u006c\u0046\u006f\u006e\u0074\u002e\u0020\u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c.\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _fbdb)
	}
	return _fbdb._cbec
}

// AddFont adds a font dictionary to the Font resources.
func (_gbcd *PdfPage) AddFont(name _bgd.PdfObjectName, font _bgd.PdfObject) error {
	if _gbcd.Resources == nil {
		_gbcd.Resources = NewPdfPageResources()
	}
	if _gbcd.Resources.Font == nil {
		_gbcd.Resources.Font = _bgd.MakeDict()
	}
	_cabba, _fdgd := _bgd.TraceToDirectObject(_gbcd.Resources.Font).(*_bgd.PdfObjectDictionary)
	if !_fdgd {
		_fg.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u0066\u006f\u006et \u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a \u0025\u0076", _bgd.TraceToDirectObject(_gbcd.Resources.Font))
		return _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cabba.Set(name, font)
	return nil
}

// DecodeArray returns the range of color component values in DeviceGray colorspace.
func (_fdebg *PdfColorspaceDeviceGray) DecodeArray() []float64 { return []float64{0, 1.0} }

func _edbge(_agea _bgd.PdfObject, _dbeg *fontCommon) (*_cf.CMap, error) {
	_debd, _bbfb := _bgd.GetStream(_agea)
	if !_bbfb {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0074\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u0054\u006f\u0043m\u0061\u0070\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0025\u0054\u0029", _agea)
		return nil, _bgd.ErrTypeError
	}
	_aeefc, _gddbd := _bgd.DecodeStream(_debd)
	if _gddbd != nil {
		return nil, _gddbd
	}
	_gaca, _gddbd := _cf.LoadCmapFromData(_aeefc, !_dbeg.isCIDFont())
	if _gddbd != nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u004e\u0075\u006d\u0062\u0065\u0072\u003d\u0025\u0064\u0020\u0065\u0072r=\u0025\u0076", _debd.ObjectNumber, _gddbd)
	}
	return _gaca, _gddbd
}

// NewPdfAnnotationFreeText returns a new free text annotation.
func NewPdfAnnotationFreeText() *PdfAnnotationFreeText {
	_fac := NewPdfAnnotation()
	_bdd := &PdfAnnotationFreeText{}
	_bdd.PdfAnnotation = _fac
	_bdd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fac.SetContext(_bdd)
	return _bdd
}

func _cgdg(_abfcbb *_bgd.PdfObjectArray) (float64, error) {
	_eeaed, _eccgbe := _abfcbb.ToFloat64Array()
	if _eccgbe != nil {
		_fg.Log.Debug("\u0042\u0061\u0064\u0020\u004d\u0061\u0074\u0074\u0065\u0020\u0061\u0072\u0072\u0061\u0079:\u0020m\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _abfcbb, _eccgbe)
	}
	switch len(_eeaed) {
	case 1:
		return _eeaed[0], nil
	case 3:
		_bfaeg := PdfColorspaceDeviceRGB{}
		_fffdb, _cfgfc := _bfaeg.ColorFromFloats(_eeaed)
		if _cfgfc != nil {
			return 0.0, _cfgfc
		}
		return _fffdb.(*PdfColorDeviceRGB).ToGray().Val(), nil
	case 4:
		_egffb := PdfColorspaceDeviceCMYK{}
		_gebag, _ddfddf := _egffb.ColorFromFloats(_eeaed)
		if _ddfddf != nil {
			return 0.0, _ddfddf
		}
		_cacfe, _ddfddf := _egffb.ColorToRGB(_gebag.(*PdfColorDeviceCMYK))
		if _ddfddf != nil {
			return 0.0, _ddfddf
		}
		return _cacfe.(*PdfColorDeviceRGB).ToGray().Val(), nil
	}
	_eccgbe = _gb.New("\u0062a\u0064 \u004d\u0061\u0074\u0074\u0065\u0020\u0063\u006f\u006c\u006f\u0072")
	_fg.Log.Error("\u0074\u006f\u0047ra\u0079\u003a\u0020\u006d\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _abfcbb, _eccgbe)
	return 0.0, _eccgbe
}

// ToPdfObject returns the button field dictionary within an indirect object.
func (_bfaca *PdfFieldButton) ToPdfObject() _bgd.PdfObject {
	_bfaca.PdfField.ToPdfObject()
	_gffcb := _bfaca._bcgde
	_ddbgc := _gffcb.PdfObject.(*_bgd.PdfObjectDictionary)
	_ddbgc.Set("\u0046\u0054", _bgd.MakeName("\u0042\u0074\u006e"))
	if _bfaca.Opt != nil {
		_ddbgc.Set("\u004f\u0070\u0074", _bfaca.Opt)
	}
	return _gffcb
}

// FlattenFields flattens the form fields and annotations for the PDF loaded in `pdf` and makes
// non-editable.
// Looks up all widget annotations corresponding to form fields and flattens them by drawing the content
// through the content stream rather than annotations.
// References to flattened annotations will be removed from Page Annots array. For fields the AcroForm entry
// will be emptied.
// When `allannots` is true, all annotations will be flattened. Keep false if want to keep non-form related
// annotations intact.
// When `appgen` is not nil, it will be used to generate appearance streams for the field annotations.
func (_gebab *PdfReader) FlattenFields(allannots bool, appgen FieldAppearanceGenerator) error {
	return _gebab.flattenFieldsWithOpts(allannots, appgen, nil)
}

// ColorFromFloats returns a new PdfColorDevice based on the input slice of
// color components. The slice should contain four elements representing the
// cyan, magenta, yellow and key components of the color. The values of the
// elements should be between 0 and 1.
func (_eaaf *PdfColorspaceDeviceCMYK) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 4 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_abc := vals[0]
	if _abc < 0.0 || _abc > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _abc)
		return nil, ErrColorOutOfRange
	}
	_cegg := vals[1]
	if _cegg < 0.0 || _cegg > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _cegg)
		return nil, ErrColorOutOfRange
	}
	_ffga := vals[2]
	if _ffga < 0.0 || _ffga > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _ffga)
		return nil, ErrColorOutOfRange
	}
	_bbcf := vals[3]
	if _bbcf < 0.0 || _bbcf > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bbcf)
		return nil, ErrColorOutOfRange
	}
	_dfcb := NewPdfColorDeviceCMYK(_abc, _cegg, _ffga, _bbcf)
	return _dfcb, nil
}

// PdfPage represents a page in a PDF document. (7.7.3.3 - Table 30).
type PdfPage struct {
	Parent               _bgd.PdfObject
	LastModified         *PdfDate
	Resources            *PdfPageResources
	CropBox              *PdfRectangle
	MediaBox             *PdfRectangle
	BleedBox             *PdfRectangle
	TrimBox              *PdfRectangle
	ArtBox               *PdfRectangle
	BoxColorInfo         _bgd.PdfObject
	Contents             _bgd.PdfObject
	Rotate               *int64
	Group                _bgd.PdfObject
	Thumb                _bgd.PdfObject
	B                    _bgd.PdfObject
	Dur                  _bgd.PdfObject
	Trans                _bgd.PdfObject
	AA                   _bgd.PdfObject
	Metadata             _bgd.PdfObject
	PieceInfo            _bgd.PdfObject
	StructParents        _bgd.PdfObject
	ID                   _bgd.PdfObject
	PZ                   _bgd.PdfObject
	SeparationInfo       _bgd.PdfObject
	Tabs                 _bgd.PdfObject
	TemplateInstantiated _bgd.PdfObject
	PresSteps            _bgd.PdfObject
	UserUnit             _bgd.PdfObject
	VP                   _bgd.PdfObject
	Annots               _bgd.PdfObject
	_dffab               []*PdfAnnotation
	_cfdgca              *_bgd.PdfObjectDictionary
	_bbgfg               *_bgd.PdfIndirectObject
	_cdfec               _bgd.PdfObjectDictionary
	_ccagbb              *PdfReader
}

// NewPdfColorCalGray returns a new CalGray color.
func NewPdfColorCalGray(grayVal float64) *PdfColorCalGray {
	_gabff := PdfColorCalGray(grayVal)
	return &_gabff
}

func (_aaee *PdfReader) loadAction(_edfb _bgd.PdfObject) (*PdfAction, error) {
	if _ggaa, _gcg := _bgd.GetIndirect(_edfb); _gcg {
		_cdeg, _bffe := _aaee.newPdfActionFromIndirectObject(_ggaa)
		if _bffe != nil {
			return nil, _bffe
		}
		return _cdeg, nil
	} else if !_bgd.IsNullObject(_edfb) {
		return nil, _gb.New("\u0061\u0063\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074 \u0074\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	return nil, nil
}

// NewPdfAction returns an initialized generic PDF action model.
func NewPdfAction() *PdfAction {
	_bfg := &PdfAction{}
	_bfg._fab = _bgd.MakeIndirectObject(_bgd.MakeDict())
	return _bfg
}

// NewStandardPdfOutputIntent creates a new standard PdfOutputIntent.
func NewStandardPdfOutputIntent(outputCondition, outputConditionIdentifier, registryName string, destOutputProfile []byte, colorComponents int) *PdfOutputIntent {
	return &PdfOutputIntent{Type: "\u004f\u0075\u0074p\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074", OutputCondition: outputCondition, OutputConditionIdentifier: outputConditionIdentifier, RegistryName: registryName, DestOutputProfile: destOutputProfile, ColorComponents: colorComponents, _gfcce: _bgd.MakeDict()}
}

func (_fcgbb *PdfWriter) setHashIDs(_gcddb _d.Hash) error {
	_adeaa := _gcddb.Sum(nil)
	if _fcgbb._fedfb == "" {
		_fcgbb._fedfb = _bf.EncodeToString(_adeaa[:8])
	}
	_fcgbb.setDocumentIDs(_fcgbb._fedfb, _bf.EncodeToString(_adeaa[8:]))
	return nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_gbbe *PdfColorspaceSpecialSeparation) ToPdfObject() _bgd.PdfObject {
	_cdee := _bgd.MakeArray(_bgd.MakeName("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"))
	_cdee.Append(_gbbe.ColorantName)
	_cdee.Append(_gbbe.AlternateSpace.ToPdfObject())
	_cdee.Append(_gbbe.TintTransform.ToPdfObject())
	if _gbbe._gaeb != nil {
		_gbbe._gaeb.PdfObject = _cdee
		return _gbbe._gaeb
	}
	return _cdee
}

// GetXObjectByName gets XObject by name.
func (_aadce *PdfPage) GetXObjectByName(name _bgd.PdfObjectName) (_bgd.PdfObject, bool) {
	_dbfg, _acgge := _aadce.Resources.XObject.(*_bgd.PdfObjectDictionary)
	if !_acgge {
		return nil, false
	}
	if _ddgcab := _dbfg.Get(name); _ddgcab != nil {
		return _ddgcab, true
	}
	return nil, false
}

func _fbbf(_cgae _bgd.PdfObject) (*_bgd.PdfObjectDictionary, *fontCommon, error) {
	_becee := &fontCommon{}
	if _eeacd, _ebbde := _cgae.(*_bgd.PdfIndirectObject); _ebbde {
		_becee._eaaec = _eeacd.ObjectNumber
	}
	_bfcd, _bbagb := _bgd.GetDict(_cgae)
	if !_bbagb {
		_fg.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _cgae)
		return nil, nil, ErrFontNotSupported
	}
	_daceg, _bbagb := _bgd.GetNameVal(_bfcd.Get("\u0054\u0079\u0070\u0065"))
	if !_bbagb {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	if _daceg != "\u0046\u006f\u006e\u0074" {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u0020\u0049\u006e\u0063\u006f\u006d\u0070\u0061t\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u003d\u0025\u0071\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0025\u0071.", _daceg, "\u0046\u006f\u006e\u0074")
		return nil, nil, _bgd.ErrTypeError
	}
	_caggc, _bbagb := _bgd.GetNameVal(_bfcd.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_bbagb {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020F\u006f\u006e\u0074 \u0049\u006e\u0063o\u006d\u0070a\u0074\u0069\u0062\u0069\u006c\u0069t\u0079. \u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	_becee._gecd = _caggc
	_dfbfb, _bbagb := _bgd.GetNameVal(_bfcd.Get("\u004e\u0061\u006d\u0065"))
	if _bbagb {
		_becee._ggef = _dfbfb
	}
	_fbcf := _bfcd.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _fbcf != nil {
		_becee._cagce = _bgd.TraceToDirectObject(_fbcf)
		_efda, _ffcc := _edbge(_becee._cagce, _becee)
		if _ffcc != nil {
			return _bfcd, _becee, _ffcc
		}
		_becee._edab = _efda
	} else if _caggc == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" || _caggc == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_dgeg, _effe := _cf.NewCIDSystemInfo(_bfcd.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
		if _effe != nil {
			return _bfcd, _becee, _effe
		}
		_cdbaa := _f.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0055\u0043\u0053\u0032", _dgeg.Registry, _dgeg.Ordering)
		if _cf.IsPredefinedCMap(_cdbaa) {
			_becee._edab, _effe = _cf.LoadPredefinedCMap(_cdbaa)
			if _effe != nil {
				_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _cdbaa, _effe)
			}
		}
	}
	_cdbdd := _bfcd.Get("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072")
	if _cdbdd != nil {
		_aefa, _bgad := _egcbe(_cdbdd)
		if _bgad != nil {
			_fg.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0042\u0061\u0064\u0020\u0066\u006f\u006et\u0020d\u0065s\u0063r\u0069\u0070\u0074\u006f\u0072\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _bgad)
			return _bfcd, _becee, _bgad
		}
		_becee._ggde = _aefa
	}
	if _caggc != "\u0054\u0079\u0070e\u0033" {
		_ddfc, _aggfb := _bgd.GetNameVal(_bfcd.Get("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074"))
		if !_aggfb {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u006f\u006et\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069t\u0079\u002e\u0020\u0042\u0061se\u0046\u006f\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
			return _bfcd, _becee, ErrRequiredAttributeMissing
		}
		_becee._eebe = _ddfc
	}
	return _bfcd, _becee, nil
}

// ColorToRGB converts a Lab color to an RGB color.
func (_fgcd *PdfColorspaceLab) ColorToRGB(color PdfColor) (PdfColor, error) {
	_abggc := func(_ebga float64) float64 {
		if _ebga >= 6.0/29 {
			return _ebga * _ebga * _ebga
		}
		return 108.0 / 841 * (_ebga - 4.0/29.0)
	}
	_cfed, _dead := color.(*PdfColorLab)
	if !_dead {
		_fg.Log.Debug("\u0069\u006e\u0070\u0075t \u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u006c\u0061\u0062")
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	LStar := _cfed.L()
	AStar := _cfed.A()
	BStar := _cfed.B()
	L := (LStar+16)/116 + AStar/500
	M := (LStar + 16) / 116
	N := (LStar+16)/116 - BStar/200
	X := _fgcd.WhitePoint[0] * _abggc(L)
	Y := _fgcd.WhitePoint[1] * _abggc(M)
	Z := _fgcd.WhitePoint[2] * _abggc(N)
	_dfagbb := 3.240479*X + -1.537150*Y + -0.498535*Z
	_ddbg := -0.969256*X + 1.875992*Y + 0.041556*Z
	_cfdd := 0.055648*X + -0.204043*Y + 1.057311*Z
	_dfagbb = _da.Min(_da.Max(_dfagbb, 0), 1.0)
	_ddbg = _da.Min(_da.Max(_ddbg, 0), 1.0)
	_cfdd = _da.Min(_da.Max(_cfdd, 0), 1.0)
	return NewPdfColorDeviceRGB(_dfagbb, _ddbg, _cfdd), nil
}

// NewStructTreeRoot creates a new structure tree root dictionary.
func NewStructTreeRoot() *StructTreeRoot {
	return &StructTreeRoot{K: []*KDict{}, RoleMap: _bgd.MakeDict(), ParentTreeNextKey: 0}
}

func _edfbb(_bbbg *_bgd.PdfObjectDictionary) (*PdfFieldChoice, error) {
	_adaed := &PdfFieldChoice{}
	_adaed.Opt, _ = _bgd.GetArray(_bbbg.Get("\u004f\u0070\u0074"))
	_adaed.TI, _ = _bgd.GetInt(_bbbg.Get("\u0054\u0049"))
	_adaed.I, _ = _bgd.GetArray(_bbbg.Get("\u0049"))
	return _adaed, nil
}

func (_fedgg *pdfCIDFontType0) baseFields() *fontCommon { return &_fedgg.fontCommon }

var (
	ArtifactSubtypeHeader    ArtifactSubtype = "\u0048\u0065\u0061\u0064\u0065\u0072"
	ArtifactSubtypeFooter    ArtifactSubtype = "\u0046\u006f\u006f\u0074\u0065\u0072"
	ArtifactSubtypeWatermark ArtifactSubtype = "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k"
)

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_bggfd pdfFontType3) GetRuneMetrics(r rune) (_fe.CharMetrics, bool) {
	_abce := _bggfd.Encoder()
	if _abce == nil {
		_fg.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _bggfd)
		return _fe.CharMetrics{}, false
	}
	_aegdf, _eaead := _abce.RuneToCharcode(r)
	if !_eaead {
		if r != ' ' {
			_fg.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _bggfd)
		}
		return _fe.CharMetrics{}, false
	}
	_gfcee, _badcc := _bggfd.GetCharMetrics(_aegdf)
	return _gfcee, _badcc
}

// GetContainingPdfObject returns the container of the shading object (indirect object).
func (_eedcc *PdfShading) GetContainingPdfObject() _bgd.PdfObject { return _eedcc._gccfe }

// ToPdfObject implements interface PdfModel.
func (_dgab *PdfAnnotationSquiggly) ToPdfObject() _bgd.PdfObject {
	_dgab.PdfAnnotation.ToPdfObject()
	_decb := _dgab._eag
	_fgfc := _decb.PdfObject.(*_bgd.PdfObjectDictionary)
	_dgab.appendToPdfDictionary(_fgfc)
	_fgfc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079"))
	_fgfc.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _dgab.QuadPoints)
	return _decb
}

func (_ggga *PdfReader) newPdfAnnotationPopupFromDict(_gadd *_bgd.PdfObjectDictionary) (*PdfAnnotationPopup, error) {
	_abac := PdfAnnotationPopup{}
	_abac.Parent = _gadd.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	_abac.Open = _gadd.Get("\u004f\u0070\u0065\u006e")
	return &_abac, nil
}

// NewXObjectImageFromStream builds the image xobject from a stream object.
// An image dictionary is the dictionary portion of a stream object representing an image XObject.
func NewXObjectImageFromStream(stream *_bgd.PdfObjectStream) (*XObjectImage, error) {
	_fcefa := &XObjectImage{}
	_fcefa._befec = stream
	_aggee := *(stream.PdfObjectDictionary)
	_efbcc, _deabf := _bgd.NewEncoderFromStream(stream)
	if _deabf != nil {
		return nil, _deabf
	}
	_fcefa.Filter = _efbcc
	if _daaf := _bgd.TraceToDirectObject(_aggee.Get("\u0057\u0069\u0064t\u0068")); _daaf != nil {
		_bededc, _bcecda := _daaf.(*_bgd.PdfObjectInteger)
		if !_bcecda {
			return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_afabe := int64(*_bededc)
		_fcefa.Width = &_afabe
	} else {
		return nil, _gb.New("\u0077\u0069\u0064\u0074\u0068\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _agcgb := _bgd.TraceToDirectObject(_aggee.Get("\u0048\u0065\u0069\u0067\u0068\u0074")); _agcgb != nil {
		_gbbfe, _eddac := _agcgb.(*_bgd.PdfObjectInteger)
		if !_eddac {
			return nil, _gb.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_afdgc := int64(*_gbbfe)
		_fcefa.Height = &_afdgc
	} else {
		return nil, _gb.New("\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
	}
	if _gdgbc := _bgd.TraceToDirectObject(_aggee.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")); _gdgbc != nil {
		_efgaag, _ddbdc := NewPdfColorspaceFromPdfObject(_gdgbc)
		if _ddbdc != nil {
			return nil, _ddbdc
		}
		_fcefa.ColorSpace = _efgaag
	} else {
		_fg.Log.Debug("\u0058O\u0062\u006a\u0065c\u0074\u0020\u0049m\u0061ge\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u002d\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067 1\u0020c\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065n\u0074\u0020\u002d\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047r\u0061\u0079")
		_fcefa.ColorSpace = NewPdfColorspaceDeviceGray()
	}
	if _ggced := _bgd.TraceToDirectObject(_aggee.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")); _ggced != nil {
		_aface, _fcbbg := _ggced.(*_bgd.PdfObjectInteger)
		if !_fcbbg {
			return nil, _gb.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_fgfab := int64(*_aface)
		_fcefa.BitsPerComponent = &_fgfab
	}
	_fcefa.Intent = _aggee.Get("\u0049\u006e\u0074\u0065\u006e\u0074")
	_fcefa.ImageMask = _aggee.Get("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k")
	_fcefa.Mask = _aggee.Get("\u004d\u0061\u0073\u006b")
	_fcefa.Decode = _aggee.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	_fcefa.Interpolate = _aggee.Get("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065")
	_fcefa.Alternatives = _aggee.Get("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073")
	_fcefa.SMask = _aggee.Get("\u0053\u004d\u0061s\u006b")
	_fcefa.SMaskInData = _aggee.Get("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061")
	_fcefa.Matte = _aggee.Get("\u004d\u0061\u0074t\u0065")
	_fcefa.Name = _aggee.Get("\u004e\u0061\u006d\u0065")
	_fcefa.StructParent = _aggee.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_fcefa.ID = _aggee.Get("\u0049\u0044")
	_fcefa.OPI = _aggee.Get("\u004f\u0050\u0049")
	_fcefa.Metadata = _aggee.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	_fcefa.OC = _aggee.Get("\u004f\u0043")
	_fcefa.Stream = stream.Stream
	return _fcefa, nil
}

// GetContentStreams returns the content stream as an array of strings.
func (_eafd *PdfPage) GetContentStreams() ([]string, error) {
	_ageg := _eafd.GetContentStreamObjs()
	var _ccbbd []string
	for _, _adfcg := range _ageg {
		_cddeef, _aefbf := _fdccc(_adfcg)
		if _aefbf != nil {
			return nil, _aefbf
		}
		_ccbbd = append(_ccbbd, _cddeef)
	}
	return _ccbbd, nil
}

// ToPdfObject implements interface PdfModel.
func (_gef *PdfAction) ToPdfObject() _bgd.PdfObject {
	_fgd := _gef._fab
	_gg := _fgd.PdfObject.(*_bgd.PdfObjectDictionary)
	_gg.Clear()
	_gg.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0041\u0063\u0074\u0069\u006f\u006e"))
	_gg.SetIfNotNil("\u0053", _gef.S)
	_gg.SetIfNotNil("\u004e\u0065\u0078\u0074", _gef.Next)
	return _fgd
}

// Sign signs a specific page with a digital signature.
// The signature field parameter must have a valid signature dictionary
// specified by its V field.
func (_fcff *PdfAppender) Sign(pageNum int, field *PdfFieldSignature) error {
	if field == nil {
		return _gb.New("\u0073\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 n\u0069\u006c")
	}
	_bdc := field.V
	if _bdc == nil {
		return _gb.New("\u0073\u0069\u0067na\u0074\u0075\u0072\u0065\u0020\u0064\u0069\u0063\u0074i\u006fn\u0061r\u0079 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	_acb := pageNum - 1
	if _acb < 0 || _acb > len(_fcff._ffcf)-1 {
		return _f.Errorf("\u0070\u0061\u0067\u0065\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064", pageNum)
	}
	_dgdf := _fcff.Reader.PageList[_acb]
	field.P = _dgdf.ToPdfObject()
	if field.T == nil || field.T.String() == "" {
		field.T = _bgd.MakeString(_f.Sprintf("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072\u0065\u0020\u0025\u0064", pageNum))
	}
	_dgdf.AddAnnotation(field.PdfAnnotation)
	if _fcff._cabc == _fcff._gdf.AcroForm {
		_fcff._cabc = _fcff.Reader.AcroForm
	}
	_fdca := _fcff._cabc
	if _fdca == nil {
		_fdca = NewPdfAcroForm()
	}
	_fdca.SigFlags = _bgd.MakeInteger(3)
	if _fdca.NeedAppearances != nil {
		_fdca.NeedAppearances = nil
	}
	_dadc := append(_fdca.AllFields(), field.PdfField)
	_fdca.Fields = &_dadc
	_fcff.ReplaceAcroForm(_fdca)
	_fcff.UpdatePage(_dgdf)
	_fcff._ffcf[_acb] = _dgdf
	if _, _babb := field.V.GetDocMDPPermission(); _babb {
		_fcff._gdbgd = NewPermissions(field.V)
	}
	return nil
}

// IsShading specifies if the pattern is a shading pattern.
func (_dfaab *PdfPattern) IsShading() bool { return _dfaab.PatternType == 2 }

// SetPrintScaling sets the value of the printScaling.
func (_gbaag *ViewerPreferences) SetPrintScaling(printScaling PrintScaling) {
	_gbaag._edfcg = printScaling
}

func _bgdf(_bebff _bgd.PdfObject) (*PdfColorspaceDeviceN, error) {
	_gddba := NewPdfColorspaceDeviceN()
	if _fdfd, _deeaf := _bebff.(*_bgd.PdfIndirectObject); _deeaf {
		_gddba._fdec = _fdfd
	}
	_bebff = _bgd.TraceToDirectObject(_bebff)
	_afff, _gecb := _bebff.(*_bgd.PdfObjectArray)
	if !_gecb {
		return nil, _f.Errorf("\u0064\u0065\u0076\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if _afff.Len() != 4 && _afff.Len() != 5 {
		return nil, _f.Errorf("\u0064\u0065\u0076ic\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0049\u006ec\u006fr\u0072e\u0063t\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_bebff = _afff.Get(0)
	_dbggc, _gecb := _bebff.(*_bgd.PdfObjectName)
	if !_gecb {
		return nil, _f.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_dbggc != "\u0044e\u0076\u0069\u0063\u0065\u004e" {
		return nil, _f.Errorf("\u0064\u0065v\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020na\u006d\u0065")
	}
	_bebff = _afff.Get(1)
	_bebff = _bgd.TraceToDirectObject(_bebff)
	_cfbebe, _gecb := _bebff.(*_bgd.PdfObjectArray)
	if !_gecb {
		return nil, _f.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_gddba.ColorantNames = _cfbebe
	_bebff = _afff.Get(2)
	_bded, _gbab := NewPdfColorspaceFromPdfObject(_bebff)
	if _gbab != nil {
		return nil, _gbab
	}
	_gddba.AlternateSpace = _bded
	_geece, _gbab := _fbbb(_afff.Get(3))
	if _gbab != nil {
		return nil, _gbab
	}
	_gddba.TintTransform = _geece
	if _afff.Len() == 5 {
		_eeeed, _fafc := _ebfd(_afff.Get(4))
		if _fafc != nil {
			return nil, _fafc
		}
		_gddba.Attributes = _eeeed
	}
	return _gddba, nil
}

// PdfShadingPatternType3 is shading patterns that will use a Type 3 shading pattern (Radial).
type PdfShadingPatternType3 struct {
	*PdfPattern
	Shading   *PdfShadingType3
	Matrix    *_bgd.PdfObjectArray
	ExtGState _bgd.PdfObject
}

// ImageToGray returns a new grayscale image based on the passed in RGB image.
func (_gebdb *PdfColorspaceDeviceRGB) ImageToGray(img Image) (Image, error) {
	if img.ColorComponents != 3 {
		return img, _gb.New("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0044\u0065\u0076\u0069c\u0065\u0052\u0047\u0042")
	}
	_baga, _gdgd := _daf.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._bdgdb, img._agcea)
	if _gdgd != nil {
		return img, _gdgd
	}
	_adfe, _gdgd := _daf.GrayConverter.Convert(_baga)
	if _gdgd != nil {
		return img, _gdgd
	}
	return _acfa(_adfe.Base()), nil
}

// PdfActionSetOCGState represents a SetOCGState action.
type PdfActionSetOCGState struct {
	*PdfAction
	State      _bgd.PdfObject
	PreserveRB _bgd.PdfObject
}

// NewStructureTagInfo creates a new StructureTagInfo with default values.
func NewStructureTagInfo() *StructureTagInfo {
	return &StructureTagInfo{Mcid: 0, StructureType: StructureTypeUnknown}
}

func (_gad *PdfReader) newPdfActionImportDataFromDict(_ccfg *_bgd.PdfObjectDictionary) (*PdfActionImportData, error) {
	_cea, _gda := _ada(_ccfg.Get("\u0046"))
	if _gda != nil {
		return nil, _gda
	}
	return &PdfActionImportData{F: _cea}, nil
}

// ViewClip returns the value of the viewClip.
func (_ggfadc *ViewerPreferences) ViewClip() PageBoundary { return _ggfadc._bedce }

// GetCatalogLanguage gets catalog Language object.
func (_adfgd *PdfReader) GetCatalogLanguage() (_bgd.PdfObject, bool) {
	if _adfgd._ffabf == nil {
		return nil, false
	}
	_afab := _adfgd._ffabf.Get("\u004c\u0061\u006e\u0067")
	return _afab, _afab != nil
}

func (_baaeb *pdfCIDFontType0) getFontDescriptor() *PdfFontDescriptor { return _baaeb._ggde }

// PdfActionGoTo represents a GoTo action.
type PdfActionGoTo struct {
	*PdfAction
	D _bgd.PdfObject
}

// NewPdfActionThread returns a new "thread" action.
func NewPdfActionThread() *PdfActionThread {
	_bac := NewPdfAction()
	_ggd := &PdfActionThread{}
	_ggd.PdfAction = _bac
	_bac.SetContext(_ggd)
	return _ggd
}

// NewStandard14Font returns the standard 14 font named `basefont` as a *PdfFont, or an error if it
// `basefont` is not one of the standard 14 font names.
func NewStandard14Font(basefont StdFontName) (*PdfFont, error) {
	_bcaad, _beeegd := _eeccg(basefont)
	if _beeegd != nil {
		return nil, _beeegd
	}
	if basefont != SymbolName && basefont != ZapfDingbatsName {
		_bcaad._dcfdfd = _dabf.NewWinAnsiEncoder()
	}
	return &PdfFont{_cbec: &_bcaad}, nil
}

func _accf(_baedd *_bgd.PdfIndirectObject) (*PdfOutline, error) {
	_fgdcb, _agca := _baedd.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_agca {
		return nil, _f.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_aabbb := NewPdfOutline()
	if _gbfcd := _fgdcb.Get("\u0054\u0079\u0070\u0065"); _gbfcd != nil {
		_ebgad, _dagebf := _gbfcd.(*_bgd.PdfObjectName)
		if _dagebf {
			if *_ebgad != "\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073" {
				_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u004f\u0075\u0074l\u0069\u006e\u0065s\u0020(\u0025\u0073\u0029", *_ebgad)
			}
		}
	}
	if _afcfe := _fgdcb.Get("\u0043\u006f\u0075n\u0074"); _afcfe != nil {
		_feeea, _gbgb := _bgd.GetNumberAsInt64(_afcfe)
		if _gbgb != nil {
			return nil, _gbgb
		}
		_aabbb.Count = &_feeea
	}
	return _aabbb, nil
}

// Inspect inspects the object types, subtypes and content in the PDF file returning a map of
// object type to number of instances of each.
func (_adbe *PdfReader) Inspect() (map[string]int, error) { return _adbe._ccade.Inspect() }

// GetOutlineTree returns the outline tree.
func (_cfgab *PdfReader) GetOutlineTree() *PdfOutlineTreeNode { return _cfgab._gfbcg }

// GetAttachedFiles retrieves all the attached files info and content.
func (_edcad *PdfReader) GetAttachedFiles() ([]*EmbeddedFile, error) {
	_gfcbd := []*EmbeddedFile{}
	_bgaf, _daadae := _edcad.GetNameDictionary()
	if _daadae != nil {
		return nil, _daadae
	}
	if _bgaf == nil {
		return _gfcbd, nil
	}
	_ddcc := _eddg(_bgaf)
	if _ddcc.EmbeddedFiles == nil {
		return nil, nil
	}
	_ggfa := _ddcc.EmbeddedFiles.Get("\u004e\u0061\u006de\u0073")
	_bebebe, _bbee := _ggfa.(*_bgd.PdfObjectArray)
	if !_bbee {
		return nil, _gb.New("\u0049\u006e\u0076\u0061li\u0064\u0020\u004e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	for _defe := 1; _defe < len(_bebebe.Elements()); _defe += 2 {
		if _defe%2 != 0 {
			_bggcb := _bebebe.Get(_defe)
			_affa, _badeda := NewPdfFilespecFromObj(_bggcb)
			if _badeda != nil {
				return nil, _badeda
			}
			_gefaa, _badeda := NewEmbeddedFileFromObject(_affa.EF)
			if _badeda != nil {
				return nil, _badeda
			}
			_eafg, _fbfb := _affa.F.(*_bgd.PdfObjectString)
			if _fbfb {
				_gefaa.Name = _eafg.Str()
			}
			_gefaa.Description = string(_affa.Desc.Write())
			_gefaa.Relationship = RelationshipUnspecified
			if _affa.AFRelationship != nil {
				switch string(_affa.AFRelationship.Write()) {
				case "\u0053\u006f\u0075\u0072\u0063\u0065":
					_gefaa.Relationship = RelationshipSource
				case "\u0044\u0061\u0074\u0061":
					_gefaa.Relationship = RelationshipData
				case "A\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065":
					_gefaa.Relationship = RelationshipAlternative
				case "\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074":
					_gefaa.Relationship = RelationshipSupplement
				default:
					_gefaa.Relationship = RelationshipUnspecified
				}
			}
			_gfcbd = append(_gfcbd, _gefaa)
		}
	}
	return _gfcbd, nil
}

// GetDocMDPPermission returns the DocMDP level of the restrictions
func (_dcfef *PdfSignature) GetDocMDPPermission() (_fa.DocMDPPermission, bool) {
	for _, _fadeg := range _dcfef.Reference.Elements() {
		if _gfdac, _gdfga := _bgd.GetDict(_fadeg); _gdfga {
			if _cagfac, _abdda := _bgd.GetNameVal(_gfdac.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064")); _abdda && _cagfac == "\u0044\u006f\u0063\u004d\u0044\u0050" {
				if _aedfe, _cfdcg := _bgd.GetDict(_gfdac.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073")); _cfdcg {
					if P, _adcgd := _bgd.GetIntVal(_aedfe.Get("\u0050")); _adcgd {
						return _fa.DocMDPPermission(P), true
					}
				}
			}
		}
	}
	return 0, false
}

// PdfColorspaceSpecialSeparation is a Separation colorspace.
// At the moment the colour space is set to a Separation space, the conforming reader shall determine whether the
// device has an available colorant (e.g. dye) corresponding to the name of the requested space. If so, the conforming
// reader shall ignore the alternateSpace and tintTransform parameters; subsequent painting operations within the
// space shall apply the designated colorant directly, according to the tint values supplied.
//
// Format: [/Separation name alternateSpace tintTransform]
type PdfColorspaceSpecialSeparation struct {
	ColorantName   *_bgd.PdfObjectName
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	_gaeb          *_bgd.PdfIndirectObject
}

// NewPdfReaderFromFile creates a new PdfReader from the speficied PDF file.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderFromFile(pdfFile string, opts *ReaderOpts) (*PdfReader, *_gc.File, error) {
	const _dgagf = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0046\u0072\u006f\u006dF\u0069\u006c\u0065"
	_ccbcg, _defba := _gc.Open(pdfFile)
	if _defba != nil {
		return nil, nil, _defba
	}
	_cfaed, _defba := _acbcg(_ccbcg, opts, true, _dgagf)
	if _defba != nil {
		_ccbcg.Close()
		return nil, nil, _defba
	}
	_cfaed._babg = pdfFile
	return _cfaed, _ccbcg, nil
}

// GetAsShadingPattern returns a shading pattern. Check with IsShading() prior to using this.
func (_bcfda *PdfPattern) GetAsShadingPattern() *PdfShadingPattern {
	return _bcfda._ggafd.(*PdfShadingPattern)
}

// NewPdfActionHide returns a new "hide" action.
func NewPdfActionHide() *PdfActionHide {
	_dcf := NewPdfAction()
	_fgg := &PdfActionHide{}
	_fgg.PdfAction = _dcf
	_dcf.SetContext(_fgg)
	return _fgg
}

func (_dfccb *pdfFontSimple) addEncoding() error {
	var (
		_fcce  string
		_bdbgg map[_dabf.CharCode]_dabf.GlyphName
		_dfbc  _dabf.SimpleEncoder
	)
	if _dfccb.Encoder() != nil {
		_adfee, _adgdf := _dfccb.Encoder().(_dabf.SimpleEncoder)
		if _adgdf && _adfee != nil {
			_fcce = _adfee.BaseName()
		}
	}
	if _dfccb.Encoding != nil {
		_abggf, _ffeg, _fbaae := _dfccb.getFontEncoding()
		if _fbaae != nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0073\u0065F\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0053u\u0062t\u0079\u0070\u0065\u003d\u0025\u0071\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003d\u0025\u0073 \u0028\u0025\u0054\u0029\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _dfccb._eebe, _dfccb._gecd, _dfccb.Encoding, _dfccb.Encoding, _fbaae)
			return _fbaae
		}
		if _abggf != "" {
			_fcce = _abggf
		}
		_bdbgg = _ffeg
		_dfbc, _fbaae = _dabf.NewSimpleTextEncoder(_fcce, _bdbgg)
		if _fbaae != nil {
			return _fbaae
		}
	}
	if _dfbc == nil {
		_ggceb := _dfccb._ggde
		if _ggceb != nil {
			switch _dfccb._gecd {
			case "\u0054\u0079\u0070e\u0031":
				if _ggceb.fontFile != nil && _ggceb._edef != nil {
					_fg.Log.Debug("\u0055\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006et\u0046\u0069\u006c\u0065")
					_dfbc = _ggceb._edef
				}
			case "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
				if _ggceb._agdd != nil {
					_fg.Log.Debug("\u0055s\u0069n\u0067\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0032")
					_fgdg, _feacf := _ggceb._agdd.MakeEncoder()
					if _feacf == nil {
						_dfbc = _fgdg
					}
					if _dfccb._edab == nil {
						_dfccb._edab = _ggceb._agdd.MakeToUnicode()
					}
				}
			}
		}
	}
	if _dfbc != nil {
		if _bdbgg != nil {
			_fg.Log.Trace("\u0064\u0069\u0066fe\u0072\u0065\u006e\u0063\u0065\u0073\u003d\u0025\u002b\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _bdbgg, _dfccb.baseFields())
			_dfbc = _dabf.ApplyDifferences(_dfbc, _bdbgg)
		}
		_dfccb.SetEncoder(_dfbc)
	}
	return nil
}

// KDict represents a K dictionary object.
type KDict struct {

	// The structure type, a name object identifying the nature of the
	// structure element and its role within the document,
	// such as a chapter, paragraph, or footnote
	S _bgd.PdfObject

	// The structure element that is the immediate parent of this one
	// in the structure hierarchy.
	P _bgd.PdfObject

	// The element identifier, a byte string designating this structure element.
	ID *_bgd.PdfObjectString

	// A page object representing a page on which some or all of the content
	// items designated by the K entry shall be rendered.
	Pg _bgd.PdfObject

	// The children of this structure element.
	K _bgd.PdfObject

	// A single attribute object or array of attribute objects associated
	// with this structure element.
	A _bgd.PdfObject

	// An attribute class name or array of class names associated with
	// this structure element.
	C _bgd.PdfObject

	// The current revision number of this structure element
	R *_bgd.PdfObjectInteger

	// The title of the structure element, a text string representing
	// it in human-readable form.
	T *_bgd.PdfObjectString

	// A language identifier specifying the natural language for all text
	// in the structure element except where overridden by
	// language specifications for nested structure elements or marked content.
	Lang *_bgd.PdfObjectString

	// An alternate description of the structure element and its
	// children in human-readable form, which is useful when extracting
	// the document’s contents in support of accessibility to users with
	// disabilities or for other purposes.
	Alt *_bgd.PdfObjectString

	// The expanded form of an abbreviation.
	E *_bgd.PdfObjectString

	// Text that is an exact replacement for the structure element and its children.
	ActualText *_bgd.PdfObjectString
	_fabbb     []*KValue
	_eddd      int64
	_febg      *PdfRectangle
}

// PdfSignatureReference represents a PDF signature reference dictionary and is used for signing via form signature fields.
// (Section 12.8.1, Table 253 - Entries in a signature reference dictionary p. 469 in PDF32000_2008).
type PdfSignatureReference struct {
	_ceca           *_bgd.PdfObjectDictionary
	Type            *_bgd.PdfObjectName
	TransformMethod *_bgd.PdfObjectName
	TransformParams _bgd.PdfObject
	Data            _bgd.PdfObject
	DigestMethod    *_bgd.PdfObjectName
}

// PdfAnnotationRichMedia represents Rich Media annotations.
type PdfAnnotationRichMedia struct {
	*PdfAnnotation
	RichMediaSettings _bgd.PdfObject
	RichMediaContent  _bgd.PdfObject
}

func (_ccgfg *PdfWriter) flushWriter() error {
	if _ccgfg._fgegc == nil {
		_ccgfg._fgegc = _ccgfg._ggaff.Flush()
	}
	return _ccgfg._fgegc
}

func (_efbbf *PdfReader) buildOutlineTree(_bgecc _bgd.PdfObject, _gfgce *PdfOutlineTreeNode, _gcacc *PdfOutlineTreeNode, _fbdgfa map[_bgd.PdfObject]struct{}) (*PdfOutlineTreeNode, *PdfOutlineTreeNode, error) {
	if _fbdgfa == nil {
		_fbdgfa = map[_bgd.PdfObject]struct{}{}
	}
	_fbdgfa[_bgecc] = struct{}{}
	_eggge, _efaa := _bgecc.(*_bgd.PdfIndirectObject)
	if !_efaa {
		return nil, nil, _f.Errorf("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0063\u006f\u006et\u0061\u0069\u006e\u0065r\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _bgecc)
	}
	_aaaga, _fcbbf := _eggge.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_fcbbf {
		return nil, nil, _gb.New("\u006e\u006f\u0074 a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	_fg.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0074\u0072\u0065\u0065\u003a\u0020d\u0069\u0063\u0074\u003a\u0020\u0025\u0076\u0020\u0028\u0025\u0076\u0029\u0020p\u003a\u0020\u0025\u0070", _aaaga, _eggge, _eggge)
	if _cdfaf := _aaaga.Get("\u0054\u0069\u0074l\u0065"); _cdfaf != nil {
		_eaeae, _egcga := _efbbf.newPdfOutlineItemFromIndirectObject(_eggge)
		if _egcga != nil {
			return nil, nil, _egcga
		}
		_eaeae.Parent = _gfgce
		_eaeae.Prev = _gcacc
		_edcfc := _bgd.ResolveReference(_aaaga.Get("\u0046\u0069\u0072s\u0074"))
		if _, _egcaa := _fbdgfa[_edcfc]; _edcfc != nil && _edcfc != _eggge && !_egcaa {
			if !_bgd.IsNullObject(_edcfc) {
				_fgdbe, _gbde, _aeaff := _efbbf.buildOutlineTree(_edcfc, &_eaeae.PdfOutlineTreeNode, nil, _fbdgfa)
				if _aeaff != nil {
					_fg.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0069\u0074\u0065\u006d\u0020\u0074\u0072\u0065\u0065\u003a \u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020n\u006f\u0064\u0065\u0020\u0063\u0068\u0069\u006c\u0064\u0072\u0065n\u002e", _aeaff)
				} else {
					_eaeae.First = _fgdbe
					_eaeae.Last = _gbde
				}
			}
		}
		_abfeg := _bgd.ResolveReference(_aaaga.Get("\u004e\u0065\u0078\u0074"))
		if _, _bged := _fbdgfa[_abfeg]; _abfeg != nil && _abfeg != _eggge && !_bged {
			if !_bgd.IsNullObject(_abfeg) {
				_acaea, _ebaae, _ccdfa := _efbbf.buildOutlineTree(_abfeg, _gfgce, &_eaeae.PdfOutlineTreeNode, _fbdgfa)
				if _ccdfa != nil {
					_fg.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065\u0020\u0066\u006f\u0072\u0020\u004ee\u0078\u0074\u0020\u006e\u006f\u0064\u0065\u003a\u0020\u0025\u0076\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006e\u006f\u0064e\u002e", _ccdfa)
				} else {
					_eaeae.Next = _acaea
					return &_eaeae.PdfOutlineTreeNode, _ebaae, nil
				}
			}
		}
		return &_eaeae.PdfOutlineTreeNode, &_eaeae.PdfOutlineTreeNode, nil
	}
	_gedbg, _dfffc := _accf(_eggge)
	if _dfffc != nil {
		return nil, nil, _dfffc
	}
	_gedbg.Parent = _gfgce
	if _fdafa := _aaaga.Get("\u0046\u0069\u0072s\u0074"); _fdafa != nil {
		_fdafa = _bgd.ResolveReference(_fdafa)
		if _, _bggca := _fbdgfa[_fdafa]; _fdafa != nil && _fdafa != _eggge && !_bggca {
			_gbebe := _bgd.TraceToDirectObject(_fdafa)
			if _, _ecfe := _gbebe.(*_bgd.PdfObjectNull); !_ecfe && _gbebe != nil {
				_bdbfe, _cbed, _befgf := _efbbf.buildOutlineTree(_fdafa, &_gedbg.PdfOutlineTreeNode, nil, _fbdgfa)
				if _befgf != nil {
					_fg.Log.Debug("\u0044\u0045\u0042\u0055\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020b\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0074\u0072\u0065\u0065\u003a\u0020\u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006e\u006f\u0064\u0065 \u0063\u0068i\u006c\u0064r\u0065n\u002e", _befgf)
				} else {
					_gedbg.First = _bdbfe
					_gedbg.Last = _cbed
				}
			}
		}
	}
	return &_gedbg.PdfOutlineTreeNode, &_gedbg.PdfOutlineTreeNode, nil
}

// AddExtension adds the specified extension to the Extensions dictionary.
// See section 7.1.2 "Extensions Dictionary" (pp. 108-109 PDF32000_2008).
func (_dfbee *PdfWriter) AddExtension(extName, baseVersion string, extLevel int) {
	_cfcac, _defgd := _bgd.GetDict(_dfbee._aaea.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073"))
	if !_defgd {
		_cfcac = _bgd.MakeDict()
		_dfbee._aaea.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073", _cfcac)
	}
	_gggaa, _defgd := _bgd.GetDict(_cfcac.Get(_bgd.PdfObjectName(extName)))
	if !_defgd {
		_gggaa = _bgd.MakeDict()
		_cfcac.Set(_bgd.PdfObjectName(extName), _gggaa)
	}
	if _decf, _ := _bgd.GetNameVal(_gggaa.Get("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e")); _decf != baseVersion {
		_gggaa.Set("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e", _bgd.MakeName(baseVersion))
	}
	if _gdgeb, _ := _bgd.GetIntVal(_gggaa.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c")); _gdgeb != extLevel {
		_gggaa.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c", _bgd.MakeInteger(int64(extLevel)))
	}
}

// IsCID returns true if the underlying font is CID.
func (_aaaf *PdfFont) IsCID() bool { return _aaaf.baseFields().isCIDFont() }

// GetContainingPdfObject returns the container of the PdfAcroForm (indirect object).
func (_fgbd *PdfAcroForm) GetContainingPdfObject() _bgd.PdfObject { return _fgbd._fecg }

func (_bcda *LTV) enable(_afgfb, _aedgf []*_cb.Certificate, _gged string) error {
	_dgfbc, _bbgce, _bdcfg := _bcda.buildCertChain(_afgfb, _aedgf)
	if _bdcfg != nil {
		return _bdcfg
	}
	_dgdce, _bdcfg := _bcda.getCerts(_dgfbc)
	if _bdcfg != nil {
		return _bdcfg
	}
	var _fceec, _ecff [][]byte
	if _bcda.OCSPClient != nil {
		_fceec, _bdcfg = _bcda.getOCSPs(_dgfbc, _bbgce)
		if _bdcfg != nil {
			return _bdcfg
		}
	}
	if _bcda.CRLClient != nil {
		_ecff, _bdcfg = _bcda.getCRLs(_dgfbc)
		if _bdcfg != nil {
			return _bdcfg
		}
	}
	_efgf := _bcda._bfafg
	_bbdfb, _bdcfg := _efgf.AddCerts(_dgdce)
	if _bdcfg != nil {
		return _bdcfg
	}
	_bcece, _bdcfg := _efgf.AddOCSPs(_fceec)
	if _bdcfg != nil {
		return _bdcfg
	}
	_decgb, _bdcfg := _efgf.AddCRLs(_ecff)
	if _bdcfg != nil {
		return _bdcfg
	}
	if _gged != "" {
		_efgf.VRI[_gged] = &VRI{Cert: _bbdfb, OCSP: _bcece, CRL: _decgb}
	}
	_bcda._deefd.SetDSS(_efgf)
	return nil
}

// SetAction sets the PDF action for the annotation link.
func (_efbf *PdfAnnotationLink) SetAction(action *PdfAction) {
	_efbf._ecb = action
	if action == nil {
		_efbf.A = nil
	}
}

// NewPdfColorspaceSpecialIndexed returns a new Indexed color.
func NewPdfColorspaceSpecialIndexed() *PdfColorspaceSpecialIndexed {
	return &PdfColorspaceSpecialIndexed{HiVal: 255}
}

// GetCatalogStructTreeRoot gets the catalog StructTreeRoot object.
func (_dcaaf *PdfReader) GetCatalogStructTreeRoot() (_bgd.PdfObject, bool) {
	_aacf := _bgd.ResolveReference(_dcaaf._ffabf.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074"))
	if _aacf == nil {
		return nil, false
	}
	if !_dcaaf._ffce {
		_fdfdc := _dcaaf.traverseObjectData(_aacf)
		if _fdfdc != nil {
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046a\u0069\u006c\u0065\u0064\u0020t\u006f\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0065\u0020\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006f\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029", _fdfdc)
			return nil, false
		}
	}
	return _aacf, true
}

func _gabcb(_dbbfb _bgd.PdfObject) *IDTree {
	_dbbfb = _bgd.ResolveReference(_dbbfb)
	_adfccg := _bgd.MakeArray()
	_edged := _bgd.MakeArray()
	_begdd := []*IDTree{}
	if _bccdf, _baebb := _bgd.GetDict(_dbbfb); _baebb {
		if _fgeee := _bccdf.Get("\u004e\u0061\u006de\u0073"); _fgeee != nil {
			_fgeee = _bgd.ResolveReference(_fgeee)
			if _fafbd, _afcdd := _bgd.GetArray(_fgeee); _afcdd {
				for _, _ffeca := range _fafbd.Elements() {
					_adfccg.Append(_ffeca)
				}
			}
		}
		if _dfgdcf := _bccdf.Get("\u004c\u0069\u006d\u0069\u0074\u0073"); _dfgdcf != nil {
			_dfgdcf = _bgd.ResolveReference(_dfgdcf)
			if _fffca, _afgfc := _bgd.GetArray(_dfgdcf); _afgfc {
				for _adage := 0; _adage < 2; _adage++ {
					_edged.Append(_fffca.Get(_adage))
				}
			}
		}
		if _dfbe := _bccdf.Get("\u004b\u0069\u0064\u0073"); _dfbe != nil {
			_dfbe = _bgd.ResolveReference(_dfbe)
			if _gdceg, _ddca := _bgd.GetArray(_dfbe); _ddca {
				for _, _cafed := range _gdceg.Elements() {
					_aebee := _gabcb(_cafed)
					_begdd = append(_begdd, _aebee)
				}
			}
		}
	}
	_cbdde := &IDTree{Names: _adfccg, Limits: _edged}
	if len(_begdd) > 0 {
		_cbdde.Kids = _begdd
	}
	return _cbdde
}

// NewOutlineItem returns a new outline item instance.
func NewOutlineItem(title string, dest OutlineDest) *OutlineItem {
	return &OutlineItem{Title: title, Dest: dest}
}

// SignatureHandler interface defines the common functionality for PDF signature handlers, which
// need to be capable of validating digital signatures and signing PDF documents.
type SignatureHandler interface {

	// IsApplicable checks if a given signature dictionary `sig` is applicable for the signature handler.
	// For example a signature of type `adbe.pkcs7.detached` might not fit for a rsa.sha1 handler.
	IsApplicable(_eeddde *PdfSignature) bool

	// Validate validates a PDF signature against a given digest (hash) such as that determined
	// for an input file. Returns validation results.
	Validate(_fegbe *PdfSignature, _bffb Hasher) (SignatureValidationResult, error)

	// InitSignature prepares the signature dictionary for signing. This involves setting all
	// necessary fields, and also allocating sufficient space to the Contents so that the
	// finalized signature can be inserted once the hash is calculated.
	InitSignature(_fabdd *PdfSignature) error

	// NewDigest creates a new digest/hasher based on the signature dictionary and handler.
	NewDigest(_aeaecg *PdfSignature) (Hasher, error)

	// Sign receives the hash `digest` (for example hash of an input file), and signs based
	// on the signature dictionary `sig` and applies the signature data to the signature
	// dictionary Contents field.
	Sign(_faffc *PdfSignature, _aaae Hasher) error
}

var _ddfab = map[string]struct{}{"\u0054\u0069\u0074l\u0065": {}, "\u0041\u0075\u0074\u0068\u006f\u0072": {}, "\u0053u\u0062\u006a\u0065\u0063\u0074": {}, "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073": {}, "\u0043r\u0065\u0061\u0074\u006f\u0072": {}, "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072": {}, "\u0054r\u0061\u0070\u0070\u0065\u0064": {}, "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065": {}, "\u004do\u0064\u0044\u0061\u0074\u0065": {}}

// PdfActionGoToR represents a GoToR action.
type PdfActionGoToR struct {
	*PdfAction
	F         *PdfFilespec
	D         _bgd.PdfObject
	NewWindow _bgd.PdfObject
}

func (_fbdfag *PdfWriter) mapObjectStreams(_efffd bool) (map[_bgd.PdfObject]bool, bool) {
	_deagg := make(map[_bgd.PdfObject]bool)
	for _, _bdcc := range _fbdfag._edcbg {
		if _fegcc, _abacg := _bdcc.(*_bgd.PdfObjectStreams); _abacg {
			_efffd = true
			for _, _fbada := range _fegcc.Elements() {
				_deagg[_fbada] = true
				if _ecdcc, _efcdg := _fbada.(*_bgd.PdfIndirectObject); _efcdg {
					_deagg[_ecdcc.PdfObject] = true
				}
			}
		}
	}
	return _deagg, _efffd
}

// SetRotation sets the rotation of all pages added to writer. The rotation is
// specified in degrees and must be a multiple of 90.
// The Rotate field of individual pages has priority over the global rotation.
func (_edbfe *PdfWriter) SetRotation(rotate int64) error {
	_gccaa, _aeegge := _bgd.GetDict(_edbfe._cfaee)
	if !_aeegge {
		return ErrTypeCheck
	}
	_gccaa.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _bgd.MakeInteger(rotate))
	return nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_edfc *PdfAnnotation) GetContainingPdfObject() _bgd.PdfObject { return _edfc._eag }

// PdfColorspaceDeviceGray represents a grayscale colorspace.
type PdfColorspaceDeviceGray struct{}

// GetPdfInfo returns the PDF info dictionary.
func (_bdgdc *PdfReader) GetPdfInfo() (*PdfInfo, error) {
	_gdcae, _fcdge := _bdgdc.GetTrailer()
	if _fcdge != nil {
		return nil, _fcdge
	}
	var _cdaf *_bgd.PdfObjectDictionary
	_gebdc := _gdcae.Get("\u0049\u006e\u0066\u006f")
	switch _gfcf := _gebdc.(type) {
	case *_bgd.PdfObjectReference:
		_ccacg := _gfcf
		_gebdc, _fcdge = _bdgdc.GetIndirectObjectByNumber(int(_ccacg.ObjectNumber))
		_gebdc = _bgd.TraceToDirectObject(_gebdc)
		if _fcdge != nil {
			return nil, _fcdge
		}
		_cdaf, _ = _gebdc.(*_bgd.PdfObjectDictionary)
	case *_bgd.PdfObjectDictionary:
		_cdaf = _gfcf
	}
	if _cdaf == nil {
		return nil, _gb.New("I\u006e\u0066\u006f\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006eo\u0074\u0020\u0070r\u0065s\u0065\u006e\u0074")
	}
	_edfdc, _fcdge := NewPdfInfoFromObject(_cdaf)
	if _fcdge != nil {
		return nil, _fcdge
	}
	return _edfdc, nil
}

// AllFields returns a flattened list of all fields in the form.
func (_daeedg *PdfAcroForm) AllFields() []*PdfField {
	if _daeedg == nil {
		return nil
	}
	var _ffeae []*PdfField
	if _daeedg.Fields != nil {
		for _, _caag := range *_daeedg.Fields {
			_ffeae = append(_ffeae, _faegc(_caag)...)
		}
	}
	return _ffeae
}

// PdfRectangle is a definition of a rectangle.
type PdfRectangle struct {
	Llx float64
	Lly float64
	Urx float64
	Ury float64
}

func (_cfdgcd *pdfFontType3) baseFields() *fontCommon { return &_cfdgcd.fontCommon }

// ToPdfObject returns the PDF representation of the DSS dictionary.
func (_acefd *DSS) ToPdfObject() _bgd.PdfObject {
	_deefc := _acefd._bdbe.PdfObject.(*_bgd.PdfObjectDictionary)
	_deefc.Clear()
	_aacag := _bgd.MakeDict()
	for _egfc, _bdggd := range _acefd.VRI {
		_aacag.Set(*_bgd.MakeName(_egfc), _bdggd.ToPdfObject())
	}
	_deefc.SetIfNotNil("\u0043\u0065\u0072t\u0073", _befa(_acefd.Certs))
	_deefc.SetIfNotNil("\u004f\u0043\u0053P\u0073", _befa(_acefd.OCSPs))
	_deefc.SetIfNotNil("\u0043\u0052\u004c\u0073", _befa(_acefd.CRLs))
	_deefc.Set("\u0056\u0052\u0049", _aacag)
	return _acefd._bdbe
}

// NewPdfColorspaceICCBased returns a new ICCBased colorspace object.
func NewPdfColorspaceICCBased(N int) (*PdfColorspaceICCBased, error) {
	_geea := &PdfColorspaceICCBased{}
	if N != 1 && N != 3 && N != 4 {
		return nil, _f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u0031/\u0033\u002f\u0034\u0029")
	}
	_geea.N = N
	return _geea, nil
}

// NewPdfActionNamed returns a new "named" action.
func NewPdfActionNamed() *PdfActionNamed {
	_dd := NewPdfAction()
	_ffg := &PdfActionNamed{}
	_ffg.PdfAction = _dd
	_dd.SetContext(_ffg)
	return _ffg
}

func _eeedbe(_deefb string) (map[_dabf.CharCode]_dabf.GlyphName, error) {
	_fbcfe := _ef.Split(_deefb, "\u000a")
	_gfcda := make(map[_dabf.CharCode]_dabf.GlyphName)
	for _, _fdfbd := range _fbcfe {
		_cccf := _bcfaf.FindStringSubmatch(_fdfbd)
		if _cccf == nil {
			continue
		}
		_aacbg, _gbbc := _cccf[1], _cccf[2]
		_ebeb, _feaef := _ae.Atoi(_aacbg)
		if _feaef != nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0042\u0061\u0064\u0020\u0065\u006e\u0063\u006fd\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u002e \u0025\u0071", _fdfbd)
			return nil, _bgd.ErrTypeError
		}
		_gfcda[_dabf.CharCode(_ebeb)] = _dabf.GlyphName(_gbbc)
	}
	_fg.Log.Trace("g\u0065\u0074\u0045\u006e\u0063\u006fd\u0069\u006e\u0067\u0073\u003a\u0020\u006b\u0065\u0079V\u0061\u006c\u0075e\u0073=\u0025\u0023\u0076", _gfcda)
	return _gfcda, nil
}

// PdfFunction interface represents the common methods of a function in PDF.
type PdfFunction interface {
	Evaluate([]float64) ([]float64, error)
	ToPdfObject() _bgd.PdfObject
}

// NewPdfFontFromPdfObject loads a PdfFont from the dictionary `fontObj`.  If there is a problem an
// error is returned.
func NewPdfFontFromPdfObject(fontObj _bgd.PdfObject) (*PdfFont, error) {
	return _eafebe(fontObj, true)
}

func (_cddb *PdfReader) newPdfAnnotationWidgetFromDict(_dafe *_bgd.PdfObjectDictionary) (*PdfAnnotationWidget, error) {
	_adga := PdfAnnotationWidget{}
	_adga.H = _dafe.Get("\u0048")
	_adga.MK = _dafe.Get("\u004d\u004b")
	_adga.A = _dafe.Get("\u0041")
	_adga.AA = _dafe.Get("\u0041\u0041")
	_adga.BS = _dafe.Get("\u0042\u0053")
	_adga.Parent = _dafe.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	return &_adga, nil
}

// G returns the value of the green component of the color.
func (_gdecc *PdfColorDeviceRGB) G() float64 { return _gdecc[1] }

// StructTreeRoot represents the structure tree root dictionary.
// Reference: PDF documentation chapter 14.7 Logical Structure, table 322.
type StructTreeRoot struct {
	K                 []*KDict
	IDTree            *IDTree
	ParentTree        *_bgd.PdfObjectDictionary
	ParentTreeNextKey int64
	RoleMap           _bgd.PdfObject
	ClassMap          *_bgd.PdfObjectDictionary
	_gagf             *_bgd.PdfIndirectObject
	_cfgbd            []_gff.UUID
}

// PdfShading represents a shading dictionary. There are 7 types of shading,
// indicatedby the shading type variable:
// 1: Function-based shading.
// 2: Axial shading.
// 3: Radial shading.
// 4: Free-form Gouraud-shaded triangle mesh.
// 5: Lattice-form Gouraud-shaded triangle mesh.
// 6: Coons patch mesh.
// 7: Tensor-product patch mesh.
// types 4-7 are contained in a stream object, where the dictionary is given by the stream dictionary.
type PdfShading struct {
	ShadingType *_bgd.PdfObjectInteger
	ColorSpace  PdfColorspace
	Background  *_bgd.PdfObjectArray
	BBox        *PdfRectangle
	AntiAlias   *_bgd.PdfObjectBool
	_gggga      PdfModel
	_gccfe      _bgd.PdfObject
}

// GetExtGState gets the ExtGState specified by keyName. Returns a bool
// indicating whether it was found or not.
func (_gcgea *PdfPageResources) GetExtGState(keyName _bgd.PdfObjectName) (_bgd.PdfObject, bool) {
	if _gcgea.ExtGState == nil {
		return nil, false
	}
	_abgdf, _ceefae := _bgd.TraceToDirectObject(_gcgea.ExtGState).(*_bgd.PdfObjectDictionary)
	if !_ceefae {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064 \u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0065\u006e\u0074\u0072\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _gcgea.ExtGState)
		return nil, false
	}
	if _acdaf := _abgdf.Get(keyName); _acdaf != nil {
		return _acdaf, true
	}
	return nil, false
}

// Has checks if flag fl is set in flag and returns true if so, false otherwise.
func (_dbbgg FieldFlag) Has(fl FieldFlag) bool { return (_dbbgg.Mask() & fl.Mask()) > 0 }

// ToPdfObject implements interface PdfModel.
func (_fea *PdfActionHide) ToPdfObject() _bgd.PdfObject {
	_fea.PdfAction.ToPdfObject()
	_fcf := _fea._fab
	_dda := _fcf.PdfObject.(*_bgd.PdfObjectDictionary)
	_dda.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeHide)))
	_dda.SetIfNotNil("\u0054", _fea.T)
	_dda.SetIfNotNil("\u0048", _fea.H)
	return _fcf
}

// ToPdfObject implements interface PdfModel.
func (_acdd *PdfAnnotationSquare) ToPdfObject() _bgd.PdfObject {
	_acdd.PdfAnnotation.ToPdfObject()
	_ged := _acdd._eag
	_bfge := _ged.PdfObject.(*_bgd.PdfObjectDictionary)
	if _acdd.PdfAnnotationMarkup != nil {
		_acdd.appendToPdfDictionary(_bfge)
	}
	_bfge.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0053\u0071\u0075\u0061\u0072\u0065"))
	_bfge.SetIfNotNil("\u0042\u0053", _acdd.BS)
	_bfge.SetIfNotNil("\u0049\u0043", _acdd.IC)
	_bfge.SetIfNotNil("\u0042\u0045", _acdd.BE)
	_bfge.SetIfNotNil("\u0052\u0044", _acdd.RD)
	return _ged
}

// NewPermissions returns a new permissions object.
func NewPermissions(docMdp *PdfSignature) *Permissions {
	_eggga := Permissions{}
	_eggga.DocMDP = docMdp
	_gedabf := _bgd.MakeDict()
	_gedabf.Set("\u0044\u006f\u0063\u004d\u0044\u0050", docMdp.ToPdfObject())
	_eggga._cfgcg = _gedabf
	return &_eggga
}

// PdfActionLaunch represents a launch action.
type PdfActionLaunch struct {
	*PdfAction
	F         *PdfFilespec
	Win       _bgd.PdfObject
	Mac       _bgd.PdfObject
	Unix      _bgd.PdfObject
	NewWindow _bgd.PdfObject
}

func (_agbgg *PdfWriter) writeObject(_dfbdf int, _aacga _bgd.PdfObject) {
	_fg.Log.Trace("\u0057\u0072\u0069\u0074\u0065\u0020\u006f\u0062\u006a \u0023\u0025\u0064\u000a", _dfbdf)
	if _fcfggg, _eceff := _aacga.(*_bgd.PdfIndirectObject); _eceff {
		_agbgg._bdfbdd[_dfbdf] = crossReference{Type: 1, Offset: _agbgg._bcfba, Generation: _fcfggg.GenerationNumber}
		_ggcdf := _f.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _dfbdf)
		if _bdafb, _ddgdga := _fcfggg.PdfObject.(*pdfSignDictionary); _ddgdga {
			_bdafb._becbf = _agbgg._bcfba + int64(len(_ggcdf))
		}
		if _fcfggg.PdfObject == nil {
			_fg.Log.Debug("E\u0072\u0072\u006fr\u003a\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0027\u0073\u0020\u0050\u0064\u0066\u004f\u0062j\u0065\u0063\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020b\u0065\u0020\u006e\u0069l\u0020\u002d\u0020\u0073e\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063t\u004e\u0075\u006c\u006c")
			_fcfggg.PdfObject = _bgd.MakeNull()
		}
		_ggcdf += string(_fcfggg.PdfObject.Write())
		_ggcdf += "\u000a\u0065\u006e\u0064\u006f\u0062\u006a\u000a"
		_agbgg.writeString(_ggcdf)
		return
	}
	if _ebgcag, _bcdbdc := _aacga.(*_bgd.PdfObjectStream); _bcdbdc {
		_agbgg._bdfbdd[_dfbdf] = crossReference{Type: 1, Offset: _agbgg._bcfba, Generation: _ebgcag.GenerationNumber}
		_agbgg.writeString(_f.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _dfbdf))
		_agbgg.writeBytes(_ebgcag.PdfObjectDictionary.Write())
		_agbgg.writeString("\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a")
		if _ebgcag.Lazy {
			_cddbab, _gbdga := _gc.Open(_ebgcag.TempFile)
			if _gbdga != nil {
				_fg.Log.Info("\u0045\u0072\u0072\u006f\u0072\u0020\u0066\u0069\u006e\u0064\u0069\u006e\u0067\u0020\u006ca\u007ay\u0020\u0074\u0065\u006d\u0070\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _ebgcag.TempFile)
				return
			}
			defer _cddbab.Close()
			_beaeg := make([]byte, 64*1024)
			for {
				_cgeeeg, _eebfg := _cddbab.Read(_beaeg)
				if _cgeeeg > 0 {
					_agbgg.writeBytes(_beaeg[:_cgeeeg])
				}
				if _eebfg == _ca.EOF {
					break
				}
				if _eebfg != nil {
					_fg.Log.Info("\u0045\u0072\u0072\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u006ca\u007ay\u0020\u0074\u0065\u006d\u0070\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _ebgcag.TempFile)
					return
				}
			}
			_gc.Remove(_ebgcag.TempFile)
		} else {
			_agbgg.writeBytes(_ebgcag.Stream)
		}
		_agbgg.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	if _bgbbe, _gcaaa := _aacga.(*_bgd.PdfObjectStreams); _gcaaa {
		_agbgg._bdfbdd[_dfbdf] = crossReference{Type: 1, Offset: _agbgg._bcfba, Generation: _bgbbe.GenerationNumber}
		_agbga := _f.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _dfbdf)
		var _bebda []string
		var _egfcf string
		var _feadc int64
		for _adefee, _bfegfc := range _bgbbe.Elements() {
			_agbdc, _acbef := _bfegfc.(*_bgd.PdfIndirectObject)
			if !_acbef {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065am\u0073 \u004e\u0020\u0025\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006es\u0020\u006e\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u0070\u0064\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0076", _dfbdf, _bfegfc)
				continue
			}
			_cdaec := string(_agbdc.PdfObject.Write()) + "\u0020"
			_egfcf = _egfcf + _cdaec
			_bebda = append(_bebda, _f.Sprintf("\u0025\u0064\u0020%\u0064", _agbdc.ObjectNumber, _feadc))
			_agbgg._bdfbdd[int(_agbdc.ObjectNumber)] = crossReference{Type: 2, ObjectNumber: _dfbdf, Index: _adefee}
			_feadc = _feadc + int64(len([]byte(_cdaec)))
		}
		_eaabaf := _ef.Join(_bebda, "\u0020") + "\u0020"
		_bccdg := _bgd.NewFlateEncoder()
		_eddfe := _bccdg.MakeStreamDict()
		_eddfe.Set(_bgd.PdfObjectName("\u0054\u0079\u0070\u0065"), _bgd.MakeName("\u004f\u0062\u006a\u0053\u0074\u006d"))
		_cbgeg := int64(_bgbbe.Len())
		_eddfe.Set(_bgd.PdfObjectName("\u004e"), _bgd.MakeInteger(_cbgeg))
		_ffagf := int64(len(_eaabaf))
		_eddfe.Set(_bgd.PdfObjectName("\u0046\u0069\u0072s\u0074"), _bgd.MakeInteger(_ffagf))
		_efaedb, _ := _bccdg.EncodeBytes([]byte(_eaabaf + _egfcf))
		_ddbf := int64(len(_efaedb))
		_eddfe.Set(_bgd.PdfObjectName("\u004c\u0065\u006e\u0067\u0074\u0068"), _bgd.MakeInteger(_ddbf))
		_agbga += string(_eddfe.Write())
		_agbga += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_agbgg.writeString(_agbga)
		_agbgg.writeBytes(_efaedb)
		_agbgg.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	_agbgg.writeBytes(_aacga.Write())
}

// PdfActionResetForm represents a resetForm action.
type PdfActionResetForm struct {
	*PdfAction
	Fields _bgd.PdfObject
	Flags  _bgd.PdfObject
}

// GetContainingPdfObject implements interface PdfModel.
func (_fddgf *PdfSignature) GetContainingPdfObject() _bgd.PdfObject { return _fddgf._ddggd }

func _acbcg(_cdbbf _ca.ReadSeeker, _fgge *ReaderOpts, _cdcbag bool, _cdab string) (*PdfReader, error) {
	if _fgge == nil {
		_fgge = NewReaderOpts()
	}
	_ddbbc := ""
	if _acadc, _afdaa := _cdbbf.(*_gc.File); _afdaa {
		_ddbbc = _acadc.Name()
	}
	_fefec := *_fgge
	_ecccfe := &PdfReader{_cfebb: _cdbbf, _dadbf: map[_bgd.PdfObject]struct{}{}, _gggb: _dcag(), _ffce: _fgge.LazyLoad, _bfgg: _fgge.ComplianceMode, _dfceg: _cdcbag, _daae: &_fefec, _babg: _ddbbc}
	_eead, _ceegb := _eggfgd("\u0072")
	if _ceegb != nil {
		return nil, _ceegb
	}
	_ceegb = _gdg.Track(_eead, _cdab, _ecccfe._babg)
	if _ceegb != nil {
		return nil, _ceegb
	}
	_ecccfe._cdff = _eead
	var _aacdg *_bgd.PdfParser
	if !_ecccfe._bfgg {
		if _fgge != nil {
			_fcfbb := _bgd.ParserOpts{RelaxedMode: _fgge.RelaxedMode}
			_aacdg, _ceegb = _bgd.NewParserWithOpts(_cdbbf, _fcfbb)
		} else {
			_aacdg, _ceegb = _bgd.NewParser(_cdbbf)
		}
	} else {
		_aacdg, _ceegb = _bgd.NewCompliancePdfParser(_cdbbf)
	}
	if _ceegb != nil {
		return nil, _ceegb
	}
	_ecccfe._ccade = _aacdg
	_cdag, _ceegb := _ecccfe.IsEncrypted()
	if _ceegb != nil {
		return nil, _ceegb
	}
	if !_cdag {
		_ceegb = _ecccfe.loadStructure()
		if _ceegb != nil {
			return nil, _ceegb
		}
	} else if _cdcbag {
		_gbeab, _cabec := _ecccfe.Decrypt([]byte(_fgge.Password))
		if _cabec != nil {
			return nil, _cabec
		}
		if !_gbeab {
			return nil, _gb.New("\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0064\u0065c\u0072\u0079\u0070\u0074\u0020\u0070\u0061\u0073\u0073w\u006f\u0072\u0064\u0020p\u0072\u006f\u0074\u0065\u0063\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u002d\u0020\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0073\u0070\u0065\u0063\u0069\u0066y\u0020\u0070\u0061s\u0073\u0020\u0074\u006f\u0020\u0044\u0065\u0063\u0072\u0079\u0070\u0074")
		}
	}
	_ecccfe._dcbb = make(map[*PdfReader]*PdfReader)
	_ecccfe._acgcb = make([]*PdfReader, _aacdg.GetRevisionNumber())
	return _ecccfe, nil
}

// PdfWriter handles outputing PDF content.
type PdfWriter struct {
	_fcgc          *_bgd.PdfIndirectObject
	_cfaee         *_bgd.PdfIndirectObject
	_bbcec         map[_bgd.PdfObject]struct{}
	_bgbga         []*_bgd.PdfIndirectObject
	_edcbg         []_bgd.PdfObject
	_abccd         map[_bgd.PdfObject]struct{}
	_gebac         []*_bgd.PdfIndirectObject
	_fabdf         *PdfOutlineTreeNode
	_aaea          *_bgd.PdfObjectDictionary
	_cdabd         []_bgd.PdfObject
	_gefe          *_bgd.PdfIndirectObject
	_ggaff         *_a.Writer
	_bcfba         int64
	_fgegc         error
	_ddcee         *_bgd.PdfCrypt
	_bbfge         *_bgd.PdfObjectDictionary
	_abeb          *_bgd.PdfIndirectObject
	_beadb         *_bgd.PdfObjectArray
	_egbga         _bgd.Version
	_dadab         *bool
	_fedfa         map[_bgd.PdfObject][]*_bgd.PdfObjectDictionary
	_edcdb         *PdfAcroForm
	_dcfdfdg       *Names
	_acff          Optimizer
	_egbb          StandardApplier
	_bdfbdd        map[int]crossReference
	_dceeb         int64
	ObjNumOffset   int
	_fgaba         bool
	_daffe         _bgd.XrefTable
	_gebgb         int64
	_bdgag         int64
	_gbcg          map[_bgd.PdfObject]int64
	_accgae        map[_bgd.PdfObject]struct{}
	_caaf          string
	_cfadf         string
	_ecbcfd        []*PdfOutputIntent
	_gdgceg        bool
	_fedfb, _gdcfb string
}

func (_cabed *PdfReader) resolveReference(_dabgg *_bgd.PdfObjectReference) (_bgd.PdfObject, bool, error) {
	_cgga, _gcbbg := _cabed._ccade.ObjCache[int(_dabgg.ObjectNumber)]
	if !_gcbbg {
		_fg.Log.Trace("R\u0065\u0061\u0064\u0065r \u004co\u006f\u006b\u0075\u0070\u0020r\u0065\u0066\u003a\u0020\u0025\u0073", _dabgg)
		_ecbcg, _dgdd := _cabed._ccade.LookupByReference(*_dabgg)
		if _dgdd != nil {
			return nil, false, _dgdd
		}
		_cabed._ccade.ObjCache[int(_dabgg.ObjectNumber)] = _ecbcg
		return _ecbcg, false, nil
	}
	return _cgga, true, nil
}

func (_geef *PdfAppender) mergeResources(_aedc, _dcdf _bgd.PdfObject, _cfbcb map[_bgd.PdfObjectName]_bgd.PdfObjectName) _bgd.PdfObject {
	if _dcdf == nil && _aedc == nil {
		return nil
	}
	if _dcdf == nil {
		return _aedc
	}
	_cacf, _ggaee := _bgd.GetDict(_dcdf)
	if !_ggaee {
		return _aedc
	}
	if _aedc == nil {
		_gddb := _bgd.MakeDict()
		_gddb.Merge(_cacf)
		return _dcdf
	}
	_abec, _ggaee := _bgd.GetDict(_aedc)
	if !_ggaee {
		_fg.Log.Error("\u0045\u0072\u0072or\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		_abec = _bgd.MakeDict()
	}
	for _, _gabf := range _cacf.Keys() {
		if _gbfg, _adag := _cfbcb[_gabf]; _adag {
			_abec.Set(_gbfg, _cacf.Get(_gabf))
		} else {
			_abec.Set(_gabf, _cacf.Get(_gabf))
		}
	}
	return _abec
}

// NewXObjectImageFromImage creates a new XObject Image from an image object
// with default options. If encoder is nil, uses raw encoding (none).
func NewXObjectImageFromImage(img *Image, cs PdfColorspace, encoder _bgd.StreamEncoder) (*XObjectImage, error) {
	_cgace := NewXObjectImage()
	return UpdateXObjectImageFromImage(_cgace, img, cs, encoder)
}

func (_gddf *PdfReader) newPdfAnnotationRedactFromDict(_gdgb *_bgd.PdfObjectDictionary) (*PdfAnnotationRedact, error) {
	_ggeee := PdfAnnotationRedact{}
	_efaca, _fceg := _gddf.newPdfAnnotationMarkupFromDict(_gdgb)
	if _fceg != nil {
		return nil, _fceg
	}
	_ggeee.PdfAnnotationMarkup = _efaca
	_ggeee.QuadPoints = _gdgb.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_ggeee.IC = _gdgb.Get("\u0049\u0043")
	_ggeee.RO = _gdgb.Get("\u0052\u004f")
	_ggeee.OverlayText = _gdgb.Get("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074")
	_ggeee.Repeat = _gdgb.Get("\u0052\u0065\u0070\u0065\u0061\u0074")
	_ggeee.DA = _gdgb.Get("\u0044\u0041")
	_ggeee.Q = _gdgb.Get("\u0051")
	return &_ggeee, nil
}

// ToOutlineTree returns a low level PdfOutlineTreeNode object, based on
// the current instance.
func (_bgdcf *Outline) ToOutlineTree() *PdfOutlineTreeNode {
	return &_bgdcf.ToPdfOutline().PdfOutlineTreeNode
}

// GetOutlines returns a high-level Outline object, based on the outline tree
// of the reader.
func (_egadf *PdfReader) GetOutlines() (*Outline, error) {
	if _egadf == nil {
		return nil, _gb.New("\u0063\u0061n\u006e\u006f\u0074\u0020c\u0072\u0065a\u0074\u0065\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u006e\u0069\u006c\u0020\u0072e\u0061\u0064\u0065\u0072")
	}
	_dcccb := _egadf.GetOutlineTree()
	if _dcccb == nil {
		return nil, _gb.New("\u0074\u0068\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u0064\u006f\u0065\u0073\u0020n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u006e\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065")
	}
	var _eeafb func(_dedaf *PdfOutlineTreeNode, _cfdde *[]*OutlineItem)
	_eeafb = func(_aefbc *PdfOutlineTreeNode, _fdbaf *[]*OutlineItem) {
		if _aefbc == nil {
			return
		}
		if _aefbc._bfff == nil {
			_fg.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020m\u0069\u0073\u0073\u0069ng \u006fut\u006c\u0069\u006e\u0065\u0020\u0065\u006etr\u0079\u0020\u0063\u006f\u006e\u0074\u0065x\u0074")
			return
		}
		var _gcgd *OutlineItem
		if _fcdd, _bcef := _aefbc._bfff.(*PdfOutlineItem); _bcef {
			_gdfbb := _fcdd.Dest
			if (_gdfbb == nil || _bgd.IsNullObject(_gdfbb)) && _fcdd.A != nil {
				if _begde, _cccca := _bgd.GetDict(_fcdd.A); _cccca {
					if _bgdabe, _fddcd := _bgd.GetArray(_begde.Get("\u0044")); _fddcd {
						_gdfbb = _bgdabe
					} else {
						_bgcg, _fgccg := _bgd.GetString(_begde.Get("\u0044"))
						if !_fgccg {
							return
						}
						_cdacd, _fgccg := _egadf._ffabf.Get("\u004e\u0061\u006de\u0073").(*_bgd.PdfObjectReference)
						if !_fgccg {
							return
						}
						_fadeb, _aaaad := _egadf._ccade.LookupByReference(*_cdacd)
						if _aaaad != nil {
							_fg.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0020\u0028\u0025\u0073\u0029", _aaaad.Error())
							return
						}
						_fccdf, _fgccg := _fadeb.(*_bgd.PdfIndirectObject)
						if !_fgccg {
							return
						}
						_gdbdg := map[_bgd.PdfObject]struct{}{}
						_aaaad = _egadf.buildNameNodes(_fccdf, _gdbdg)
						if _aaaad != nil {
							_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006ea\u006d\u0065\u0020\u006e\u006fd\u0065\u0073 \u0028\u0025\u0073\u0029", _aaaad.Error())
							return
						}
						for _gacac := range _gdbdg {
							_gcbgg, _daefe := _bgd.GetDict(_gacac)
							if !_daefe {
								continue
							}
							_ebcfc, _daefe := _bgd.GetArray(_gcbgg.Get("\u004e\u0061\u006de\u0073"))
							if !_daefe {
								continue
							}
							for _gaea, _dfgaf := range _ebcfc.Elements() {
								switch _dfgaf.(type) {
								case *_bgd.PdfObjectString:
									if _dfgaf.String() == _bgcg.String() {
										if _ddffe := _ebcfc.Get(_gaea + 1); _ddffe != nil {
											if _dbbadb, _bedea := _bgd.GetDict(_ddffe); _bedea {
												_gdfbb = _dbbadb.Get("\u0044")
												break
											}
										}
									}
								}
							}
						}
					}
				}
			}
			var _ccgfb OutlineDest
			if _gdfbb != nil && !_bgd.IsNullObject(_gdfbb) {
				if _bafdf, _cabg := _dfac(_gdfbb, _egadf); _cabg == nil {
					_ccgfb = *_bafdf
				} else {
					_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020p\u0061\u0072\u0073\u0065\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065\u0073\u0074\u0020\u0028\u0025\u0076\u0029\u003a\u0020\u0025\u0076", _gdfbb, _cabg)
				}
			}
			_gcgd = NewOutlineItem(_fcdd.Title.Decoded(), _ccgfb)
			*_fdbaf = append(*_fdbaf, _gcgd)
			if _fcdd.Next != nil {
				_eeafb(_fcdd.Next, _fdbaf)
			}
		}
		if _aefbc.First != nil {
			if _gcgd != nil {
				_fdbaf = &_gcgd.Entries
			}
			_eeafb(_aefbc.First, _fdbaf)
		}
	}
	_dbead := NewOutline()
	_eeafb(_dcccb, &_dbead.Entries)
	return _dbead, nil
}

// NewBorderStyle returns an initialized PdfBorderStyle.
func NewBorderStyle() *PdfBorderStyle { _bfdgc := &PdfBorderStyle{}; return _bfdgc }

var _fdfg = _b.MustCompile("\u005b\\\u006e\u005c\u0072\u005d\u002b")

// GetPageIndirectObject returns the indirect object of page for the specified page number.
func (_agebf *PdfWriter) GetPageIndirectObject(pageNum int) (*_bgd.PdfIndirectObject, error) {
	if pageNum < 0 || pageNum >= len(_agebf._bgbga) {
		return nil, _gb.New("\u0070a\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	return _agebf._bgbga[pageNum], nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_cbcgad *PdfShadingType6) ToPdfObject() _bgd.PdfObject {
	_cbcgad.PdfShading.ToPdfObject()
	_bfcaa, _ffgfe := _cbcgad.getShadingDict()
	if _ffgfe != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _cbcgad.BitsPerCoordinate != nil {
		_bfcaa.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _cbcgad.BitsPerCoordinate)
	}
	if _cbcgad.BitsPerComponent != nil {
		_bfcaa.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _cbcgad.BitsPerComponent)
	}
	if _cbcgad.BitsPerFlag != nil {
		_bfcaa.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _cbcgad.BitsPerFlag)
	}
	if _cbcgad.Decode != nil {
		_bfcaa.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _cbcgad.Decode)
	}
	if _cbcgad.Function != nil {
		if len(_cbcgad.Function) == 1 {
			_bfcaa.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _cbcgad.Function[0].ToPdfObject())
		} else {
			_ddbcbf := _bgd.MakeArray()
			for _, _eecgg := range _cbcgad.Function {
				_ddbcbf.Append(_eecgg.ToPdfObject())
			}
			_bfcaa.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _ddbcbf)
		}
	}
	return _cbcgad._gccfe
}

// PdfAnnotationInk represents Ink annotations.
// (Section 12.5.6.13).
type PdfAnnotationInk struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	InkList _bgd.PdfObject
	BS      _bgd.PdfObject
}

type modelManager struct {
	_dagg  map[PdfModel]_bgd.PdfObject
	_bcdf  map[_bgd.PdfObject]PdfModel
	_cegbb _g.RWMutex
	_bagb  _g.RWMutex
}

// GetContext returns the PdfField context which is the more specific field data type, e.g. PdfFieldButton
// for a button field.
func (_efacf *PdfField) GetContext() PdfModel { return _efacf._babbg }

// ColorAt returns the color of the image pixel specified by the x and y coordinates.
func (_cdeaec *Image) ColorAt(x, y int) (_e.Color, error) {
	_daegd := _daf.BytesPerLine(int(_cdeaec.Width), int(_cdeaec.BitsPerComponent), _cdeaec.ColorComponents)
	switch _cdeaec.ColorComponents {
	case 1:
		return _daf.ColorAtGrayscale(x, y, int(_cdeaec.BitsPerComponent), _daegd, _cdeaec.Data, _cdeaec._agcea)
	case 3:
		return _daf.ColorAtNRGBA(x, y, int(_cdeaec.Width), _daegd, int(_cdeaec.BitsPerComponent), _cdeaec.Data, _cdeaec._bdgdb, _cdeaec._agcea)
	case 4:
		return _daf.ColorAtCMYK(x, y, int(_cdeaec.Width), _cdeaec.Data, _cdeaec._agcea)
	}
	_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 i\u006da\u0067\u0065\u002e\u0020\u0025\u0064\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074\u0073\u002c\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072 \u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _cdeaec.ColorComponents, _cdeaec.BitsPerComponent)
	return nil, _gb.New("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006d\u0061g\u0065 \u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065")
}

// ToPdfObject implements interface PdfModel.
func (_dbeaf *PdfTransformParamsDocMDP) ToPdfObject() _bgd.PdfObject {
	_cefgdg := _bgd.MakeDict()
	_cefgdg.SetIfNotNil("\u0054\u0079\u0070\u0065", _dbeaf.Type)
	_cefgdg.SetIfNotNil("\u0056", _dbeaf.V)
	_cefgdg.SetIfNotNil("\u0050", _dbeaf.P)
	return _cefgdg
}

// ToPdfObject implements interface PdfModel.
func (_cag *PdfActionResetForm) ToPdfObject() _bgd.PdfObject {
	_cag.PdfAction.ToPdfObject()
	_fed := _cag._fab
	_ggdb := _fed.PdfObject.(*_bgd.PdfObjectDictionary)
	_ggdb.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeResetForm)))
	_ggdb.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _cag.Fields)
	_ggdb.SetIfNotNil("\u0046\u006c\u0061g\u0073", _cag.Flags)
	return _fed
}

// EnableByName LTV enables the signature dictionary of the PDF AcroForm
// field identified the specified name. The signing certificate chain is
// extracted from the signature dictionary. Optionally, additional certificates
// can be specified through the `extraCerts` parameter. The LTV client attempts
// to build the certificate chain up to a trusted root by downloading any
// missing certificates.
func (_daga *LTV) EnableByName(name string, extraCerts []*_cb.Certificate) error {
	_eadbb := _daga._deefd._gdf.AcroForm
	for _, _ebdd := range _eadbb.AllFields() {
		_eeda, _ := _ebdd.GetContext().(*PdfFieldSignature)
		if _eeda == nil {
			continue
		}
		if _bbeca := _eeda.PartialName(); _bbeca != name {
			continue
		}
		return _daga.Enable(_eeda.V, extraCerts)
	}
	return nil
}

// SetNamedDestinations sets the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_dccgc *PdfWriter) SetNamedDestinations(dests _bgd.PdfObject) error {
	if dests == nil {
		return nil
	}
	_fg.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u0044\u0065\u0073\u0074\u0073\u002e\u002e\u002e")
	_dccgc._aaea.Set("\u0044\u0065\u0073t\u0073", dests)
	return _dccgc.addObjects(dests)
}

// GetContainingPdfObject implements interface PdfModel.
func (_fb *PdfAction) GetContainingPdfObject() _bgd.PdfObject { return _fb._fab }

// ToPdfObject implements interface PdfModel.
func (_cfcd *PdfAnnotationUnderline) ToPdfObject() _bgd.PdfObject {
	_cfcd.PdfAnnotation.ToPdfObject()
	_edbg := _cfcd._eag
	_aabc := _edbg.PdfObject.(*_bgd.PdfObjectDictionary)
	_cfcd.appendToPdfDictionary(_aabc)
	_aabc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee"))
	_aabc.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _cfcd.QuadPoints)
	return _edbg
}

// ToWriter creates a new writer from the current reader, based on the specified options.
// If no options are provided, all reader properties are copied to the writer.
func (_bbbda *PdfReader) ToWriter(opts *ReaderToWriterOpts) (*PdfWriter, error) {
	_fabad := NewPdfWriter()
	_fabad.SetFileName(_bbbda._babg)
	if opts == nil {
		opts = &ReaderToWriterOpts{}
	}
	_edcaf, _dcaaac := _bbbda.GetNumPages()
	if _dcaaac != nil {
		_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _dcaaac)
		return nil, _dcaaac
	}
	for _dbab := 1; _dbab <= _edcaf; _dbab++ {
		_facbc, _gcge := _bbbda.GetPage(_dbab)
		if _gcge != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gcge)
			return nil, _gcge
		}
		if opts.PageProcessCallback != nil {
			_gcge = opts.PageProcessCallback(_dbab, _facbc)
			if _gcge != nil {
				_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gcge)
				return nil, _gcge
			}
		} else if opts.PageCallback != nil {
			opts.PageCallback(_dbab, _facbc)
		}
		_gcge = _fabad.AddPage(_facbc)
		if _gcge != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gcge)
			return nil, _gcge
		}
	}
	_fabad._egbga = _bbbda.PdfVersion()
	if !opts.SkipInfo {
		_cdead, _ffeeb := _bbbda.GetPdfInfo()
		if _ffeeb != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ffeeb)
		} else {
			_fabad._gefe.PdfObject = _cdead.ToPdfObject()
		}
	}
	if !opts.SkipMetadata {
		if _ggfgb := _bbbda._ffabf.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _ggfgb != nil {
			if _agbg := _fabad.SetCatalogMetadata(_ggfgb); _agbg != nil {
				return nil, _agbg
			}
		}
	}
	if !opts.SkipMarkInfo {
		if _cdef, _cbfcb := _bbbda.GetCatalogMarkInfo(); _cbfcb {
			if _facbf := _fabad.SetCatalogMarkInfo(_cdef); _facbf != nil {
				return nil, _facbf
			}
		}
	}
	if !opts.SkipAcroForm {
		_baeag := _fabad.SetForms(_bbbda.AcroForm)
		if _baeag != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _baeag)
			return nil, _baeag
		}
	}
	if !opts.SkipViewerPreferences {
		if _befgb, _cdcda := _bbbda.GetCatalogViewerPreferences(); _cdcda {
			if _ffgga := _fabad.SetCatalogViewerPreferences(_befgb); _ffgga != nil {
				return nil, _ffgga
			}
		}
	}
	if !opts.SkipLanguage {
		if _edadf, _cagcb := _bbbda.GetCatalogLanguage(); _cagcb {
			if _fgged := _fabad.SetCatalogLanguage(_edadf); _fgged != nil {
				return nil, _fgged
			}
		}
	}
	if !opts.SkipOutlines {
		_fabad.AddOutlineTree(_bbbda.GetOutlineTree())
	}
	if !opts.SkipOCProperties {
		_gedab, _eefa := _bbbda.GetOCProperties()
		if _eefa != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _eefa)
		} else {
			_eefa = _fabad.SetOCProperties(_gedab)
			if _eefa != nil {
				_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _eefa)
			}
		}
	}
	if !opts.SkipPageLabels {
		_gcdac, _agcead := _bbbda.GetPageLabels()
		if _agcead != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _agcead)
		} else {
			_agcead = _fabad.SetPageLabels(_gcdac)
			if _agcead != nil {
				_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _agcead)
			}
		}
	}
	if !opts.SkipNamedDests {
		_fdcff, _dfcd := _bbbda.GetNamedDestinations()
		if _dfcd != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _dfcd)
		} else {
			_dfcd = _fabad.SetNamedDestinations(_fdcff)
			if _dfcd != nil {
				_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _dfcd)
			}
		}
	}
	if !opts.SkipNameDictionary {
		_fcecg, _gffbd := _bbbda.GetNameDictionary()
		if _gffbd != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gffbd)
		} else {
			_gffbd = _fabad.SetNameDictionary(_fcecg)
			if _gffbd != nil {
				_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gffbd)
			}
		}
	}
	_fgeaa, _acdbb := _bbbda.GetCatalogStructTreeRoot()
	if _acdbb {
		_dffcc := _fabad.SetCatalogStructTreeRoot(_fgeaa)
		if _dffcc != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _dffcc)
		}
	}
	if !opts.SkipRotation && _bbbda.Rotate != nil {
		if _facf := _fabad.SetRotation(*_bbbda.Rotate); _facf != nil {
			_fg.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _facf)
		}
	}
	return &_fabad, nil
}

// GetAsTilingPattern returns a tiling pattern. Check with IsTiling() prior to using this.
func (_fcdga *PdfPattern) GetAsTilingPattern() *PdfTilingPattern {
	return _fcdga._ggafd.(*PdfTilingPattern)
}

func (_eegfce *PdfWriter) optimize() error {
	if _eegfce._acff == nil {
		return nil
	}
	var _fdgcg error
	_eegfce._edcbg, _fdgcg = _eegfce._acff.Optimize(_eegfce._edcbg)
	if _fdgcg != nil {
		return _fdgcg
	}
	_bacaf := make(map[_bgd.PdfObject]struct{}, len(_eegfce._edcbg))
	for _, _bbagd := range _eegfce._edcbg {
		_bacaf[_bbagd] = struct{}{}
	}
	_eegfce._abccd = _bacaf
	return nil
}

// GetContainingPdfObject returns the container of the outline tree node (indirect object).
func (_egdff *PdfOutlineTreeNode) GetContainingPdfObject() _bgd.PdfObject {
	return _egdff.GetContext().GetContainingPdfObject()
}

func _efdgb(_deadb _bgd.PdfObject) {
	_fg.Log.Debug("\u006f\u0062\u006a\u003a\u0020\u0025\u0054\u0020\u0025\u0073", _deadb, _deadb.String())
	if _dbegdf, _fbadb := _deadb.(*_bgd.PdfObjectStream); _fbadb {
		_ccebb, _dgec := _bgd.DecodeStream(_dbegdf)
		if _dgec != nil {
			_fg.Log.Debug("\u0045r\u0072\u006f\u0072\u003a\u0020\u0025v", _dgec)
			return
		}
		_fg.Log.Debug("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073", _ccebb)
	} else if _dfgfg, _dabgc := _deadb.(*_bgd.PdfIndirectObject); _dabgc {
		_fg.Log.Debug("\u0025\u0054\u0020%\u0076", _dfgfg.PdfObject, _dfgfg.PdfObject)
		_fg.Log.Debug("\u0025\u0073", _dfgfg.PdfObject.String())
	}
}

// PdfAnnotationPolygon represents Polygon annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolygon struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _bgd.PdfObject
	LE       _bgd.PdfObject
	BS       _bgd.PdfObject
	IC       _bgd.PdfObject
	BE       _bgd.PdfObject
	IT       _bgd.PdfObject
	Measure  _bgd.PdfObject
}

func (_cgff *pdfFontSimple) baseFields() *fontCommon { return &_cgff.fontCommon }

// SetPdfSubject sets the Subject attribute of the output PDF.
func SetPdfSubject(subject string) { _adcf.Lock(); defer _adcf.Unlock(); _ebgca = subject }

// SetPageLabels sets the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_cdgbd *PdfWriter) SetPageLabels(pageLabels _bgd.PdfObject) error {
	if pageLabels == nil {
		return nil
	}
	_fg.Log.Trace("\u0053\u0065t\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006cs.\u002e\u002e")
	_cdgbd._aaea.Set("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073", pageLabels)
	return _cdgbd.addObjects(pageLabels)
}

func (_gdeg *PdfReader) newPdfAnnotationLinkFromDict(_dagb *_bgd.PdfObjectDictionary) (*PdfAnnotationLink, error) {
	_dbc := PdfAnnotationLink{}
	_dbc.A = _dagb.Get("\u0041")
	_dbc.Dest = _dagb.Get("\u0044\u0065\u0073\u0074")
	_dbc.H = _dagb.Get("\u0048")
	_dbc.PA = _dagb.Get("\u0050\u0041")
	_dbc.QuadPoints = _dagb.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_dbc.BS = _dagb.Get("\u0042\u0053")
	return &_dbc, nil
}

// PdfActionTrans represents a trans action.
type PdfActionTrans struct {
	*PdfAction
	Trans _bgd.PdfObject
}

// ToPdfObject converts the K dictionary to a PDF object.
func (_ceeff *KDict) ToPdfObject() _bgd.PdfObject {
	_bdff := _bgd.MakeDict()
	if _ceeff.ID != nil {
		_bdff.Set("\u0049\u0044", _ceeff.ID)
	}
	if _ceeff.K != nil {
		_bdff.Set("\u004b", _ceeff.K)
	} else if len(_ceeff._fabbb) > 0 {
		if len(_ceeff._fabbb) == 1 {
			_ceeff.K = _ceeff._fabbb[0].ToPdfObject()
		} else {
			_egadd := _bgd.MakeArray()
			for _, _ebgbd := range _ceeff._fabbb {
				_egadd.Append(_ebgbd.ToPdfObject())
			}
			_ceeff.K = _egadd
		}
		_bdff.Set("\u004b", _ceeff.K)
	}
	if _ceeff.S != nil {
		_bdff.Set("\u0053", _ceeff.S)
	}
	if _ceeff.P != nil {
		_bdff.Set("\u0050", _ceeff.P)
	}
	if _ceeff.Pg != nil {
		_bdff.Set("\u0050\u0067", _ceeff.Pg)
	}
	if _ceeff.C != nil {
		_bdff.Set("\u0043", _ceeff.C)
	}
	if _ceeff.R != nil {
		_bdff.Set("\u0052", _ceeff.R)
	}
	if _ceeff.T != nil {
		_bdff.Set("\u0054", _ceeff.T)
	}
	if _ceeff.Lang != nil {
		_bdff.Set("\u004c\u0061\u006e\u0067", _ceeff.Lang)
	}
	if _ceeff.Alt != nil {
		_bdff.Set("\u0041\u006c\u0074", _ceeff.Alt)
	}
	if _ceeff.E != nil {
		_bdff.Set("\u0045", _ceeff.E)
	}
	if _ceeff.A != nil {
		_bdff.Set("\u0041", _ceeff.A)
	} else if _ceeff._febg != nil {
		_eebeb := _bgd.MakeArrayFromFloats([]float64{_ceeff._febg.Llx, _ceeff._febg.Lly, _ceeff._febg.Urx, _ceeff._febg.Ury})
		_agdda := _bgd.MakeDict()
		_agdda.Set("\u0042\u0042\u006f\u0078", _eebeb)
		_agdda.Set("\u004f", _bgd.MakeString("\u004c\u0061\u0079\u006f\u0075\u0074"))
		_bdff.Set("\u0041", _bgd.MakeIndirectObject(_agdda))
	}
	if _ceeff.ActualText != nil {
		_bdff.Set("\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074", _ceeff.ActualText)
	}
	if _ceeff.E != nil {
		_bdff.Set("\u0045", _ceeff.E)
	}
	if _ceeff.Alt != nil {
		_bdff.Set("\u0041\u006c\u0074", _ceeff.Alt)
	}
	return _bdff
}

// SetBoundingBox sets the bounding box in the attribute object.
func (_addgg *KDict) SetBoundingBox(x, y, width, height float64) {
	_addgg._febg = &PdfRectangle{Llx: x, Lly: y, Urx: x + width, Ury: y + height}
}

func (_gcb *PdfReader) newPdfAnnotation3DFromDict(_ccb *_bgd.PdfObjectDictionary) (*PdfAnnotation3D, error) {
	_aadf := PdfAnnotation3D{}
	_aadf.T3DD = _ccb.Get("\u0033\u0044\u0044")
	_aadf.T3DV = _ccb.Get("\u0033\u0044\u0056")
	_aadf.T3DA = _ccb.Get("\u0033\u0044\u0041")
	_aadf.T3DI = _ccb.Get("\u0033\u0044\u0049")
	_aadf.T3DB = _ccb.Get("\u0033\u0044\u0042")
	return &_aadf, nil
}

// PdfFont represents an underlying font structure which can be of type:
// - Type0
// - Type1
// - TrueType
// etc.
type PdfFont struct{ _cbec pdfFont }

// GetPage returns the PdfPage model for the specified page number.
func (_efcbf *PdfReader) GetPage(pageNumber int) (*PdfPage, error) {
	if _efcbf._ccade.GetCrypter() != nil && !_efcbf._ccade.IsAuthenticated() {
		return nil, _f.Errorf("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	if len(_efcbf._gfggf) < pageNumber {
		return nil, _gb.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0028\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0074o\u006f\u0020\u0073\u0068\u006f\u0072\u0074\u0029")
	}
	_cfefe := pageNumber - 1
	if _cfefe < 0 {
		return nil, _f.Errorf("\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0069\u006e\u0067\u0020\u006d\u0075\u0073t\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0061\u0074\u0020\u0031")
	}
	_cdeaf := _efcbf.PageList[_cfefe]
	return _cdeaf, nil
}

// SetImage updates XObject Image with new image data.
func (_dbedf *XObjectImage) SetImage(img *Image, cs PdfColorspace) error {
	_dbedf.Filter.UpdateParams(img.GetParamsDict())
	_ecgbb, _cfcea := _dbedf.Filter.EncodeBytes(img.Data)
	if _cfcea != nil {
		return _cfcea
	}
	_dbedf.Stream = _ecgbb
	_agddeg := img.Width
	_dbedf.Width = &_agddeg
	_gcaed := img.Height
	_dbedf.Height = &_gcaed
	_cbegg := img.BitsPerComponent
	_dbedf.BitsPerComponent = &_cbegg
	if cs == nil {
		if img.ColorComponents == 1 {
			_dbedf.ColorSpace = NewPdfColorspaceDeviceGray()
		} else if img.ColorComponents == 3 {
			_dbedf.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			_dbedf.ColorSpace = NewPdfColorspaceDeviceCMYK()
		} else {
			return _gb.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_dbedf.ColorSpace = cs
	}
	return nil
}

// HasXObjectByName checks if an XObject with a specified keyName is defined.
func (_gbgf *PdfPageResources) HasXObjectByName(keyName _bgd.PdfObjectName) bool {
	_cbgfd, _ := _gbgf.GetXObjectByName(keyName)
	return _cbgfd != nil
}

// ToPdfObject implements interface PdfModel.
func (_gdbg *PdfBorderStyle) ToPdfObject() _bgd.PdfObject {
	_edgd := _bgd.MakeDict()
	if _gdbg._ffc != nil {
		if _fagc, _gbba := _gdbg._ffc.(*_bgd.PdfIndirectObject); _gbba {
			_fagc.PdfObject = _edgd
		}
	}
	_edgd.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0042\u006f\u0072\u0064\u0065\u0072"))
	if _gdbg.W != nil {
		_edgd.Set("\u0057", _bgd.MakeFloat(*_gdbg.W))
	}
	if _gdbg.S != nil {
		_edgd.Set("\u0053", _bgd.MakeName(_gdbg.S.GetPdfName()))
	}
	if _gdbg.D != nil {
		_edgd.Set("\u0044", _bgd.MakeArrayFromIntegers(*_gdbg.D))
	}
	if _gdbg._ffc != nil {
		return _gdbg._ffc
	}
	return _edgd
}

// ImageToRGB convert 1-component grayscale data to 3-component RGB.
func (_gfbe *PdfColorspaceDeviceGray) ImageToRGB(img Image) (Image, error) {
	if img.ColorComponents != 1 {
		return img, _gb.New("\u0074\u0068e \u0070\u0072\u006fv\u0069\u0064\u0065\u0064 im\u0061ge\u0020\u0069\u0073\u0020\u006e\u006f\u0074 g\u0072\u0061\u0079\u0020\u0073\u0063\u0061l\u0065")
	}
	_ebae, _gdaf := _daf.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._bdgdb, img._agcea)
	if _gdaf != nil {
		return img, _gdaf
	}
	_eagf, _gdaf := _daf.NRGBAConverter.Convert(_ebae)
	if _gdaf != nil {
		return img, _gdaf
	}
	_acbe := _acfa(_eagf.Base())
	_fg.Log.Trace("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079\u0020\u002d>\u0020\u0052\u0047\u0042")
	_fg.Log.Trace("s\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", img.Data)
	_fg.Log.Trace("\u0052G\u0042 \u0073\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", _acbe.Data)
	_fg.Log.Trace("\u0025\u0076\u0020\u002d\u003e\u0020\u0025\u0076", img, _acbe)
	return _acbe, nil
}

// PdfAnnotationMovie represents Movie annotations.
// (Section 12.5.6.17).
type PdfAnnotationMovie struct {
	*PdfAnnotation
	T     _bgd.PdfObject
	Movie _bgd.PdfObject
	A     _bgd.PdfObject
}

// Transform rectangle with the supplied matrix.
func (_eddf *PdfRectangle) Transform(transformMatrix _ga.Matrix) {
	_eddf.Llx, _eddf.Lly = transformMatrix.Transform(_eddf.Llx, _eddf.Lly)
	_eddf.Urx, _eddf.Ury = transformMatrix.Transform(_eddf.Urx, _eddf.Ury)
	_eddf.Normalize()
}

// PdfAnnotationLine represents Line annotations.
// (Section 12.5.6.7).
type PdfAnnotationLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	L       _bgd.PdfObject
	BS      _bgd.PdfObject
	LE      _bgd.PdfObject
	IC      _bgd.PdfObject
	LL      _bgd.PdfObject
	LLE     _bgd.PdfObject
	Cap     _bgd.PdfObject
	IT      _bgd.PdfObject
	LLO     _bgd.PdfObject
	CP      _bgd.PdfObject
	Measure _bgd.PdfObject
	CO      _bgd.PdfObject
}

// SignatureValidationResult defines the response from the signature validation handler.
type SignatureValidationResult struct {

	// List of errors when validating the signature.
	Errors      []string
	IsSigned    bool
	IsVerified  bool
	IsTrusted   bool
	Fields      []*PdfField
	Name        string
	Date        PdfDate
	Reason      string
	Location    string
	ContactInfo string
	DiffResults *_fa.DiffResults
	IsCrlFound  bool
	IsOcspFound bool

	// GeneralizedTime is the time at which the time-stamp token has been created by the TSA (RFC 3161).
	GeneralizedTime _ge.Time
}

// ToInteger convert to an integer format.
func (_ccdb *PdfColorCalGray) ToInteger(bits int) uint32 {
	_dceb := _da.Pow(2, float64(bits)) - 1
	return uint32(_dceb * _ccdb.Val())
}

// NewXObjectFormFromStream builds the Form XObject from a stream object.
// TODO: Should this be exposed? Consider different access points.
func NewXObjectFormFromStream(stream *_bgd.PdfObjectStream) (*XObjectForm, error) {
	_ebcfe := &XObjectForm{}
	_ebcfe._aagg = stream
	_beega := *(stream.PdfObjectDictionary)
	_edbeaf, _gbecg := _bgd.NewEncoderFromStream(stream)
	if _gbecg != nil {
		return nil, _gbecg
	}
	_ebcfe.Filter = _edbeaf
	if _edbbf := _beega.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _edbbf != nil {
		_fdbfa, _ffaba := _edbbf.(*_bgd.PdfObjectName)
		if !_ffaba {
			return nil, _gb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if *_fdbfa != "\u0046\u006f\u0072\u006d" {
			_fg.Log.Debug("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
			return nil, _gb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
		}
	}
	if _ecefc := _beega.Get("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065"); _ecefc != nil {
		_ebcfe.FormType = _ecefc
	}
	if _ccebg := _beega.Get("\u0042\u0042\u006f\u0078"); _ccebg != nil {
		_ebcfe.BBox = _ccebg
	}
	if _gaeda := _beega.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _gaeda != nil {
		_ebcfe.Matrix = _gaeda
	}
	if _cccba := _beega.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _cccba != nil {
		_cccba = _bgd.TraceToDirectObject(_cccba)
		_dabfba, _dabef := _cccba.(*_bgd.PdfObjectDictionary)
		if !_dabef {
			_fg.Log.Debug("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0058\u004f\u0062j\u0065c\u0074\u0020\u0046\u006f\u0072\u006d\u0020\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u002c\u0020\u0070\u006f\u0069\u006e\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _bgd.ErrTypeError
		}
		_dbaf, _gdced := NewPdfPageResourcesFromDict(_dabfba)
		if _gdced != nil {
			_fg.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0020\u0072\u0065\u0073\u006f\u0075rc\u0065\u0073")
			return nil, _gdced
		}
		_ebcfe.Resources = _dbaf
		_fg.Log.Trace("\u0046\u006f\u0072\u006d r\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u003a\u0020\u0025\u0023\u0076", _ebcfe.Resources)
	}
	_ebcfe.Group = _beega.Get("\u0047\u0072\u006fu\u0070")
	_ebcfe.Ref = _beega.Get("\u0052\u0065\u0066")
	_ebcfe.MetaData = _beega.Get("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061")
	_ebcfe.PieceInfo = _beega.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o")
	_ebcfe.LastModified = _beega.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064")
	_ebcfe.StructParent = _beega.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_ebcfe.StructParents = _beega.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073")
	_ebcfe.OPI = _beega.Get("\u004f\u0050\u0049")
	_ebcfe.OC = _beega.Get("\u004f\u0043")
	_ebcfe.Name = _beega.Get("\u004e\u0061\u006d\u0065")
	_ebcfe.Stream = stream.Stream
	return _ebcfe, nil
}

func (_edadg *PdfReader) newPdfAnnotationLineFromDict(_bae *_bgd.PdfObjectDictionary) (*PdfAnnotationLine, error) {
	_bdad := PdfAnnotationLine{}
	_ebfg, _adgb := _edadg.newPdfAnnotationMarkupFromDict(_bae)
	if _adgb != nil {
		return nil, _adgb
	}
	_bdad.PdfAnnotationMarkup = _ebfg
	_bdad.L = _bae.Get("\u004c")
	_bdad.BS = _bae.Get("\u0042\u0053")
	_bdad.LE = _bae.Get("\u004c\u0045")
	_bdad.IC = _bae.Get("\u0049\u0043")
	_bdad.LL = _bae.Get("\u004c\u004c")
	_bdad.LLE = _bae.Get("\u004c\u004c\u0045")
	_bdad.Cap = _bae.Get("\u0043\u0061\u0070")
	_bdad.IT = _bae.Get("\u0049\u0054")
	_bdad.LLO = _bae.Get("\u004c\u004c\u004f")
	_bdad.CP = _bae.Get("\u0043\u0050")
	_bdad.Measure = _bae.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	_bdad.CO = _bae.Get("\u0043\u004f")
	return &_bdad, nil
}

func (_egc *PdfReader) newPdfAnnotationPolygonFromDict(_aba *_bgd.PdfObjectDictionary) (*PdfAnnotationPolygon, error) {
	_gfa := PdfAnnotationPolygon{}
	_abgd, _cfggc := _egc.newPdfAnnotationMarkupFromDict(_aba)
	if _cfggc != nil {
		return nil, _cfggc
	}
	_gfa.PdfAnnotationMarkup = _abgd
	_gfa.Vertices = _aba.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_gfa.LE = _aba.Get("\u004c\u0045")
	_gfa.BS = _aba.Get("\u0042\u0053")
	_gfa.IC = _aba.Get("\u0049\u0043")
	_gfa.BE = _aba.Get("\u0042\u0045")
	_gfa.IT = _aba.Get("\u0049\u0054")
	_gfa.Measure = _aba.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_gfa, nil
}

func (_gfgb *PdfReader) newPdfAnnotationPrinterMarkFromDict(_aeeb *_bgd.PdfObjectDictionary) (*PdfAnnotationPrinterMark, error) {
	_fgff := PdfAnnotationPrinterMark{}
	_fgff.MN = _aeeb.Get("\u004d\u004e")
	return &_fgff, nil
}

// RemoveKChild removes a specific KDict child from the kChildren slice.
func (_ggggg *KDict) RemoveKChild(kChild *KDict) bool {
	for _faaf, _edac := range _ggggg._fabbb {
		if _edac._fgcbd == kChild {
			_ggggg._fabbb = append(_ggggg._fabbb[:_faaf], _ggggg._fabbb[_faaf+1:]...)
			return true
		}
	}
	return false
}

// Hasher is the interface that wraps the basic Write method.
type Hasher interface {
	Write(_ccaab []byte) (_gdfcb int, _gccca error)
}

func (_abfcb *PdfReader) newPdfSignatureReferenceFromDict(_aegdg *_bgd.PdfObjectDictionary) (*PdfSignatureReference, error) {
	if _eefbfg, _fccdfd := _abfcb._gggb.GetModelFromPrimitive(_aegdg).(*PdfSignatureReference); _fccdfd {
		return _eefbfg, nil
	}
	_fdgad := &PdfSignatureReference{_ceca: _aegdg, Data: _aegdg.Get("\u0044\u0061\u0074\u0061")}
	var _abcde bool
	_fdgad.Type, _ = _bgd.GetName(_aegdg.Get("\u0054\u0079\u0070\u0065"))
	_fdgad.TransformMethod, _abcde = _bgd.GetName(_aegdg.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"))
	if !_abcde {
		_fg.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0054\u0072\u0061\u006e\u0073\u0066o\u0072\u006dM\u0065\u0074h\u006f\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020in\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020m\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_fdgad.TransformParams, _ = _bgd.GetDict(_aegdg.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"))
	_fdgad.DigestMethod, _ = _bgd.GetName(_aegdg.Get("\u0044\u0069\u0067e\u0073\u0074\u004d\u0065\u0074\u0068\u006f\u0064"))
	return _fdgad, nil
}

// ToPdfObject converts the pdfFontSimple to its PDF representation for outputting.
func (_ggacg *pdfFontSimple) ToPdfObject() _bgd.PdfObject {
	if _ggacg._gaff == nil {
		_ggacg._gaff = &_bgd.PdfIndirectObject{}
	}
	_bcgf := _ggacg.baseFields().asPdfObjectDictionary("")
	_ggacg._gaff.PdfObject = _bcgf
	if _ggacg.FirstChar != nil {
		_bcgf.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _ggacg.FirstChar)
	}
	if _ggacg.LastChar != nil {
		_bcgf.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _ggacg.LastChar)
	}
	if _ggacg.Widths != nil {
		_bcgf.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _ggacg.Widths)
	}
	if _ggacg.Encoding != nil {
		_bcgf.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _ggacg.Encoding)
	} else if _ggacg._dcfdfd != nil {
		_cfafc := _ggacg._dcfdfd.ToPdfObject()
		if _cfafc != nil {
			_bcgf.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _cfafc)
		}
	}
	return _ggacg._gaff
}

// ToPdfObject implements interface PdfModel.
func (_aecec *PdfFilespec) ToPdfObject() _bgd.PdfObject {
	_eegaf := _aecec.getDict()
	_eegaf.Clear()
	_eegaf.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063"))
	_eegaf.SetIfNotNil("\u0046\u0053", _aecec.FS)
	_eegaf.SetIfNotNil("\u0046", _aecec.F)
	_eegaf.SetIfNotNil("\u0055\u0046", _aecec.UF)
	_eegaf.SetIfNotNil("\u0044\u004f\u0053", _aecec.DOS)
	_eegaf.SetIfNotNil("\u004d\u0061\u0063", _aecec.Mac)
	_eegaf.SetIfNotNil("\u0055\u006e\u0069\u0078", _aecec.Unix)
	_eegaf.SetIfNotNil("\u0049\u0044", _aecec.ID)
	_eegaf.SetIfNotNil("\u0056", _aecec.V)
	_eegaf.SetIfNotNil("\u0045\u0046", _aecec.EF)
	_eegaf.SetIfNotNil("\u0052\u0046", _aecec.RF)
	_eegaf.SetIfNotNil("\u0044\u0065\u0073\u0063", _aecec.Desc)
	_eegaf.SetIfNotNil("\u0043\u0049", _aecec.CI)
	_eegaf.SetIfNotNil("\u0041\u0046\u0052\u0065\u006c\u0061\u0074\u0069\u006fn\u0073\u0068\u0069\u0070", _aecec.AFRelationship)
	return _aecec._bbbfb
}

// NewXObjectForm creates a brand new XObject Form. Creates a new underlying PDF object stream primitive.
func NewXObjectForm() *XObjectForm {
	_bdeed := &XObjectForm{}
	_cffdc := &_bgd.PdfObjectStream{}
	_cffdc.PdfObjectDictionary = _bgd.MakeDict()
	_bdeed._aagg = _cffdc
	return _bdeed
}

// NewPdfSignature creates a new PdfSignature object.
func NewPdfSignature(handler SignatureHandler) *PdfSignature {
	_dagde := &PdfSignature{Type: _bgd.MakeName("\u0053\u0069\u0067"), Handler: handler}
	_baef := &pdfSignDictionary{PdfObjectDictionary: _bgd.MakeDict(), _bcdbef: &handler, _egebe: _dagde}
	_dagde._ddggd = _bgd.MakeIndirectObject(_baef)
	return _dagde
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a CalGray device.
func (_cdaa *PdfColorspaceCalGray) GetNumComponents() int { return 1 }

// CharcodesToUnicode converts the character codes `charcodes` to a slice of runes.
// How it works:
//  1. Use the ToUnicode CMap if there is one.
//  2. Use the underlying font's encoding.
func (_egae *PdfFont) CharcodesToUnicode(charcodes []_dabf.CharCode) []rune {
	_gcag, _, _ := _egae.CharcodesToUnicodeWithStats(charcodes)
	return _gcag
}

// GetColorspaces loads PdfPageResourcesColorspaces from `r.ColorSpace` and returns an error if there
// is a problem loading. Once loaded, the same object is returned on multiple calls.
func (_abbb *PdfPageResources) GetColorspaces() (*PdfPageResourcesColorspaces, error) {
	if _abbb._fabf != nil {
		return _abbb._fabf, nil
	}
	if _abbb.ColorSpace == nil {
		return nil, nil
	}
	_bagac, _cbcbg := _ebaag(_abbb.ColorSpace)
	if _cbcbg != nil {
		return nil, _cbcbg
	}
	_abbb._fabf = _bagac
	return _abbb._fabf, nil
}

func (_bcdff *PdfReader) traverseObjectData(_gadbf _bgd.PdfObject) error {
	return _bgd.ResolveReferencesDeep(_gadbf, _bcdff._dadbf)
}

// PdfAnnotationSound represents Sound annotations.
// (Section 12.5.6.16).
type PdfAnnotationSound struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Sound _bgd.PdfObject
	Name  _bgd.PdfObject
}

// NewPdfDate returns a new PdfDate object from a PDF date string (see 7.9.4 Dates).
// format: "D: YYYYMMDDHHmmSSOHH'mm"
func NewPdfDate(dateStr string) (PdfDate, error) {
	_efcbff, _agdff := _bfb.ParsePdfTime(dateStr)
	if _agdff != nil {
		return PdfDate{}, _agdff
	}
	return NewPdfDateFromTime(_efcbff)
}

// GetPreviousRevision returns the previous revision of PdfReader for the Pdf document
func (_gacfb *PdfReader) GetPreviousRevision() (*PdfReader, error) {
	if _gacfb._ccade.GetRevisionNumber() == 0 {
		return nil, _gb.New("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0065xi\u0073\u0074")
	}
	if _bgfdb, _cgbge := _gacfb._dcbb[_gacfb]; _cgbge {
		return _bgfdb, nil
	}
	_gcdf, _ggceg := _gacfb._ccade.GetPreviousRevisionReadSeeker()
	if _ggceg != nil {
		return nil, _ggceg
	}
	_dagac, _ggceg := _acbcg(_gcdf, _gacfb._daae, _gacfb._dfceg, "\u006do\u0064\u0065\u006c\u003aG\u0065\u0074\u0050\u0072\u0065v\u0069o\u0075s\u0052\u0065\u0076\u0069\u0073\u0069\u006fn")
	if _ggceg != nil {
		return nil, _ggceg
	}
	_gacfb._acgcb[_gacfb._ccade.GetRevisionNumber()-1] = _dagac
	_gacfb._dcbb[_gacfb] = _dagac
	_dagac._dcbb = _gacfb._dcbb
	return _dagac, nil
}

func (_fdgee *PdfAcroForm) filteredFields(_eebc FieldFilterFunc, _fgeac bool) []*PdfField {
	if _fdgee == nil {
		return nil
	}
	return _fggc(_fdgee.Fields, _eebc, _fgeac)
}

func (_gagg *PdfReader) newPdfAnnotationSoundFromDict(_babf *_bgd.PdfObjectDictionary) (*PdfAnnotationSound, error) {
	_cbebg := PdfAnnotationSound{}
	_dgd, _aca := _gagg.newPdfAnnotationMarkupFromDict(_babf)
	if _aca != nil {
		return nil, _aca
	}
	_cbebg.PdfAnnotationMarkup = _dgd
	_cbebg.Name = _babf.Get("\u004e\u0061\u006d\u0065")
	_cbebg.Sound = _babf.Get("\u0053\u006f\u0075n\u0064")
	return &_cbebg, nil
}

// SetPrintPageRange sets the value of the printPageRange.
func (_ebceg *ViewerPreferences) SetPrintPageRange(printPageRange []int) {
	_ebceg._gdfab = printPageRange
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_egbd *PdfFunctionType0) Evaluate(x []float64) ([]float64, error) {
	if len(x) != _egbd.NumInputs {
		_fg.Log.Error("\u004eu\u006d\u0062e\u0072\u0020\u006f\u0066 \u0069\u006e\u0070u\u0074\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061tc\u0068\u0069\u006eg\u0020\u0077h\u0061\u0074\u0020\u0069\u0073\u0020n\u0065\u0065d\u0065\u0064")
		return nil, _gb.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	}
	if _egbd._bbfbe == nil {
		_dcbeg := _egbd.processSamples()
		if _dcbeg != nil {
			return nil, _dcbeg
		}
	}
	_ddbgg := _egbd.Encode
	if _ddbgg == nil {
		_ddbgg = []float64{}
		for _gfga := 0; _gfga < len(_egbd.Size); _gfga++ {
			_ddbgg = append(_ddbgg, 0)
			_ddbgg = append(_ddbgg, float64(_egbd.Size[_gfga]-1))
		}
	}
	_efgb := _egbd.Decode
	if _efgb == nil {
		_efgb = _egbd.Range
	}
	_afcccb := make([]int, len(x))
	for _fcafc := 0; _fcafc < len(x); _fcafc++ {
		_gececb := x[_fcafc]
		_befdg := _da.Min(_da.Max(_gececb, _egbd.Domain[2*_fcafc]), _egbd.Domain[2*_fcafc+1])
		_dfeae := _daf.LinearInterpolate(_befdg, _egbd.Domain[2*_fcafc], _egbd.Domain[2*_fcafc+1], _ddbgg[2*_fcafc], _ddbgg[2*_fcafc+1])
		_cadef := _da.Min(_da.Max(_dfeae, 0), float64(_egbd.Size[_fcafc]-1))
		_eadcg := int(_da.Floor(_cadef + 0.5))
		if _eadcg < 0 {
			_eadcg = 0
		} else if _eadcg > _egbd.Size[_fcafc] {
			_eadcg = _egbd.Size[_fcafc] - 1
		}
		_afcccb[_fcafc] = _eadcg
	}
	_befff := _afcccb[0]
	for _eebdg := 1; _eebdg < _egbd.NumInputs; _eebdg++ {
		_dfgcf := _afcccb[_eebdg]
		for _dddcg := 0; _dddcg < _eebdg; _dddcg++ {
			_dfgcf *= _egbd.Size[_dddcg]
		}
		_befff += _dfgcf
	}
	_befff *= _egbd.NumOutputs
	var _eggb []float64
	for _efee := 0; _efee < _egbd.NumOutputs; _efee++ {
		_edfg := _befff + _efee
		if _edfg >= len(_egbd._bbfbe) {
			_fg.Log.Debug("\u0057\u0041\u0052\u004e\u003a \u006e\u006ft\u0020\u0065\u006eo\u0075\u0067\u0068\u0020\u0069\u006ep\u0075\u0074\u0020sa\u006dp\u006c\u0065\u0073\u0020\u0074\u006f\u0020d\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0076\u0061lu\u0065\u0073\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e")
			continue
		}
		_geccg := _egbd._bbfbe[_edfg]
		_geafg := _daf.LinearInterpolate(float64(_geccg), 0, _da.Pow(2, float64(_egbd.BitsPerSample)), _efgb[2*_efee], _efgb[2*_efee+1])
		_eeebg := _da.Min(_da.Max(_geafg, _egbd.Range[2*_efee]), _egbd.Range[2*_efee+1])
		_eggb = append(_eggb, _eeebg)
	}
	return _eggb, nil
}

func (_fecf *PdfAppender) replaceObject(_becb, _beab _bgd.PdfObject) {
	switch _aeag := _becb.(type) {
	case *_bgd.PdfIndirectObject:
		_fecf._baae[_beab] = _aeag.ObjectNumber
	case *_bgd.PdfObjectStream:
		_fecf._baae[_beab] = _aeag.ObjectNumber
	}
}

// ColorToRGB verifies that the input color is an RGB color. Method exists in
// order to satisfy the PdfColorspace interface.
func (_daab *PdfColorspaceDeviceRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_ebgg, _cbgfg := color.(*PdfColorDeviceRGB)
	if !_cbgfg {
		_fg.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072 \u006e\u006f\u0074\u0020\u0064\u0065\u0076\u0069\u0063\u0065 \u0052\u0047\u0042")
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return _ebgg, nil
}

// PdfShadingType4 is a Free-form Gouraud-shaded triangle mesh.
type PdfShadingType4 struct {
	*PdfShading
	BitsPerCoordinate *_bgd.PdfObjectInteger
	BitsPerComponent  *_bgd.PdfObjectInteger
	BitsPerFlag       *_bgd.PdfObjectInteger
	Decode            *_bgd.PdfObjectArray
	Function          []PdfFunction
}

// PdfAnnotationPolyLine represents PolyLine annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolyLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _bgd.PdfObject
	LE       _bgd.PdfObject
	BS       _bgd.PdfObject
	IC       _bgd.PdfObject
	BE       _bgd.PdfObject
	IT       _bgd.PdfObject
	Measure  _bgd.PdfObject
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a CalRGB device.
func (_afaf *PdfColorspaceCalRGB) GetNumComponents() int { return 3 }

// WatermarkImageOptions contains options for configuring the image watermark process.
type WatermarkImageOptions struct {
	Alpha               float64
	FitToWidth          bool
	PreserveAspectRatio bool
	Angle               float64
}

func (_gebe *PdfWriter) checkLicense() error {
	_feca := _gdg.GetLicenseKey()
	if (_feca == nil || !_feca.IsLicensed()) && !_geced {
		_f.Printf("\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020c\u006f\u0070\u0079\u0020\u006f\u0066\u0020\u0055\u006e\u0069P\u0044\u0046\u000a")
		_f.Println("-\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u0066\u0072e\u0065\u0020\u0074\u0072\u0069\u0061\u006c l\u0069\u0063\u0065\u006es\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070s:\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return _gb.New("\u0075\u006e\u0069\u0070d\u0066\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020c\u006fd\u0065\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0064")
	}
	return nil
}

func _dfef(_adfdc _bgd.PdfObject) (*PdfFunctionType3, error) {
	_fcadd := &PdfFunctionType3{}
	var _ceeef *_bgd.PdfObjectDictionary
	if _fgae, _dacb := _adfdc.(*_bgd.PdfIndirectObject); _dacb {
		_gdagf, _gbfaf := _fgae.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_gbfaf {
			return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fcadd._ccdd = _fgae
		_ceeef = _gdagf
	} else if _gaad, _gdcf := _adfdc.(*_bgd.PdfObjectDictionary); _gdcf {
		_ceeef = _gaad
	} else {
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cdbddc, _cafbd := _bgd.TraceToDirectObject(_ceeef.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_bgd.PdfObjectArray)
	if !_cafbd {
		_fg.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _cdbddc.Len() != 2 {
		_fg.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _gb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_dffcg, _abdbe := _cdbddc.ToFloat64Array()
	if _abdbe != nil {
		return nil, _abdbe
	}
	_fcadd.Domain = _dffcg
	_cdbddc, _cafbd = _bgd.TraceToDirectObject(_ceeef.Get("\u0052\u0061\u006eg\u0065")).(*_bgd.PdfObjectArray)
	if _cafbd {
		if _cdbddc.Len() < 0 || _cdbddc.Len()%2 != 0 {
			return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_eece, _gggd := _cdbddc.ToFloat64Array()
		if _gggd != nil {
			return nil, _gggd
		}
		_fcadd.Range = _eece
	}
	_cdbddc, _cafbd = _bgd.TraceToDirectObject(_ceeef.Get("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es")).(*_bgd.PdfObjectArray)
	if !_cafbd {
		_fg.Log.Error("\u0046\u0075\u006ect\u0069\u006f\u006e\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_fcadd.Functions = []PdfFunction{}
	for _, _bafeg := range _cdbddc.Elements() {
		_agffa, _geffcg := _fbbb(_bafeg)
		if _geffcg != nil {
			return nil, _geffcg
		}
		_fcadd.Functions = append(_fcadd.Functions, _agffa)
	}
	_cdbddc, _cafbd = _bgd.TraceToDirectObject(_ceeef.Get("\u0042\u006f\u0075\u006e\u0064\u0073")).(*_bgd.PdfObjectArray)
	if !_cafbd {
		_fg.Log.Error("B\u006fu\u006e\u0064\u0073\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_ebcec, _abdbe := _cdbddc.ToFloat64Array()
	if _abdbe != nil {
		return nil, _abdbe
	}
	_fcadd.Bounds = _ebcec
	if len(_fcadd.Bounds) != len(_fcadd.Functions)-1 {
		_fg.Log.Error("B\u006f\u0075\u006e\u0064\u0073\u0020\u0028\u0025\u0064)\u0020\u0061\u006e\u0064\u0020\u006e\u0075m \u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029 n\u006f\u0074 \u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067", len(_fcadd.Bounds), len(_fcadd.Functions))
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_cdbddc, _cafbd = _bgd.TraceToDirectObject(_ceeef.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_bgd.PdfObjectArray)
	if !_cafbd {
		_fg.Log.Error("E\u006ec\u006f\u0064\u0065\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_defgf, _abdbe := _cdbddc.ToFloat64Array()
	if _abdbe != nil {
		return nil, _abdbe
	}
	_fcadd.Encode = _defgf
	if len(_fcadd.Encode) != 2*len(_fcadd.Functions) {
		_fg.Log.Error("\u004c\u0065\u006e\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0020\u0028\u0025\u0064\u0029 \u0061\u006e\u0064\u0020\u006e\u0075\u006d\u0020\u0066\u0075\u006e\u0063\u0074i\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029\u0020\u006e\u006f\u0074 m\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u0075\u0070", len(_fcadd.Encode), len(_fcadd.Functions))
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return _fcadd, nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// L (range 0-100), A (range -100-100) and B (range -100-100) components of
// the color.
func (_bfaf *PdfColorspaceLab) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bbec := vals[0]
	if _bbec < 0.0 || _bbec > 100.0 {
		_fg.Log.Debug("\u004c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0030-\u0031\u0030\u0030\u0029", _bbec)
		return nil, ErrColorOutOfRange
	}
	_addf := vals[1]
	_bggcc := float64(-100)
	_gfcg := float64(100)
	if len(_bfaf.Range) > 1 {
		_bggcc = _bfaf.Range[0]
		_gfcg = _bfaf.Range[1]
	}
	if _addf < _bggcc || _addf > _gfcg {
		_fg.Log.Debug("\u0041\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _addf, _bggcc, _gfcg)
		return nil, ErrColorOutOfRange
	}
	_cfdaa := vals[2]
	_bgab := float64(-100)
	_gffg := float64(100)
	if len(_bfaf.Range) > 3 {
		_bgab = _bfaf.Range[2]
		_gffg = _bfaf.Range[3]
	}
	if _cfdaa < _bgab || _cfdaa > _gffg {
		_fg.Log.Debug("\u0062\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _cfdaa, _bgab, _gffg)
		return nil, ErrColorOutOfRange
	}
	_defcb := NewPdfColorLab(_bbec, _addf, _cfdaa)
	return _defcb, nil
}

func (_cgdad *PdfWriter) adjustXRefAffectedVersion(_gbcca bool) {
	if _gbcca && _cgdad._egbga.Major == 1 && _cgdad._egbga.Minor < 5 {
		_cgdad._egbga.Minor = 5
	}
}

// NewStandard14FontMustCompile returns the standard 14 font named `basefont` as a *PdfFont.
// If `basefont` is one of the 14 Standard14Font values defined above then NewStandard14FontMustCompile
// is guaranteed to succeed.
func NewStandard14FontMustCompile(basefont StdFontName) *PdfFont {
	_faagf, _eegc := NewStandard14Font(basefont)
	if _eegc != nil {
		panic(_f.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0031\u0034\u0046\u006f\u006e\u0074 \u0025\u0023\u0071", basefont))
	}
	return _faagf
}

// ToPdfObject implements interface PdfModel.
func (_bfc *PdfActionImportData) ToPdfObject() _bgd.PdfObject {
	_bfc.PdfAction.ToPdfObject()
	_fdg := _bfc._fab
	_cfbd := _fdg.PdfObject.(*_bgd.PdfObjectDictionary)
	_cfbd.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeImportData)))
	if _bfc.F != nil {
		_cfbd.Set("\u0046", _bfc.F.ToPdfObject())
	}
	return _fdg
}

// GetModelFromPrimitive returns the model corresponding to the `primitive` PdfObject.
func (_adbbb *modelManager) GetModelFromPrimitive(primitive _bgd.PdfObject) PdfModel {
	_adbbb._bagb.RLock()
	defer _adbbb._bagb.RUnlock()
	model, _dfbcb := _adbbb._bcdf[primitive]
	if !_dfbcb {
		return nil
	}
	return model
}

// NewGrayImageFromGoImage creates a new grayscale unidoc Image from a golang Image.
func (_aedd DefaultImageHandler) NewGrayImageFromGoImage(goimg _fc.Image) (*Image, error) {
	_dbcgg := goimg.Bounds()
	_dfbdd := &Image{Width: int64(_dbcgg.Dx()), Height: int64(_dbcgg.Dy()), ColorComponents: 1, BitsPerComponent: 8}
	switch _bgfcc := goimg.(type) {
	case *_fc.Gray:
		if len(_bgfcc.Pix) != _dbcgg.Dx()*_dbcgg.Dy() {
			_cbfce, _edccb := _daf.GrayConverter.Convert(goimg)
			if _edccb != nil {
				return nil, _edccb
			}
			_dfbdd.Data = _cbfce.Pix()
		} else {
			_dfbdd.Data = _bgfcc.Pix
		}
	case *_fc.Gray16:
		_dfbdd.BitsPerComponent = 16
		if len(_bgfcc.Pix) != _dbcgg.Dx()*_dbcgg.Dy()*2 {
			_gaeg, _gfead := _daf.Gray16Converter.Convert(goimg)
			if _gfead != nil {
				return nil, _gfead
			}
			_dfbdd.Data = _gaeg.Pix()
		} else {
			_dfbdd.Data = _bgfcc.Pix
		}
	case _daf.Image:
		_gafga := _bgfcc.Base()
		if _gafga.ColorComponents == 1 {
			_dfbdd.BitsPerComponent = int64(_gafga.BitsPerComponent)
			_dfbdd.Data = _gafga.Data
			return _dfbdd, nil
		}
		_eeged, _bced := _daf.GrayConverter.Convert(goimg)
		if _bced != nil {
			return nil, _bced
		}
		_dfbdd.Data = _eeged.Pix()
	default:
		_cbdeb, _dcaaa := _daf.GrayConverter.Convert(goimg)
		if _dcaaa != nil {
			return nil, _dcaaa
		}
		_dfbdd.Data = _cbdeb.Pix()
	}
	return _dfbdd, nil
}

// L returns the value of the L component of the color.
func (_dfcg *PdfColorLab) L() float64 { return _dfcg[0] }

func (_gfcbe *pdfFontSimple) getFontEncoding() (_edgc string, _ecfb map[_dabf.CharCode]_dabf.GlyphName, _cfdcd error) {
	_edgc = "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"
	if _cdcbc, _dbdad := _gddca[_gfcbe._eebe]; _dbdad {
		_edgc = _cdcbc
	} else if _gfcbe.fontFlags()&_gdegf != 0 {
		for _dcaa, _dddb := range _gddca {
			if _ef.Contains(_gfcbe._eebe, _dcaa) {
				_edgc = _dddb
				break
			}
		}
	}
	if _gfcbe.Encoding == nil {
		return _edgc, nil, nil
	}
	switch _cggbd := _gfcbe.Encoding.(type) {
	case *_bgd.PdfObjectName:
		return string(*_cggbd), nil, nil
	case *_bgd.PdfObjectDictionary:
		_gdba, _bgddb := _bgd.GetName(_cggbd.Get("\u0042\u0061\u0073e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
		if _bgddb {
			_edgc = _gdba.String()
		}
		if _dbegd := _cggbd.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"); _dbegd != nil {
			_fbbab, _gdedf := _bgd.GetArray(_dbegd)
			if !_gdedf {
				_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042a\u0064\u0020\u0066on\u0074\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u003d\u0025\u002b\u0076\u0020\u0044\u0069f\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073=\u0025\u0054", _cggbd, _cggbd.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"))
				return "", nil, _bgd.ErrTypeError
			}
			_ecfb, _cfdcd = _dabf.FromFontDifferences(_fbbab)
		}
		return _edgc, _ecfb, _cfdcd
	default:
		_fg.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0072\u0020\u0064\u0069\u0063t\u0020\u0028\u0025\u0054\u0029\u0020\u0025\u0073", _gfcbe.Encoding, _gfcbe.Encoding)
		return "", nil, _bgd.ErrTypeError
	}
}

// ToPdfObject converts date to a PDF string object.
func (_gdfea *PdfDate) ToPdfObject() _bgd.PdfObject {
	_dbbdb := _f.Sprintf("\u0044\u003a\u0025\u002e\u0034\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e2\u0064\u0025\u0063\u0025\u002e2\u0064\u0027%\u002e\u0032\u0064\u0027", _gdfea._ccgca, _gdfea._agbb, _gdfea._bdef, _gdfea._ccdga, _gdfea._cfba, _gdfea._cgde, _gdfea._eceda, _gdfea._bgcab, _gdfea._dgbfg)
	return _bgd.MakeString(_dbbdb)
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for an RGB device.
func (_agce *PdfColorspaceDeviceRGB) GetNumComponents() int { return 3 }

// PdfActionRendition represents a Rendition action.
type PdfActionRendition struct {
	*PdfAction
	R  _bgd.PdfObject
	AN _bgd.PdfObject
	OP _bgd.PdfObject
	JS _bgd.PdfObject
}

func (_adad *PdfReader) newPdfActionSoundFromDict(_abe *_bgd.PdfObjectDictionary) (*PdfActionSound, error) {
	return &PdfActionSound{Sound: _abe.Get("\u0053\u006f\u0075n\u0064"), Volume: _abe.Get("\u0056\u006f\u006c\u0075\u006d\u0065"), Synchronous: _abe.Get("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073"), Repeat: _abe.Get("\u0052\u0065\u0070\u0065\u0061\u0074"), Mix: _abe.Get("\u004d\u0069\u0078")}, nil
}

func (_dga *PdfReader) newPdfAnnotationCaretFromDict(_bec *_bgd.PdfObjectDictionary) (*PdfAnnotationCaret, error) {
	_ggae := PdfAnnotationCaret{}
	_ceef, _egb := _dga.newPdfAnnotationMarkupFromDict(_bec)
	if _egb != nil {
		return nil, _egb
	}
	_ggae.PdfAnnotationMarkup = _ceef
	_ggae.RD = _bec.Get("\u0052\u0044")
	_ggae.Sy = _bec.Get("\u0053\u0079")
	return &_ggae, nil
}

func _dcag() *modelManager {
	_gabb := modelManager{}
	_gabb._dagg = map[PdfModel]_bgd.PdfObject{}
	_gabb._bcdf = map[_bgd.PdfObject]PdfModel{}
	_gabb._cegbb = _g.RWMutex{}
	_gabb._bagb = _g.RWMutex{}
	return &_gabb
}

// GetNumPages returns the number of pages in the document.
func (_bfedcf *PdfReader) GetNumPages() (int, error) {
	if _bfedcf._ccade.GetCrypter() != nil && !_bfedcf._ccade.IsAuthenticated() {
		return 0, _f.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	return len(_bfedcf._gfggf), nil
}

// NewPdfPageResourcesColorspaces returns a new PdfPageResourcesColorspaces object.
func NewPdfPageResourcesColorspaces() *PdfPageResourcesColorspaces {
	_adegd := &PdfPageResourcesColorspaces{}
	_adegd.Names = []string{}
	_adegd.Colorspaces = map[string]PdfColorspace{}
	_adegd._dggea = &_bgd.PdfIndirectObject{}
	return _adegd
}

// GetMCID returns the MCID of the KValue.
func (_fecfa *KValue) GetMCID() *int { return _fecfa._ecdf }

// NewPdfFilespecFromObj creates and returns a new PdfFilespec object.
func NewPdfFilespecFromObj(obj _bgd.PdfObject) (*PdfFilespec, error) {
	_ebfb := &PdfFilespec{}
	var _bffeg *_bgd.PdfObjectDictionary
	if _daddc, _adgac := _bgd.GetIndirect(obj); _adgac {
		_ebfb._bbbfb = _daddc
		_edeb, _dbea := _bgd.GetDict(_daddc.PdfObject)
		if !_dbea {
			_fg.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _bgd.ErrTypeError
		}
		_bffeg = _edeb
	} else if _gcgfad, _fecd := _bgd.GetDict(obj); _fecd {
		_ebfb._bbbfb = _gcgfad
		_bffeg = _gcgfad
	} else {
		_fg.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", obj)
		return nil, _bgd.ErrTypeError
	}
	if _bffeg == nil {
		_fg.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _gb.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _fadfd := _bffeg.Get("\u0054\u0079\u0070\u0065"); _fadfd != nil {
		_feafc, _gbbaf := _fadfd.(*_bgd.PdfObjectName)
		if !_gbbaf {
			_fg.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _fadfd)
		} else {
			if *_feafc != "\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063" {
				_fg.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070e\u0063\u0074\u0065\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063 \u0028\u0025\u0073\u0029", *_feafc)
			}
		}
	}
	if _fbaa := _bffeg.Get("\u0046\u0053"); _fbaa != nil {
		_ebfb.FS = _fbaa
	}
	if _gecgfe := _bffeg.Get("\u0046"); _gecgfe != nil {
		_ebfb.F = _gecgfe
	}
	if _bcadd := _bffeg.Get("\u0055\u0046"); _bcadd != nil {
		_ebfb.UF = _bcadd
	}
	if _ccfa := _bffeg.Get("\u0044\u004f\u0053"); _ccfa != nil {
		_ebfb.DOS = _ccfa
	}
	if _agdc := _bffeg.Get("\u004d\u0061\u0063"); _agdc != nil {
		_ebfb.Mac = _agdc
	}
	if _edaf := _bffeg.Get("\u0055\u006e\u0069\u0078"); _edaf != nil {
		_ebfb.Unix = _edaf
	}
	if _cfce := _bffeg.Get("\u0049\u0044"); _cfce != nil {
		_ebfb.ID = _cfce
	}
	if _deed := _bffeg.Get("\u0056"); _deed != nil {
		_ebfb.V = _deed
	}
	if _cddc := _bffeg.Get("\u0045\u0046"); _cddc != nil {
		_ebfb.EF = _cddc
	}
	if _egde := _bffeg.Get("\u0052\u0046"); _egde != nil {
		_ebfb.RF = _egde
	}
	if _fdebd := _bffeg.Get("\u0044\u0065\u0073\u0063"); _fdebd != nil {
		_ebfb.Desc = _fdebd
	}
	if _bbeb := _bffeg.Get("\u0043\u0049"); _bbeb != nil {
		_ebfb.CI = _bbeb
	}
	if _efcg := _bffeg.Get("\u0041\u0046\u0052\u0065\u006c\u0061\u0074\u0069\u006fn\u0073\u0068\u0069\u0070"); _efcg != nil {
		_ebfb.AFRelationship = _efcg
	}
	return _ebfb, nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_fcab *Permissions) GetContainingPdfObject() _bgd.PdfObject { return _fcab._cfgcg }

// AddContentStreamByString adds content stream by string. Puts the content
// string into a stream object and points the content stream towards it.
func (_feeeb *PdfPage) AddContentStreamByString(contentStr string) error {
	_gecbb, _bcgdef := _bgd.MakeStream([]byte(contentStr), _bgd.NewFlateEncoder())
	if _bcgdef != nil {
		return _bcgdef
	}
	if _feeeb.Contents == nil {
		_feeeb.Contents = _gecbb
	} else {
		_gbeff := _bgd.TraceToDirectObject(_feeeb.Contents)
		_bcdaa, _geege := _gbeff.(*_bgd.PdfObjectArray)
		if !_geege {
			_bcdaa = _bgd.MakeArray(_gbeff)
		}
		_bcdaa.Append(_gecbb)
		_feeeb.Contents = _bcdaa
	}
	return nil
}

// ImageHandler interface implements common image loading and processing tasks.
// Implementing as an interface allows for the possibility to use non-standard libraries for faster
// loading and processing of images.
type ImageHandler interface {

	// Read any image type and load into a new Image object.
	Read(_baee _ca.Reader) (*Image, error)

	// NewImageFromGoImage loads a NRGBA32 unidoc Image from a standard Go image structure.
	NewImageFromGoImage(_egggc _fc.Image) (*Image, error)

	// NewGrayImageFromGoImage loads a grayscale unidoc Image from a standard Go image structure.
	NewGrayImageFromGoImage(_cafef _fc.Image) (*Image, error)

	// Compress an image.
	Compress(_eabcg *Image, _bedabb int64) (*Image, error)
}

// PdfColorCalRGB represents a color in the Colorimetric CIE RGB colorspace.
// A, B, C components
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorCalRGB [3]float64

func (_fdbafg *PdfReader) newPdfSignatureFromIndirect(_gfcgb *_bgd.PdfIndirectObject) (*PdfSignature, error) {
	_cebc, _badg := _gfcgb.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_badg {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		return nil, ErrTypeCheck
	}
	if _bffde, _ebdg := _fdbafg._gggb.GetModelFromPrimitive(_gfcgb).(*PdfSignature); _ebdg {
		return _bffde, nil
	}
	_abead := &PdfSignature{}
	_abead._ddggd = _gfcgb
	_abead.Type, _ = _bgd.GetName(_cebc.Get("\u0054\u0079\u0070\u0065"))
	_abead.Filter, _badg = _bgd.GetName(_cebc.Get("\u0046\u0069\u006c\u0074\u0065\u0072"))
	if !_badg {
		_fg.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053i\u0067\u006e\u0061\u0074\u0075r\u0065\u0020\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_abead.SubFilter, _ = _bgd.GetName(_cebc.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r"))
	_abead.Contents, _badg = _bgd.GetString(_cebc.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"))
	if !_badg {
		_fg.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0065\u006e\u0074\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	if _edfac, _dbdc := _bgd.GetArray(_cebc.Get("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e")); _dbdc {
		_abead.Reference = _bgd.MakeArray()
		for _, _cgbed := range _edfac.Elements() {
			_cefgd, _efade := _bgd.GetDict(_cgbed)
			if !_efade {
				_fg.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020R\u0065\u0066e\u0072\u0065\u006e\u0063\u0065\u0020\u0063\u006fn\u0074\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0061\u0074\u0065\u0064")
				return nil, ErrInvalidAttribute
			}
			_gbfce, _edgfd := _fdbafg.newPdfSignatureReferenceFromDict(_cefgd)
			if _edgfd != nil {
				return nil, _edgfd
			}
			_abead.Reference.Append(_gbfce.ToPdfObject())
		}
	}
	_abead.Cert = _cebc.Get("\u0043\u0065\u0072\u0074")
	_abead.ByteRange, _ = _bgd.GetArray(_cebc.Get("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e"))
	_abead.Changes, _ = _bgd.GetArray(_cebc.Get("\u0043h\u0061\u006e\u0067\u0065\u0073"))
	_abead.Name, _ = _bgd.GetString(_cebc.Get("\u004e\u0061\u006d\u0065"))
	_abead.M, _ = _bgd.GetString(_cebc.Get("\u004d"))
	_abead.Location, _ = _bgd.GetString(_cebc.Get("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e"))
	_abead.Reason, _ = _bgd.GetString(_cebc.Get("\u0052\u0065\u0061\u0073\u006f\u006e"))
	_abead.ContactInfo, _ = _bgd.GetString(_cebc.Get("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f"))
	_abead.R, _ = _bgd.GetInt(_cebc.Get("\u0052"))
	_abead.V, _ = _bgd.GetInt(_cebc.Get("\u0056"))
	_abead.PropBuild, _ = _bgd.GetDict(_cebc.Get("\u0050\u0072\u006f\u0070\u005f\u0042\u0075\u0069\u006c\u0064"))
	_abead.PropAuthTime, _ = _bgd.GetInt(_cebc.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0069\u006d\u0065"))
	_abead.PropAuthType, _ = _bgd.GetName(_cebc.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0079\u0070\u0065"))
	_fdbafg._gggb.Register(_gfcgb, _abead)
	return _abead, nil
}

func (_bcaggd *PdfColorspaceDeviceGray) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079"
}

func (_daag *LTV) getCerts(_ddcgg []*_cb.Certificate) ([][]byte, error) {
	_ccgcg := make([][]byte, 0, len(_ddcgg))
	for _, _ccfbd := range _ddcgg {
		_ccgcg = append(_ccgcg, _ccfbd.Raw)
	}
	return _ccgcg, nil
}

func (_efdfb *PdfWriter) makeOffSetReference(_eegea int64) {
	_baebd := _f.Sprintf("\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u000a\u0025\u0064\u000a", _eegea)
	_efdfb.writeString(_baebd)
	_efdfb.writeString("\u0025\u0025\u0045\u004f\u0046\u000a")
}

// AcroFormNeedsRepair returns true if the document contains widget annotations
// linked to fields which are not referenced in the AcroForm. The AcroForm can
// be repaired using the RepairAcroForm method of the reader.
func (_bgbed *PdfReader) AcroFormNeedsRepair() (bool, error) {
	var _ffacb []*PdfField
	if _bgbed.AcroForm != nil {
		_ffacb = _bgbed.AcroForm.AllFields()
	}
	_gcgdb := make(map[*PdfField]struct{}, len(_ffacb))
	for _, _dabca := range _ffacb {
		_gcgdb[_dabca] = struct{}{}
	}
	for _, _fbafdd := range _bgbed.PageList {
		_fgbfb, _dfgefg := _fbafdd.GetAnnotations()
		if _dfgefg != nil {
			return false, _dfgefg
		}
		for _, _cgbae := range _fgbfb {
			_dcdd, _eadf := _cgbae.GetContext().(*PdfAnnotationWidget)
			if !_eadf {
				continue
			}
			_fada := _dcdd.Field()
			if _fada == nil {
				return true, nil
			}
			if _, _beada := _gcgdb[_fada]; !_beada {
				return true, nil
			}
		}
	}
	return false, nil
}

// NewPdfOutputIntentFromPdfObject creates a new PdfOutputIntent from the input core.PdfObject.
func NewPdfOutputIntentFromPdfObject(object _bgd.PdfObject) (*PdfOutputIntent, error) {
	_adfgf := &PdfOutputIntent{}
	if _bfbea := _adfgf.ParsePdfObject(object); _bfbea != nil {
		return nil, _bfbea
	}
	return _adfgf, nil
}

// Add appends an outline item as a child of the current outline item.
func (_caffe *OutlineItem) Add(item *OutlineItem) { _caffe.Entries = append(_caffe.Entries, item) }

// SetImageHandler sets the image handler used by the package.
func SetImageHandler(imgHandling ImageHandler) { ImageHandling = imgHandling }

func (_fegad Image) getBase() _daf.ImageBase {
	return _daf.NewImageBase(int(_fegad.Width), int(_fegad.Height), int(_fegad.BitsPerComponent), _fegad.ColorComponents, _fegad.Data, _fegad._bdgdb, _fegad._agcea)
}

// SetKDict sets the KDict for the KValue.
func (_egfbd *KValue) SetKDict(kDict *KDict) { _egfbd.Clear(); _egfbd._fgcbd = kDict }

func (_fbbae *PdfReader) flattenFieldsWithOpts(_egebf bool, _bcabb FieldAppearanceGenerator, _edgb *FieldFlattenOpts) error {
	if _edgb == nil {
		_edgb = &FieldFlattenOpts{}
	}
	var _dcac bool
	_efefb := map[*PdfAnnotation]bool{}
	{
		var _eaaba []*PdfField
		_fcdb := _fbbae.AcroForm
		if _fcdb != nil {
			if _edgb.FilterFunc != nil {
				_eaaba = _fcdb.filteredFields(_edgb.FilterFunc, true)
				_dcac = _fcdb.Fields != nil && len(*_fcdb.Fields) > 0
			} else {
				_eaaba = _fcdb.AllFields()
			}
		}
		for _, _ecdde := range _eaaba {
			if len(_ecdde.Annotations) < 1 {
				_fg.Log.Debug("\u004e\u006f\u0020\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u006f\u0075\u006ed\u0020\u0066\u006f\u0072\u003a\u0020\u0025v\u002c\u0020\u006c\u006f\u006f\u006b\u0020\u0069\u006e\u0074\u006f \u004b\u0069\u0064\u0073\u0020\u004f\u0062\u006a\u0065\u0063\u0074", _ecdde.PartialName())
				for _cafa, _fafce := range _ecdde.Kids {
					for _, _fgga := range _fafce.Annotations {
						_efefb[_fgga.PdfAnnotation] = _ecdde.V != nil
						if _fafce.V == nil {
							_fafce.V = _ecdde.V
						}
						if _fafce.T == nil {
							_fafce.T = _bgd.MakeString(_f.Sprintf("\u0025\u0073\u0023%\u0064", _ecdde.PartialName(), _cafa))
						}
						if _bcabb != nil {
							_ebbbb, _efdf := _bcabb.GenerateAppearanceDict(_fcdb, _fafce, _fgga)
							if _efdf != nil {
								return _efdf
							}
							_fgga.AP = _ebbbb
						}
					}
				}
			}
			for _, _acaca := range _ecdde.Annotations {
				_efefb[_acaca.PdfAnnotation] = _ecdde.V != nil
				if _bcabb != nil {
					_aagfd, _bgda := _bcabb.GenerateAppearanceDict(_fcdb, _ecdde, _acaca)
					if _bgda != nil {
						return _bgda
					}
					_acaca.AP = _aagfd
				}
			}
		}
	}
	if _egebf {
		for _, _aceb := range _fbbae.PageList {
			_deab, _ddfd := _aceb.GetAnnotations()
			if _ddfd != nil {
				return _ddfd
			}
			for _, _effaa := range _deab {
				_efefb[_effaa] = true
			}
		}
	}
	for _, _gdfb := range _fbbae.PageList {
		_fcdeg := _gdfb.flattenFieldsWithOpts(_bcabb, _edgb, _efefb)
		if _fcdeg != nil {
			return _fcdeg
		}
	}
	if !_dcac {
		_fbbae.AcroForm = nil
	}
	return nil
}

func _ebgcc(_dfgg *_bgd.PdfObjectDictionary) (*PdfShadingType7, error) {
	_ggggab := PdfShadingType7{}
	_gfdg := _dfgg.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _gfdg == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_acdbc, _bacfed := _gfdg.(*_bgd.PdfObjectInteger)
	if !_bacfed {
		_fg.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _gfdg)
		return nil, _bgd.ErrTypeError
	}
	_ggggab.BitsPerCoordinate = _acdbc
	_gfdg = _dfgg.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _gfdg == nil {
		_fg.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_acdbc, _bacfed = _gfdg.(*_bgd.PdfObjectInteger)
	if !_bacfed {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _gfdg)
		return nil, _bgd.ErrTypeError
	}
	_ggggab.BitsPerComponent = _acdbc
	_gfdg = _dfgg.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _gfdg == nil {
		_fg.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_acdbc, _bacfed = _gfdg.(*_bgd.PdfObjectInteger)
	if !_bacfed {
		_fg.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _gfdg)
		return nil, _bgd.ErrTypeError
	}
	_ggggab.BitsPerComponent = _acdbc
	_gfdg = _dfgg.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _gfdg == nil {
		_fg.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_dcdfa, _bacfed := _gfdg.(*_bgd.PdfObjectArray)
	if !_bacfed {
		_fg.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _gfdg)
		return nil, _bgd.ErrTypeError
	}
	_ggggab.Decode = _dcdfa
	if _dcad := _dfgg.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _dcad != nil {
		_ggggab.Function = []PdfFunction{}
		if _eecg, _gebgd := _dcad.(*_bgd.PdfObjectArray); _gebgd {
			for _, _ecfeg := range _eecg.Elements() {
				_ceefb, _bccge := _fbbb(_ecfeg)
				if _bccge != nil {
					_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bccge)
					return nil, _bccge
				}
				_ggggab.Function = append(_ggggab.Function, _ceefb)
			}
		} else {
			_feedd, _bddeb := _fbbb(_dcad)
			if _bddeb != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bddeb)
				return nil, _bddeb
			}
			_ggggab.Function = append(_ggggab.Function, _feedd)
		}
	}
	return &_ggggab, nil
}

// ToImage converts an object to an Image which can be transformed or saved out.
// The image data is decoded and the Image returned.
func (_agddgb *XObjectImage) ToImage() (*Image, error) {
	_ddgcb := &Image{}
	if _agddgb.Height == nil {
		return nil, _gb.New("\u0068e\u0069\u0067\u0068\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062u\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_ddgcb.Height = *_agddgb.Height
	if _agddgb.Width == nil {
		return nil, _gb.New("\u0077\u0069\u0064th\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_ddgcb.Width = *_agddgb.Width
	if _agddgb.BitsPerComponent == nil {
		switch _agddgb.Filter.(type) {
		case *_bgd.CCITTFaxEncoder, *_bgd.JBIG2Encoder:
			_ddgcb.BitsPerComponent = 1
		case *_bgd.LZWEncoder, *_bgd.RunLengthEncoder:
			_ddgcb.BitsPerComponent = 8
		default:
			return nil, _gb.New("\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
		}
	} else {
		_ddgcb.BitsPerComponent = *_agddgb.BitsPerComponent
	}
	_ddgcb.ColorComponents = _agddgb.ColorSpace.GetNumComponents()
	_agddgb._befec.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _bgd.MakeInteger(int64(_ddgcb.ColorComponents)))
	_gdcecf, _gdefd := _bgd.DecodeStream(_agddgb._befec)
	if _gdefd != nil {
		return nil, _gdefd
	}
	_ddgcb.Data = _gdcecf
	if _agddgb.Decode != nil {
		_egffa, _bgfgg := _agddgb.Decode.(*_bgd.PdfObjectArray)
		if !_bgfgg {
			_fg.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020D\u0065\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074")
			return nil, _gb.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065")
		}
		_geddf, _gead := _egffa.ToFloat64Array()
		if _gead != nil {
			return nil, _gead
		}
		switch _agddgb.ColorSpace.(type) {
		case *PdfColorspaceDeviceCMYK:
			_ddegc := _agddgb.ColorSpace.DecodeArray()
			if _ddegc[0] == _geddf[0] && _ddegc[1] == _geddf[1] && _ddegc[2] == _geddf[2] && _ddegc[3] == _geddf[3] {
				_ddgcb._agcea = _geddf
			}
		default:
			_ddgcb._agcea = _geddf
		}
	}
	return _ddgcb, nil
}

func _eeebd() string {
	_fcbfa := "\u0051\u0057\u0045\u0052\u0054\u0059\u0055\u0049\u004f\u0050\u0041S\u0044\u0046\u0047\u0048\u004a\u004b\u004c\u005a\u0058\u0043V\u0042\u004e\u004d"
	var _begc _ea.Buffer
	for _fefgb := 0; _fefgb < 6; _fefgb++ {
		_begc.WriteRune(rune(_fcbfa[_aa.Intn(len(_fcbfa))]))
	}
	return _begc.String()
}

// PdfFilespec represents a file specification which can either refer to an external or embedded file.
type PdfFilespec struct {
	Type           _bgd.PdfObject
	FS             _bgd.PdfObject
	F              _bgd.PdfObject
	UF             _bgd.PdfObject
	DOS            _bgd.PdfObject
	Mac            _bgd.PdfObject
	Unix           _bgd.PdfObject
	ID             _bgd.PdfObject
	V              _bgd.PdfObject
	EF             _bgd.PdfObject
	RF             _bgd.PdfObject
	Desc           _bgd.PdfObject
	CI             _bgd.PdfObject
	AFRelationship _bgd.PdfObject
	_bbbfb         _bgd.PdfObject
}

// C returns the value of the C component of the color.
func (_cdda *PdfColorCalRGB) C() float64 { return _cdda[2] }

// AlphaMapFunc represents a alpha mapping function: byte -> byte. Can be used for
// thresholding the alpha channel, i.e. setting all alpha values below threshold to transparent.
type AlphaMapFunc func(_aged byte) byte

// Write outputs the object as it is to be written to file.
func (_bcebaa *PdfTransformParamsDocMDP) Write() []byte { return _bcebaa.ToPdfObject().Write() }

// SetContext sets the sub pattern (context).  Either PdfTilingPattern or PdfShadingPattern.
func (_cffea *PdfPattern) SetContext(ctx PdfModel) { _cffea._ggafd = ctx }

// VariableText contains the common attributes of a variable text.
// The VariableText is typically not used directly, but is can encapsulate by PdfField
// See section 12.7.3.3 "Variable Text" and Table 222 (pp. 434-436 PDF32000_2008).
type VariableText struct {
	DA *_bgd.PdfObjectString
	Q  *_bgd.PdfObjectInteger
	DS *_bgd.PdfObjectString
	RV _bgd.PdfObject
}

// ToGoImage converts the unidoc Image to a golang Image structure.
func (_bcbgd *Image) ToGoImage() (_fc.Image, error) {
	_fg.Log.Trace("\u0043\u006f\u006e\u0076er\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0067\u006f\u0020\u0069\u006d\u0061g\u0065")
	_dbaac, _aaed := _daf.NewImage(int(_bcbgd.Width), int(_bcbgd.Height), int(_bcbgd.BitsPerComponent), _bcbgd.ColorComponents, _bcbgd.Data, _bcbgd._bdgdb, _bcbgd._agcea)
	if _aaed != nil {
		return nil, _aaed
	}
	return _dbaac, nil
}

// GetRevision returns the specific version of the PdfReader for the current Pdf document
func (_dgeab *PdfReader) GetRevision(revisionNumber int) (*PdfReader, error) {
	_ffegg := _dgeab._ccade.GetRevisionNumber()
	if revisionNumber < 0 || revisionNumber > _ffegg {
		return nil, _gb.New("w\u0072\u006f\u006e\u0067 r\u0065v\u0069\u0073\u0069\u006f\u006e \u006e\u0075\u006d\u0062\u0065\u0072")
	}
	if revisionNumber == _ffegg {
		return _dgeab, nil
	}
	if _dgeab._acgcb[revisionNumber] != nil {
		return _dgeab._acgcb[revisionNumber], nil
	}
	_gdgce := _dgeab
	for _efgfc := _ffegg - 1; _efgfc >= revisionNumber; _efgfc-- {
		_eaaa, _edabc := _gdgce.GetPreviousRevision()
		if _edabc != nil {
			return nil, _edabc
		}
		_dgeab._acgcb[_efgfc] = _eaaa
		_gdgce = _eaaa
	}
	return _gdgce, nil
}

// ToPdfObject implements interface PdfModel.
func (_aggg *PdfAnnotationProjection) ToPdfObject() _bgd.PdfObject {
	_aggg.PdfAnnotation.ToPdfObject()
	_dgbe := _aggg._eag
	_dfaa := _dgbe.PdfObject.(*_bgd.PdfObjectDictionary)
	_aggg.appendToPdfDictionary(_dfaa)
	return _dgbe
}

// NewPdfTransformParamsDocMDP create a PdfTransformParamsDocMDP with the specific permissions.
func NewPdfTransformParamsDocMDP(permission _fa.DocMDPPermission) *PdfTransformParamsDocMDP {
	return &PdfTransformParamsDocMDP{Type: _bgd.MakeName("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"), P: _bgd.MakeInteger(int64(permission)), V: _bgd.MakeName("\u0031\u002e\u0032")}
}

func (_ddfcf *PdfFunctionType0) processSamples() error {
	_aeebab := _eaa.ResampleBytes(_ddfcf._eggg, _ddfcf.BitsPerSample)
	_ddfcf._bbfbe = _aeebab
	return nil
}

// AddOutlineTree adds outlines to a PDF file.
func (_bfgda *PdfWriter) AddOutlineTree(outlineTree *PdfOutlineTreeNode) {
	_bfgda._fabdf = outlineTree
}

// NewPdfActionGoToE returns a new "go to embedded" action.
func NewPdfActionGoToE() *PdfActionGoToE {
	_ece := NewPdfAction()
	_eg := &PdfActionGoToE{}
	_eg.PdfAction = _ece
	_ece.SetContext(_eg)
	return _eg
}

// Duplex returns the value of the duplex.
func (_daacf *ViewerPreferences) Duplex() Duplex { return _daacf._affbc }

// GetVersion gets the document version.
func (_gfadf *PdfWriter) GetVersion() _bgd.Version { return _gfadf._egbga }

// DecodeArray returns the range of color component values in CalGray colorspace.
func (_bebg *PdfColorspaceCalGray) DecodeArray() []float64 { return []float64{0.0, 1.0} }

// String returns a string representation of what flags are set.
func (_bdf FieldFlag) String() string {
	_egcgb := ""
	if _bdf == FieldFlagClear {
		_egcgb = "\u0043\u006c\u0065a\u0072"
		return _egcgb
	}
	if _bdf&FieldFlagReadOnly > 0 {
		_egcgb += "\u007cR\u0065\u0061\u0064\u004f\u006e\u006cy"
	}
	if _bdf&FieldFlagRequired > 0 {
		_egcgb += "\u007cR\u0065\u0071\u0075\u0069\u0072\u0065d"
	}
	if _bdf&FieldFlagNoExport > 0 {
		_egcgb += "\u007cN\u006f\u0045\u0078\u0070\u006f\u0072t"
	}
	if _bdf&FieldFlagNoToggleToOff > 0 {
		_egcgb += "\u007c\u004e\u006f\u0054\u006f\u0067\u0067\u006c\u0065T\u006f\u004f\u0066\u0066"
	}
	if _bdf&FieldFlagRadio > 0 {
		_egcgb += "\u007c\u0052\u0061\u0064\u0069\u006f"
	}
	if _bdf&FieldFlagPushbutton > 0 {
		_egcgb += "|\u0050\u0075\u0073\u0068\u0062\u0075\u0074\u0074\u006f\u006e"
	}
	if _bdf&FieldFlagRadiosInUnision > 0 {
		_egcgb += "\u007c\u0052a\u0064\u0069\u006fs\u0049\u006e\u0055\u006e\u0069\u0073\u0069\u006f\u006e"
	}
	if _bdf&FieldFlagMultiline > 0 {
		_egcgb += "\u007c\u004d\u0075\u006c\u0074\u0069\u006c\u0069\u006e\u0065"
	}
	if _bdf&FieldFlagPassword > 0 {
		_egcgb += "\u007cP\u0061\u0073\u0073\u0077\u006f\u0072d"
	}
	if _bdf&FieldFlagFileSelect > 0 {
		_egcgb += "|\u0046\u0069\u006c\u0065\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _bdf&FieldFlagDoNotScroll > 0 {
		_egcgb += "\u007c\u0044\u006fN\u006f\u0074\u0053\u0063\u0072\u006f\u006c\u006c"
	}
	if _bdf&FieldFlagComb > 0 {
		_egcgb += "\u007c\u0043\u006fm\u0062"
	}
	if _bdf&FieldFlagRichText > 0 {
		_egcgb += "\u007cR\u0069\u0063\u0068\u0054\u0065\u0078t"
	}
	if _bdf&FieldFlagDoNotSpellCheck > 0 {
		_egcgb += "\u007c\u0044o\u004e\u006f\u0074S\u0070\u0065\u006c\u006c\u0043\u0068\u0065\u0063\u006b"
	}
	if _bdf&FieldFlagCombo > 0 {
		_egcgb += "\u007c\u0043\u006f\u006d\u0062\u006f"
	}
	if _bdf&FieldFlagEdit > 0 {
		_egcgb += "\u007c\u0045\u0064i\u0074"
	}
	if _bdf&FieldFlagSort > 0 {
		_egcgb += "\u007c\u0053\u006fr\u0074"
	}
	if _bdf&FieldFlagMultiSelect > 0 {
		_egcgb += "\u007c\u004d\u0075l\u0074\u0069\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _bdf&FieldFlagCommitOnSelChange > 0 {
		_egcgb += "\u007cC\u006fm\u006d\u0069\u0074\u004f\u006eS\u0065\u006cC\u0068\u0061\u006e\u0067\u0065"
	}
	return _ef.Trim(_egcgb, "\u007c")
}

func (_deabb *LTV) getOCSPs(_fgfcf []*_cb.Certificate, _adcd map[string]*_cb.Certificate) ([][]byte, error) {
	_dfdc := make([][]byte, 0, len(_fgfcf))
	for _, _dfccbb := range _fgfcf {
		for _, _adfda := range _dfccbb.OCSPServer {
			if _deabb.CertClient.IsCA(_dfccbb) {
				continue
			}
			_egcfd, _bege := _adcd[_dfccbb.Issuer.CommonName]
			if !_bege {
				_fg.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
				continue
			}
			_, _agfag, _cgafc := _deabb.OCSPClient.MakeRequest(_adfda, _dfccbb, _egcfd)
			if _cgafc != nil {
				_fg.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076", _cgafc)
				continue
			}
			_dfdc = append(_dfdc, _agfag)
		}
	}
	return _dfdc, nil
}

func (_bedf *PdfReader) newPdfAnnotationStrikeOut(_defb *_bgd.PdfObjectDictionary) (*PdfAnnotationStrikeOut, error) {
	_aace := PdfAnnotationStrikeOut{}
	_eeb, _agb := _bedf.newPdfAnnotationMarkupFromDict(_defb)
	if _agb != nil {
		return nil, _agb
	}
	_aace.PdfAnnotationMarkup = _eeb
	_aace.QuadPoints = _defb.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_aace, nil
}

// PdfAnnotationText represents Text annotations.
// (Section 12.5.6.4 p. 402).
type PdfAnnotationText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Open       _bgd.PdfObject
	Name       _bgd.PdfObject
	State      _bgd.PdfObject
	StateModel _bgd.PdfObject
}

func (_fcdf *PdfReader) newPdfAnnotationStampFromDict(_bada *_bgd.PdfObjectDictionary) (*PdfAnnotationStamp, error) {
	_gee := PdfAnnotationStamp{}
	_ffe, _ccd := _fcdf.newPdfAnnotationMarkupFromDict(_bada)
	if _ccd != nil {
		return nil, _ccd
	}
	_gee.PdfAnnotationMarkup = _ffe
	_gee.Name = _bada.Get("\u004e\u0061\u006d\u0065")
	return &_gee, nil
}

// NewPdfAnnotation3D returns a new 3d annotation.
func NewPdfAnnotation3D() *PdfAnnotation3D {
	_daec := NewPdfAnnotation()
	_egg := &PdfAnnotation3D{}
	_egg.PdfAnnotation = _daec
	_daec.SetContext(_egg)
	return _egg
}

// DecodeArray returns the range of color component values in DeviceRGB colorspace.
func (_cfab *PdfColorspaceDeviceRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// NewPdfAnnotationSquiggly returns a new text squiggly annotation.
func NewPdfAnnotationSquiggly() *PdfAnnotationSquiggly {
	_ccc := NewPdfAnnotation()
	_aad := &PdfAnnotationSquiggly{}
	_aad.PdfAnnotation = _ccc
	_aad.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ccc.SetContext(_aad)
	return _aad
}

// PdfPageResourcesColorspaces contains the colorspace in the PdfPageResources.
// Needs to have matching name and colorspace map entry. The Names define the order.
type PdfPageResourcesColorspaces struct {
	Names       []string
	Colorspaces map[string]PdfColorspace
	_dggea      *_bgd.PdfIndirectObject
}

type crossReference struct {
	Type int

	// Type 1
	Offset     int64
	Generation int64

	// Type 2
	ObjectNumber int
	Index        int
}

// PdfOutline represents a PDF outline dictionary (Table 152 - p. 376).
type PdfOutline struct {
	PdfOutlineTreeNode
	Parent *PdfOutlineTreeNode
	Count  *int64
	_edgaf *_bgd.PdfIndirectObject
}

func (_gddfa *PdfWriter) setCatalogVersion() {
	_gddfa._aaea.Set("\u0056e\u0072\u0073\u0069\u006f\u006e", _bgd.MakeName(_f.Sprintf("\u0025\u0064\u002e%\u0064", _gddfa._egbga.Major, _gddfa._egbga.Minor)))
}

func _ddfea(_cefbg *_bgd.PdfObjectDictionary) (*PdfShadingType3, error) {
	_beffg := PdfShadingType3{}
	_fbege := _cefbg.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _fbege == nil {
		_fg.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0043\u006f\u006f\u0072\u0064\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_decaf, _gcfa := _fbege.(*_bgd.PdfObjectArray)
	if !_gcfa {
		_fg.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _fbege)
		return nil, _bgd.ErrTypeError
	}
	if _decaf.Len() != 6 {
		_fg.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0036\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _decaf.Len())
		return nil, ErrInvalidAttribute
	}
	_beffg.Coords = _decaf
	if _dabcab := _cefbg.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _dabcab != nil {
		_dabcab = _bgd.TraceToDirectObject(_dabcab)
		_bdbee, _fedf := _dabcab.(*_bgd.PdfObjectArray)
		if !_fedf {
			_fg.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _dabcab)
			return nil, _bgd.ErrTypeError
		}
		_beffg.Domain = _bdbee
	}
	_fbege = _cefbg.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _fbege == nil {
		_fg.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_beffg.Function = []PdfFunction{}
	if _ebcd, _cfgbg := _fbege.(*_bgd.PdfObjectArray); _cfgbg {
		for _, _effcc := range _ebcd.Elements() {
			_cdcgbd, _ebbe := _fbbb(_effcc)
			if _ebbe != nil {
				_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ebbe)
				return nil, _ebbe
			}
			_beffg.Function = append(_beffg.Function, _cdcgbd)
		}
	} else {
		_affce, _dffd := _fbbb(_fbege)
		if _dffd != nil {
			_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dffd)
			return nil, _dffd
		}
		_beffg.Function = append(_beffg.Function, _affce)
	}
	if _aeaec := _cefbg.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _aeaec != nil {
		_aeaec = _bgd.TraceToDirectObject(_aeaec)
		_aafcd, _cdedc := _aeaec.(*_bgd.PdfObjectArray)
		if !_cdedc {
			_fg.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _aeaec)
			return nil, _bgd.ErrTypeError
		}
		if _aafcd.Len() != 2 {
			_fg.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _aafcd.Len())
			return nil, ErrInvalidAttribute
		}
		_beffg.Extend = _aafcd
	}
	return &_beffg, nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_bbgf *PdfColorspaceDeviceRGB) ToPdfObject() _bgd.PdfObject {
	return _bgd.MakeName("\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B")
}

func _fafb(_ggce map[_fe.GID]int, _aaag uint16) *_bgd.PdfObjectArray {
	_gacb := &_bgd.PdfObjectArray{}
	_faagc := _fe.GID(_aaag)
	for _eacg := _fe.GID(0); _eacg < _faagc; {
		_agfgc, _daebg := _ggce[_eacg]
		if !_daebg {
			_eacg++
			continue
		}
		_bdgd := _eacg
		for _bbdbg := _bdgd + 1; _bbdbg < _faagc; _bbdbg++ {
			if _eddc, _egac := _ggce[_bbdbg]; !_egac || _agfgc != _eddc {
				break
			}
			_bdgd = _bbdbg
		}
		_gacb.Append(_bgd.MakeInteger(int64(_eacg)))
		_gacb.Append(_bgd.MakeInteger(int64(_bdgd)))
		_gacb.Append(_bgd.MakeInteger(int64(_agfgc)))
		_eacg = _bdgd + 1
	}
	return _gacb
}

// ToPdfObject generates a PdfObject representation of the Names struct.
func (_cadfb *Names) ToPdfObject() _bgd.PdfObject {
	_cded := _cadfb._cafda
	_fffbg, _cdcea := _cded.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_cdcea {
		_fg.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006fb\u006a\u0065\u0063\u0074")
		return _cded
	}
	if _cadfb.EmbeddedFiles != nil {
		_fffbg.Set("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0046\u0069\u006c\u0065\u0073", _bgd.MakeIndirectObject(_cadfb.EmbeddedFiles))
	}
	return _cded
}

// SetContentStream sets the pattern cell's content stream.
func (_egeffd *PdfTilingPattern) SetContentStream(content []byte, encoder _bgd.StreamEncoder) error {
	_ecbed, _cebec := _egeffd._eaddb.(*_bgd.PdfObjectStream)
	if !_cebec {
		_fg.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _egeffd._eaddb)
		return _bgd.ErrTypeError
	}
	if encoder == nil {
		encoder = _bgd.NewRawEncoder()
	}
	_dcga := _ecbed.PdfObjectDictionary
	_bbfdc := encoder.MakeStreamDict()
	_dcga.Merge(_bbfdc)
	_cdfcg, _deec := encoder.EncodeBytes(content)
	if _deec != nil {
		return _deec
	}
	_dcga.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_cdfcg))))
	_ecbed.Stream = _cdfcg
	return nil
}

func (_dggf *PdfReader) newPdfActionJavaScriptFromDict(_gdee *_bgd.PdfObjectDictionary) (*PdfActionJavaScript, error) {
	return &PdfActionJavaScript{JS: _gdee.Get("\u004a\u0053")}, nil
}

const (
	BorderStyleSolid     BorderStyle = iota
	BorderStyleDashed    BorderStyle = iota
	BorderStyleBeveled   BorderStyle = iota
	BorderStyleInset     BorderStyle = iota
	BorderStyleUnderline BorderStyle = iota
)

var (
	ArtifactAttachPositionTop    ArtifactAttachPosition = "\u0054\u006f\u0070"
	ArtifactAttachPositionBottom ArtifactAttachPosition = "\u0042\u006f\u0074\u0074\u006f\u006d"
	ArtifactAttachPositionLeft   ArtifactAttachPosition = "\u004c\u0065\u0066\u0074"
	ArtifactAttachPositionRight  ArtifactAttachPosition = "\u0052\u0069\u0067h\u0074"
)

// NewEmbeddedFileFromObject construct a new EmbeddedFile from supplied object.
func NewEmbeddedFileFromObject(obj _bgd.PdfObject) (*EmbeddedFile, error) {
	_dgde := _bgd.TraceToDirectObject(obj)
	_cbde, _gbbeg := _dgde.(*_bgd.PdfObjectDictionary)
	if !_gbbeg {
		return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_ecfd := _bgd.TraceToDirectObject(_cbde.Get("\u0046"))
	if _ecfd == nil {
		return nil, _gb.New("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0073\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065")
	}
	_ebage, _gbbeg := _ecfd.(*_bgd.PdfObjectStream)
	if !_gbbeg {
		return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073t\u0072\u0065\u0061\u006d")
	}
	_eeab := _ebage.PdfObjectDictionary
	_bfdb := _eeab.Get("\u0050\u0061\u0072\u0061\u006d\u0073")
	if _bfdb == nil {
		return nil, _gb.New("p\u0061\u0072\u0061\u006d\u0073\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061i\u006ca\u0062\u006c\u0065")
	}
	_gbdcc, _gbbeg := _bfdb.(*_bgd.PdfObjectDictionary)
	if !_gbbeg {
		return nil, _gb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0061\u006d\u0073 \u006f\u0062\u006a\u0065\u0063\u0074")
	}
	_acabf := ""
	_dbbf := _gbdcc.Get("\u0043\u0068\u0065\u0063\u006b\u0053\u0075\u006d")
	if _dbbf != nil {
		_acabf = _dbbf.(*_bgd.PdfObjectString).Str()
	}
	_aabf, _gfceb := _bgd.DecodeStream(_ebage)
	if _gfceb != nil {
		return nil, _gfceb
	}
	_eefbf := &EmbeddedFile{Content: _aabf, Hash: _acabf}
	return _eefbf, nil
}

// ToPdfObject implements interface PdfModel.
// Note: Call the sub-annotation's ToPdfObject to set both the generic and non-generic information.
func (_dddd *PdfAnnotation) ToPdfObject() _bgd.PdfObject {
	_fgcf := _dddd._eag
	_fdc := _fgcf.PdfObject.(*_bgd.PdfObjectDictionary)
	_fdc.Clear()
	_fdc.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0041\u006e\u006eo\u0074"))
	_fdc.SetIfNotNil("\u0052\u0065\u0063\u0074", _dddd.Rect)
	_fdc.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _dddd.Contents)
	_fdc.SetIfNotNil("\u0050", _dddd.P)
	_fdc.SetIfNotNil("\u004e\u004d", _dddd.NM)
	_fdc.SetIfNotNil("\u004d", _dddd.M)
	_fdc.SetIfNotNil("\u0046", _dddd.F)
	_fdc.SetIfNotNil("\u0041\u0050", _dddd.AP)
	_fdc.SetIfNotNil("\u0041\u0053", _dddd.AS)
	_fdc.SetIfNotNil("\u0042\u006f\u0072\u0064\u0065\u0072", _dddd.Border)
	_fdc.SetIfNotNil("\u0043", _dddd.C)
	_fdc.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _dddd.StructParent)
	_fdc.SetIfNotNil("\u004f\u0043", _dddd.OC)
	return _fgcf
}

func _bdadd(_eaeaf *XObjectImage) error {
	if _eaeaf.SMask == nil {
		return nil
	}
	_ceeeb, _facbe := _eaeaf.SMask.(*_bgd.PdfObjectStream)
	if !_facbe {
		_fg.Log.Debug("\u0053\u004da\u0073\u006b\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0053\u0074re\u0061\u006d")
		return _bgd.ErrTypeError
	}
	_ceaeed := _ceeeb.PdfObjectDictionary
	_bgce := _ceaeed.Get("\u004d\u0061\u0074t\u0065")
	if _bgce == nil {
		return nil
	}
	_dfffa, _bdgagc := _cgdg(_bgce.(*_bgd.PdfObjectArray))
	if _bdgagc != nil {
		return _bdgagc
	}
	_gabde := _bgd.MakeArrayFromFloats([]float64{_dfffa})
	_ceaeed.SetIfNotNil("\u004d\u0061\u0074t\u0065", _gabde)
	return nil
}

func _cfea(_fcdcg *_bgd.PdfObjectDictionary) (*PdfFieldButton, error) {
	_acgcg := &PdfFieldButton{}
	_acgcg.PdfField = NewPdfField()
	_acgcg.SetContext(_acgcg)
	_acgcg.Opt, _ = _bgd.GetArray(_fcdcg.Get("\u004f\u0070\u0074"))
	_bfeb := NewPdfAnnotationWidget()
	_bfeb.A, _ = _bgd.GetDict(_fcdcg.Get("\u0041"))
	_bfeb.AP, _ = _bgd.GetDict(_fcdcg.Get("\u0041\u0050"))
	_bfeb.SetContext(_acgcg)
	_acgcg.Annotations = append(_acgcg.Annotations, _bfeb)
	return _acgcg, nil
}

// SetCatalogMetadata sets the catalog metadata (XMP) stream object.
func (_ffccc *PdfWriter) SetCatalogMetadata(meta _bgd.PdfObject) error {
	if meta == nil {
		_ffccc._aaea.Remove("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
		return nil
	}
	_cffeb, _bdede := _bgd.GetStream(meta)
	if !_bdede {
		return _gb.New("\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006d\u0065\u0074\u0061\u0064a\u0074\u0061\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0073t\u0072\u0065\u0061\u006d")
	}
	_ffccc.addObject(_cffeb)
	_ffccc._aaea.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _cffeb)
	return nil
}

func (_aeegg *LTV) generateVRIKey(_beeac *PdfSignature) (string, error) {
	_bbadd, _affc := _deagf(_beeac.Contents.Bytes())
	if _affc != nil {
		return "", _affc
	}
	return _ef.ToUpper(_bf.EncodeToString(_bbadd)), nil
}

func (_bbggc *PdfWriter) copyObject(_aefgb _bgd.PdfObject, _degaf map[_bgd.PdfObject]_bgd.PdfObject, _cccgd map[_bgd.PdfObject]struct{}, _ebgea bool) _bgd.PdfObject {
	_fdagg := !_bbggc._fgaba && _cccgd != nil
	if _bggcd, _bbgca := _degaf[_aefgb]; _bbgca {
		if _fdagg && !_ebgea {
			delete(_cccgd, _aefgb)
		}
		return _bggcd
	}
	if _aefgb == nil {
		_adaff := _bgd.MakeNull()
		return _adaff
	}
	_caege := _aefgb
	switch _daba := _aefgb.(type) {
	case *_bgd.PdfObjectArray:
		_bbgffd := _bgd.MakeArray()
		_caege = _bbgffd
		_degaf[_aefgb] = _caege
		for _, _abgaa := range _daba.Elements() {
			_bbgffd.Append(_bbggc.copyObject(_abgaa, _degaf, _cccgd, _ebgea))
		}
	case *_bgd.PdfObjectStreams:
		_ccdgc := &_bgd.PdfObjectStreams{PdfObjectReference: _daba.PdfObjectReference}
		_caege = _ccdgc
		_degaf[_aefgb] = _caege
		for _, _gacage := range _daba.Elements() {
			_ccdgc.Append(_bbggc.copyObject(_gacage, _degaf, _cccgd, _ebgea))
		}
	case *_bgd.PdfObjectStream:
		_gabec := &_bgd.PdfObjectStream{Stream: _daba.Stream, PdfObjectReference: _daba.PdfObjectReference, Lazy: _daba.Lazy, TempFile: _daba.TempFile}
		_caege = _gabec
		_degaf[_aefgb] = _caege
		_gabec.PdfObjectDictionary = _bbggc.copyObject(_daba.PdfObjectDictionary, _degaf, _cccgd, _ebgea).(*_bgd.PdfObjectDictionary)
	case *_bgd.PdfObjectDictionary:
		var _cfac bool
		if _fdagg && !_ebgea {
			if _ggca, _ := _bgd.GetNameVal(_daba.Get("\u0054\u0079\u0070\u0065")); _ggca == "\u0050\u0061\u0067\u0065" {
				_, _dfged := _bbggc._bbcec[_daba]
				_ebgea = !_dfged
				_cfac = _ebgea
			}
		}
		_efbda := _bgd.MakeDict()
		_caege = _efbda
		_degaf[_aefgb] = _caege
		for _, _fgeea := range _daba.Keys() {
			_efbda.Set(_fgeea, _bbggc.copyObject(_daba.Get(_fgeea), _degaf, _cccgd, _ebgea))
		}
		if _cfac {
			_caege = _bgd.MakeNull()
			_ebgea = false
		}
	case *_bgd.PdfIndirectObject:
		_ddcdg := &_bgd.PdfIndirectObject{PdfObjectReference: _daba.PdfObjectReference}
		_caege = _ddcdg
		_degaf[_aefgb] = _caege
		_ddcdg.PdfObject = _bbggc.copyObject(_daba.PdfObject, _degaf, _cccgd, _ebgea)
	case *_bgd.PdfObjectString:
		_bgadd := *_daba
		_caege = &_bgadd
		_degaf[_aefgb] = _caege
	case *_bgd.PdfObjectName:
		_gbedc := *_daba
		_caege = &_gbedc
		_degaf[_aefgb] = _caege
	case *_bgd.PdfObjectNull:
		_caege = _bgd.MakeNull()
		_degaf[_aefgb] = _caege
	case *_bgd.PdfObjectInteger:
		_gccfd := *_daba
		_caege = &_gccfd
		_degaf[_aefgb] = _caege
	case *_bgd.PdfObjectReference:
		_ccfdf := *_daba
		_caege = &_ccfdf
		_degaf[_aefgb] = _caege
	case *_bgd.PdfObjectFloat:
		_gcffg := *_daba
		_caege = &_gcffg
		_degaf[_aefgb] = _caege
	case *_bgd.PdfObjectBool:
		_gcgbf := *_daba
		_caege = &_gcgbf
		_degaf[_aefgb] = _caege
	case *pdfSignDictionary:
		_gedfa := &pdfSignDictionary{PdfObjectDictionary: _bgd.MakeDict(), _bcdbef: _daba._bcdbef, _egebe: _daba._egebe}
		_caege = _gedfa
		_degaf[_aefgb] = _caege
		for _, _fdggd := range _daba.Keys() {
			_gedfa.Set(_fdggd, _bbggc.copyObject(_daba.Get(_fdggd), _degaf, _cccgd, _ebgea))
		}
	default:
		_fg.Log.Info("\u0054\u004f\u0044\u004f\u0028\u0061\u0035\u0069\u0029\u003a\u0020\u0069\u006dp\u006c\u0065\u006d\u0065\u006e\u0074 \u0063\u006f\u0070\u0079\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0066\u006fr\u0020\u0025\u002b\u0076", _aefgb)
	}
	if _fdagg && _ebgea {
		_cccgd[_aefgb] = struct{}{}
	}
	return _caege
}

// ToPdfObject returns the choice field dictionary within an indirect object (container).
func (_edcc *PdfFieldChoice) ToPdfObject() _bgd.PdfObject {
	_edcc.PdfField.ToPdfObject()
	_egeb := _edcc._bcgde
	_cfggd := _egeb.PdfObject.(*_bgd.PdfObjectDictionary)
	_cfggd.Set("\u0046\u0054", _bgd.MakeName("\u0043\u0068"))
	if _edcc.Opt != nil {
		_cfggd.Set("\u004f\u0070\u0074", _edcc.Opt)
	}
	if _edcc.TI != nil {
		_cfggd.Set("\u0054\u0049", _edcc.TI)
	}
	if _edcc.I != nil {
		_cfggd.Set("\u0049", _edcc.I)
	}
	return _egeb
}

type pdfCIDFontType0 struct {
	fontCommon
	_dggac *_bgd.PdfIndirectObject
	_gddac _dabf.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// (Required) Dictionary that defines the character collection of the CIDFont.
	// See Table 116.
	CIDSystemInfo *_bgd.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW     _bgd.PdfObject
	W      _bgd.PdfObject
	DW2    _bgd.PdfObject
	W2     _bgd.PdfObject
	_ddbab map[_dabf.CharCode]float64
	_bfgb  float64
}

var _ pdfFont = (*pdfCIDFontType2)(nil)

// ToInteger convert to an integer format.
func (_cgge *PdfColorDeviceGray) ToInteger(bits int) uint32 {
	_aceef := _da.Pow(2, float64(bits)) - 1
	return uint32(_aceef * _cgge.Val())
}

// ViewerPreferences represents the viewer preferences of a PDF document.
type ViewerPreferences struct {
	_ebbdd  *bool
	_gfca   *bool
	_eagcc  *bool
	_faccc  *bool
	_bbfdf  *bool
	_fcdcbd *bool
	_ggfcc  NonFullScreenPageMode
	_fdcge  Direction
	_eabg   PageBoundary
	_bedce  PageBoundary
	_fccec  PageBoundary
	_fffgf  PageBoundary
	_edfcg  PrintScaling
	_affbc  Duplex
	_babbb  *bool
	_gdfab  []int
	_bcdg   int
}

// GenerateKDict generates K Dictionary based on existing Annotation type.
func (_afed *PdfAnnotation) GenerateKDict() *KDict {
	if _afed == nil {
		return nil
	}
	_fec := NewKDictionary()
	_fec.S = _bgd.MakeName(string(StructureTypeAnnot))
	_fec.AddRefChild(_afed._eag)
	return _fec
}

func _ada(_feag _bgd.PdfObject) (*PdfFilespec, error) {
	if _feag == nil {
		return nil, nil
	}
	return NewPdfFilespecFromObj(_feag)
}

// SetPrintClip sets the value of the printClip.
func (_eccgd *ViewerPreferences) SetPrintClip(printClip PageBoundary) { _eccgd._fffgf = printClip }

// NewCustomPdfOutputIntent creates a new custom PdfOutputIntent.
func NewCustomPdfOutputIntent(outputCondition, outputConditionIdentifier, info string, destOutputProfile []byte, colorComponents int) *PdfOutputIntent {
	return &PdfOutputIntent{Type: "\u004f\u0075\u0074p\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074", OutputCondition: outputCondition, OutputConditionIdentifier: outputConditionIdentifier, Info: info, DestOutputProfile: destOutputProfile, _gfcce: _bgd.MakeDict(), ColorComponents: colorComponents}
}

// ReplacePage replaces the original page to a new page.
func (_cdde *PdfAppender) ReplacePage(pageNum int, page *PdfPage) {
	_cbcb := pageNum - 1
	for _afcb := range _cdde._ffcf {
		if _afcb == _cbcb {
			_gecgf := page.Duplicate()
			_fdbfd(_gecgf)
			_cdde._ffcf[_afcb] = _gecgf
		}
	}
}

// ArtifactAttachPosition specifies the position where an artifact is attached to a page.
type ArtifactAttachPosition string

// NewPdfShadingType3 creates an empty shading type 3 dictionary.
func NewPdfShadingType3() *PdfShadingType3 {
	_afeeg := &PdfShadingType3{}
	_afeeg.PdfShading = &PdfShading{}
	_afeeg.PdfShading._gccfe = _bgd.MakeIndirectObject(_bgd.MakeDict())
	_afeeg.PdfShading._gggga = _afeeg
	return _afeeg
}

// PdfAnnotationSquiggly represents Squiggly annotations.
// (Section 12.5.6.10).
type PdfAnnotationSquiggly struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _bgd.PdfObject
}

// IsHideToolbar returns the value of the hideToolbar flag.
func (_cfbec *ViewerPreferences) IsHideToolbar() bool {
	if _cfbec._ebbdd == nil {
		return false
	}
	return *_cfbec._ebbdd
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_defgag *PdfFunctionType3) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_fg.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return nil, _gb.New("\u006e\u006f\u0074\u0020im\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
}

// SetCatalogMarkInfo sets the catalog MarkInfo dictionary.
func (_ffedg *PdfWriter) SetCatalogMarkInfo(info _bgd.PdfObject) error {
	if info == nil {
		_ffedg._aaea.Remove("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
		return nil
	}
	if _cbbgg, _cgdee := info.(*_bgd.PdfObjectReference); _cgdee {
		info = _cbbgg.Resolve()
		if info == nil {
			_ffedg._aaea.Remove("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
			return nil
		}
	}
	if _, _aabfc := info.(*_bgd.PdfIndirectObject); _aabfc {
		_ffedg.addObject(info)
	}
	_ffedg._aaea.Set("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f", info)
	return nil
}

func (_efbaba *fontFile) parseASCIIPart(_cdae []byte) error {
	if len(_cdae) < 2 || string(_cdae[:2]) != "\u0025\u0021" {
		return _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0074a\u0072\u0074\u0020\u006f\u0066\u0020\u0041S\u0043\u0049\u0049\u0020\u0073\u0065\u0067\u006d\u0065\u006e\u0074")
	}
	_abdff, _fdbe, _fcdbe := _eddcg(_cdae)
	if _fcdbe != nil {
		return _fcdbe
	}
	_cdbc := _fdggb(_abdff)
	_efbaba._ffeeef = _cdbc["\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"]
	if _efbaba._ffeeef == "" {
		_fg.Log.Debug("\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0020\u0068a\u0073\u0020\u006e\u006f\u0020\u002f\u0046\u006f\u006e\u0074N\u0061\u006d\u0065")
	}
	if _fdbe != "" {
		_fdag, _bdcff := _eeedbe(_fdbe)
		if _bdcff != nil {
			return _bdcff
		}
		_dfae, _bdcff := _dabf.NewCustomSimpleTextEncoder(_fdag, nil)
		if _bdcff != nil {
			_fg.Log.Debug("\u0045\u0052\u0052\u004fR\u0020\u003a\u0055\u004e\u004b\u004e\u004f\u0057\u004e\u0020G\u004cY\u0050\u0048\u003a\u0020\u0065\u0072\u0072=\u0025\u0076", _bdcff)
			return nil
		}
		_efbaba._edef = _dfae
	}
	return nil
}

// SetSamples convert samples to byte-data and sets for the image.
// NOTE: The method resamples the data and this could lead to high memory usage,
// especially on large images. It should be used only when it is not possible
// to work with the image byte data directly.
func (_efgaa *Image) SetSamples(samples []uint32) {
	if _efgaa.BitsPerComponent < 8 {
		samples = _efgaa.samplesAddPadding(samples)
	}
	_cdeab := _eaa.ResampleUint32(samples, int(_efgaa.BitsPerComponent), 8)
	_aaecb := make([]byte, len(_cdeab))
	for _beeg, _bdfg := range _cdeab {
		_aaecb[_beeg] = byte(_bdfg)
	}
	_efgaa.Data = _aaecb
}

// GetNumComponents returns the number of color components.
func (_ecaeg *PdfColorspaceICCBased) GetNumComponents() int { return _ecaeg.N }

// ToPdfObject implements interface PdfModel.
func (_babfb *EmbeddedFile) ToPdfObject() _bgd.PdfObject {
	_ggfd := _bgd.NewFlateEncoder()
	_dfcc, _bgdc := _bgd.MakeStream(_babfb.Content, _ggfd)
	if _bgdc != nil {
		_fg.Log.Debug("\u0046\u0061\u0069\u006c\u0065d\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020\u0065\u006db\u0065\u0064\u0064\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _bgdc)
		return nil
	}
	_cfcf := _dfcc.PdfObjectDictionary
	_cfcf.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0045\u006d\u0062e\u0064\u0064\u0065\u0064\u0046\u0069\u006c\u0065"))
	_cfcf.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeEncodedString("\u0074\u0065\u0078\u0074\u002f\u0070\u006c\u0061\u0069\u006e", true))
	_fcde := _bgd.MakeDict()
	_fcde.Set("\u0043\u0068\u0065\u0063\u006b\u0053\u0075\u006d", _bgd.MakeString(_babfb.Hash[:]))
	_fcde.Set("\u0053\u0069\u007a\u0065", _bgd.MakeInteger(int64(len(_babfb.Content))))
	_dggc := _babfb.CreationTime
	if _dggc.IsZero() {
		_dggc = _ge.Now()
	}
	_geebe := _babfb.ModTime
	if _geebe.IsZero() {
		_geebe = _dggc
	}
	_eeca, _bgdc := NewPdfDateFromTime(_dggc)
	if _bgdc != nil {
		_fg.Log.Debug("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074o\u0020\u0063\u0072ea\u0074\u0065\u0020\u0065\u006d\u0062e\u0064\u0064\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0063\u0072\u0065\u0061\u0074i\u006f\u006e\u0020\u0064\u0061\u0074\u0065\u003a \u0025\u0076", _bgdc)
		return nil
	}
	_afeaa, _bgdc := NewPdfDateFromTime(_geebe)
	if _bgdc != nil {
		_fg.Log.Debug("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074o\u0020\u0063\u0072ea\u0074\u0065\u0020\u0065\u006d\u0062e\u0064\u0064\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0063\u0072\u0065\u0061\u0074i\u006f\u006e\u0020\u0064\u0061\u0074\u0065\u003a \u0025\u0076", _bgdc)
		return nil
	}
	_fcde.Set("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _eeca.ToPdfObject())
	_fcde.Set("\u004do\u0064\u0044\u0061\u0074\u0065", _afeaa.ToPdfObject())
	_cfcf.Set("\u0050\u0061\u0072\u0061\u006d\u0073", _fcde)
	_beea := _bgd.MakeDict()
	_beea.Set(*_bgd.MakeName("\u0046"), _dfcc)
	return _beea
}

func _gaccd(_ddea _fe.StdFont) pdfFontSimple {
	_ebaff := _ddea.Descriptor()
	return pdfFontSimple{fontCommon: fontCommon{_gecd: "\u0054\u0079\u0070e\u0031", _eebe: _ddea.Name()}, _dcbff: _ddea.GetMetricsTable(), _aegbd: &PdfFontDescriptor{FontName: _bgd.MakeName(string(_ebaff.Name)), FontFamily: _bgd.MakeName(_ebaff.Family), FontWeight: _bgd.MakeFloat(float64(_ebaff.Weight)), Flags: _bgd.MakeInteger(int64(_ebaff.Flags)), FontBBox: _bgd.MakeArrayFromFloats(_ebaff.BBox[:]), ItalicAngle: _bgd.MakeFloat(_ebaff.ItalicAngle), Ascent: _bgd.MakeFloat(_ebaff.Ascent), Descent: _bgd.MakeFloat(_ebaff.Descent), CapHeight: _bgd.MakeFloat(_ebaff.CapHeight), XHeight: _bgd.MakeFloat(_ebaff.XHeight), StemV: _bgd.MakeFloat(_ebaff.StemV), StemH: _bgd.MakeFloat(_ebaff.StemH)}, _dfagc: _ddea.Encoder()}
}

// Clear clears the KValue.
func (_eaaaa *KValue) Clear() { _eaaaa._fgcbd = nil; _eaaaa._bcdd = nil; _eaaaa._ecdf = nil }

func (_ecee *PdfReader) newPdfAnnotationFileAttachmentFromDict(_ffee *_bgd.PdfObjectDictionary) (*PdfAnnotationFileAttachment, error) {
	_daef := PdfAnnotationFileAttachment{}
	_cccg, _afag := _ecee.newPdfAnnotationMarkupFromDict(_ffee)
	if _afag != nil {
		return nil, _afag
	}
	_daef.PdfAnnotationMarkup = _cccg
	_daef.FS = _ffee.Get("\u0046\u0053")
	_daef.Name = _ffee.Get("\u004e\u0061\u006d\u0065")
	return &_daef, nil
}

// ToPdfObject implements interface PdfModel.
func (_bbf *PdfActionGoToE) ToPdfObject() _bgd.PdfObject {
	_bbf.PdfAction.ToPdfObject()
	_acg := _bbf._fab
	_bfdg := _acg.PdfObject.(*_bgd.PdfObjectDictionary)
	_bfdg.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeGoToE)))
	if _bbf.F != nil {
		_bfdg.Set("\u0046", _bbf.F.ToPdfObject())
	}
	_bfdg.SetIfNotNil("\u0044", _bbf.D)
	_bfdg.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _bbf.NewWindow)
	_bfdg.SetIfNotNil("\u0054", _bbf.T)
	return _acg
}

// SetDecode sets the decode image float slice.
func (_bdbge *Image) SetDecode(decode []float64) { _bdbge._agcea = decode }

// ToPdfObject converts rectangle to a PDF object.
func (_gebgc *PdfRectangle) ToPdfObject() _bgd.PdfObject {
	return _bgd.MakeArray(_bgd.MakeFloat(_gebgc.Llx), _bgd.MakeFloat(_gebgc.Lly), _bgd.MakeFloat(_gebgc.Urx), _bgd.MakeFloat(_gebgc.Ury))
}

func _abgec() string {
	_adcf.Lock()
	defer _adcf.Unlock()
	_gecgbg := _gdg.GetLicenseKey()
	if len(_edbfc) > 0 && (_gecgbg.IsLicensed() || _geced) {
		return _edbfc
	}
	return _f.Sprintf("\u0055\u006e\u0069Do\u0063\u0020\u0076\u0025\u0073\u0020\u0028\u0025\u0073)\u0020-\u0020h\u0074t\u0070\u003a\u002f\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f", _egddb(), _gecgbg.TypeToString())
}

// DecodeArray returns an empty slice as there are no components associated with pattern colorspace.
func (_gcae *PdfColorspaceSpecialPattern) DecodeArray() []float64 { return []float64{} }

// ToPdfObject returns the PDF representation of the shading pattern.
func (_dccfbg *PdfShadingPatternType3) ToPdfObject() _bgd.PdfObject {
	_dccfbg.PdfPattern.ToPdfObject()
	_fadgc := _dccfbg.getDict()
	if _dccfbg.Shading != nil {
		_fadgc.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _dccfbg.Shading.ToPdfObject())
	}
	if _dccfbg.Matrix != nil {
		_fadgc.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _dccfbg.Matrix)
	}
	if _dccfbg.ExtGState != nil {
		_fadgc.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _dccfbg.ExtGState)
	}
	return _dccfbg._eaddb
}

// ToPdfObject returns a PDF object representation of the ViewerPreferences.
func (_edceb *ViewerPreferences) ToPdfObject() _bgd.PdfObject {
	_abdge := _bgd.MakeDict()
	if _edceb._ebbdd != nil {
		_abdge.Set("H\u0069\u0064\u0065\u0054\u006f\u006f\u006c\u0062\u0061\u0072", _bgd.MakeBool(*_edceb._ebbdd))
	}
	if _edceb._gfca != nil {
		_abdge.Set("H\u0069\u0064\u0065\u004d\u0065\u006e\u0075\u0062\u0061\u0072", _bgd.MakeBool(*_edceb._gfca))
	}
	if _edceb._eagcc != nil {
		_abdge.Set("\u0048\u0069\u0064e\u0057\u0069\u006e\u0064\u006f\u0077\u0055\u0049", _bgd.MakeBool(*_edceb._eagcc))
	}
	if _edceb._faccc != nil {
		_abdge.Set("\u0046i\u0074\u0057\u0069\u006e\u0064\u006fw", _bgd.MakeBool(*_edceb._faccc))
	}
	if _edceb._bbfdf != nil {
		_abdge.Set("\u0043\u0065\u006et\u0065\u0072\u0057\u0069\u006e\u0064\u006f\u0077", _bgd.MakeBool(*_edceb._bbfdf))
	}
	if _edceb._fcdcbd != nil {
		_abdge.Set("\u0044i\u0073p\u006c\u0061\u0079\u0044\u006f\u0063\u0054\u0069\u0074\u006c\u0065", _bgd.MakeBool(*_edceb._fcdcbd))
	}
	if _edceb._ggfcc != "" {
		_abdge.Set("N\u006f\u006e\u0046\u0075ll\u0053c\u0072\u0065\u0065\u006e\u0050a\u0067\u0065\u004d\u006f\u0064\u0065", _bgd.MakeName(string(_edceb._ggfcc)))
	}
	if _edceb._fdcge != "" {
		_abdge.Set("\u0044i\u0072\u0065\u0063\u0074\u0069\u006fn", _bgd.MakeName(string(_edceb._fdcge)))
	}
	if _edceb._eabg != "" {
		_abdge.Set("\u0056\u0069\u0065\u0077\u0041\u0072\u0065\u0061", _bgd.MakeName(string(_edceb._eabg)))
	}
	if _edceb._bedce != "" {
		_abdge.Set("\u0056\u0069\u0065\u0077\u0043\u006c\u0069\u0070", _bgd.MakeName(string(_edceb._bedce)))
	}
	if _edceb._fccec != "" {
		_abdge.Set("\u0050r\u0069\u006e\u0074\u0041\u0072\u0065a", _bgd.MakeName(string(_edceb._fccec)))
	}
	if _edceb._fffgf != "" {
		_abdge.Set("\u0050r\u0069\u006e\u0074\u0043\u006c\u0069p", _bgd.MakeName(string(_edceb._fffgf)))
	}
	if _edceb._edfcg != "" {
		_abdge.Set("\u0050\u0072\u0069n\u0074\u0053\u0063\u0061\u006c\u0069\u006e\u0067", _bgd.MakeName(string(_edceb._edfcg)))
	}
	if _edceb._affbc != "" {
		_abdge.Set("\u0044\u0075\u0070\u006c\u0065\u0078", _bgd.MakeName(string(_edceb._affbc)))
	}
	if _edceb._babbb != nil {
		_abdge.Set("\u0050\u0069\u0063\u006b\u0054\u0072\u0061\u0079\u0042\u0079\u0050\u0044F\u0053\u0069\u007a\u0065", _bgd.MakeBool(*_edceb._babbb))
	}
	if _edceb._gdfab != nil {
		_abdge.Set("\u0050\u0072\u0069\u006e\u0074\u0050\u0061\u0067\u0065R\u0061\u006e\u0067\u0065", _bgd.MakeArrayFromIntegers(_edceb._gdfab))
	}
	if _edceb._bcdg != 0 {
		_abdge.Set("\u004eu\u006d\u0043\u006f\u0070\u0069\u0065s", _bgd.MakeInteger(int64(_edceb._bcdg)))
	}
	return _abdge
}

func (_bfea *PdfReader) newPdfFieldSignatureFromDict(_caggb *_bgd.PdfObjectDictionary) (*PdfFieldSignature, error) {
	_ddcd := &PdfFieldSignature{}
	_efbdfb, _gaafa := _bgd.GetIndirect(_caggb.Get("\u0056"))
	if _gaafa {
		var _gbdg error
		_ddcd.V, _gbdg = _bfea.newPdfSignatureFromIndirect(_efbdfb)
		if _gbdg != nil {
			return nil, _gbdg
		}
	}
	_ddcd.Lock, _ = _bgd.GetIndirect(_caggb.Get("\u004c\u006f\u0063\u006b"))
	_ddcd.SV, _ = _bgd.GetIndirect(_caggb.Get("\u0053\u0056"))
	return _ddcd, nil
}

// SetHideToolbar sets the value of the hideToolbar flag.
func (_ecbcf *ViewerPreferences) SetHideToolbar(hideToolbar bool) { _ecbcf._ebbdd = &hideToolbar }

func (_gbeg *PdfWriter) checkCrossReferenceStream() bool {
	_daca := _gbeg._egbga.Major > 1 || (_gbeg._egbga.Major == 1 && _gbeg._egbga.Minor > 4)
	if _gbeg._dadab != nil {
		_daca = *_gbeg._dadab
	}
	return _daca
}

// GetCIDToGIDMapObject get the underlying CIDToGIDMap object if the font type is CIDFontType2.
func (_ebbf *PdfFont) GetCIDToGIDMapObject() _bgd.PdfObject {
	_fedg, _cefee := _ebbf._cbec.(*pdfCIDFontType2)
	if _cefee {
		return _fedg.CIDToGIDMap
	}
	return nil
}

// NewPdfAnnotationUnderline returns a new text underline annotation.
func NewPdfAnnotationUnderline() *PdfAnnotationUnderline {
	_afc := NewPdfAnnotation()
	_cfc := &PdfAnnotationUnderline{}
	_cfc.PdfAnnotation = _afc
	_cfc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_afc.SetContext(_cfc)
	return _cfc
}

// StructureType represents a standard structure type in a tagged PDF document.
type StructureType string

// PdfActionType represents an action type in PDF (section 12.6.4 p. 417).
type PdfActionType string

// PdfFunctionType3 defines stitching of the subdomains of several 1-input functions to produce
// a single new 1-input function.
type PdfFunctionType3 struct {
	Domain    []float64
	Range     []float64
	Functions []PdfFunction
	Bounds    []float64
	Encode    []float64
	_ccdd     *_bgd.PdfIndirectObject
}

// SetSubtype sets the Subtype S for given PdfOutputIntent.
func (_efaed *PdfOutputIntent) SetSubtype(subtype PdfOutputIntentType) error {
	if !subtype.IsValid() {
		return _gb.New("\u0070\u0072o\u0076\u0069\u0064\u0065d\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u004f\u0075t\u0070\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074\u0020\u0053\u0075b\u0054\u0079\u0070\u0065")
	}
	_efaed.S = subtype
	return nil
}

// A PdfPattern can represent a Pattern, either a tiling pattern or a shading pattern.
// Note that all patterns shall be treated as colours; a Pattern colour space shall be established with the CS or cs
// operator just like other colour spaces, and a particular pattern shall be installed as the current colour with the
// SCN or scn operator.
type PdfPattern struct {

	// Type: Pattern
	PatternType int64
	_ggafd      PdfModel
	_eaddb      _bgd.PdfObject
}

// SetCatalogStructTreeRoot sets the catalog struct tree root object.
func (_aacec *PdfWriter) SetCatalogStructTreeRoot(tree _bgd.PdfObject) error {
	if tree == nil {
		_aacec._aaea.Remove("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074")
		return nil
	}
	_aacec._aaea.Set("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074", tree)
	return _aacec.addObjects(tree)
}

// PdfAnnotationFileAttachment represents FileAttachment annotations.
// (Section 12.5.6.15).
type PdfAnnotationFileAttachment struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	FS   _bgd.PdfObject
	Name _bgd.PdfObject
}

// PdfSignature represents a PDF signature dictionary and is used for signing via form signature fields.
// (Section 12.8, Table 252 - Entries in a signature dictionary p. 475 in PDF32000_2008).
type PdfSignature struct {
	Handler SignatureHandler
	_ddggd  *_bgd.PdfIndirectObject

	// Type: Sig/DocTimeStamp
	Type         *_bgd.PdfObjectName
	Filter       *_bgd.PdfObjectName
	SubFilter    *_bgd.PdfObjectName
	Contents     *_bgd.PdfObjectString
	Cert         _bgd.PdfObject
	ByteRange    *_bgd.PdfObjectArray
	Reference    *_bgd.PdfObjectArray
	Changes      *_bgd.PdfObjectArray
	Name         *_bgd.PdfObjectString
	M            *_bgd.PdfObjectString
	Location     *_bgd.PdfObjectString
	Reason       *_bgd.PdfObjectString
	ContactInfo  *_bgd.PdfObjectString
	R            *_bgd.PdfObjectInteger
	V            *_bgd.PdfObjectInteger
	PropBuild    *_bgd.PdfObjectDictionary
	PropAuthTime *_bgd.PdfObjectInteger
	PropAuthType *_bgd.PdfObjectName
}

// SetFillImage attach a model.Image to push button.
func (_beeeb *PdfFieldButton) SetFillImage(image *Image) {
	if _beeeb.IsPush() {
		_beeeb._fbedg = image
	}
}

// PdfInfoTrapped specifies pdf trapped information.
type PdfInfoTrapped string

// NewPdfReader returns a new PdfReader for an input io.ReadSeeker interface. Can be used to read PDF from
// memory or file. Immediately loads and traverses the PDF structure including pages and page contents (if
// not encrypted). Loads entire document structure into memory.
// Alternatively a lazy-loading reader can be created with NewPdfReaderLazy which loads only references,
// and references are loaded from disk into memory on an as-needed basis.
func NewPdfReader(rs _ca.ReadSeeker) (*PdfReader, error) {
	const _efcd = "\u006do\u0064e\u006c\u003a\u004e\u0065\u0077P\u0064\u0066R\u0065\u0061\u0064\u0065\u0072"
	return _acbcg(rs, &ReaderOpts{}, false, _efcd)
}

// AcroFormRepairOptions contains options for rebuilding the AcroForm.
type AcroFormRepairOptions struct{}

// GetXHeight returns the XHeight of the font `descriptor`.
func (_eebbe *PdfFontDescriptor) GetXHeight() (float64, error) {
	return _bgd.GetNumberAsFloat(_eebbe.XHeight)
}

func (_bfbeg *PdfWriter) writeObjectsInStreams(_cgaee map[_bgd.PdfObject]bool) error {
	for _, _cfged := range _bfbeg._edcbg {
		if _aeff := _cgaee[_cfged]; _aeff {
			continue
		}
		_fffeg := int64(0)
		switch _beagf := _cfged.(type) {
		case *_bgd.PdfIndirectObject:
			_fffeg = _beagf.ObjectNumber
		case *_bgd.PdfObjectStream:
			_fffeg = _beagf.ObjectNumber
		case *_bgd.PdfObjectStreams:
			_fffeg = _beagf.ObjectNumber
		case *_bgd.PdfObjectDictionary, *_bgd.PdfObjectString:
		default:
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075p\u0070\u006f\u0072t\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069n\u0020wr\u0069\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0054\u0020\u0028\u0074\u0079\u0070\u0065\u0020\u0025\u0054\u0029", _cfged, _beagf)
			return ErrTypeCheck
		}
		if _bfbeg._ddcee != nil && _cfged != _bfbeg._abeb {
			_edeebd := _bfbeg._ddcee.Encrypt(_cfged, _fffeg, 0)
			if _edeebd != nil {
				_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067\u0020(%\u0073\u0029", _edeebd)
				return _edeebd
			}
		}
		_bfbeg.writeObject(int(_fffeg), _cfged)
	}
	return nil
}

// PdfColorDeviceGray represents a grayscale color value that shall be represented by a single number in the
// range 0.0 to 1.0 where 0.0 corresponds to black and 1.0 to white.
type PdfColorDeviceGray float64

// PdfActionJavaScript represents a javaScript action.
type PdfActionJavaScript struct {
	*PdfAction
	JS _bgd.PdfObject
}

func _fdbfd(_ceafb *PdfPage) _bgd.PdfObject {
	_aege := _gdg.GetLicenseKey()
	if _aege != nil && _aege.IsLicensed() {
		return _ceafb.ToPdfObject()
	}
	_dcefd := _bgd.PdfObjectName("\u0055\u0046\u0031")
	if !_ceafb.Resources.HasFontByName(_dcefd) {
		_ceafb.Resources.SetFontByName(_dcefd, DefaultFont().ToPdfObject())
	}
	var _gfdgf []string
	_gfdgf = append(_gfdgf, "\u0071")
	_gfdgf = append(_gfdgf, "\u0042\u0054")
	_gfdgf = append(_gfdgf, _f.Sprintf("\u002f%\u0073\u0020\u0031\u0034\u0020\u0054f", _dcefd.String()))
	_gfdgf = append(_gfdgf, "\u0031\u0020\u0030\u0020\u0030\u0020\u0072\u0067")
	_gfdgf = append(_gfdgf, "\u0031\u0030\u0020\u0031\u0030\u0020\u0054\u0064")
	_gcaaf := "\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020\u0055\u006e\u0069\u0044o\u0063\u0020\u002d\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u006c\u0069\u0063e\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073:/\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f"
	_gfdgf = append(_gfdgf, _f.Sprintf("\u0028%\u0073\u0029\u0020\u0054\u006a", _gcaaf))
	_gfdgf = append(_gfdgf, "\u0045\u0054")
	_gfdgf = append(_gfdgf, "\u0051")
	_fcdcbc := _ef.Join(_gfdgf, "\u000a")
	_ceafb.AddContentStreamByString(_fcdcbc)
	return _ceafb.ToPdfObject()
}

func (_efbbc *PdfWriter) writeOutputIntents() error {
	if len(_efbbc._ecbcfd) == 0 {
		return nil
	}
	_bfgc := make([]_bgd.PdfObject, len(_efbbc._ecbcfd))
	for _gfadcb, _gbfcc := range _efbbc._ecbcfd {
		_afdea := _gbfcc.ToPdfObject()
		_bfgc[_gfadcb] = _bgd.MakeIndirectObject(_afdea)
	}
	_eeedd := _bgd.MakeIndirectObject(_bgd.MakeArray(_bfgc...))
	_efbbc._aaea.Set("\u004f\u0075\u0074\u0070\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074\u0073", _eeedd)
	if _dbfce := _efbbc.addObjects(_eeedd); _dbfce != nil {
		return _dbfce
	}
	return nil
}

// FieldImageProvider provides fields images for specified fields.
type FieldImageProvider interface {
	FieldImageValues() (map[string]*Image, error)
}

func (_edaaf *PdfWriter) writeOutlines() error {
	if _edaaf._fabdf == nil {
		return nil
	}
	_fg.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0054\u0072\u0065\u0065\u003a\u0020\u0025\u002b\u0076", _edaaf._fabdf)
	_cfbdac := _edaaf._fabdf.ToPdfObject()
	_fg.Log.Trace("\u004fu\u0074\u006c\u0069\u006e\u0065\u0073\u003a\u0020\u0025\u002b\u0076 \u0028\u0025\u0054\u002c\u0020\u0070\u003a\u0025\u0070\u0029", _cfbdac, _cfbdac, _cfbdac)
	_edaaf._aaea.Set("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073", _cfbdac)
	_fecb := _edaaf.addObjects(_cfbdac)
	if _fecb != nil {
		return _fecb
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_acac *PdfAnnotationPolyLine) ToPdfObject() _bgd.PdfObject {
	_acac.PdfAnnotation.ToPdfObject()
	_ebb := _acac._eag
	_egcg := _ebb.PdfObject.(*_bgd.PdfObjectDictionary)
	_acac.appendToPdfDictionary(_egcg)
	_egcg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065"))
	_egcg.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _acac.Vertices)
	_egcg.SetIfNotNil("\u004c\u0045", _acac.LE)
	_egcg.SetIfNotNil("\u0042\u0053", _acac.BS)
	_egcg.SetIfNotNil("\u0049\u0043", _acac.IC)
	_egcg.SetIfNotNil("\u0042\u0045", _acac.BE)
	_egcg.SetIfNotNil("\u0049\u0054", _acac.IT)
	_egcg.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _acac.Measure)
	return _ebb
}

// Initialize initializes the PdfSignature.
func (_ebdea *PdfSignature) Initialize() error {
	if _ebdea.Handler == nil {
		return _gb.New("\u0073\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0068\u0061\u006e\u0064\u006c\u0065r\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	return _ebdea.Handler.InitSignature(_ebdea)
}

// Permissions specify a permissions dictionary (PDF 1.5).
// (Section 12.8.4, Table 258 - Entries in a permissions dictionary p. 477 in PDF32000_2008).
type Permissions struct {
	DocMDP *PdfSignature
	_cfgcg *_bgd.PdfObjectDictionary
}

func (_edfd *PdfReader) newPdfAnnotationInkFromDict(_agbd *_bgd.PdfObjectDictionary) (*PdfAnnotationInk, error) {
	_cfda := PdfAnnotationInk{}
	_acca, _cbgf := _edfd.newPdfAnnotationMarkupFromDict(_agbd)
	if _cbgf != nil {
		return nil, _cbgf
	}
	_cfda.PdfAnnotationMarkup = _acca
	_cfda.InkList = _agbd.Get("\u0049n\u006b\u004c\u0069\u0073\u0074")
	_cfda.BS = _agbd.Get("\u0042\u0053")
	return &_cfda, nil
}

func _ebfd(_cafe _bgd.PdfObject) (*PdfColorspaceDeviceNAttributes, error) {
	_cbcg := &PdfColorspaceDeviceNAttributes{}
	var _eefb *_bgd.PdfObjectDictionary
	switch _afbab := _cafe.(type) {
	case *_bgd.PdfIndirectObject:
		_cbcg._gecge = _afbab
		var _gfgdg bool
		_eefb, _gfgdg = _afbab.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_gfgdg {
			_fg.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
			return nil, _gb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
	case *_bgd.PdfObjectDictionary:
		_eefb = _afbab
	case *_bgd.PdfObjectReference:
		_edda := _afbab.Resolve()
		return _ebfd(_edda)
	default:
		_fg.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
		return nil, _gb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _accg := _eefb.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _accg != nil {
		_bfab, _cdcf := _bgd.TraceToDirectObject(_accg).(*_bgd.PdfObjectName)
		if !_cdcf {
			_fg.Log.Error("\u0044\u0065vi\u0063\u0065\u004e \u0061\u0074\u0074\u0072ibu\u0074e \u0053\u0075\u0062\u0074\u0079\u0070\u0065 t\u0079\u0070\u0065\u0020\u0065\u0072\u0072o\u0072")
			return nil, _gb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_cbcg.Subtype = _bfab
	}
	if _bgdg := _eefb.Get("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s"); _bgdg != nil {
		_cbcg.Colorants = _bgdg
	}
	if _ddab := _eefb.Get("\u0050r\u006f\u0063\u0065\u0073\u0073"); _ddab != nil {
		_cbcg.Process = _ddab
	}
	if _bbdb := _eefb.Get("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073"); _bbdb != nil {
		_cbcg.MixingHints = _bbdb
	}
	return _cbcg, nil
}

// DecodeArray returns the range of color component values in the ICCBased colorspace.
func (_dfgb *PdfColorspaceICCBased) DecodeArray() []float64 { return _dfgb.Range }

func _fdccc(_efagc _bgd.PdfObject) (string, error) {
	_efagc = _bgd.TraceToDirectObject(_efagc)
	switch _edbc := _efagc.(type) {
	case *_bgd.PdfObjectString:
		return _edbc.Str(), nil
	case *_bgd.PdfObjectStream:
		_acec, _bffca := _bgd.DecodeStream(_edbc)
		if _bffca != nil {
			return "", _bffca
		}
		return string(_acec), nil
	}
	return "", _f.Errorf("\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0073\u0074\u0072e\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0068\u006f\u006c\u0064\u0065\u0072\u0020\u0028\u0025\u0054\u0029", _efagc)
}

// SetPdfTitle sets the Title attribute of the output PDF.
func SetPdfTitle(title string) { _adcf.Lock(); defer _adcf.Unlock(); _fcfe = title }

// PdfColorspaceDeviceN represents a DeviceN color space. DeviceN color spaces are similar to Separation color
// spaces, except they can contain an arbitrary number of color components.
/*
	Format: [/DeviceN names alternateSpace tintTransform]
        or: [/DeviceN names alternateSpace tintTransform attributes]
*/
type PdfColorspaceDeviceN struct {
	ColorantNames  *_bgd.PdfObjectArray
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	Attributes     *PdfColorspaceDeviceNAttributes
	_fdec          *_bgd.PdfIndirectObject
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_fffb *PdfColorspaceDeviceGray) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_agfg, _dabdf := _bgd.GetNumbersAsFloat(objects)
	if _dabdf != nil {
		return nil, _dabdf
	}
	return _fffb.ColorFromFloats(_agfg)
}

// SetPrintArea sets the value of the printArea.
func (_ecfea *ViewerPreferences) SetPrintArea(printArea PageBoundary) { _ecfea._fccec = printArea }

// FieldFilterFunc represents a PDF field filtering function. If the function
// returns true, the PDF field is kept, otherwise it is discarded.
type FieldFilterFunc func(*PdfField) bool

// GetRotate gets the inheritable rotate value, either from the page
// or a higher up page/pages struct.
func (_aadgb *PdfPage) GetRotate() (int64, error) {
	if _aadgb.Rotate != nil {
		return *_aadgb.Rotate, nil
	}
	_gdfcf := _aadgb.Parent
	for _gdfcf != nil {
		_ddedd, _faddc := _bgd.GetDict(_gdfcf)
		if !_faddc {
			return 0, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _fabab := _ddedd.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _fabab != nil {
			_fefb, _gfcdf := _bgd.GetInt(_fabab)
			if !_gfcdf {
				return 0, _gb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0074a\u0074\u0065\u0020\u0076al\u0075\u0065")
			}
			if _fefb != nil {
				return int64(*_fefb), nil
			}
			return 0, _gb.New("\u0072\u006f\u0074\u0061te\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		_gdfcf = _ddedd.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return 0, _gb.New("\u0072o\u0074a\u0074\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064")
}

// NewPdfDateFromTime will create a PdfDate based on the given time
func NewPdfDateFromTime(timeObj _ge.Time) (PdfDate, error) {
	_cbddff := timeObj.Format("\u002d\u0030\u0037\u003a\u0030\u0030")
	_bbcbd, _ := _ae.ParseInt(_cbddff[1:3], 10, 32)
	_ggfad, _ := _ae.ParseInt(_cbddff[4:6], 10, 32)
	return PdfDate{_ccgca: int64(timeObj.Year()), _agbb: int64(timeObj.Month()), _bdef: int64(timeObj.Day()), _ccdga: int64(timeObj.Hour()), _cfba: int64(timeObj.Minute()), _cgde: int64(timeObj.Second()), _eceda: _cbddff[0], _bgcab: _bbcbd, _dgbfg: _ggfad}, nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_cedfd *PdfPageResourcesColorspaces) ToPdfObject() _bgd.PdfObject {
	_ebggg := _bgd.MakeDict()
	for _, _ffba := range _cedfd.Names {
		_ebggg.Set(_bgd.PdfObjectName(_ffba), _cedfd.Colorspaces[_ffba].ToPdfObject())
	}
	if _cedfd._dggea != nil {
		_cedfd._dggea.PdfObject = _ebggg
		return _cedfd._dggea
	}
	return _ebggg
}

// HasFontByName checks if has font resource by name.
func (_ggcdb *PdfPage) HasFontByName(name _bgd.PdfObjectName) bool {
	_fdegf, _caffa := _ggcdb.Resources.Font.(*_bgd.PdfObjectDictionary)
	if !_caffa {
		return false
	}
	if _egade := _fdegf.Get(name); _egade != nil {
		return true
	}
	return false
}

// PdfColorLab represents a color in the L*, a*, b* 3 component colorspace.
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorLab [3]float64

// AppendContentBytes creates a PDF stream from `cs` and appends it to the
// array of streams specified by the pages's Contents entry.
// If `wrapContents` is true, the content stream of the page is wrapped using
// a `q/Q` operator pair, so that its state does not affect the appended
// content stream.
func (_bagbf *PdfPage) AppendContentBytes(cs []byte, wrapContents bool) error {
	_fgbea := _bagbf.GetContentStreamObjs()
	wrapContents = wrapContents && len(_fgbea) > 0
	_ebbdb := _bgd.NewFlateEncoder()
	_fbgcba := _bgd.MakeArray()
	if wrapContents {
		_dddee, _cdegc := _bgd.MakeStream([]byte("\u0071\u000a"), _ebbdb)
		if _cdegc != nil {
			return _cdegc
		}
		_fbgcba.Append(_dddee)
	}
	_fbgcba.Append(_fgbea...)
	if wrapContents {
		_cdcfb, _gfef := _bgd.MakeStream([]byte("\u000a\u0051\u000a"), _ebbdb)
		if _gfef != nil {
			return _gfef
		}
		_fbgcba.Append(_cdcfb)
	}
	_fddg, _bfcfc := _bgd.MakeStream(cs, _ebbdb)
	if _bfcfc != nil {
		return _bfcfc
	}
	_fbgcba.Append(_fddg)
	_bagbf.Contents = _fbgcba
	return nil
}

var (
	StructureTypeSpan               StructureType = "\u0053\u0070\u0061\u006e"
	StructureTypeQuote              StructureType = "\u0051\u0075\u006ft\u0065"
	StructureTypeNote               StructureType = "\u004e\u006f\u0074\u0065"
	StructureTypeReference          StructureType = "\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e"
	StructureTypeBibliography       StructureType = "\u0042\u0069\u0062\u0045\u006e\u0074\u0072\u0079"
	StructureTypeCode               StructureType = "\u0043\u006f\u0064\u0065"
	StructureTypeLink               StructureType = "\u004c\u0069\u006e\u006b"
	StructureTypeAnnot              StructureType = "\u0041\u006e\u006eo\u0074"
	StructureTypeRuby               StructureType = "\u0052\u0075\u0062\u0079"
	StructureTypeWarichu            StructureType = "\u0057a\u0072\u0069\u0063\u0068\u0075"
	StructureTypeRubyBase           StructureType = "\u0052\u0042"
	StructureTypeRubyText           StructureType = "\u0052\u0054"
	StructureTypeRubyPunctuation    StructureType = "\u0052\u0050"
	StructureTypeWarichuText        StructureType = "\u0057\u0054"
	StructureTypeWarichuPunctuation StructureType = "\u0057\u0050"
	StructureTypeFigure             StructureType = "\u0046\u0069\u0067\u0075\u0072\u0065"
	StructureTypeFormula            StructureType = "\u0046o\u0072\u006d\u0075\u006c\u0061"
	StructureTypeForm               StructureType = "\u0046\u006f\u0072\u006d"
)

// NewPdfActionURI returns a new "Uri" action.
func NewPdfActionURI() *PdfActionURI {
	_gde := NewPdfAction()
	_dfd := &PdfActionURI{}
	_dfd.PdfAction = _gde
	_gde.SetContext(_dfd)
	return _dfd
}

func (_bfedb *PdfWriter) writeObjects() {
	_fg.Log.Trace("\u0057\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u0025d\u0020\u006f\u0062\u006a", len(_bfedb._edcbg))
	_bfedb._bdfbdd = make(map[int]crossReference)
	_bfedb._bdfbdd[0] = crossReference{Type: 0, ObjectNumber: 0, Generation: 0xFFFF}
	if _bfedb._daffe.ObjectMap != nil {
		for _fcaga, _baeaa := range _bfedb._daffe.ObjectMap {
			if _fcaga == 0 {
				continue
			}
			if _baeaa.XType == _bgd.XrefTypeObjectStream {
				_edbab := crossReference{Type: 2, ObjectNumber: _baeaa.OsObjNumber, Index: _baeaa.OsObjIndex}
				_bfedb._bdfbdd[_fcaga] = _edbab
			}
			if _baeaa.XType == _bgd.XrefTypeTableEntry {
				_gaccb := crossReference{Type: 1, ObjectNumber: _baeaa.ObjectNumber, Offset: _baeaa.Offset}
				_bfedb._bdfbdd[_fcaga] = _gaccb
			}
		}
	}
}

// SetColorSpace sets `r` colorspace object to `colorspace`.
func (_ggaba *PdfPageResources) SetColorSpace(colorspace *PdfPageResourcesColorspaces) {
	_ggaba._fabf = colorspace
}

func _ddbd() *Names { return &Names{_cafda: _bgd.MakeIndirectObject(_bgd.MakeDict())} }

func _dffff(_abfb _bgd.PdfObject) (*PdfFunctionType2, error) {
	_faadd := &PdfFunctionType2{}
	var _gbfc *_bgd.PdfObjectDictionary
	if _gfbgg, _eeafg := _abfb.(*_bgd.PdfIndirectObject); _eeafg {
		_geaba, _dcbgc := _gfbgg.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_dcbgc {
			return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_faadd._edeg = _gfbgg
		_gbfc = _geaba
	} else if _aedaa, _dfcfa := _abfb.(*_bgd.PdfObjectDictionary); _dfcfa {
		_gbfc = _aedaa
	} else {
		return nil, _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_fg.Log.Trace("\u0046U\u004e\u0043\u0032\u003a\u0020\u0025s", _gbfc.String())
	_bfcfd, _cdcba := _bgd.TraceToDirectObject(_gbfc.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_bgd.PdfObjectArray)
	if !_cdcba {
		_fg.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _bfcfd.Len() < 0 || _bfcfd.Len()%2 != 0 {
		_fg.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u0069\u006e\u0076al\u0069\u0064")
		return nil, _gb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_fbaaa, _gedbe := _bfcfd.ToFloat64Array()
	if _gedbe != nil {
		return nil, _gedbe
	}
	_faadd.Domain = _fbaaa
	_bfcfd, _cdcba = _bgd.TraceToDirectObject(_gbfc.Get("\u0052\u0061\u006eg\u0065")).(*_bgd.PdfObjectArray)
	if _cdcba {
		if _bfcfd.Len() < 0 || _bfcfd.Len()%2 != 0 {
			return nil, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_adab, _adegac := _bfcfd.ToFloat64Array()
		if _adegac != nil {
			return nil, _adegac
		}
		_faadd.Range = _adab
	}
	_bfcfd, _cdcba = _bgd.TraceToDirectObject(_gbfc.Get("\u0043\u0030")).(*_bgd.PdfObjectArray)
	if _cdcba {
		_egdd, _ffab := _bfcfd.ToFloat64Array()
		if _ffab != nil {
			return nil, _ffab
		}
		_faadd.C0 = _egdd
	}
	_bfcfd, _cdcba = _bgd.TraceToDirectObject(_gbfc.Get("\u0043\u0031")).(*_bgd.PdfObjectArray)
	if _cdcba {
		_afceg, _ddcbb := _bfcfd.ToFloat64Array()
		if _ddcbb != nil {
			return nil, _ddcbb
		}
		_faadd.C1 = _afceg
	}
	if len(_faadd.C0) != len(_faadd.C1) {
		_fg.Log.Error("\u0043\u0030\u0020\u0061nd\u0020\u0043\u0031\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0069n\u0067")
		return nil, _bgd.ErrRangeError
	}
	N, _gedbe := _bgd.GetNumberAsFloat(_bgd.TraceToDirectObject(_gbfc.Get("\u004e")))
	if _gedbe != nil {
		_fg.Log.Error("\u004e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020o\u0072\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u002c\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073", _gbfc.String())
		return nil, _gedbe
	}
	_faadd.N = N
	return _faadd, nil
}

func _ccbe(_cbaggg _bgd.PdfObject) (*PdfPattern, error) {
	_fbfg := &PdfPattern{}
	var _cabbae *_bgd.PdfObjectDictionary
	if _afcega, _gcdde := _bgd.GetIndirect(_cbaggg); _gcdde {
		_fbfg._eaddb = _afcega
		_dgcb, _dfdcb := _afcega.PdfObject.(*_bgd.PdfObjectDictionary)
		if !_dfdcb {
			_fg.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006fn\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079\u0020\u0028g\u006f\u0074\u0020%\u0054\u0029", _afcega.PdfObject)
			return nil, _bgd.ErrTypeError
		}
		_cabbae = _dgcb
	} else if _gdagcg, _cfca := _bgd.GetStream(_cbaggg); _cfca {
		_fbfg._eaddb = _gdagcg
		_cabbae = _gdagcg.PdfObjectDictionary
	} else {
		_fg.Log.Debug("\u0050a\u0074\u0074e\u0072\u006e\u0020\u006eo\u0074\u0020\u0061n\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 o\u0062\u006a\u0065c\u0074\u0020o\u0072\u0020\u0073\u0074\u0072\u0065a\u006d\u002e \u0025\u0054", _cbaggg)
		return nil, _bgd.ErrTypeError
	}
	_effge := _cabbae.Get("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065")
	if _effge == nil {
		_fg.Log.Debug("\u0050\u0064\u0066\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069n\u0067\u0020\u0050\u0061\u0074t\u0065\u0072n\u0054\u0079\u0070\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bcgdd, _dadaa := _effge.(*_bgd.PdfObjectInteger)
	if !_dadaa {
		_fg.Log.Debug("\u0050\u0061tt\u0065\u0072\u006e \u0074\u0079\u0070\u0065 no\u0074 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067er\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _effge)
		return nil, _bgd.ErrTypeError
	}
	if *_bcgdd != 1 && *_bcgdd != 2 {
		_fg.Log.Debug("\u0050\u0061\u0074\u0074e\u0072\u006e\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d \u0031/\u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", *_bcgdd)
		return nil, _bgd.ErrRangeError
	}
	_fbfg.PatternType = int64(*_bcgdd)
	switch *_bcgdd {
	case 1:
		_dgdcd, _ccbcc := _aadab(_cabbae)
		if _ccbcc != nil {
			return nil, _ccbcc
		}
		_dgdcd.PdfPattern = _fbfg
		_fbfg._ggafd = _dgdcd
		return _fbfg, nil
	case 2:
		_dfdg, _effc := _fbcc(_cabbae)
		if _effc != nil {
			return nil, _effc
		}
		_dfdg.PdfPattern = _fbfg
		_fbfg._ggafd = _dfdg
		return _fbfg, nil
	}
	return nil, _gb.New("\u0075n\u006bn\u006f\u0077\u006e\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e")
}

// NewPdfActionImportData returns a new "import data" action.
func NewPdfActionImportData() *PdfActionImportData {
	_adg := NewPdfAction()
	_cgd := &PdfActionImportData{}
	_cgd.PdfAction = _adg
	_adg.SetContext(_cgd)
	return _cgd
}

// ColorFromPdfObjects gets the color from a series of pdf objects (4 for cmyk).
func (_bdgca *PdfColorspaceDeviceCMYK) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 4 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ceee, _bcgc := _bgd.GetNumbersAsFloat(objects)
	if _bcgc != nil {
		return nil, _bcgc
	}
	return _bdgca.ColorFromFloats(_ceee)
}

// NewReaderForText makes a new PdfReader for an input PDF content string. For use in testing.
func NewReaderForText(txt string) *PdfReader {
	return &PdfReader{_dadbf: map[_bgd.PdfObject]struct{}{}, _gggb: _dcag(), _ccade: _bgd.NewParserFromString(txt)}
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the L, A and B components of the color.
func (_geba *PdfColorspaceLab) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bdceb, _aaebe := _bgd.GetNumbersAsFloat(objects)
	if _aaebe != nil {
		return nil, _aaebe
	}
	return _geba.ColorFromFloats(_bdceb)
}

func (_abg *PdfReader) newPdfActionLaunchFromDict(_ddda *_bgd.PdfObjectDictionary) (*PdfActionLaunch, error) {
	_fdge, _ddgg := _ada(_ddda.Get("\u0046"))
	if _ddgg != nil {
		return nil, _ddgg
	}
	return &PdfActionLaunch{Win: _ddda.Get("\u0057\u0069\u006e"), Mac: _ddda.Get("\u004d\u0061\u0063"), Unix: _ddda.Get("\u0055\u006e\u0069\u0078"), NewWindow: _ddda.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _fdge}, nil
}

// ImageToRGB returns an error since an image cannot be defined in a pattern colorspace.
func (_bfbgg *PdfColorspaceSpecialPattern) ImageToRGB(img Image) (Image, error) {
	_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0049\u006d\u0061\u0067\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0069\u006e\u0020\u0050\u0061\u0074\u0074\u0065\u0072n \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	return img, _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0066\u006f\u0072\u0020\u0069m\u0061\u0067\u0065\u0020\u0028p\u0061\u0074t\u0065\u0072\u006e\u0029")
}

// ImageToRGB convert an indexed image to RGB.
func (_cca *PdfColorspaceSpecialIndexed) ImageToRGB(img Image) (Image, error) {
	N := _cca.Base.GetNumComponents()
	if N < 1 {
		return Image{}, _f.Errorf("\u0062\u0061d \u0062\u0061\u0073e\u0020\u0063\u006f\u006cors\u0070ac\u0065\u0020\u004e\u0075\u006d\u0043\u006fmp\u006f\u006e\u0065\u006e\u0074\u0073\u003d%\u0064", N)
	}
	_ecfa := _daf.NewImageBase(int(img.Width), int(img.Height), 8, N, nil, img._bdgdb, img._agcea)
	_gdcag := _eaa.NewReader(img.getBase())
	_aeef := _eaa.NewWriter(_ecfa)
	var (
		_gfaf  uint32
		_ecefb int
		_cecf  error
	)
	for {
		_gfaf, _cecf = _gdcag.ReadSample()
		if _cecf == _ca.EOF {
			break
		} else if _cecf != nil {
			return img, _cecf
		}
		_ecefb = int(_gfaf)
		_fg.Log.Trace("\u0049\u006ed\u0065\u0078\u0065\u0064\u003a\u0020\u0069\u006e\u0064\u0065\u0078\u003d\u0025\u0064\u0020\u004e\u003d\u0025\u0064\u0020\u006c\u0075t=\u0025\u0064", _ecefb, N, len(_cca._bcecd))
		if (_ecefb+1)*N > len(_cca._bcecd) {
			_ecefb = len(_cca._bcecd)/N - 1
			_fg.Log.Trace("C\u006c\u0069\u0070\u0070in\u0067 \u0074\u006f\u0020\u0069\u006ed\u0065\u0078\u003a\u0020\u0025\u0064", _ecefb)
			if _ecefb < 0 {
				_fg.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0043a\u006e\u0027\u0074\u0020\u0063\u006c\u0069p\u0020\u0069\u006e\u0064\u0065\u0078.\u0020\u0049\u0073\u0020\u0050\u0044\u0046\u0020\u0066\u0069\u006ce\u0020\u0064\u0061\u006d\u0061\u0067\u0065\u0064\u003f")
				break
			}
		}
		for _aegb := _ecefb * N; _aegb < (_ecefb+1)*N; _aegb++ {
			if _cecf = _aeef.WriteSample(uint32(_cca._bcecd[_aegb])); _cecf != nil {
				return img, _cecf
			}
		}
	}
	return _cca.Base.ImageToRGB(_acfa(&_ecfa))
}

// PdfActionURI represents an URI action.
type PdfActionURI struct {
	*PdfAction
	URI   _bgd.PdfObject
	IsMap _bgd.PdfObject
}

var _gddca = map[string]string{"\u0053\u0079\u006d\u0062\u006f\u006c": "\u0053\u0079\u006d\u0062\u006f\u006c\u0045\u006e\u0063o\u0064\u0069\u006e\u0067", "\u005a\u0061\u0070f\u0044\u0069\u006e\u0067\u0062\u0061\u0074\u0073": "Z\u0061p\u0066\u0044\u0069\u006e\u0067\u0062\u0061\u0074s\u0045\u006e\u0063\u006fdi\u006e\u0067"}

// ColorFromPdfObjects returns a new PdfColor based on input color components. The input PdfObjects should
// be numeric.
func (_cdbed *PdfColorspaceDeviceN) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != _cdbed.GetNumComponents() {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gege, _adge := _bgd.GetNumbersAsFloat(objects)
	if _adge != nil {
		return nil, _adge
	}
	return _cdbed.ColorFromFloats(_gege)
}

// PdfColorPatternType3 represents a color shading pattern type 3 (Radial).
type PdfColorPatternType3 struct {
	Color       PdfColor
	PatternName _bgd.PdfObjectName
}

// GetCatalogViewerPreferences gets catalog ViewerPreferences object.
func (_degc *PdfReader) GetCatalogViewerPreferences() (_bgd.PdfObject, bool) {
	if _degc._ffabf == nil {
		return nil, false
	}
	_gfgdf := _degc._ffabf.Get("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073")
	return _gfgdf, _gfgdf != nil
}

// ToPdfObject implements interface PdfModel.
func (_edae *PdfAnnotationRedact) ToPdfObject() _bgd.PdfObject {
	_edae.PdfAnnotation.ToPdfObject()
	_cff := _edae._eag
	_cce := _cff.PdfObject.(*_bgd.PdfObjectDictionary)
	_edae.appendToPdfDictionary(_cce)
	_cce.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0052\u0065\u0064\u0061\u0063\u0074"))
	_cce.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _edae.QuadPoints)
	_cce.SetIfNotNil("\u0049\u0043", _edae.IC)
	_cce.SetIfNotNil("\u0052\u004f", _edae.RO)
	_cce.SetIfNotNil("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074", _edae.OverlayText)
	_cce.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _edae.Repeat)
	_cce.SetIfNotNil("\u0044\u0041", _edae.DA)
	_cce.SetIfNotNil("\u0051", _edae.Q)
	return _cff
}

// GenerateHashMaps generates DSS hashmaps for Certificates, OCSPs and CRLs to make sure they are unique.
func (_bgge *DSS) GenerateHashMaps() error {
	_abfffe, _agfc := _bgge.generateHashMap(_bgge.Certs)
	if _agfc != nil {
		return _agfc
	}
	_egdb, _agfc := _bgge.generateHashMap(_bgge.OCSPs)
	if _agfc != nil {
		return _agfc
	}
	_dfce, _agfc := _bgge.generateHashMap(_bgge.CRLs)
	if _agfc != nil {
		return _agfc
	}
	_bgge._gbed = _abfffe
	_bgge._edecd = _egdb
	_bgge._agbcg = _dfce
	return nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_bcee *PdfColorspaceSpecialSeparation) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bcga := vals[0]
	_eeebb := []float64{_bcga}
	_ffgdc, _eafa := _bcee.TintTransform.Evaluate(_eeebb)
	if _eafa != nil {
		_fg.Log.Debug("\u0045\u0072r\u006f\u0072\u002c\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0065: \u0025\u0076", _eafa)
		_fg.Log.Trace("\u0054\u0069\u006e\u0074 t\u0072\u0061\u006e\u0073\u0066\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _bcee.TintTransform)
		return nil, _eafa
	}
	_fg.Log.Trace("\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u0020\u0043\u006f\u006c\u006fr\u0046\u0072\u006f\u006d\u0046\u006c\u006f\u0061\u0074\u0073\u0028\u0025\u002bv\u0029\u0020\u006f\u006e\u0020\u0041\u006c\u0074\u0065\u0072\u006e\u0061te\u0053\u0070\u0061\u0063\u0065\u003a\u0020\u0025\u0023\u0076", _ffgdc, _bcee.AlternateSpace)
	_cgdc, _eafa := _bcee.AlternateSpace.ColorFromFloats(_ffgdc)
	if _eafa != nil {
		_fg.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u002c\u0020\u0066a\u0069\u006c\u0065d \u0074\u006f\u0020\u0065\u0076\u0061l\u0075\u0061\u0074\u0065\u0020\u0069\u006e\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u003a \u0025\u0076", _eafa)
		return nil, _eafa
	}
	return _cgdc, nil
}

func (_gdc *PdfReader) newPdfActionGotoEFromDict(_adgc *_bgd.PdfObjectDictionary) (*PdfActionGoToE, error) {
	_cgfe, _dcd := _ada(_adgc.Get("\u0046"))
	if _dcd != nil {
		return nil, _dcd
	}
	return &PdfActionGoToE{D: _adgc.Get("\u0044"), NewWindow: _adgc.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), T: _adgc.Get("\u0054"), F: _cgfe}, nil
}

// String returns the name of the colorspace (DeviceN).
func (_bdaaa *PdfColorspaceDeviceN) String() string { return "\u0044e\u0076\u0069\u0063\u0065\u004e" }

// SetVersion sets the PDF version of the output file.
func (_ggaea *PdfWriter) SetVersion(majorVersion, minorVersion int) {
	_ggaea._egbga.Major = majorVersion
	_ggaea._egbga.Minor = minorVersion
}

func (_bca *PdfReader) newPdfAnnotationProjectionFromDict(_ace *_bgd.PdfObjectDictionary) (*PdfAnnotationProjection, error) {
	_gae := &PdfAnnotationProjection{}
	_geeb, _dee := _bca.newPdfAnnotationMarkupFromDict(_ace)
	if _dee != nil {
		return nil, _dee
	}
	_gae.PdfAnnotationMarkup = _geeb
	return _gae, nil
}

// ToPdfObject return the CalGray colorspace as a PDF object (name dictionary).
func (_accb *PdfColorspaceCalGray) ToPdfObject() _bgd.PdfObject {
	_fadf := &_bgd.PdfObjectArray{}
	_fadf.Append(_bgd.MakeName("\u0043a\u006c\u0047\u0072\u0061\u0079"))
	_baff := _bgd.MakeDict()
	if _accb.WhitePoint != nil {
		_baff.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _bgd.MakeArray(_bgd.MakeFloat(_accb.WhitePoint[0]), _bgd.MakeFloat(_accb.WhitePoint[1]), _bgd.MakeFloat(_accb.WhitePoint[2])))
	} else {
		_fg.Log.Error("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006fi\u006e\u0074\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _accb.BlackPoint != nil {
		_baff.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _bgd.MakeArray(_bgd.MakeFloat(_accb.BlackPoint[0]), _bgd.MakeFloat(_accb.BlackPoint[1]), _bgd.MakeFloat(_accb.BlackPoint[2])))
	}
	_baff.Set("\u0047\u0061\u006dm\u0061", _bgd.MakeFloat(_accb.Gamma))
	_fadf.Append(_baff)
	if _accb._ecad != nil {
		_accb._ecad.PdfObject = _fadf
		return _accb._ecad
	}
	return _fadf
}

// NewPdfAnnotationHighlight returns a new text highlight annotation.
func NewPdfAnnotationHighlight() *PdfAnnotationHighlight {
	_cee := NewPdfAnnotation()
	_bff := &PdfAnnotationHighlight{}
	_bff.PdfAnnotation = _cee
	_bff.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cee.SetContext(_bff)
	return _bff
}

// HasColorspaceByName checks if the colorspace with the specified name exists in the page resources.
func (_cacda *PdfPageResources) HasColorspaceByName(keyName _bgd.PdfObjectName) bool {
	_abcfc, _dgee := _cacda.GetColorspaces()
	if _dgee != nil {
		_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _dgee)
		return false
	}
	if _abcfc == nil {
		return false
	}
	_, _cbcd := _abcfc.Colorspaces[string(keyName)]
	return _cbcd
}

// GenerateRandomID generates a random ID for the K dictionary object.
func (_aceg *KDict) GenerateRandomID() string {
	_bgddg, _bcbef := _gff.NewUUID()
	if _bcbef != nil {
		_fg.Log.Debug("\u0045r\u0072\u006f\u0072\u0020g\u0065\u006e\u0065\u0072\u0061t\u0069n\u0067 \u0055\u0055\u0049\u0044\u003a\u0020\u0025v", _bcbef)
	}
	if _bgddg != _gff.Nil {
		_dcbbe := _bgddg.String()
		_aceg.ID = _bgd.MakeString(_dcbbe)
		return _dcbbe
	}
	return ""
}

func (_decg *PdfColorspaceCalRGB) String() string { return "\u0043\u0061\u006c\u0052\u0047\u0042" }

// Evaluate runs the function on the passed in slice and returns the results.
func (_aabfg *PdfFunctionType2) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_fg.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dgcae := []float64{0.0}
	if _aabfg.C0 != nil {
		_dgcae = _aabfg.C0
	}
	_gfdd := []float64{1.0}
	if _aabfg.C1 != nil {
		_gfdd = _aabfg.C1
	}
	var _cddee []float64
	for _fegf := 0; _fegf < len(_dgcae); _fegf++ {
		_cgcc := _dgcae[_fegf] + _da.Pow(x[0], _aabfg.N)*(_gfdd[_fegf]-_dgcae[_fegf])
		_cddee = append(_cddee, _cgcc)
	}
	return _cddee, nil
}

var ImageHandling ImageHandler = DefaultImageHandler{}

const (
	BorderEffectNoEffect BorderEffect = iota
	BorderEffectCloudy   BorderEffect = iota
)

func (_egece *PdfWriter) seekByName(_gbfbc _bgd.PdfObject, _dgaeb []string, _eecd string) ([]_bgd.PdfObject, error) {
	_fg.Log.Trace("\u0053\u0065\u0065\u006b\u0020\u0062\u0079\u0020\u006e\u0061\u006d\u0065.\u002e\u0020\u0025\u0054", _gbfbc)
	var _addec []_bgd.PdfObject
	if _dfacd, _gbdcga := _gbfbc.(*_bgd.PdfIndirectObject); _gbdcga {
		return _egece.seekByName(_dfacd.PdfObject, _dgaeb, _eecd)
	}
	if _feacd, _febag := _gbfbc.(*_bgd.PdfObjectStream); _febag {
		return _egece.seekByName(_feacd.PdfObjectDictionary, _dgaeb, _eecd)
	}
	if _cdgc, _efaag := _gbfbc.(*_bgd.PdfObjectDictionary); _efaag {
		_fg.Log.Trace("\u0044\u0069\u0063\u0074")
		for _, _fgfac := range _cdgc.Keys() {
			_ddbef := _cdgc.Get(_fgfac)
			if string(_fgfac) == _eecd {
				_addec = append(_addec, _ddbef)
			}
			for _, _fdbbe := range _dgaeb {
				if string(_fgfac) == _fdbbe {
					_fg.Log.Trace("\u0046\u006f\u006c\u006c\u006f\u0077\u0020\u006b\u0065\u0079\u0020\u0025\u0073", _fdbbe)
					_fdbfe, _babae := _egece.seekByName(_ddbef, _dgaeb, _eecd)
					if _babae != nil {
						return _addec, _babae
					}
					_addec = append(_addec, _fdbfe...)
					break
				}
			}
		}
		return _addec, nil
	}
	return _addec, nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_dded *PdfColorspaceCalGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ebde := vals[0]
	if _ebde < 0.0 || _ebde > 1.0 {
		_fg.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _ebde)
		return nil, ErrColorOutOfRange
	}
	_abcc := NewPdfColorCalGray(_ebde)
	return _abcc, nil
}

// IsColored specifies if the pattern is colored.
func (_edfda *PdfTilingPattern) IsColored() bool {
	if _edfda.PaintType != nil && *_edfda.PaintType == 1 {
		return true
	}
	return false
}

// ToPdfObject implements interface PdfModel.
func (_gbac *PdfSignatureReference) ToPdfObject() _bgd.PdfObject {
	_dadef := _bgd.MakeDict()
	_dadef.SetIfNotNil("\u0054\u0079\u0070\u0065", _gbac.Type)
	_dadef.SetIfNotNil("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064", _gbac.TransformMethod)
	_dadef.SetIfNotNil("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073", _gbac.TransformParams)
	_dadef.SetIfNotNil("\u0044\u0061\u0074\u0061", _gbac.Data)
	_dadef.SetIfNotNil("\u0044\u0069\u0067e\u0073\u0074\u004d\u0065\u0074\u0068\u006f\u0064", _gbac.DigestMethod)
	return _dadef
}

// GetCharMetrics returns the character metrics for the specified character code.  A bool flag is
// returned to indicate whether or not the entry was found in the glyph to charcode mapping.
// How it works:
//  1. Return a value the /Widths array (charWidths) if there is one.
//  2. If the font has the same name as a standard 14 font then return width=250.
//  3. Otherwise return no match and let the caller substitute a default.
func (_cafae pdfFontSimple) GetCharMetrics(code _dabf.CharCode) (_fe.CharMetrics, bool) {
	if _baddc, _cabdb := _cafae._ffagd[code]; _cabdb {
		return _fe.CharMetrics{Wx: _baddc}, true
	}
	if _fe.IsStdFont(_fe.StdFontName(_cafae._eebe)) {
		return _fe.CharMetrics{Wx: 250}, true
	}
	return _fe.CharMetrics{}, false
}

// NewPdfFontFromTTF loads a TTF font and returns a PdfFont type that can be
// used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTF.
func NewPdfFontFromTTF(r _ca.ReadSeeker) (*PdfFont, error) {
	const _cbbc = _dabf.CharCode(32)
	const _dbcg = _dabf.CharCode(255)
	_fbdf, _gbeb := _ca.ReadAll(r)
	if _gbeb != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _gbeb)
		return nil, _gbeb
	}
	_bgba, _gbeb := _fe.TtfParse(_ea.NewReader(_fbdf))
	if _gbeb != nil {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0054\u0054F\u0020\u0066\u006fn\u0074:\u0020\u0025\u0076", _gbeb)
		return nil, _gbeb
	}
	_dfbca := &pdfFontSimple{_ffagd: make(map[_dabf.CharCode]float64), fontCommon: fontCommon{_gecd: "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065"}}
	_dfbca._dcfdfd = _dabf.NewWinAnsiEncoder()
	_dfbca._eebe = _bgba.PostScriptName
	_dfbca.FirstChar = _bgd.MakeInteger(int64(_cbbc))
	_dfbca.LastChar = _bgd.MakeInteger(int64(_dbcg))
	_deda := 1000.0 / float64(_bgba.UnitsPerEm)
	if len(_bgba.Widths) <= 0 {
		return nil, _gb.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_ccaf := _deda * float64(_bgba.Widths[0])
	_feged := make([]float64, 0, _dbcg-_cbbc+1)
	for _defgc := _cbbc; _defgc <= _dbcg; _defgc++ {
		_cafdg, _agbcc := _dfbca.Encoder().CharcodeToRune(_defgc)
		if !_agbcc {
			_fg.Log.Debug("\u0052u\u006e\u0065\u0020\u006eo\u0074\u0020\u0066\u006f\u0075n\u0064 \u0028c\u006f\u0064\u0065\u003a\u0020\u0025\u0064)", _defgc)
			_feged = append(_feged, _ccaf)
			continue
		}
		_egdc, _agfb := _bgba.Chars[_cafdg]
		if !_agfb {
			_fg.Log.Debug("R\u0075\u006e\u0065\u0020no\u0074 \u0069\u006e\u0020\u0054\u0054F\u0020\u0043\u0068\u0061\u0072\u0073")
			_feged = append(_feged, _ccaf)
			continue
		}
		_cdgag := _deda * float64(_bgba.Widths[_egdc])
		_feged = append(_feged, _cdgag)
	}
	_dfbca.Widths = _bgd.MakeIndirectObject(_bgd.MakeArrayFromFloats(_feged))
	if len(_feged) < int(_dbcg-_cbbc+1) {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u006f\u0066\u0020\u0077\u0069\u0064\u0074\u0068s,\u0020\u0025\u0064 \u003c \u0025\u0064", len(_feged), 255-32+1)
		return nil, _bgd.ErrRangeError
	}
	for _beeegb := _cbbc; _beeegb <= _dbcg; _beeegb++ {
		_dfbca._ffagd[_beeegb] = _feged[_beeegb-_cbbc]
	}
	_dfbca.Encoding = _bgd.MakeName("\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
	_bcdbe := &PdfFontDescriptor{}
	_bcdbe.FontName = _bgd.MakeName(_bgba.PostScriptName)
	_bcdbe.Ascent = _bgd.MakeFloat(_deda * float64(_bgba.TypoAscender))
	_bcdbe.Descent = _bgd.MakeFloat(_deda * float64(_bgba.TypoDescender))
	_bcdbe.CapHeight = _bgd.MakeFloat(_deda * float64(_bgba.CapHeight))
	_bcdbe.FontBBox = _bgd.MakeArrayFromFloats([]float64{_deda * float64(_bgba.Xmin), _deda * float64(_bgba.Ymin), _deda * float64(_bgba.Xmax), _deda * float64(_bgba.Ymax)})
	_bcdbe.ItalicAngle = _bgd.MakeFloat(_bgba.ItalicAngle)
	_bcdbe.MissingWidth = _bgd.MakeFloat(_deda * float64(_bgba.Widths[0]))
	_bcbee, _gbeb := _bgd.MakeStream(_fbdf, _bgd.NewFlateEncoder())
	if _gbeb != nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _gbeb)
		return nil, _gbeb
	}
	_bcbee.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _bgd.MakeInteger(int64(len(_fbdf))))
	_bcdbe.FontFile2 = _bcbee
	if _bgba.Bold {
		_bcdbe.StemV = _bgd.MakeInteger(120)
	} else {
		_bcdbe.StemV = _bgd.MakeInteger(70)
	}
	_dbdb := _agfe
	if _bgba.IsFixedPitch {
		_dbdb |= _ecgf
	}
	if _bgba.ItalicAngle != 0 {
		_dbdb |= _dcgd
	}
	_bcdbe.Flags = _bgd.MakeInteger(int64(_dbdb))
	_dfbca._ggde = _bcdbe
	_aabeb := &PdfFont{_cbec: _dfbca}
	return _aabeb, nil
}

// PdfAnnotation3D represents 3D annotations.
// (Section 13.6.2).
type PdfAnnotation3D struct {
	*PdfAnnotation
	T3DD _bgd.PdfObject
	T3DV _bgd.PdfObject
	T3DA _bgd.PdfObject
	T3DI _bgd.PdfObject
	T3DB _bgd.PdfObject
}

// SetContext set the sub annotation (context).
func (_gdcdf *PdfShading) SetContext(ctx PdfModel) { _gdcdf._gggga = ctx }

func _fade(_adfccb *_bgd.PdfObjectDictionary, _eafb *fontCommon) (*pdfCIDFontType0, error) {
	if _eafb._gecd != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" {
		_fg.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0030\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _eafb)
		return nil, _bgd.ErrRangeError
	}
	_bafg := _abcda(_eafb)
	_befeb, _bdfb := _bgd.GetDict(_adfccb.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_bdfb {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _eafb)
		return nil, ErrRequiredAttributeMissing
	}
	_bafg.CIDSystemInfo = _befeb
	_bafg.DW = _adfccb.Get("\u0044\u0057")
	_bafg.W = _adfccb.Get("\u0057")
	_bafg.DW2 = _adfccb.Get("\u0044\u0057\u0032")
	_bafg.W2 = _adfccb.Get("\u0057\u0032")
	_bafg._bfgb = 1000.0
	if _cddeb, _bgdcg := _bgd.GetNumberAsFloat(_bafg.DW); _bgdcg == nil {
		_bafg._bfgb = _cddeb
	}
	_geee, _dabg := _ggcdcc(_bafg.W)
	if _dabg != nil {
		return nil, _dabg
	}
	if _geee == nil {
		_geee = map[_dabf.CharCode]float64{}
	}
	_bafg._ddbab = _geee
	return _bafg, nil
}

func (_cbdg *PdfField) inherit(_ccda func(*PdfField) bool) (bool, error) {
	_daddd := map[*PdfField]bool{}
	_bfacd := false
	_eecc := _cbdg
	for _eecc != nil {
		if _, _bbdd := _daddd[_eecc]; _bbdd {
			return false, _gb.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		_gaag := _ccda(_eecc)
		if _gaag {
			_bfacd = true
			break
		}
		_daddd[_eecc] = true
		_eecc = _eecc.Parent
	}
	return _bfacd, nil
}

// Fill populates `form` with values provided by `provider`.
func (_edde *PdfAcroForm) Fill(provider FieldValueProvider) error {
	return _edde.fill(provider, nil)
}

// SetForms sets the Acroform for a PDF file.
func (_deaad *PdfWriter) SetForms(form *PdfAcroForm) error { _deaad._edcdb = form; return nil }

// Encoder returns the font's text encoder.
func (_ebdfa *PdfFont) Encoder() _dabf.TextEncoder {
	_abdc := _ebdfa.actualFont()
	if _abdc == nil {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0045n\u0063\u006f\u0064er\u0020\u006e\u006f\u0074\u0020\u0069m\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066o\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d%\u0023\u0054", _ebdfa._cbec)
		return nil
	}
	return _abdc.Encoder()
}

// ToPdfObject returns the PDF representation of the function.
func (_cffg *PdfFunctionType0) ToPdfObject() _bgd.PdfObject {
	if _cffg._fgeeg == nil {
		_cffg._fgeeg = &_bgd.PdfObjectStream{}
	}
	_aafce := _bgd.MakeDict()
	_aafce.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _bgd.MakeInteger(0))
	_cgaf := &_bgd.PdfObjectArray{}
	for _, _bccca := range _cffg.Domain {
		_cgaf.Append(_bgd.MakeFloat(_bccca))
	}
	_aafce.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _cgaf)
	_ecdc := &_bgd.PdfObjectArray{}
	for _, _gebc := range _cffg.Range {
		_ecdc.Append(_bgd.MakeFloat(_gebc))
	}
	_aafce.Set("\u0052\u0061\u006eg\u0065", _ecdc)
	_fcafg := &_bgd.PdfObjectArray{}
	for _, _cbcga := range _cffg.Size {
		_fcafg.Append(_bgd.MakeInteger(int64(_cbcga)))
	}
	_aafce.Set("\u0053\u0069\u007a\u0065", _fcafg)
	_aafce.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065", _bgd.MakeInteger(int64(_cffg.BitsPerSample)))
	if _cffg.Order != 1 {
		_aafce.Set("\u004f\u0072\u0064e\u0072", _bgd.MakeInteger(int64(_cffg.Order)))
	}
	_aafce.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_cffg._eggg))))
	_cffg._fgeeg.Stream = _cffg._eggg
	_cffg._fgeeg.PdfObjectDictionary = _aafce
	return _cffg._fgeeg
}

func (_ffgbg *PdfReader) newPdfFieldFromIndirectObject(_gbaa *_bgd.PdfIndirectObject, _acbd *PdfField) (*PdfField, error) {
	if _dcbge, _aegg := _ffgbg._gggb.GetModelFromPrimitive(_gbaa).(*PdfField); _aegg {
		return _dcbge, nil
	}
	_fece, _bdee := _bgd.GetDict(_gbaa)
	if !_bdee {
		return nil, _f.Errorf("\u0050\u0064f\u0046\u0069\u0065\u006c\u0064 \u0069\u006e\u0064\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_acaa := NewPdfField()
	_acaa._bcgde = _gbaa
	_acaa._bcgde.PdfObject = _fece
	if _edbeg, _ccag := _bgd.GetName(_fece.Get("\u0046\u0054")); _ccag {
		_acaa.FT = _edbeg
	}
	if _acbd != nil {
		_acaa.Parent = _acbd
	}
	_acaa.T, _ = _fece.Get("\u0054").(*_bgd.PdfObjectString)
	_acaa.TU, _ = _fece.Get("\u0054\u0055").(*_bgd.PdfObjectString)
	_acaa.TM, _ = _fece.Get("\u0054\u004d").(*_bgd.PdfObjectString)
	_acaa.Ff, _ = _fece.Get("\u0046\u0066").(*_bgd.PdfObjectInteger)
	_acaa.V = _fece.Get("\u0056")
	_acaa.DV = _fece.Get("\u0044\u0056")
	_acaa.AA = _fece.Get("\u0041\u0041")
	if DA := _fece.Get("\u0044\u0041"); DA != nil {
		DA, _ := _bgd.GetString(DA)
		_acaa.VariableText = &VariableText{DA: DA}
		Q, _ := _fece.Get("\u0051").(*_bgd.PdfObjectInteger)
		DS, _ := _fece.Get("\u0044\u0053").(*_bgd.PdfObjectString)
		RV := _fece.Get("\u0052\u0056")
		_acaa.VariableText.Q = Q
		_acaa.VariableText.DS = DS
		_acaa.VariableText.RV = RV
	}
	_addce := _acaa.FT
	if _addce == nil && _acbd != nil {
		_addce = _acbd.FT
	}
	if _addce != nil {
		switch *_addce {
		case "\u0054\u0078":
			_adefed, _cbgaa := _acade(_fece)
			if _cbgaa != nil {
				return nil, _cbgaa
			}
			_adefed.PdfField = _acaa
			_acaa._babbg = _adefed
		case "\u0043\u0068":
			_dafac, _bggg := _edfbb(_fece)
			if _bggg != nil {
				return nil, _bggg
			}
			_dafac.PdfField = _acaa
			_acaa._babbg = _dafac
		case "\u0042\u0074\u006e":
			_effa, _bcbg := _cfea(_fece)
			if _bcbg != nil {
				return nil, _bcbg
			}
			_effa.PdfField = _acaa
			_acaa._babbg = _effa
		case "\u0053\u0069\u0067":
			_bbbb, _ddbac := _ffgbg.newPdfFieldSignatureFromDict(_fece)
			if _ddbac != nil {
				return nil, _ddbac
			}
			_bbbb.PdfField = _acaa
			_acaa._babbg = _bbbb
		default:
			_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", *_acaa.FT)
			return nil, _gb.New("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079p\u0065")
		}
	}
	if _bace, _fcebg := _bgd.GetName(_fece.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")); _fcebg {
		if *_bace == "\u0057\u0069\u0064\u0067\u0065\u0074" {
			_efgg, _cgfbg := _ffgbg.newPdfAnnotationFromIndirectObject(_gbaa)
			if _cgfbg != nil {
				return nil, _cgfbg
			}
			_ecac, _fgeg := _efgg.GetContext().(*PdfAnnotationWidget)
			if !_fgeg {
				return nil, _gb.New("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0067e\u0074 \u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006fn")
			}
			_ecac._eded = _acaa
			_ecac.Parent = _acaa._bcgde
			_acaa.Annotations = append(_acaa.Annotations, _ecac)
			return _acaa, nil
		}
	}
	_ffbb := true
	if _bdae, _dece := _bgd.GetArray(_fece.Get("\u004b\u0069\u0064\u0073")); _dece {
		_fdaa := make([]*_bgd.PdfIndirectObject, 0, _bdae.Len())
		for _, _gdefb := range _bdae.Elements() {
			_dcce, _cefce := _bgd.GetIndirect(_gdefb)
			if !_cefce {
				_faeb, _eacb := _bgd.GetStream(_gdefb)
				if _eacb && _faeb.PdfObjectDictionary != nil {
					_gbaac, _aaebd := _bgd.GetNameVal(_faeb.Get("\u0054\u0079\u0070\u0065"))
					if _aaebd && _gbaac == "\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061" {
						_fg.Log.Debug("E\u0052RO\u0052:\u0020f\u006f\u0072\u006d\u0020\u0066i\u0065\u006c\u0064 \u004b\u0069\u0064\u0073\u0020a\u0072\u0072\u0061y\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0073\u0020\u0069n\u0076\u0061\u006cid \u004d\u0065\u0074\u0061\u0064\u0061t\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e")
						continue
					}
				}
				return nil, _gb.New("n\u006f\u0074\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0028\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065\u006cd\u0029")
			}
			_bgag, _bbea := _bgd.GetDict(_dcce)
			if !_bbea {
				return nil, ErrTypeCheck
			}
			if _ffbb {
				_ffbb = !_effd(_bgag)
			}
			_fdaa = append(_fdaa, _dcce)
		}
		for _, _efbdf := range _fdaa {
			if _ffbb {
				_fgcag, _ccgf := _ffgbg.newPdfAnnotationFromIndirectObject(_efbdf)
				if _ccgf != nil {
					_fg.Log.Debug("\u0045r\u0072\u006fr\u0020\u006c\u006fa\u0064\u0069\u006e\u0067\u0020\u0077\u0069d\u0067\u0065\u0074\u0020\u0061\u006en\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u006f\u0072 \u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _ccgf)
					return nil, _ccgf
				}
				_adfcd, _bgfcd := _fgcag._dabfb.(*PdfAnnotationWidget)
				if !_bgfcd {
					return nil, ErrTypeCheck
				}
				_adfcd._eded = _acaa
				_acaa.Annotations = append(_acaa.Annotations, _adfcd)
			} else {
				_ggeb, _fcbe := _ffgbg.newPdfFieldFromIndirectObject(_efbdf, _acaa)
				if _fcbe != nil {
					_fg.Log.Debug("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0068\u0069\u006c\u0064\u0020\u0066\u0069\u0065\u006c\u0064: \u0025\u0076", _fcbe)
					return nil, _fcbe
				}
				_acaa.Kids = append(_acaa.Kids, _ggeb)
			}
		}
	}
	return _acaa, nil
}

// NewPdfActionLaunch returns a new "launch" action.
func NewPdfActionLaunch() *PdfActionLaunch {
	_bfd := NewPdfAction()
	_eec := &PdfActionLaunch{}
	_eec.PdfAction = _bfd
	_bfd.SetContext(_eec)
	return _eec
}

// AddPage adds a page to the PDF file. The new page should be an indirect object.
func (_bcfde *PdfWriter) AddPage(page *PdfPage) error {
	const _bcbcf = "\u006d\u006f\u0064el\u003a\u0050\u0064\u0066\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065"
	_ccggg := _fdbfd(page)
	_fg.Log.Trace("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d")
	_fg.Log.Trace("\u0041p\u0070\u0065\u006e\u0064i\u006e\u0067\u0020\u0074\u006f \u0070a\u0067e\u0020\u006c\u0069\u0073\u0074\u0020\u0025T", _ccggg)
	_geddc, _egadc := _bgd.GetIndirect(_ccggg)
	if !_egadc {
		return _gb.New("\u0070\u0061\u0067\u0065\u0020\u0073h\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_fg.Log.Trace("\u0025\u0073", _geddc)
	_fg.Log.Trace("\u0025\u0073", _geddc.PdfObject)
	_eaacf, _egadc := _bgd.GetDict(_geddc.PdfObject)
	if !_egadc {
		return _gb.New("\u0070\u0061\u0067e \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0068o\u0075l\u0064 \u0062e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_baebg, _egadc := _bgd.GetName(_eaacf.Get("\u0054\u0079\u0070\u0065"))
	if !_egadc {
		return _f.Errorf("\u0070\u0061\u0067\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054y\u0070\u0065\u0020\u006b\u0065\u0079\u0020\u0077\u0069t\u0068\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u006e\u0061m\u0065\u0020\u0028%\u0054\u0029", _eaacf.Get("\u0054\u0079\u0070\u0065"))
	}
	if _baebg.String() != "\u0050\u0061\u0067\u0065" {
		return _gb.New("\u0066\u0069e\u006c\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u0050\u0061\u0067\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069re\u0064\u0029")
	}
	_cacad := []_bgd.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	_afgdc, _bffbd := _bgd.GetIndirect(_eaacf.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	_fg.Log.Trace("P\u0061g\u0065\u0020\u0050\u0061\u0072\u0065\u006e\u0074:\u0020\u0025\u0054\u0020(%\u0076\u0029", _eaacf.Get("\u0050\u0061\u0072\u0065\u006e\u0074"), _bffbd)
	for _bffbd {
		_fg.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _afgdc)
		_aegca, _dbed := _bgd.GetDict(_afgdc.PdfObject)
		if !_dbed {
			return _gb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		for _, _acce := range _cacad {
			_fg.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _acce)
			if _eaacf.Get(_acce) != nil {
				_fg.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
				continue
			}
			if _eegaff := _aegca.Get(_acce); _eegaff != nil {
				_fg.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _acce)
				_eaacf.Set(_acce, _eegaff)
			}
		}
		_afgdc, _bffbd = _bgd.GetIndirect(_aegca.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
		_fg.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _aegca.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	}
	_fg.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c \u0064\u006f\u006e\u0065")
	_eaacf.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _bcfde._cfaee)
	_geddc.PdfObject = _eaacf
	_fcba, _egadc := _bgd.GetDict(_bcfde._cfaee.PdfObject)
	if !_egadc {
		return _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_dbdfa, _egadc := _bgd.GetArray(_fcba.Get("\u004b\u0069\u0064\u0073"))
	if !_egadc {
		return _gb.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_dbdfa.Append(_geddc)
	_bcfde._bbcec[_eaacf] = struct{}{}
	_bcfde._bgbga = append(_bcfde._bgbga, _geddc)
	_ggggc, _egadc := _bgd.GetInt(_fcba.Get("\u0043\u006f\u0075n\u0074"))
	if !_egadc {
		return _gb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	*_ggggc = *_ggggc + 1
	if page._ccagbb == nil {
		_bfaeee := _gdg.Track(_bcfde._caaf, _bcbcf, _bcfde._cfadf)
		if _bfaeee != nil {
			return _bfaeee
		}
	} else {
		_eggeb := _gdg.Track(page._ccagbb._cdff, _bcbcf, page._ccagbb._babg)
		if _eggeb != nil {
			return _eggeb
		}
	}
	_bcfde.addObject(_geddc)
	_gdaff := _bcfde.addObjects(_eaacf)
	if _gdaff != nil {
		return _gdaff
	}
	return nil
}

// Duplicate creates a duplicate page based on the current one and returns it.
func (_bagef *PdfPage) Duplicate() *PdfPage {
	_ggead := *_bagef
	_ggead._cfdgca = _bgd.MakeDict()
	_ggead._bbgfg = _bgd.MakeIndirectObject(_ggead._cfdgca)
	_ggead._cdfec = *_ggead._cfdgca
	return &_ggead
}

func (_ddeg *PdfWriter) optimizeDocument() error {
	if _ddeg._egbb == nil {
		return nil
	}
	_cdbg, _addcab := _bgd.GetDict(_ddeg._gefe)
	if !_addcab {
		return _gb.New("\u0061\u006e\u0020in\u0066\u006f\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_abacf := _ec.Document{ID: [2]string{_ddeg._fedfb, _ddeg._gdcfb}, Version: _ddeg._egbga, Objects: _ddeg._edcbg, Info: _cdbg, Crypt: _ddeg._ddcee, UseHashBasedID: _ddeg._gdgceg}
	if _eaeac := _ddeg._egbb.ApplyStandard(&_abacf); _eaeac != nil {
		return _eaeac
	}
	_ddeg._fedfb, _ddeg._gdcfb = _abacf.ID[0], _abacf.ID[1]
	_ddeg._egbga = _abacf.Version
	_ddeg._edcbg = _abacf.Objects
	_ddeg._gefe.PdfObject = _abacf.Info
	_ddeg._gdgceg = _abacf.UseHashBasedID
	_ddeg._ddcee = _abacf.Crypt
	_bgdfd := make(map[_bgd.PdfObject]struct{}, len(_ddeg._edcbg))
	for _, _bcdef := range _ddeg._edcbg {
		_bgdfd[_bcdef] = struct{}{}
	}
	_ddeg._abccd = _bgdfd
	return nil
}

// String returns a string representation of the field.
func (_fbee *PdfField) String() string {
	if _fcad, _abdf := _fbee.ToPdfObject().(*_bgd.PdfIndirectObject); _abdf {
		return _f.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _fbee._babbg, _fcad.PdfObject.String())
	}
	return ""
}

// NewPdfShadingPatternType2 creates an empty shading pattern type 2 object.
func NewPdfShadingPatternType2() *PdfShadingPatternType2 {
	_dfaff := &PdfShadingPatternType2{}
	_dfaff.Matrix = _bgd.MakeArrayFromIntegers([]int{1, 0, 0, 1, 0, 0})
	_dfaff.PdfPattern = &PdfPattern{}
	_dfaff.PdfPattern.PatternType = int64(*_bgd.MakeInteger(2))
	_dfaff.PdfPattern._ggafd = _dfaff
	_dfaff.PdfPattern._eaddb = _bgd.MakeIndirectObject(_bgd.MakeDict())
	return _dfaff
}

// String returns a string representation of PdfTransformParamsDocMDP.
func (_gdfg *PdfTransformParamsDocMDP) String() string {
	return _f.Sprintf("\u0025\u0073\u0020\u0050\u003a\u0020\u0025\u0073\u0020V\u003a\u0020\u0025\u0073", _gdfg.Type, _gdfg.P, _gdfg.V)
}

// NewPdfAppenderWithOpts creates a new Pdf appender from a Pdf reader with options.
func NewPdfAppenderWithOpts(reader *PdfReader, opts *ReaderOpts, encryptOptions *EncryptOptions) (*PdfAppender, error) {
	_feae := &PdfAppender{_bddc: reader._cfebb, Reader: reader, _badc: reader._ccade, _fdbga: reader._dadbf}
	_fbec, _gcdc := _feae._bddc.Seek(0, _ca.SeekEnd)
	if _gcdc != nil {
		return nil, _gcdc
	}
	_feae._eega = _fbec
	if _, _gcdc = _feae._bddc.Seek(0, _ca.SeekStart); _gcdc != nil {
		return nil, _gcdc
	}
	_feae._gdf, _gcdc = NewPdfReaderWithOpts(_feae._bddc, opts)
	if _gcdc != nil {
		return nil, _gcdc
	}
	for _, _feaed := range _feae.Reader.GetObjectNums() {
		if _feae._gaae < _feaed {
			_feae._gaae = _feaed
		}
	}
	_feae._adda = _feae._badc.GetXrefTable()
	_feae._cege = _feae._badc.GetXrefOffset()
	_feae._ffcf = append(_feae._ffcf, _feae._gdf.PageList...)
	_feae._dgae = make(map[_bgd.PdfObject]struct{})
	_feae._baae = make(map[_bgd.PdfObject]int64)
	_feae._gffc = make(map[_bgd.PdfObject]struct{})
	_feae._cabc = _feae._gdf.AcroForm
	_feae._bcdeg = _feae._gdf.DSS
	if opts != nil {
		_feae._cdg = opts.Password
	}
	if encryptOptions != nil {
		_feae._bcgd = encryptOptions
	}
	return _feae, nil
}

// Add appends a top level outline item to the outline.
func (_gaccg *Outline) Add(item *OutlineItem) { _gaccg.Entries = append(_gaccg.Entries, item) }

// ToPdfObject implements interface PdfModel.
func (_add *PdfAnnotationCaret) ToPdfObject() _bgd.PdfObject {
	_add.PdfAnnotation.ToPdfObject()
	_adgbg := _add._eag
	_edba := _adgbg.PdfObject.(*_bgd.PdfObjectDictionary)
	_add.appendToPdfDictionary(_edba)
	_edba.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0043\u0061\u0072e\u0074"))
	_edba.SetIfNotNil("\u0052\u0044", _add.RD)
	_edba.SetIfNotNil("\u0053\u0079", _add.Sy)
	return _adgbg
}

// EnableAll LTV enables all signatures in the PDF document.
// The signing certificate chain is extracted from each signature dictionary.
// Optionally, additional certificates can be specified through the
// `extraCerts` parameter. The LTV client attempts to build the certificate
// chain up to a trusted root by downloading any missing certificates.
func (_ebef *LTV) EnableAll(extraCerts []*_cb.Certificate) error {
	_cabcb := _ebef._deefd._gdf.AcroForm
	for _, _bfbda := range _cabcb.AllFields() {
		_cecca, _ := _bfbda.GetContext().(*PdfFieldSignature)
		if _cecca == nil {
			continue
		}
		_adbdd := _cecca.V
		if _ddcgd := _ebef.validateSig(_adbdd); _ddcgd != nil {
			_fg.Log.Debug("\u0057\u0041\u0052N\u003a\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _ddcgd)
		}
		if _aaafc := _ebef.Enable(_adbdd, extraCerts); _aaafc != nil {
			return _aaafc
		}
	}
	return nil
}

// WriteToFile writes the output PDF to file.
func (_dfgeb *PdfWriter) WriteToFile(outputFilePath string) error {
	_cedfge, _facfc := _gc.Create(outputFilePath)
	if _facfc != nil {
		return _facfc
	}
	defer _cedfge.Close()
	return _dfgeb.Write(_cedfge)
}

// ParserMetadata gets the parser  metadata.
func (_cdbaf *CompliancePdfReader) ParserMetadata() _bgd.ParserMetadata {
	if _cdbaf._gdff == (_bgd.ParserMetadata{}) {
		_cdbaf._gdff, _ = _cdbaf._ccade.ParserMetadata()
	}
	return _cdbaf._gdff
}

// PdfAnnotationWatermark represents Watermark annotations.
// (Section 12.5.6.22).
type PdfAnnotationWatermark struct {
	*PdfAnnotation
	FixedPrint _bgd.PdfObject
}

func _faegc(_fgfd *PdfField) []*PdfField {
	_gdegb := []*PdfField{_fgfd}
	for _, _eefg := range _fgfd.Kids {
		_gdegb = append(_gdegb, _faegc(_eefg)...)
	}
	return _gdegb
}

// ContentStreamWrapper wraps the Page's contentstream into q ... Q blocks.
type ContentStreamWrapper interface{ WrapContentStream(_aeadc *PdfPage) error }

// String implements interface PdfObject.
func (_gca *PdfAction) String() string {
	_fba, _db := _gca.ToPdfObject().(*_bgd.PdfIndirectObject)
	if _db {
		return _f.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _gca._df, _fba.PdfObject.String())
	}
	return ""
}

// String returns a string that describes `font`.
func (_efdfa *PdfFont) String() string {
	_dbbga := ""
	if _efdfa._cbec.Encoder() != nil {
		_dbbga = _efdfa._cbec.Encoder().String()
	}
	return _f.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0054\u0020\u0025s\u0020\u0025\u0073\u007d", _efdfa._cbec, _efdfa.baseFields().coreString(), _dbbga)
}

func _acf(_ffb *PdfPage) map[_bgd.PdfObjectName]_bgd.PdfObject {
	_gfgd := make(map[_bgd.PdfObjectName]_bgd.PdfObject)
	if _ffb.Resources == nil {
		return _gfgd
	}
	if _ffb.Resources.Font != nil {
		if _dcea, _cgee := _bgd.GetDict(_ffb.Resources.Font); _cgee {
			for _, _faac := range _dcea.Keys() {
				_gfgd[_faac] = _dcea.Get(_faac)
			}
		}
	}
	if _ffb.Resources.ExtGState != nil {
		if _deddf, _bbgab := _bgd.GetDict(_ffb.Resources.ExtGState); _bbgab {
			for _, _gbad := range _deddf.Keys() {
				_gfgd[_gbad] = _deddf.Get(_gbad)
			}
		}
	}
	if _ffb.Resources.XObject != nil {
		if _adee, _dccg := _bgd.GetDict(_ffb.Resources.XObject); _dccg {
			for _, _deca := range _adee.Keys() {
				_gfgd[_deca] = _adee.Get(_deca)
			}
		}
	}
	if _ffb.Resources.Pattern != nil {
		if _eee, _cbf := _bgd.GetDict(_ffb.Resources.Pattern); _cbf {
			for _, _fadg := range _eee.Keys() {
				_gfgd[_fadg] = _eee.Get(_fadg)
			}
		}
	}
	if _ffb.Resources.Shading != nil {
		if _cfad, _fffc := _bgd.GetDict(_ffb.Resources.Shading); _fffc {
			for _, _daad := range _cfad.Keys() {
				_gfgd[_daad] = _cfad.Get(_daad)
			}
		}
	}
	if _ffb.Resources.ProcSet != nil {
		if _dade, _afea := _bgd.GetDict(_ffb.Resources.ProcSet); _afea {
			for _, _fadb := range _dade.Keys() {
				_gfgd[_fadb] = _dade.Get(_fadb)
			}
		}
	}
	if _ffb.Resources.Properties != nil {
		if _bbba, _aece := _bgd.GetDict(_ffb.Resources.Properties); _aece {
			for _, _cfdc := range _bbba.Keys() {
				_gfgd[_cfdc] = _bbba.Get(_cfdc)
			}
		}
	}
	return _gfgd
}

// NewPdfAnnotationWatermark returns a new watermark annotation.
func NewPdfAnnotationWatermark() *PdfAnnotationWatermark {
	_bda := NewPdfAnnotation()
	_fdea := &PdfAnnotationWatermark{}
	_fdea.PdfAnnotation = _bda
	_bda.SetContext(_fdea)
	return _fdea
}

// String returns a string that describes `base`.
func (_fbefaa fontCommon) String() string {
	return _f.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0073\u007d", _fbefaa.coreString())
}

// GetSubFilter returns SubFilter value or empty string.
func (_ccbd *pdfSignDictionary) GetSubFilter() string {
	_eecabb := _ccbd.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r")
	if _eecabb == nil {
		return ""
	}
	if _cdedg, _gedg := _bgd.GetNameVal(_eecabb); _gedg {
		return _cdedg
	}
	return ""
}

func (_gbfd fontCommon) fontFlags() int {
	if _gbfd._ggde == nil {
		return 0
	}
	return _gbfd._ggde._bfgdg
}

// Write outputs the object as it is to be written to file.
func (_bbbdf *pdfSignDictionary) Write() []byte {
	_bbbdf._gcgged = 0
	_bbbdf._feefb = 0
	_bbbdf._bdbga = 0
	_bbbdf._gfagd = 0
	_gbcdf := _ea.NewBuffer(nil)
	_gbcdf.WriteString("\u003c\u003c")
	for _, _fdbf := range _bbbdf.Keys() {
		_gafd := _bbbdf.Get(_fdbf)
		switch _fdbf {
		case "\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e":
			_gbcdf.Write(_fdbf.Write())
			_gbcdf.WriteString("\u0020")
			_bbbdf._bdbga = _gbcdf.Len()
			_gbcdf.Write(_gafd.Write())
			_gbcdf.WriteString("\u0020")
			_bbbdf._gfagd = _gbcdf.Len() - 1
		case "\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
			_gbcdf.Write(_fdbf.Write())
			_gbcdf.WriteString("\u0020")
			_bbbdf._gcgged = _gbcdf.Len()
			_gbcdf.Write(_gafd.Write())
			_gbcdf.WriteString("\u0020")
			_bbbdf._feefb = _gbcdf.Len() - 1
		default:
			_gbcdf.Write(_fdbf.Write())
			_gbcdf.WriteString("\u0020")
			_gbcdf.Write(_gafd.Write())
		}
	}
	_gbcdf.WriteString("\u003e\u003e")
	return _gbcdf.Bytes()
}

// PdfAnnotationPopup represents Popup annotations.
// (Section 12.5.6.14).
type PdfAnnotationPopup struct {
	*PdfAnnotation
	Parent _bgd.PdfObject
	Open   _bgd.PdfObject
}

// ToPdfObject implements interface PdfModel.
func (_aea *PdfActionLaunch) ToPdfObject() _bgd.PdfObject {
	_aea.PdfAction.ToPdfObject()
	_cbc := _aea._fab
	_bgb := _cbc.PdfObject.(*_bgd.PdfObjectDictionary)
	_bgb.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeLaunch)))
	if _aea.F != nil {
		_bgb.Set("\u0046", _aea.F.ToPdfObject())
	}
	_bgb.SetIfNotNil("\u0057\u0069\u006e", _aea.Win)
	_bgb.SetIfNotNil("\u004d\u0061\u0063", _aea.Mac)
	_bgb.SetIfNotNil("\u0055\u006e\u0069\u0078", _aea.Unix)
	_bgb.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _aea.NewWindow)
	return _cbc
}

// SetLocation sets the `Location` field of the signature.
func (_cbggf *PdfSignature) SetLocation(location string) {
	_cbggf.Location = _bgd.MakeEncodedString(location, true)
}

// PdfAction represents an action in PDF (section 12.6 p. 412).
type PdfAction struct {
	_df  PdfModel
	Type _bgd.PdfObject
	S    _bgd.PdfObject
	Next _bgd.PdfObject
	_fab *_bgd.PdfIndirectObject
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_febbf *PdfOutlineItem) ToPdfObject() _bgd.PdfObject {
	_gfcgc := _febbf._aacdb
	_abagf := _gfcgc.PdfObject.(*_bgd.PdfObjectDictionary)
	_abagf.Set("\u0054\u0069\u0074l\u0065", _febbf.Title)
	if _febbf.A != nil {
		_abagf.Set("\u0041", _febbf.A)
	}
	if _abacd := _abagf.Get("\u0053\u0045"); _abacd != nil {
		_abagf.Remove("\u0053\u0045")
	}
	if _febbf.C != nil {
		_abagf.Set("\u0043", _febbf.C)
	}
	if _febbf.Dest != nil {
		_abagf.Set("\u0044\u0065\u0073\u0074", _febbf.Dest)
	}
	if _febbf.F != nil {
		_abagf.Set("\u0046", _febbf.F)
	}
	if _febbf.Count != nil {
		_abagf.Set("\u0043\u006f\u0075n\u0074", _bgd.MakeInteger(*_febbf.Count))
	}
	if _febbf.Next != nil {
		_abagf.Set("\u004e\u0065\u0078\u0074", _febbf.Next.ToPdfObject())
	}
	if _febbf.First != nil {
		_abagf.Set("\u0046\u0069\u0072s\u0074", _febbf.First.ToPdfObject())
	}
	if _febbf.Prev != nil {
		_abagf.Set("\u0050\u0072\u0065\u0076", _febbf.Prev.GetContext().GetContainingPdfObject())
	}
	if _febbf.Last != nil {
		_abagf.Set("\u004c\u0061\u0073\u0074", _febbf.Last.GetContext().GetContainingPdfObject())
	}
	if _febbf.Parent != nil {
		_abagf.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _febbf.Parent.GetContext().GetContainingPdfObject())
	}
	return _gfcgc
}

// GetNumComponents returns the number of color components (1 for Separation).
func (_adeb *PdfColorspaceSpecialSeparation) GetNumComponents() int { return 1 }

// IDTree represents the ID tree dictionary where the format of the content
// is using Name Trees as described in chapter 7.9.6.
type IDTree struct {

	// Limits shall be an array of two strings, that shall specify the (lexically) least and greatest keys included in the Names array.
	Limits *_bgd.PdfObjectArray

	// Names shall be an array of the form
	//
	// [ key1 value1 key2 value2 … keyn valuen]
	//
	// where each keyi shall be a string and the corresponding valuei shall be the object
	// associated with that key. The keys shall be sorted in lexical order, as described below.
	Names *_bgd.PdfObjectArray

	// Kids Shall be an array of indirect references to the immediate children of this node.
	Kids []*IDTree
}

func (_cgda *PdfReader) newPdfActionGotoFromDict(_fee *_bgd.PdfObjectDictionary) (*PdfActionGoTo, error) {
	return &PdfActionGoTo{D: _fee.Get("\u0044")}, nil
}

// ToPdfObject converts the PdfPage to a dictionary within an indirect object container.
func (_gaefb *PdfPage) ToPdfObject() _bgd.PdfObject {
	_fcfba := _gaefb._bbgfg
	_gaefb.GetPageDict()
	return _fcfba
}

// SetXObjectByName adds the XObject from the passed in stream to the page resources.
// The added XObject is identified by the specified name.
func (_cedb *PdfPageResources) SetXObjectByName(keyName _bgd.PdfObjectName, stream *_bgd.PdfObjectStream) error {
	if _cedb.XObject == nil {
		_cedb.XObject = _bgd.MakeDict()
	}
	_efdgf := _bgd.TraceToDirectObject(_cedb.XObject)
	_ccbag, _ecagc := _efdgf.(*_bgd.PdfObjectDictionary)
	if !_ecagc {
		_fg.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0058\u004f\u0062j\u0065\u0063\u0074\u002c\u0020\u0067\u006f\u0074\u0020\u0025T\u002f\u0025\u0054", _cedb.XObject, _efdgf)
		return _gb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_ccbag.Set(keyName, stream)
	return nil
}

func (_cgbfd *PdfWriter) writeXRefStreams(_fcaea int, _agbff int64) error {
	_ccdc := _fcaea + 1
	_cgbfd._bdfbdd[_ccdc] = crossReference{Type: 1, ObjectNumber: _ccdc, Offset: _agbff}
	_aebgf := _ea.NewBuffer(nil)
	_gbafa := _bgd.MakeArray()
	for _ecgdfd := 0; _ecgdfd <= _fcaea; {
		for ; _ecgdfd <= _fcaea; _ecgdfd++ {
			_agdac, _debdg := _cgbfd._bdfbdd[_ecgdfd]
			if _debdg && (!_cgbfd._fgaba || _cgbfd._fgaba && (_agdac.Type == 1 && _agdac.Offset >= _cgbfd._bdgag || _agdac.Type == 0)) {
				break
			}
		}
		var _cdgba int
		for _cdgba = _ecgdfd + 1; _cdgba <= _fcaea; _cdgba++ {
			_bbeff, _dfggg := _cgbfd._bdfbdd[_cdgba]
			if _dfggg && (!_cgbfd._fgaba || _cgbfd._fgaba && (_bbeff.Type == 1 && _bbeff.Offset > _cgbfd._bdgag)) {
				continue
			}
			break
		}
		_gbafa.Append(_bgd.MakeInteger(int64(_ecgdfd)), _bgd.MakeInteger(int64(_cdgba-_ecgdfd)))
		for _caage := _ecgdfd; _caage < _cdgba; _caage++ {
			_ebcbg := _cgbfd._bdfbdd[_caage]
			switch _ebcbg.Type {
			case 0:
				_ed.Write(_aebgf, _ed.BigEndian, byte(0))
				_ed.Write(_aebgf, _ed.BigEndian, uint32(0))
				_ed.Write(_aebgf, _ed.BigEndian, uint16(0xFFFF))
			case 1:
				_ed.Write(_aebgf, _ed.BigEndian, byte(1))
				_ed.Write(_aebgf, _ed.BigEndian, uint32(_ebcbg.Offset))
				_ed.Write(_aebgf, _ed.BigEndian, uint16(_ebcbg.Generation))
			case 2:
				_ed.Write(_aebgf, _ed.BigEndian, byte(2))
				_ed.Write(_aebgf, _ed.BigEndian, uint32(_ebcbg.ObjectNumber))
				_ed.Write(_aebgf, _ed.BigEndian, uint16(_ebcbg.Index))
			}
		}
		_ecgdfd = _cdgba + 1
	}
	_ddagc, _dgbab := _bgd.MakeStream(_aebgf.Bytes(), _bgd.NewFlateEncoder())
	if _dgbab != nil {
		return _dgbab
	}
	_ddagc.ObjectNumber = int64(_ccdc)
	_ddagc.PdfObjectDictionary.Set("\u0054\u0079\u0070\u0065", _bgd.MakeName("\u0058\u0052\u0065\u0066"))
	_ddagc.PdfObjectDictionary.Set("\u0057", _bgd.MakeArray(_bgd.MakeInteger(1), _bgd.MakeInteger(4), _bgd.MakeInteger(2)))
	_ddagc.PdfObjectDictionary.Set("\u0049\u006e\u0064e\u0078", _gbafa)
	_ddagc.PdfObjectDictionary.Set("\u0053\u0069\u007a\u0065", _bgd.MakeInteger(int64(_ccdc)))
	_ddagc.PdfObjectDictionary.Set("\u0049\u006e\u0066\u006f", _cgbfd._gefe)
	_ddagc.PdfObjectDictionary.Set("\u0052\u006f\u006f\u0074", _cgbfd._fcgc)
	if _cgbfd._fgaba && _cgbfd._gebgb > 0 {
		_ddagc.PdfObjectDictionary.Set("\u0050\u0072\u0065\u0076", _bgd.MakeInteger(_cgbfd._gebgb))
	}
	if _cgbfd._ddcee != nil {
		_ddagc.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _cgbfd._abeb)
	}
	if _cgbfd._beadb == nil && _cgbfd._fedfb != "" && _cgbfd._gdcfb != "" {
		_cgbfd._beadb = _bgd.MakeArray(_bgd.MakeHexString(_cgbfd._fedfb), _bgd.MakeHexString(_cgbfd._gdcfb))
	}
	if _cgbfd._beadb != nil {
		_fg.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _cgbfd._beadb)
		_ddagc.Set("\u0049\u0044", _cgbfd._beadb)
	}
	_cgbfd.writeObject(int(_ddagc.ObjectNumber), _ddagc)
	return nil
}

// PdfFieldButton represents a button field which includes push buttons, checkboxes, and radio buttons.
type PdfFieldButton struct {
	*PdfField
	Opt    *_bgd.PdfObjectArray
	_fbedg *Image
}

// ToPdfObject returns a PDF object representation of the outline item.
func (_abeg *OutlineItem) ToPdfObject() _bgd.PdfObject {
	_daeaf, _ := _abeg.ToPdfOutlineItem()
	return _daeaf.ToPdfObject()
}

var (
	CourierName              = _fe.CourierName
	CourierBoldName          = _fe.CourierBoldName
	CourierObliqueName       = _fe.CourierObliqueName
	CourierBoldObliqueName   = _fe.CourierBoldObliqueName
	HelveticaName            = _fe.HelveticaName
	HelveticaBoldName        = _fe.HelveticaBoldName
	HelveticaObliqueName     = _fe.HelveticaObliqueName
	HelveticaBoldObliqueName = _fe.HelveticaBoldObliqueName
	SymbolName               = _fe.SymbolName
	ZapfDingbatsName         = _fe.ZapfDingbatsName
	TimesRomanName           = _fe.TimesRomanName
	TimesBoldName            = _fe.TimesBoldName
	TimesItalicName          = _fe.TimesItalicName
	TimesBoldItalicName      = _fe.TimesBoldItalicName
)

// PrintArea returns the value of the printArea.
func (_bgecg *ViewerPreferences) PrintArea() PageBoundary { return _bgecg._fccec }

// XObjectImage (Table 89 in 8.9.5.1).
// Implements PdfModel interface.
type XObjectImage struct {

	// ColorSpace       PdfObject
	Width            *int64
	Height           *int64
	ColorSpace       PdfColorspace
	BitsPerComponent *int64
	Filter           _bgd.StreamEncoder
	Intent           _bgd.PdfObject
	ImageMask        _bgd.PdfObject
	Mask             _bgd.PdfObject
	Matte            _bgd.PdfObject
	Decode           _bgd.PdfObject
	Interpolate      _bgd.PdfObject
	Alternatives     _bgd.PdfObject
	SMask            _bgd.PdfObject
	SMaskInData      _bgd.PdfObject
	Name             _bgd.PdfObject
	StructParent     _bgd.PdfObject
	ID               _bgd.PdfObject
	OPI              _bgd.PdfObject
	Metadata         _bgd.PdfObject
	OC               _bgd.PdfObject
	Stream           []byte
	_befec           *_bgd.PdfObjectStream
	_fgbcb           bool
}

// NewPdfActionSetOCGState returns a new "named" action.
func NewPdfActionSetOCGState() *PdfActionSetOCGState {
	_beg := NewPdfAction()
	_dba := &PdfActionSetOCGState{}
	_dba.PdfAction = _beg
	_beg.SetContext(_dba)
	return _dba
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_eccg *PdfColorspaceSpecialSeparation) ColorFromPdfObjects(objects []_bgd.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_abeab, _febc := _bgd.GetNumbersAsFloat(objects)
	if _febc != nil {
		return nil, _febc
	}
	return _eccg.ColorFromFloats(_abeab)
}

// StandardApplier is the interface that performs optimization of the whole PDF document.
// As a result an input document is being changed by the optimizer.
// The writer than takes back all it's parts and overwrites it.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardApplier interface {
	ApplyStandard(_dfeag *_ec.Document) error
}

var (
	_adcf   _g.Mutex
	_eadea  = ""
	_fcfbfa _ge.Time
	_dccdf  = ""
	_agbbd  = ""
	_eccfcf _ge.Time
	_edbfc  = ""
	_ebgca  = ""
	_fcfe   = ""
)

// PdfPageResources is a Page resources model.
// Implements PdfModel.
type PdfPageResources struct {
	ExtGState  _bgd.PdfObject
	ColorSpace _bgd.PdfObject
	Pattern    _bgd.PdfObject
	Shading    _bgd.PdfObject
	XObject    _bgd.PdfObject
	Font       _bgd.PdfObject
	ProcSet    _bgd.PdfObject
	Properties _bgd.PdfObject
	_bdaf      *_bgd.PdfObjectDictionary
	_fabf      *PdfPageResourcesColorspaces
}

// AddMCIDChild adds a child MCID object.
func (_bafge *KDict) AddMCIDChild(mcid int) {
	_bafge._fabbb = append(_bafge._fabbb, &KValue{_ecdf: &mcid})
}

// PrintScaling returns the value of the printScaling.
func (_debce *ViewerPreferences) PrintScaling() PrintScaling { return _debce._edfcg }

// ToPdfObject returns the PDF representation of the function.
func (_becbg *PdfFunctionType4) ToPdfObject() _bgd.PdfObject {
	_eaeg := _becbg._baegf
	if _eaeg == nil {
		_becbg._baegf = &_bgd.PdfObjectStream{}
		_eaeg = _becbg._baegf
	}
	_ccbf := _bgd.MakeDict()
	_ccbf.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _bgd.MakeInteger(4))
	_fdccb := &_bgd.PdfObjectArray{}
	for _, _ceaee := range _becbg.Domain {
		_fdccb.Append(_bgd.MakeFloat(_ceaee))
	}
	_ccbf.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _fdccb)
	_gdcba := &_bgd.PdfObjectArray{}
	for _, _feeb := range _becbg.Range {
		_gdcba.Append(_bgd.MakeFloat(_feeb))
	}
	_ccbf.Set("\u0052\u0061\u006eg\u0065", _gdcba)
	if _becbg._bbbdd == nil && _becbg.Program != nil {
		_becbg._bbbdd = []byte(_becbg.Program.String())
	}
	_ccbf.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _bgd.MakeInteger(int64(len(_becbg._bbbdd))))
	_eaeg.Stream = _becbg._bbbdd
	_eaeg.PdfObjectDictionary = _ccbf
	return _eaeg
}

func (_cagcda *LTV) buildCertChain(_agaag, _fdcca []*_cb.Certificate) ([]*_cb.Certificate, map[string]*_cb.Certificate, error) {
	_dgcg := map[string]*_cb.Certificate{}
	for _, _cbaba := range _agaag {
		_dgcg[_cbaba.Subject.CommonName] = _cbaba
	}
	_acbedb := _agaag
	for _, _ddad := range _fdcca {
		_abaaa := _ddad.Subject.CommonName
		if _, _decad := _dgcg[_abaaa]; _decad {
			continue
		}
		_dgcg[_abaaa] = _ddad
		_acbedb = append(_acbedb, _ddad)
	}
	if len(_acbedb) == 0 {
		return nil, nil, ErrSignNoCertificates
	}
	var _aecgge error
	for _ecaee := _acbedb[0]; _ecaee != nil && !_cagcda.CertClient.IsCA(_ecaee); {
		_fgcdb, _feaga := _dgcg[_ecaee.Issuer.CommonName]
		if !_feaga {
			if _fgcdb, _aecgge = _cagcda.CertClient.GetIssuer(_ecaee); _aecgge != nil {
				_fg.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076", _aecgge)
				break
			}
			_dgcg[_ecaee.Issuer.CommonName] = _fgcdb
			_acbedb = append(_acbedb, _fgcdb)
		}
		_ecaee = _fgcdb
	}
	return _acbedb, _dgcg, nil
}

// NonFullScreenPageMode returns the value of the nonFullScreenPageMode.
func (_bgbece *ViewerPreferences) NonFullScreenPageMode() NonFullScreenPageMode {
	return _bgbece._ggfcc
}

const (
	RC4_128bit = EncryptionAlgorithm(iota)
	AES_128bit
	AES_256bit
)

// FileRelationship represents a attachment file relationship type.
type FileRelationship int

// ToGoTime returns the date in time.Time format.
func (_fcgf PdfDate) ToGoTime() _ge.Time {
	_agdga := int(_fcgf._bgcab*60*60 + _fcgf._dgbfg*60)
	switch _fcgf._eceda {
	case '-':
		_agdga = -_agdga
	case 'Z':
		_agdga = 0
	}
	_baebf := _f.Sprintf("\u0055\u0054\u0043\u0025\u0063\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064", _fcgf._eceda, _fcgf._bgcab, _fcgf._dgbfg)
	_dabcd := _ge.FixedZone(_baebf, _agdga)
	return _ge.Date(int(_fcgf._ccgca), _ge.Month(_fcgf._agbb), int(_fcgf._bdef), int(_fcgf._ccdga), int(_fcgf._cfba), int(_fcgf._cgde), 0, _dabcd)
}

// IsSimple returns true if `font` is a simple font.
func (_addaa *PdfFont) IsSimple() bool { _, _gdcgad := _addaa._cbec.(*pdfFontSimple); return _gdcgad }

// GetContainingPdfObject implements interface PdfModel.
func (_gbg *PdfFilespec) GetContainingPdfObject() _bgd.PdfObject { return _gbg._bbbfb }

// PdfAppender appends new PDF content to an existing PDF document via incremental updates.
type PdfAppender struct {
	_bddc  _ca.ReadSeeker
	_badc  *_bgd.PdfParser
	_gdf   *PdfReader
	Reader *PdfReader
	_ffcf  []*PdfPage
	_cabc  *PdfAcroForm
	_bcdeg *DSS
	_gdbgd *Permissions
	_adda  _bgd.XrefTable
	_cege  int64
	_gaae  int
	_ddce  []_bgd.PdfObject
	_dgae  map[_bgd.PdfObject]struct{}
	_baae  map[_bgd.PdfObject]int64
	_gffc  map[_bgd.PdfObject]struct{}
	_fdbga map[_bgd.PdfObject]struct{}
	_eega  int64
	_dage  bool
	_cdg   string
	_bcgd  *EncryptOptions
	_ggag  *PdfInfo
}

// Width returns the width of `rect`.
func (_cagfe *PdfRectangle) Width() float64 { return _da.Abs(_cagfe.Urx - _cagfe.Llx) }

const (
	RelationshipSource FileRelationship = iota
	RelationshipData
	RelationshipAlternative
	RelationshipSupplement
	RelationshipUnspecified
)

// ToPdfObject implements interface PdfModel.
func (_gga *PdfActionSubmitForm) ToPdfObject() _bgd.PdfObject {
	_gga.PdfAction.ToPdfObject()
	_cab := _gga._fab
	_deb := _cab.PdfObject.(*_bgd.PdfObjectDictionary)
	_deb.SetIfNotNil("\u0053", _bgd.MakeName(string(ActionTypeSubmitForm)))
	if _gga.F != nil {
		_deb.Set("\u0046", _gga.F.ToPdfObject())
	}
	_deb.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _gga.Fields)
	_deb.SetIfNotNil("\u0046\u006c\u0061g\u0073", _gga.Flags)
	return _cab
}

// Normalize swaps (Llx,Urx) if Urx < Llx, and (Lly,Ury) if Ury < Lly.
func (_adbbf *PdfRectangle) Normalize() {
	if _adbbf.Llx > _adbbf.Urx {
		_adbbf.Llx, _adbbf.Urx = _adbbf.Urx, _adbbf.Llx
	}
	if _adbbf.Lly > _adbbf.Ury {
		_adbbf.Lly, _adbbf.Ury = _adbbf.Ury, _adbbf.Lly
	}
}

func (_fdbgf *PdfReader) newPdfAnnotationFromIndirectObject(_gdag *_bgd.PdfIndirectObject) (*PdfAnnotation, error) {
	_fgb, _gfcb := _gdag.PdfObject.(*_bgd.PdfObjectDictionary)
	if !_gfcb {
		return nil, _f.Errorf("\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _fdbgf._gggb.GetModelFromPrimitive(_fgb); model != nil {
		_agad, _cgbb := model.(*PdfAnnotation)
		if !_cgbb {
			return nil, _f.Errorf("\u0063\u0061\u0063\u0068\u0065\u0064 \u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050D\u0046\u0020\u0061\u006e\u006e\u006f\u0074a\u0074\u0069\u006f\u006e")
		}
		return _agad, nil
	}
	_cgdae := &PdfAnnotation{}
	_cgdae._eag = _gdag
	_fdbgf._gggb.Register(_fgb, _cgdae)
	if _fbgb := _fgb.Get("\u0054\u0079\u0070\u0065"); _fbgb != nil {
		_ebab, _cge := _fbgb.(*_bgd.PdfObjectName)
		if !_cge {
			_fg.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _fbgb)
		} else {
			if *_ebab != "\u0041\u006e\u006eo\u0074" {
				_fg.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070\u0065\u0063\u0074\u0065d\u0020\u0054\u0079\u0070\u0065\u0020\u0021=\u0020\u0041\u006e\u006e\u006f\u0074\u0020\u0028\u0025\u0073\u0029", *_ebab)
			}
		}
	}
	if _cebg := _fgb.Get("\u0052\u0065\u0063\u0074"); _cebg != nil {
		_cgdae.Rect = _cebg
	}
	if _acc := _fgb.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _acc != nil {
		_cgdae.Contents = _acc
	}
	if _bfde := _fgb.Get("\u0050"); _bfde != nil {
		_cgdae.P = _bfde
	}
	if _gag := _fgb.Get("\u004e\u004d"); _gag != nil {
		_cgdae.NM = _gag
	}
	if _fdeac := _fgb.Get("\u004d"); _fdeac != nil {
		_cgdae.M = _fdeac
	}
	if _afcf := _fgb.Get("\u0046"); _afcf != nil {
		_cgdae.F = _afcf
	}
	if _cdd := _fgb.Get("\u0041\u0050"); _cdd != nil {
		_cgdae.AP = _cdd
	}
	if _ggee := _fgb.Get("\u0041\u0053"); _ggee != nil {
		_cgdae.AS = _ggee
	}
	if _bfdgg := _fgb.Get("\u0042\u006f\u0072\u0064\u0065\u0072"); _bfdgg != nil {
		_cgdae.Border = _bfdgg
	}
	if _gac := _fgb.Get("\u0043"); _gac != nil {
		_cgdae.C = _gac
	}
	if _acgg := _fgb.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074"); _acgg != nil {
		_cgdae.StructParent = _acgg
	}
	if _gdb := _fgb.Get("\u004f\u0043"); _gdb != nil {
		_cgdae.OC = _gdb
	}
	_bfgff := _fgb.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")
	if _bfgff == nil {
		_fg.Log.Debug("\u0057\u0041\u0052\u004e\u0049\u004e\u0047:\u0020\u0043\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079 \u0069s\u0073\u0075\u0065\u0020\u002d\u0020a\u006e\u006e\u006f\u0074\u0061\u0074\u0069o\u006e\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u002d\u0020\u0061\u0073\u0073u\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074\u0079p\u0065")
		_cgdae._dabfb = nil
		return _cgdae, nil
	}
	_ggdbe, _bacb := _bfgff.(*_bgd.PdfObjectName)
	if !_bacb {
		_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0053\u0075\u0062ty\u0070\u0065\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065 !\u003d\u0020n\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _bfgff)
		return nil, _f.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d n\u0061\u006d\u0065 \u0028%\u0054\u0029", _bfgff)
	}
	switch *_ggdbe {
	case "\u0054\u0065\u0078\u0074":
		_gfb, _bacd := _fdbgf.newPdfAnnotationTextFromDict(_fgb)
		if _bacd != nil {
			return nil, _bacd
		}
		_gfb.PdfAnnotation = _cgdae
		_cgdae._dabfb = _gfb
		return _cgdae, nil
	case "\u004c\u0069\u006e\u006b":
		_ead, _fbgc := _fdbgf.newPdfAnnotationLinkFromDict(_fgb)
		if _fbgc != nil {
			return nil, _fbgc
		}
		_ead.PdfAnnotation = _cgdae
		_cgdae._dabfb = _ead
		return _cgdae, nil
	case "\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074":
		_cbgg, _ddgc := _fdbgf.newPdfAnnotationFreeTextFromDict(_fgb)
		if _ddgc != nil {
			return nil, _ddgc
		}
		_cbgg.PdfAnnotation = _cgdae
		_cgdae._dabfb = _cbgg
		return _cgdae, nil
	case "\u004c\u0069\u006e\u0065":
		_dcfc, _aee := _fdbgf.newPdfAnnotationLineFromDict(_fgb)
		if _aee != nil {
			return nil, _aee
		}
		_dcfc.PdfAnnotation = _cgdae
		_cgdae._dabfb = _dcfc
		_fg.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041N\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u003a\u0020\u0061\u006e\u006eo\u0074\u0020\u0028\u0025\u0054\u0029\u003a \u0025\u002b\u0076\u000a", _cgdae, _cgdae)
		_fg.Log.Trace("\u004c\u0049\u004eE\u0020\u0041\u004e\u004eO\u0054\u0041\u0054\u0049\u004f\u004e\u003a \u0063\u0074\u0078\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u002b\u0076\u000a", _dcfc, _dcfc)
		_fg.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041\u004e\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u0020\u004d\u0061\u0072\u006b\u0075\u0070\u003a\u0020c\u0074\u0078\u0020\u0028\u0025T\u0029\u003a \u0025\u002b\u0076\u000a", _dcfc.PdfAnnotationMarkup, _dcfc.PdfAnnotationMarkup)
		return _cgdae, nil
	case "\u0053\u0071\u0075\u0061\u0072\u0065":
		_aafb, _bdg := _fdbgf.newPdfAnnotationSquareFromDict(_fgb)
		if _bdg != nil {
			return nil, _bdg
		}
		_aafb.PdfAnnotation = _cgdae
		_cgdae._dabfb = _aafb
		return _cgdae, nil
	case "\u0043\u0069\u0072\u0063\u006c\u0065":
		_ffgf, _ggdf := _fdbgf.newPdfAnnotationCircleFromDict(_fgb)
		if _ggdf != nil {
			return nil, _ggdf
		}
		_ffgf.PdfAnnotation = _cgdae
		_cgdae._dabfb = _ffgf
		return _cgdae, nil
	case "\u0050o\u006c\u0079\u0067\u006f\u006e":
		_dgge, _aec := _fdbgf.newPdfAnnotationPolygonFromDict(_fgb)
		if _aec != nil {
			return nil, _aec
		}
		_dgge.PdfAnnotation = _cgdae
		_cgdae._dabfb = _dgge
		return _cgdae, nil
	case "\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065":
		_fef, _fgf := _fdbgf.newPdfAnnotationPolyLineFromDict(_fgb)
		if _fgf != nil {
			return nil, _fgf
		}
		_fef.PdfAnnotation = _cgdae
		_cgdae._dabfb = _fef
		return _cgdae, nil
	case "\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t":
		_bge, _ddae := _fdbgf.newPdfAnnotationHighlightFromDict(_fgb)
		if _ddae != nil {
			return nil, _ddae
		}
		_bge.PdfAnnotation = _cgdae
		_cgdae._dabfb = _bge
		return _cgdae, nil
	case "\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee":
		_adca, _dbf := _fdbgf.newPdfAnnotationUnderlineFromDict(_fgb)
		if _dbf != nil {
			return nil, _dbf
		}
		_adca.PdfAnnotation = _cgdae
		_cgdae._dabfb = _adca
		return _cgdae, nil
	case "\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079":
		_bacg, _bcd := _fdbgf.newPdfAnnotationSquigglyFromDict(_fgb)
		if _bcd != nil {
			return nil, _bcd
		}
		_bacg.PdfAnnotation = _cgdae
		_cgdae._dabfb = _bacg
		return _cgdae, nil
	case "\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t":
		_dcca, _geag := _fdbgf.newPdfAnnotationStrikeOut(_fgb)
		if _geag != nil {
			return nil, _geag
		}
		_dcca.PdfAnnotation = _cgdae
		_cgdae._dabfb = _dcca
		return _cgdae, nil
	case "\u0043\u0061\u0072e\u0074":
		_ebf, _ceae := _fdbgf.newPdfAnnotationCaretFromDict(_fgb)
		if _ceae != nil {
			return nil, _ceae
		}
		_ebf.PdfAnnotation = _cgdae
		_cgdae._dabfb = _ebf
		return _cgdae, nil
	case "\u0053\u0074\u0061m\u0070":
		_bbb, _bfee := _fdbgf.newPdfAnnotationStampFromDict(_fgb)
		if _bfee != nil {
			return nil, _bfee
		}
		_bbb.PdfAnnotation = _cgdae
		_cgdae._dabfb = _bbb
		return _cgdae, nil
	case "\u0049\u006e\u006b":
		_bab, _geaf := _fdbgf.newPdfAnnotationInkFromDict(_fgb)
		if _geaf != nil {
			return nil, _geaf
		}
		_bab.PdfAnnotation = _cgdae
		_cgdae._dabfb = _bab
		return _cgdae, nil
	case "\u0050\u006f\u0070u\u0070":
		_aed, _cbag := _fdbgf.newPdfAnnotationPopupFromDict(_fgb)
		if _cbag != nil {
			return nil, _cbag
		}
		_aed.PdfAnnotation = _cgdae
		_cgdae._dabfb = _aed
		return _cgdae, nil
	case "\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074":
		_fagfd, _fdf := _fdbgf.newPdfAnnotationFileAttachmentFromDict(_fgb)
		if _fdf != nil {
			return nil, _fdf
		}
		_fagfd.PdfAnnotation = _cgdae
		_cgdae._dabfb = _fagfd
		return _cgdae, nil
	case "\u0053\u006f\u0075n\u0064":
		_gdac, _bffg := _fdbgf.newPdfAnnotationSoundFromDict(_fgb)
		if _bffg != nil {
			return nil, _bffg
		}
		_gdac.PdfAnnotation = _cgdae
		_cgdae._dabfb = _gdac
		return _cgdae, nil
	case "\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a":
		_ecec, _cdfe := _fdbgf.newPdfAnnotationRichMediaFromDict(_fgb)
		if _cdfe != nil {
			return nil, _cdfe
		}
		_ecec.PdfAnnotation = _cgdae
		_cgdae._dabfb = _ecec
		return _cgdae, nil
	case "\u004d\u006f\u0076i\u0065":
		_edec, _bgdb := _fdbgf.newPdfAnnotationMovieFromDict(_fgb)
		if _bgdb != nil {
			return nil, _bgdb
		}
		_edec.PdfAnnotation = _cgdae
		_cgdae._dabfb = _edec
		return _cgdae, nil
	case "\u0053\u0063\u0072\u0065\u0065\u006e":
		_cfgg, _gdcd := _fdbgf.newPdfAnnotationScreenFromDict(_fgb)
		if _gdcd != nil {
			return nil, _gdcd
		}
		_cfgg.PdfAnnotation = _cgdae
		_cgdae._dabfb = _cfgg
		return _cgdae, nil
	case "\u0057\u0069\u0064\u0067\u0065\u0074":
		_dbfe, _faa := _fdbgf.newPdfAnnotationWidgetFromDict(_fgb)
		if _faa != nil {
			return nil, _faa
		}
		_dbfe.PdfAnnotation = _cgdae
		_cgdae._dabfb = _dbfe
		return _cgdae, nil
	case "P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b":
		_gfgg, _fgac := _fdbgf.newPdfAnnotationPrinterMarkFromDict(_fgb)
		if _fgac != nil {
			return nil, _fgac
		}
		_gfgg.PdfAnnotation = _cgdae
		_cgdae._dabfb = _gfgg
		return _cgdae, nil
	case "\u0054r\u0061\u0070\u004e\u0065\u0074":
		_feb, _cafg := _fdbgf.newPdfAnnotationTrapNetFromDict(_fgb)
		if _cafg != nil {
			return nil, _cafg
		}
		_feb.PdfAnnotation = _cgdae
		_cgdae._dabfb = _feb
		return _cgdae, nil
	case "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k":
		_fcfac, _fabb := _fdbgf.newPdfAnnotationWatermarkFromDict(_fgb)
		if _fabb != nil {
			return nil, _fabb
		}
		_fcfac.PdfAnnotation = _cgdae
		_cgdae._dabfb = _fcfac
		return _cgdae, nil
	case "\u0033\u0044":
		_bbbd, _afb := _fdbgf.newPdfAnnotation3DFromDict(_fgb)
		if _afb != nil {
			return nil, _afb
		}
		_bbbd.PdfAnnotation = _cgdae
		_cgdae._dabfb = _bbbd
		return _cgdae, nil
	case "\u0050\u0072\u006f\u006a\u0065\u0063\u0074\u0069\u006f\u006e":
		_cegc, _bbga := _fdbgf.newPdfAnnotationProjectionFromDict(_fgb)
		if _bbga != nil {
			return nil, _bbga
		}
		_cegc.PdfAnnotation = _cgdae
		_cgdae._dabfb = _cegc
		return _cgdae, nil
	case "\u0052\u0065\u0064\u0061\u0063\u0074":
		_gfbg, _agcf := _fdbgf.newPdfAnnotationRedactFromDict(_fgb)
		if _agcf != nil {
			return nil, _agcf
		}
		_gfbg.PdfAnnotation = _cgdae
		_cgdae._dabfb = _gfbg
		return _cgdae, nil
	}
	_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020a\u006e\u006e\u006f\u0074\u0061t\u0069\u006fn\u003a\u0020\u0025\u0073", *_ggdbe)
	return nil, nil
}

func _beef(_ggacb []byte) []byte {
	const _bcgff = 52845
	const _eadegf = 22719
	_agbaf := 55665
	for _, _abbac := range _ggacb[:4] {
		_agbaf = (int(_abbac)+_agbaf)*_bcgff + _eadegf
	}
	_aegdb := make([]byte, len(_ggacb)-4)
	for _eegad, _edeeb := range _ggacb[4:] {
		_aegdb[_eegad] = byte(int(_edeeb) ^ _agbaf>>8)
		_agbaf = (int(_edeeb)+_agbaf)*_bcgff + _eadegf
	}
	return _aegdb
}

// NewPdfPageResources returns a new PdfPageResources object.
func NewPdfPageResources() *PdfPageResources {
	_ddfdc := &PdfPageResources{}
	_ddfdc._bdaf = _bgd.MakeDict()
	return _ddfdc
}

// ToPdfObject returns a *PdfIndirectObject containing a *PdfObjectArray representation of the DeviceN colorspace.
/*
	Format: [/DeviceN names alternateSpace tintTransform]
	    or: [/DeviceN names alternateSpace tintTransform attributes]
*/
func (_fafcg *PdfColorspaceDeviceN) ToPdfObject() _bgd.PdfObject {
	_gfe := _bgd.MakeArray(_bgd.MakeName("\u0044e\u0076\u0069\u0063\u0065\u004e"))
	_gfe.Append(_fafcg.ColorantNames)
	_gfe.Append(_fafcg.AlternateSpace.ToPdfObject())
	_gfe.Append(_fafcg.TintTransform.ToPdfObject())
	if _fafcg.Attributes != nil {
		_gfe.Append(_fafcg.Attributes.ToPdfObject())
	}
	if _fafcg._fdec != nil {
		_fafcg._fdec.PdfObject = _gfe
		return _fafcg._fdec
	}
	return _gfe
}

// ToPdfObject convert PdfInfo to pdf object.
func (_bbce *PdfInfo) ToPdfObject() _bgd.PdfObject {
	_agfdb := _bgd.MakeDict()
	_agfdb.SetIfNotNil("\u0054\u0069\u0074l\u0065", _bbce.Title)
	_agfdb.SetIfNotNil("\u0041\u0075\u0074\u0068\u006f\u0072", _bbce.Author)
	_agfdb.SetIfNotNil("\u0053u\u0062\u006a\u0065\u0063\u0074", _bbce.Subject)
	_agfdb.SetIfNotNil("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _bbce.Keywords)
	_agfdb.SetIfNotNil("\u0043r\u0065\u0061\u0074\u006f\u0072", _bbce.Creator)
	_agfdb.SetIfNotNil("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _bbce.Producer)
	_agfdb.SetIfNotNil("\u0054r\u0061\u0070\u0070\u0065\u0064", _bbce.Trapped)
	if _bbce.CreationDate != nil {
		_agfdb.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _bbce.CreationDate.ToPdfObject())
	}
	if _bbce.ModifiedDate != nil {
		_agfdb.SetIfNotNil("\u004do\u0064\u0044\u0061\u0074\u0065", _bbce.ModifiedDate.ToPdfObject())
	}
	for _, _aagc := range _bbce._dfeee.Keys() {
		_agfdb.SetIfNotNil(_aagc, _bbce._dfeee.Get(_aagc))
	}
	return _agfdb
}

// SetMCID sets the MCID for the KValue.
func (_gaede *KValue) SetMCID(mcid int) { _gaede.Clear(); _gaede._ecdf = &mcid }

// SetFilter sets compression filter. Decodes with current filter sets and
// encodes the data with the new filter.
func (_adffb *XObjectImage) SetFilter(encoder _bgd.StreamEncoder) error {
	_cdgd := _adffb.Stream
	_bgbac, _feecg := _adffb.Filter.DecodeBytes(_cdgd)
	if _feecg != nil {
		return _feecg
	}
	_adffb.Filter = encoder
	encoder.UpdateParams(_adffb.getParamsDict())
	_cdgd, _feecg = encoder.EncodeBytes(_bgbac)
	if _feecg != nil {
		return _feecg
	}
	_adffb.Stream = _cdgd
	return nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_bbbgd *PdfShadingType1) ToPdfObject() _bgd.PdfObject {
	_bbbgd.PdfShading.ToPdfObject()
	_efgdf, _cdec := _bbbgd.getShadingDict()
	if _cdec != nil {
		_fg.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bbbgd.Domain != nil {
		_efgdf.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _bbbgd.Domain)
	}
	if _bbbgd.Matrix != nil {
		_efgdf.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _bbbgd.Matrix)
	}
	if _bbbgd.Function != nil {
		if len(_bbbgd.Function) == 1 {
			_efgdf.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bbbgd.Function[0].ToPdfObject())
		} else {
			_bgfdg := _bgd.MakeArray()
			for _, _ebgaf := range _bbbgd.Function {
				_bgfdg.Append(_ebgaf.ToPdfObject())
			}
			_efgdf.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bgfdg)
		}
	}
	return _bbbgd._gccfe
}

// GetPatternByName gets the pattern specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_ccecc *PdfPageResources) GetPatternByName(keyName _bgd.PdfObjectName) (*PdfPattern, bool) {
	if _ccecc.Pattern == nil {
		return nil, false
	}
	_bgbfe, _bgcd := _bgd.TraceToDirectObject(_ccecc.Pattern).(*_bgd.PdfObjectDictionary)
	if !_bgcd {
		_fg.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074t\u0065\u0072\u006e\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _ccecc.Pattern)
		return nil, false
	}
	if _gbcda := _bgbfe.Get(keyName); _gbcda != nil {
		_geeag, _feegb := _ccbe(_gbcda)
		if _feegb != nil {
			_fg.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0070\u0061\u0074\u0074\u0065\u0072n\u003a\u0020\u0025\u0076", _feegb)
			return nil, false
		}
		return _geeag, true
	}
	return nil, false
}

// CharcodesToUnicodeWithStats is identical to CharcodesToUnicode except it returns more statistical
// information about hits and misses from the reverse mapping process.
// NOTE: The number of runes returned may be greater than the number of charcodes.
// TODO(peterwilliams97): Deprecate in v4 and use only CharcodesToStrings()
func (_dfgc *PdfFont) CharcodesToUnicodeWithStats(charcodes []_dabf.CharCode) (_ddaa []rune, _dfcee, _adgcc int) {
	_gaed, _dfcee, _adgcc := _dfgc.CharcodesToStrings(charcodes, "")
	return []rune(_ef.Join(_gaed, "")), _dfcee, _adgcc
}

// IsDisplayDocTitle returns the value of the displayDocTitle flag.
func (_aaecbd *ViewerPreferences) IsDisplayDocTitle() bool {
	if _aaecbd._fcdcbd == nil {
		return false
	}
	return *_aaecbd._fcdcbd
}

// PageCallback callback function used in page loading
// that could be used to modify the page content.
//
// Deprecated: will be removed in v4. Use PageProcessCallback instead.
type PageCallback func(_bbff int, _cace *PdfPage)

// PdfAnnotationPrinterMark represents PrinterMark annotations.
// (Section 12.5.6.20).
type PdfAnnotationPrinterMark struct {
	*PdfAnnotation
	MN _bgd.PdfObject
}

// RemoveStructParentsKey removes the StructParents key.
func (_bfgbc *PdfPage) RemoveStructParentsKey() { _bfgbc.StructParents = nil }

// M returns the value of the magenta component of the color.
func (_ecae *PdfColorDeviceCMYK) M() float64 { return _ecae[1] }

// ArtifactType represents the type of an artifact in a PDF document.
type ArtifactType string

// SetPdfCreator sets the Creator attribute of the output PDF.
func SetPdfCreator(creator string) { _adcf.Lock(); defer _adcf.Unlock(); _dccdf = creator }

// NewPdfAnnotationPolyLine returns a new polyline annotation.
func NewPdfAnnotationPolyLine() *PdfAnnotationPolyLine {
	_aeb := NewPdfAnnotation()
	_aae := &PdfAnnotationPolyLine{}
	_aae.PdfAnnotation = _aeb
	_aae.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_aeb.SetContext(_aae)
	return _aae
}

// SetObjAttrib adds an object attribute to the structure tag info.
// This is commonly used to associate annotations with structure elements.
func (_aebcc *StructureTagInfo) SetObjAttrib(obj _bgd.PdfObject) {
	if _aebcc.AnnotObjs == nil {
		_aebcc.AnnotObjs = make([]_bgd.PdfObject, 0)
	}
	_aebcc.AnnotObjs = append(_aebcc.AnnotObjs, obj)
}

// CharMetrics represents width and height metrics of a glyph.
type CharMetrics = _fe.CharMetrics

// NewPdfAppender creates a new Pdf appender from a Pdf reader.
func NewPdfAppender(reader *PdfReader) (*PdfAppender, error) {
	_eaeb := &PdfAppender{_bddc: reader._cfebb, Reader: reader, _badc: reader._ccade, _fdbga: reader._dadbf}
	_gffa, _gacg := _eaeb._bddc.Seek(0, _ca.SeekEnd)
	if _gacg != nil {
		return nil, _gacg
	}
	_eaeb._eega = _gffa
	if _, _gacg = _eaeb._bddc.Seek(0, _ca.SeekStart); _gacg != nil {
		return nil, _gacg
	}
	_eaeb._gdf, _gacg = NewPdfReader(_eaeb._bddc)
	if _gacg != nil {
		return nil, _gacg
	}
	for _, _eaga := range _eaeb.Reader.GetObjectNums() {
		if _eaeb._gaae < _eaga {
			_eaeb._gaae = _eaga
		}
	}
	_eaeb._adda = _eaeb._badc.GetXrefTable()
	_eaeb._cege = _eaeb._badc.GetXrefOffset()
	_eaeb._ffcf = append(_eaeb._ffcf, _eaeb._gdf.PageList...)
	_eaeb._dgae = make(map[_bgd.PdfObject]struct{})
	_eaeb._baae = make(map[_bgd.PdfObject]int64)
	_eaeb._gffc = make(map[_bgd.PdfObject]struct{})
	_eaeb._cabc = _eaeb._gdf.AcroForm
	_eaeb._bcdeg = _eaeb._gdf.DSS
	return _eaeb, nil
}

// GetOutlinesFlattened returns a flattened list of tree nodes and titles.
// NOTE: for most use cases, it is recommended to use the high-level GetOutlines
// method instead, which also provides information regarding the destination
// of the outline items.
func (_gdbd *PdfReader) GetOutlinesFlattened() ([]*PdfOutlineTreeNode, []string, error) {
	var _gegeg []*PdfOutlineTreeNode
	var _gadb []string
	var _begb func(*PdfOutlineTreeNode, *[]*PdfOutlineTreeNode, *[]string, int)
	_begb = func(_gcbde *PdfOutlineTreeNode, _caadc *[]*PdfOutlineTreeNode, _bebd *[]string, _cefeb int) {
		if _gcbde == nil {
			return
		}
		if _gcbde._bfff == nil {
			_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020M\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006e\u006fd\u0065\u002e\u0063o\u006et\u0065\u0078\u0074")
			return
		}
		_bfefa, _edded := _gcbde._bfff.(*PdfOutlineItem)
		if _edded {
			*_caadc = append(*_caadc, &_bfefa.PdfOutlineTreeNode)
			_eegfg := _ef.Repeat("\u0020", _cefeb*2) + _bfefa.Title.Decoded()
			*_bebd = append(*_bebd, _eegfg)
		}
		if _gcbde.First != nil {
			_abbcc := _ef.Repeat("\u0020", _cefeb*2) + "\u002b"
			*_bebd = append(*_bebd, _abbcc)
			_begb(_gcbde.First, _caadc, _bebd, _cefeb+1)
		}
		if _edded && _bfefa.Next != nil {
			_begb(_bfefa.Next, _caadc, _bebd, _cefeb)
		}
	}
	_begb(_gdbd._gfbcg, &_gegeg, &_gadb, 0)
	return _gegeg, _gadb, nil
}

// PdfOutputIntentType is the subtype of the given PdfOutputIntent.
type PdfOutputIntentType int

// DetermineColorspaceNameFromPdfObject determines PDF colorspace from a PdfObject.  Returns the colorspace name and
// an error on failure. If the colorspace was not found, will return an empty string.
func DetermineColorspaceNameFromPdfObject(obj _bgd.PdfObject) (_bgd.PdfObjectName, error) {
	var _dabd *_bgd.PdfObjectName
	var _facc *_bgd.PdfObjectArray
	if _addca, _cfee := obj.(*_bgd.PdfIndirectObject); _cfee {
		if _defc, _cgfa := _addca.PdfObject.(*_bgd.PdfObjectArray); _cgfa {
			_facc = _defc
		} else if _fefad, _gabg := _addca.PdfObject.(*_bgd.PdfObjectName); _gabg {
			_dabd = _fefad
		}
	} else if _bbge, _gggaf := obj.(*_bgd.PdfObjectArray); _gggaf {
		_facc = _bbge
	} else if _aabb, _edgfe := obj.(*_bgd.PdfObjectName); _edgfe {
		_dabd = _aabb
	}
	if _dabd != nil {
		switch *_dabd {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return *_dabd, nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return *_dabd, nil
		}
	}
	if _facc != nil && _facc.Len() > 0 {
		if _bgc, _bfgeb := _facc.Get(0).(*_bgd.PdfObjectName); _bfgeb {
			switch *_bgc {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _facc.Len() == 1 {
					return *_bgc, nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079", "\u0043\u0061\u006c\u0052\u0047\u0042", "\u004c\u0061\u0062":
				return *_bgc, nil
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064", "\u0050a\u0074\u0074\u0065\u0072\u006e", "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return *_bgc, nil
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e", "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return *_bgc, nil
			}
		}
	}
	return "", nil
}

// SetName sets the `Name` field of the signature.
func (_fefaf *PdfSignature) SetName(name string) {
	_fefaf.Name = _bgd.MakeEncodedString(name, true)
}

// StringToCharcodeBytes maps the provided string runes to charcode bytes and
// it returns the resulting slice of bytes, along with the number of runes
// which could not be converted. If the number of misses is 0, all string runes
// were successfully converted.
func (_babfd *PdfFont) StringToCharcodeBytes(str string) ([]byte, int) {
	return _babfd.RunesToCharcodeBytes([]rune(str))
}

// IsCheckbox returns true if the button field represents a checkbox, false otherwise.
func (_cagca *PdfFieldButton) IsCheckbox() bool { return _cagca.GetType() == ButtonTypeCheckbox }

// NewPdfColorDeviceRGB returns a new PdfColorDeviceRGB based on the r,g,b component values.
func NewPdfColorDeviceRGB(r, g, b float64) *PdfColorDeviceRGB {
	_acddc := PdfColorDeviceRGB{r, g, b}
	return &_acddc
}

// ToPdfObject implements interface PdfModel.
func (_gebb *PdfAnnotationPopup) ToPdfObject() _bgd.PdfObject {
	_gebb.PdfAnnotation.ToPdfObject()
	_bfec := _gebb._eag
	_ebeg := _bfec.PdfObject.(*_bgd.PdfObjectDictionary)
	_ebeg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0050\u006f\u0070u\u0070"))
	_ebeg.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _gebb.Parent)
	_ebeg.SetIfNotNil("\u004f\u0070\u0065\u006e", _gebb.Open)
	return _bfec
}

func (_fdfge *PdfReader) loadForms() (*PdfAcroForm, error) {
	if _fdfge._ccade.GetCrypter() != nil && !_fdfge._ccade.IsAuthenticated() {
		return nil, _f.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_cddd := _fdfge._ffabf
	_gggdg := _cddd.Get("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d")
	if _gggdg == nil {
		return nil, nil
	}
	_ecffa, _dbga := _bgd.GetIndirect(_gggdg)
	_gggdg = _bgd.TraceToDirectObject(_gggdg)
	if _bgd.IsNullObject(_gggdg) {
		_fg.Log.Trace("\u0041\u0063\u0072of\u006f\u0072\u006d\u0020\u0069\u0073\u0020\u0061\u0020n\u0075l\u006c \u006fb\u006a\u0065\u0063\u0074\u0020\u0028\u0065\u006d\u0070\u0074\u0079\u0029\u000a")
		return nil, nil
	}
	_aacgg, _dfgf := _bgd.GetDict(_gggdg)
	if !_dfgf {
		_fg.Log.Debug("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0041\u0063\u0072\u006fF\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _gggdg)
		_fg.Log.Debug("\u0044\u006f\u0065\u0073 n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0066\u006f\u0072\u006d\u0073")
		if _fdfge._daae.RelaxedMode {
			_fg.Log.Debug("\u0052\u0065\u006c\u0061\u0078\u0065\u0064\u004d\u006f\u0064\u0065 \u0065\u006e\u0061\u0062\u006c\u0065\u0064\u002e \u0049g\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u0020\u006c\u006fa\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u0073")
			return nil, nil
		}
		return nil, _f.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0061\u0063\u0072\u006ff\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _gggdg)
	}
	_fg.Log.Trace("\u0048\u0061\u0073\u0020\u0041\u0063\u0072\u006f\u0020f\u006f\u0072\u006d\u0073")
	_fg.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0065\u0020\u0074\u0068\u0065\u0020\u0041\u0063r\u006ff\u006f\u0072\u006d\u0073\u0020\u0073\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065")
	if !_fdfge._ffce {
		_efgdd := _fdfge.traverseObjectData(_aacgg)
		if _efgdd != nil {
			_fg.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0074\u0072a\u0076\u0065\u0072\u0073\u0065\u0020\u0041\u0063\u0072\u006fFo\u0072\u006d\u0073 \u0028%\u0073\u0029", _efgdd)
			return nil, _efgdd
		}
	}
	_acaee, _dccfg := _fdfge.newPdfAcroFormFromDict(_ecffa, _aacgg)
	if _dccfg != nil {
		return nil, _dccfg
	}
	_acaee._gbfgd = !_dbga
	return _acaee, nil
}

// PdfVersion returns version of the PDF file.
func (_fbbcg *PdfReader) PdfVersion() _bgd.Version { return _fbbcg._ccade.PdfVersion() }

// PdfColorspaceICCBased format [/ICCBased stream]
//
// The stream shall contain the ICC profile.
// A conforming reader shall support ICC.1:2004:10 as required by PDF 1.7, which will enable it
// to properly render all embedded ICC profiles regardless of the PDF version
//
// In the current implementation, we rely on the alternative colormap provided.
type PdfColorspaceICCBased struct {
	N         int
	Alternate PdfColorspace

	// If omitted ICC not supported: then use DeviceGray,
	// DeviceRGB or DeviceCMYK for N=1,3,4 respectively.
	Range    []float64
	Metadata *_bgd.PdfObjectStream
	Data     []byte
	_efgaf   *_bgd.PdfIndirectObject
	_cfde    *_bgd.PdfObjectStream
}

// ToPdfObject implements interface PdfModel.
func (_feba *PdfAnnotationPolygon) ToPdfObject() _bgd.PdfObject {
	_feba.PdfAnnotation.ToPdfObject()
	_baf := _feba._eag
	_adfa := _baf.PdfObject.(*_bgd.PdfObjectDictionary)
	_feba.appendToPdfDictionary(_adfa)
	_adfa.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _bgd.MakeName("\u0050o\u006c\u0079\u0067\u006f\u006e"))
	_adfa.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _feba.Vertices)
	_adfa.SetIfNotNil("\u004c\u0045", _feba.LE)
	_adfa.SetIfNotNil("\u0042\u0053", _feba.BS)
	_adfa.SetIfNotNil("\u0049\u0043", _feba.IC)
	_adfa.SetIfNotNil("\u0042\u0045", _feba.BE)
	_adfa.SetIfNotNil("\u0049\u0054", _feba.IT)
	_adfa.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _feba.Measure)
	return _baf
}

// NewPdfAnnotationInk returns a new ink annotation.
func NewPdfAnnotationInk() *PdfAnnotationInk {
	_dccf := NewPdfAnnotation()
	_cgfd := &PdfAnnotationInk{}
	_cgfd.PdfAnnotation = _dccf
	_cgfd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_dccf.SetContext(_cgfd)
	return _cgfd
}

// DSS represents a Document Security Store dictionary.
// The DSS dictionary contains both global and signature specific validation
// information. The certificates and revocation data in the `Certs`, `OCSPs`,
// and `CRLs` fields can be used to validate any signature in the document.
// Additionally, the VRI entry contains validation data per signature.
// The keys in the VRI entry are calculated as upper(hex(sha1(sig.Contents))).
// The values are VRI dictionaries containing certificates and revocation
// information used for validating a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type DSS struct {
	_bdbe  *_bgd.PdfIndirectObject
	Certs  []*_bgd.PdfObjectStream
	OCSPs  []*_bgd.PdfObjectStream
	CRLs   []*_bgd.PdfObjectStream
	VRI    map[string]*VRI
	_gbed  map[string]*_bgd.PdfObjectStream
	_edecd map[string]*_bgd.PdfObjectStream
	_agbcg map[string]*_bgd.PdfObjectStream
}

// IsHideWindowUI returns the value of the hideWindowUI flag.
func (_aaccg *ViewerPreferences) IsHideWindowUI() bool {
	if _aaccg._eagcc == nil {
		return false
	}
	return *_aaccg._eagcc
}

// NewXObjectImage returns a new XObjectImage.
func NewXObjectImage() *XObjectImage {
	_cbeab := &XObjectImage{}
	_ddcda := &_bgd.PdfObjectStream{}
	_ddcda.PdfObjectDictionary = _bgd.MakeDict()
	_cbeab._befec = _ddcda
	return _cbeab
}

// PdfShadingType6 is a Coons patch mesh.
type PdfShadingType6 struct {
	*PdfShading
	BitsPerCoordinate *_bgd.PdfObjectInteger
	BitsPerComponent  *_bgd.PdfObjectInteger
	BitsPerFlag       *_bgd.PdfObjectInteger
	Decode            *_bgd.PdfObjectArray
	Function          []PdfFunction
}

func (_beag *PdfReader) newPdfActionURIFromDict(_fffg *_bgd.PdfObjectDictionary) (*PdfActionURI, error) {
	return &PdfActionURI{URI: _fffg.Get("\u0055\u0052\u0049"), IsMap: _fffg.Get("\u0049\u0073\u004da\u0070")}, nil
}

// FieldAppearanceGenerator generates appearance stream for a given field.
type FieldAppearanceGenerator interface {
	ContentStreamWrapper
	GenerateAppearanceDict(_geefb *PdfAcroForm, _gegb *PdfField, _ggfc *PdfAnnotationWidget) (*_bgd.PdfObjectDictionary, error)
}
