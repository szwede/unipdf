//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr

import (
	_f "errors"
	_e "fmt"
	_g "github.com/szwede/unipdf/v4/common"
	_ag "github.com/szwede/unipdf/v4/internal/bitwise"
	_b "github.com/szwede/unipdf/v4/internal/jbig2/bitmap"
	_a "io"
)

const (
	_bce mmrCode = iota
	_fg
	_dg
	_age
	_df
	_aaf
	_cd
	_dfa
	_ca
	_ed
	_eb
)

var (
	_ff = [][3]int{{4, 0x1, int(_bce)}, {3, 0x1, int(_fg)}, {1, 0x1, int(_dg)}, {3, 0x3, int(_age)}, {6, 0x3, int(_df)}, {7, 0x3, int(_aaf)}, {3, 0x2, int(_cd)}, {6, 0x2, int(_dfa)}, {7, 0x2, int(_ca)}, {10, 0xf, int(_ed)}, {12, 0xf, int(_eb)}, {12, 0x1, int(EOL)}}
	_fd = [][3]int{{4, 0x07, 2}, {4, 0x08, 3}, {4, 0x0B, 4}, {4, 0x0C, 5}, {4, 0x0E, 6}, {4, 0x0F, 7}, {5, 0x12, 128}, {5, 0x13, 8}, {5, 0x14, 9}, {5, 0x1B, 64}, {5, 0x07, 10}, {5, 0x08, 11}, {6, 0x17, 192}, {6, 0x18, 1664}, {6, 0x2A, 16}, {6, 0x2B, 17}, {6, 0x03, 13}, {6, 0x34, 14}, {6, 0x35, 15}, {6, 0x07, 1}, {6, 0x08, 12}, {7, 0x13, 26}, {7, 0x17, 21}, {7, 0x18, 28}, {7, 0x24, 27}, {7, 0x27, 18}, {7, 0x28, 24}, {7, 0x2B, 25}, {7, 0x03, 22}, {7, 0x37, 256}, {7, 0x04, 23}, {7, 0x08, 20}, {7, 0xC, 19}, {8, 0x12, 33}, {8, 0x13, 34}, {8, 0x14, 35}, {8, 0x15, 36}, {8, 0x16, 37}, {8, 0x17, 38}, {8, 0x1A, 31}, {8, 0x1B, 32}, {8, 0x02, 29}, {8, 0x24, 53}, {8, 0x25, 54}, {8, 0x28, 39}, {8, 0x29, 40}, {8, 0x2A, 41}, {8, 0x2B, 42}, {8, 0x2C, 43}, {8, 0x2D, 44}, {8, 0x03, 30}, {8, 0x32, 61}, {8, 0x33, 62}, {8, 0x34, 63}, {8, 0x35, 0}, {8, 0x36, 320}, {8, 0x37, 384}, {8, 0x04, 45}, {8, 0x4A, 59}, {8, 0x4B, 60}, {8, 0x5, 46}, {8, 0x52, 49}, {8, 0x53, 50}, {8, 0x54, 51}, {8, 0x55, 52}, {8, 0x58, 55}, {8, 0x59, 56}, {8, 0x5A, 57}, {8, 0x5B, 58}, {8, 0x64, 448}, {8, 0x65, 512}, {8, 0x67, 640}, {8, 0x68, 576}, {8, 0x0A, 47}, {8, 0x0B, 48}, {9, 0x01, _gd}, {9, 0x98, 1472}, {9, 0x99, 1536}, {9, 0x9A, 1600}, {9, 0x9B, 1728}, {9, 0xCC, 704}, {9, 0xCD, 768}, {9, 0xD2, 832}, {9, 0xD3, 896}, {9, 0xD4, 960}, {9, 0xD5, 1024}, {9, 0xD6, 1088}, {9, 0xD7, 1152}, {9, 0xD8, 1216}, {9, 0xD9, 1280}, {9, 0xDA, 1344}, {9, 0xDB, 1408}, {10, 0x01, _gd}, {11, 0x01, _gd}, {11, 0x08, 1792}, {11, 0x0C, 1856}, {11, 0x0D, 1920}, {12, 0x00, EOF}, {12, 0x01, EOL}, {12, 0x12, 1984}, {12, 0x13, 2048}, {12, 0x14, 2112}, {12, 0x15, 2176}, {12, 0x16, 2240}, {12, 0x17, 2304}, {12, 0x1C, 2368}, {12, 0x1D, 2432}, {12, 0x1E, 2496}, {12, 0x1F, 2560}}
	_bf = [][3]int{{2, 0x02, 3}, {2, 0x03, 2}, {3, 0x02, 1}, {3, 0x03, 4}, {4, 0x02, 6}, {4, 0x03, 5}, {5, 0x03, 7}, {6, 0x04, 9}, {6, 0x05, 8}, {7, 0x04, 10}, {7, 0x05, 11}, {7, 0x07, 12}, {8, 0x04, 13}, {8, 0x07, 14}, {9, 0x01, _gd}, {9, 0x18, 15}, {10, 0x01, _gd}, {10, 0x17, 16}, {10, 0x18, 17}, {10, 0x37, 0}, {10, 0x08, 18}, {10, 0x0F, 64}, {11, 0x01, _gd}, {11, 0x17, 24}, {11, 0x18, 25}, {11, 0x28, 23}, {11, 0x37, 22}, {11, 0x67, 19}, {11, 0x68, 20}, {11, 0x6C, 21}, {11, 0x08, 1792}, {11, 0x0C, 1856}, {11, 0x0D, 1920}, {12, 0x00, EOF}, {12, 0x01, EOL}, {12, 0x12, 1984}, {12, 0x13, 2048}, {12, 0x14, 2112}, {12, 0x15, 2176}, {12, 0x16, 2240}, {12, 0x17, 2304}, {12, 0x1C, 2368}, {12, 0x1D, 2432}, {12, 0x1E, 2496}, {12, 0x1F, 2560}, {12, 0x24, 52}, {12, 0x27, 55}, {12, 0x28, 56}, {12, 0x2B, 59}, {12, 0x2C, 60}, {12, 0x33, 320}, {12, 0x34, 384}, {12, 0x35, 448}, {12, 0x37, 53}, {12, 0x38, 54}, {12, 0x52, 50}, {12, 0x53, 51}, {12, 0x54, 44}, {12, 0x55, 45}, {12, 0x56, 46}, {12, 0x57, 47}, {12, 0x58, 57}, {12, 0x59, 58}, {12, 0x5A, 61}, {12, 0x5B, 256}, {12, 0x64, 48}, {12, 0x65, 49}, {12, 0x66, 62}, {12, 0x67, 63}, {12, 0x68, 30}, {12, 0x69, 31}, {12, 0x6A, 32}, {12, 0x6B, 33}, {12, 0x6C, 40}, {12, 0x6D, 41}, {12, 0xC8, 128}, {12, 0xC9, 192}, {12, 0xCA, 26}, {12, 0xCB, 27}, {12, 0xCC, 28}, {12, 0xCD, 29}, {12, 0xD2, 34}, {12, 0xD3, 35}, {12, 0xD4, 36}, {12, 0xD5, 37}, {12, 0xD6, 38}, {12, 0xD7, 39}, {12, 0xDA, 42}, {12, 0xDB, 43}, {13, 0x4A, 640}, {13, 0x4B, 704}, {13, 0x4C, 768}, {13, 0x4D, 832}, {13, 0x52, 1280}, {13, 0x53, 1344}, {13, 0x54, 1408}, {13, 0x55, 1472}, {13, 0x5A, 1536}, {13, 0x5B, 1600}, {13, 0x64, 1664}, {13, 0x65, 1728}, {13, 0x6C, 512}, {13, 0x6D, 576}, {13, 0x72, 896}, {13, 0x73, 960}, {13, 0x74, 1024}, {13, 0x75, 1088}, {13, 0x76, 1152}, {13, 0x77, 1216}}
)

func (_daa *runData) uncompressGetCodeLittleEndian(_dff []*code) (*code, error) {
	_egf, _fgca := _daa.uncompressGetNextCodeLittleEndian()
	if _fgca != nil {
		_g.Log.Debug("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076", _fgca)
		return nil, _fgca
	}
	_egf &= 0xffffff
	_cbf := _egf >> (_dfe - _ddb)
	_fda := _dff[_cbf]
	if _fda != nil && _fda._af {
		_cbf = (_egf >> (_dfe - _ddb - _geg)) & _db
		_fda = _fda._da[_cbf]
	}
	return _fda, nil
}

func (_dfd *Decoder) detectAndSkipEOL() error {
	for {
		_ef, _cb := _dfd._fe.uncompressGetCode(_dfd._gdg)
		if _cb != nil {
			return _cb
		}
		if _ef != nil && _ef._ea == EOL {
			_dfd._fe._fdb += _ef._gf
		} else {
			return nil
		}
	}
}

func (_bcb *runData) uncompressGetCode(_ddbe []*code) (*code, error) {
	return _bcb.uncompressGetCodeLittleEndian(_ddbe)
}

func (_ab *Decoder) createLittleEndianTable(_ba [][3]int) ([]*code, error) {
	_dbb := make([]*code, _cg+1)
	for _dea := 0; _dea < len(_ba); _dea++ {
		_afg := _eac(_ba[_dea])
		if _afg._gf <= _ddb {
			_fc := _ddb - _afg._gf
			_ddf := _afg._ac << uint(_fc)
			for _gac := (1 << uint(_fc)) - 1; _gac >= 0; _gac-- {
				_ae := _ddf | _gac
				_dbb[_ae] = _afg
			}
		} else {
			_gc := _afg._ac >> uint(_afg._gf-_ddb)
			if _dbb[_gc] == nil {
				var _fb = _eac([3]int{})
				_fb._da = make([]*code, _db+1)
				_dbb[_gc] = _fb
			}
			if _afg._gf <= _ddb+_geg {
				_ffd := _ddb + _geg - _afg._gf
				_eba := (_afg._ac << uint(_ffd)) & _db
				_dbb[_gc]._af = true
				for _abd := (1 << uint(_ffd)) - 1; _abd >= 0; _abd-- {
					_dbb[_gc]._da[_eba|_abd] = _afg
				}
			} else {
				return nil, _f.New("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072")
			}
		}
	}
	return _dbb, nil
}

func (_cdf *runData) align() { _cdf._fdb = ((_cdf._fdb + 7) >> 3) << 3 }

func New(r *_ag.Reader, width, height int, dataOffset, dataLength int64) (*Decoder, error) {
	_agd := &Decoder{_deg: width, _afa: height}
	_eaa, _ce := r.NewPartialReader(int(dataOffset), int(dataLength), false)
	if _ce != nil {
		return nil, _ce
	}
	_acc, _ce := _gec(_eaa)
	if _ce != nil {
		return nil, _ce
	}
	_, _ce = r.Seek(_eaa.RelativePosition(), _a.SeekCurrent)
	if _ce != nil {
		return nil, _ce
	}
	_agd._fe = _acc
	if _gde := _agd.initTables(); _gde != nil {
		return nil, _gde
	}
	return _agd, nil
}

func (_ccg *Decoder) initTables() (_gee error) {
	if _ccg._dgd == nil {
		_ccg._dgd, _gee = _ccg.createLittleEndianTable(_fd)
		if _gee != nil {
			return
		}
		_ccg._bb, _gee = _ccg.createLittleEndianTable(_bf)
		if _gee != nil {
			return
		}
		_ccg._gdg, _gee = _ccg.createLittleEndianTable(_ff)
		if _gee != nil {
			return
		}
	}
	return nil
}

type code struct {
	_gf int
	_ac int
	_ea int
	_da []*code
	_af bool
}

func (_abf *runData) uncompressGetNextCodeLittleEndian() (int, error) {
	_fdbg := _abf._fdb - _abf._ecf
	if _fdbg < 0 || _fdbg > 24 {
		_bde := (_abf._fdb >> 3) - _abf._gb
		if _bde >= _abf._fgg {
			_bde += _abf._gb
			if _edc := _abf.fillBuffer(_bde); _edc != nil {
				return 0, _edc
			}
			_bde -= _abf._gb
		}
		_cae := (uint32(_abf._fce[_bde]&0xFF) << 16) | (uint32(_abf._fce[_bde+1]&0xFF) << 8) | (uint32(_abf._fce[_bde+2] & 0xFF))
		_aca := uint32(_abf._fdb & 7)
		_cae <<= _aca
		_abf._edg = int(_cae)
	} else {
		_fedd := _abf._ecf & 7
		_ggg := 7 - _fedd
		if _fdbg <= _ggg {
			_abf._edg <<= uint(_fdbg)
		} else {
			_cbd := (_abf._ecf >> 3) + 3 - _abf._gb
			if _cbd >= _abf._fgg {
				_cbd += _abf._gb
				if _gaf := _abf.fillBuffer(_cbd); _gaf != nil {
					return 0, _gaf
				}
				_cbd -= _abf._gb
			}
			_fedd = 8 - _fedd
			for {
				_abf._edg <<= uint(_fedd)
				_abf._edg |= int(uint(_abf._fce[_cbd]) & 0xFF)
				_fdbg -= _fedd
				_cbd++
				_fedd = 8
				if !(_fdbg >= 8) {
					break
				}
			}
			_abf._edg <<= uint(_fdbg)
		}
	}
	_abf._ecf = _abf._fdb
	return _abf._edg, nil
}

type Decoder struct {
	_deg, _afa int
	_fe        *runData
	_dgd       []*code
	_bb        []*code
	_gdg       []*code
}

func (_bc *code) String() string {
	return _e.Sprintf("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064", _bc._gf, _bc._ac, _bc._ea)
}

const (
	_efb int  = 1024 << 7
	_bdg int  = 3
	_dfe uint = 24
)

func _eac(_de [3]int) *code { return &code{_gf: _de[0], _ac: _de[1], _ea: _de[2]} }

func _gec(_degb *_ag.Reader) (*runData, error) {
	_ggc := &runData{_bff: _degb, _fdb: 0, _ecf: 1}
	_aec := _dd(_aga(_bdg, int(_degb.Length())), _efb)
	_ggc._fce = make([]byte, _aec)
	if _acg := _ggc.fillBuffer(0); _acg != nil {
		if _acg == _a.EOF {
			_ggc._fce = make([]byte, 10)
			_g.Log.Debug("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076", _acg)
		} else {
			return nil, _acg
		}
	}
	return _ggc, nil
}

func (_afac *Decoder) uncompress1d(_aaa *runData, _fea []int, _ad int) (int, error) {
	var (
		_cfb = true
		_adf int
		_cge *code
		_gfd int
		_gfg error
	)
_aff:
	for _adf < _ad {
	_daf:
		for {
			if _cfb {
				_cge, _gfg = _aaa.uncompressGetCode(_afac._dgd)
				if _gfg != nil {
					return 0, _gfg
				}
			} else {
				_cge, _gfg = _aaa.uncompressGetCode(_afac._bb)
				if _gfg != nil {
					return 0, _gfg
				}
			}
			_aaa._fdb += _cge._gf
			if _cge._ea < 0 {
				break _aff
			}
			_adf += _cge._ea
			if _cge._ea < 64 {
				_cfb = !_cfb
				_fea[_gfd] = _adf
				_gfd++
				break _daf
			}
		}
	}
	if _fea[_gfd] != _ad {
		_fea[_gfd] = _ad
	}
	_geb := EOL
	if _cge != nil && _cge._ea != EOL {
		_geb = _gfd
	}
	return _geb, nil
}

type mmrCode int

func _dd(_ec, _ge int) int {
	if _ec > _ge {
		return _ge
	}
	return _ec
}

func (_cgg *runData) fillBuffer(_abc int) error {
	_cgg._gb = _abc
	_, _bee := _cgg._bff.Seek(int64(_abc), _a.SeekStart)
	if _bee != nil {
		if _bee == _a.EOF {
			_g.Log.Debug("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046")
			_cgg._fgg = -1
		} else {
			return _bee
		}
	}
	if _bee == nil {
		_cgg._fgg, _bee = _cgg._bff.Read(_cgg._fce)
		if _bee != nil {
			if _bee == _a.EOF {
				_g.Log.Trace("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046")
				_cgg._fgg = -1
			} else {
				return _bee
			}
		}
	}
	if _cgg._fgg > -1 && _cgg._fgg < 3 {
		for _cgg._fgg < 3 {
			_bgb, _agf := _cgg._bff.ReadByte()
			if _agf != nil {
				if _agf == _a.EOF {
					_cgg._fce[_cgg._fgg] = 0
				} else {
					return _agf
				}
			} else {
				_cgg._fce[_cgg._fgg] = _bgb & 0xFF
			}
			_cgg._fgg++
		}
	}
	_cgg._fgg -= 3
	if _cgg._fgg < 0 {
		_cgg._fce = make([]byte, len(_cgg._fce))
		_cgg._fgg = len(_cgg._fce) - 3
	}
	return nil
}

func _aga(_aa, _c int) int {
	if _aa < _c {
		return _c
	}
	return _aa
}

func (_fa *Decoder) UncompressMMR() (_ceg *_b.Bitmap, _be error) {
	_ceg = _b.New(_fa._deg, _fa._afa)
	_ced := make([]int, _ceg.Width+5)
	_cga := make([]int, _ceg.Width+5)
	_cga[0] = _ceg.Width
	_ga := 1
	var _edb int
	for _ecb := 0; _ecb < _ceg.Height; _ecb++ {
		_edb, _be = _fa.uncompress2d(_fa._fe, _cga, _ga, _ced, _ceg.Width)
		if _be != nil {
			return nil, _be
		}
		if _edb == EOF {
			break
		}
		if _edb > 0 {
			_be = _fa.fillBitmap(_ceg, _ecb, _ced, _edb)
			if _be != nil {
				return nil, _be
			}
		}
		_cga, _ced = _ced, _cga
		_ga = _edb
	}
	if _be = _fa.detectAndSkipEOL(); _be != nil {
		return nil, _be
	}
	_fa._fe.align()
	return _ceg, nil
}

const (
	EOF  = -3
	_gd  = -2
	EOL  = -1
	_ddb = 8
	_cg  = (1 << _ddb) - 1
	_geg = 5
	_db  = (1 << _geg) - 1
)

func (_cec *Decoder) fillBitmap(_cf *_b.Bitmap, _bd int, _fca []int, _ded int) error {
	var _cc byte
	_dde := 0
	_bcf := _cf.GetByteIndex(_dde, _bd)
	for _afad := 0; _afad < _ded; _afad++ {
		_gg := byte(1)
		_dgc := _fca[_afad]
		if (_afad & 1) == 0 {
			_gg = 0
		}
		for _dde < _dgc {
			_cc = (_cc << 1) | _gg
			_dde++
			if (_dde & 7) == 0 {
				if _dgdd := _cf.SetByte(_bcf, _cc); _dgdd != nil {
					return _dgdd
				}
				_bcf++
				_cc = 0
			}
		}
	}
	if (_dde & 7) != 0 {
		_cc <<= uint(8 - (_dde & 7))
		if _bg := _cf.SetByte(_bcf, _cc); _bg != nil {
			return _bg
		}
	}
	return nil
}

func (_fgc *Decoder) uncompress2d(_beb *runData, _dda []int, _ecbd int, _cged []int, _cfbe int) (int, error) {
	var (
		_efd  int
		_eg   int
		_dgcc int
		_fed  = true
		_fead error
		_dab  *code
	)
	_dda[_ecbd] = _cfbe
	_dda[_ecbd+1] = _cfbe
	_dda[_ecbd+2] = _cfbe + 1
	_dda[_ecbd+3] = _cfbe + 1
_dfc:
	for _dgcc < _cfbe {
		_dab, _fead = _beb.uncompressGetCode(_fgc._gdg)
		if _fead != nil {
			return EOL, nil
		}
		if _dab == nil {
			_beb._fdb++
			break _dfc
		}
		_beb._fdb += _dab._gf
		switch mmrCode(_dab._ea) {
		case _dg:
			_dgcc = _dda[_efd]
		case _age:
			_dgcc = _dda[_efd] + 1
		case _cd:
			_dgcc = _dda[_efd] - 1
		case _fg:
			for {
				var _dga []*code
				if _fed {
					_dga = _fgc._dgd
				} else {
					_dga = _fgc._bb
				}
				_dab, _fead = _beb.uncompressGetCode(_dga)
				if _fead != nil {
					return 0, _fead
				}
				if _dab == nil {
					break _dfc
				}
				_beb._fdb += _dab._gf
				if _dab._ea < 64 {
					if _dab._ea < 0 {
						_cged[_eg] = _dgcc
						_eg++
						_dab = nil
						break _dfc
					}
					_dgcc += _dab._ea
					_cged[_eg] = _dgcc
					_eg++
					break
				}
				_dgcc += _dab._ea
			}
			_gcd := _dgcc
		_cbg:
			for {
				var _ceb []*code
				if !_fed {
					_ceb = _fgc._dgd
				} else {
					_ceb = _fgc._bb
				}
				_dab, _fead = _beb.uncompressGetCode(_ceb)
				if _fead != nil {
					return 0, _fead
				}
				if _dab == nil {
					break _dfc
				}
				_beb._fdb += _dab._gf
				if _dab._ea < 64 {
					if _dab._ea < 0 {
						_cged[_eg] = _dgcc
						_eg++
						break _dfc
					}
					_dgcc += _dab._ea
					if _dgcc < _cfbe || _dgcc != _gcd {
						_cged[_eg] = _dgcc
						_eg++
					}
					break _cbg
				}
				_dgcc += _dab._ea
			}
			for _dgcc < _cfbe && _dda[_efd] <= _dgcc {
				_efd += 2
			}
			continue _dfc
		case _bce:
			_efd++
			_dgcc = _dda[_efd]
			_efd++
			continue _dfc
		case _df:
			_dgcc = _dda[_efd] + 2
		case _dfa:
			_dgcc = _dda[_efd] - 2
		case _aaf:
			_dgcc = _dda[_efd] + 3
		case _ca:
			_dgcc = _dda[_efd] - 3
		default:
			if _beb._fdb == 12 && _dab._ea == EOL {
				_beb._fdb = 0
				if _, _fead = _fgc.uncompress1d(_beb, _dda, _cfbe); _fead != nil {
					return 0, _fead
				}
				_beb._fdb++
				if _, _fead = _fgc.uncompress1d(_beb, _cged, _cfbe); _fead != nil {
					return 0, _fead
				}
				_fdc, _add := _fgc.uncompress1d(_beb, _dda, _cfbe)
				if _add != nil {
					return EOF, _add
				}
				_beb._fdb++
				return _fdc, nil
			}
			_dgcc = _cfbe
			continue _dfc
		}
		if _dgcc <= _cfbe {
			_fed = !_fed
			_cged[_eg] = _dgcc
			_eg++
			if _efd > 0 {
				_efd--
			} else {
				_efd++
			}
			for _dgcc < _cfbe && _dda[_efd] <= _dgcc {
				_efd += 2
			}
		}
	}
	if _cged[_eg] != _cfbe {
		_cged[_eg] = _cfbe
	}
	if _dab == nil {
		return EOL, nil
	}
	return _eg, nil
}

type runData struct {
	_bff *_ag.Reader
	_fdb int
	_ecf int
	_edg int
	_fce []byte
	_gb  int
	_fgg int
}
