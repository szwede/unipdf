//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform

import (
	_d "fmt"
	_g "github.com/szwede/unipdf/v4/common"
	_dd "math"
)

func (_fd Matrix) String() string {
	_ee, _cd, _ff, _ef, _df, _ab := _fd[0], _fd[1], _fd[3], _fd[4], _fd[6], _fd[7]
	return _d.Sprintf("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d", _ee, _cd, _ff, _ef, _df, _ab)
}

func ScaleMatrix(x, y float64) Matrix { return NewMatrix(x, 0, 0, y, 0, 0) }

func (_ecaf *Point) Set(x, y float64) { _ecaf.X, _ecaf.Y = x, y }

func ShearMatrix(x, y float64) Matrix { return NewMatrix(1, y, x, 1, 0, 0) }

func (_cf Matrix) ScalingFactorX() float64 { return _dd.Hypot(_cf[0], _cf[1]) }

func (_ddf Matrix) Translate(tx, ty float64) Matrix { return _ddf.Mult(TranslationMatrix(tx, ty)) }

func TranslationMatrix(tx, ty float64) Matrix { return NewMatrix(1, 0, 0, 1, tx, ty) }

func (_b *Matrix) Shear(x, y float64) { _b.Concat(ShearMatrix(x, y)) }

func (_fe *Matrix) Set(a, b, c, d, tx, ty float64) {
	_fe[0], _fe[1] = a, b
	_fe[3], _fe[4] = c, d
	_fe[6], _fe[7] = tx, ty
	_fe.clampRange()
}

func (_cg Matrix) Angle() float64 {
	_bd := _dd.Atan2(-_cg[1], _cg[0])
	if _bd < 0.0 {
		_bd += 2 * _dd.Pi
	}
	return _bd / _dd.Pi * 180.0
}

func (_fce *Matrix) clampRange() {
	for _aca, _bgf := range _fce {
		if _bgf > _cbg {
			_g.Log.Debug("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067", _bgf, _cbg)
			_fce[_aca] = _cbg
		} else if _bgf < -_cbg {
			_g.Log.Debug("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067", _bgf, -_cbg)
			_fce[_aca] = -_cbg
		}
	}
}

func (_eb Point) Displace(delta Point) Point { return Point{_eb.X + delta.X, _eb.Y + delta.Y} }

func IdentityMatrix() Matrix { return NewMatrix(1, 0, 0, 1, 0, 0) }

func (_cffa Point) Rotate(theta float64) Point {
	_bdg := _dd.Hypot(_cffa.X, _cffa.Y)
	_cc := _dd.Atan2(_cffa.Y, _cffa.X)
	_eff, _ebc := _dd.Sincos(_cc + theta/180.0*_dd.Pi)
	return Point{_bdg * _ebc, _bdg * _eff}
}

func (_bb Matrix) Unrealistic() bool {
	_dg, _ggg, _bbg, _ade := _dd.Abs(_bb[0]), _dd.Abs(_bb[1]), _dd.Abs(_bb[3]), _dd.Abs(_bb[4])
	_aaf := _dg > _cac && _ade > _cac
	_acd := _ggg > _cac && _bbg > _cac
	return !(_aaf || _acd)
}

const _gdd = 1e-10

func (_cb Matrix) Transform(x, y float64) (float64, float64) {
	_fec := x*_cb[0] + y*_cb[3] + _cb[6]
	_gd := x*_cb[1] + y*_cb[4] + _cb[7]
	return _fec, _gd
}

func (_gb Matrix) Mult(b Matrix) Matrix { _gb.Concat(b); return _gb }

func NewMatrix(a, b, c, d, tx, ty float64) Matrix {
	_fb := Matrix{a, b, 0, c, d, 0, tx, ty, 1}
	_fb.clampRange()
	return _fb
}

func NewPoint(x, y float64) Point { return Point{X: x, Y: y} }

const _cbg = 1e9

func (_ea Matrix) Translation() (float64, float64) { return _ea[6], _ea[7] }

func (_af *Matrix) Clone() Matrix { return NewMatrix(_af[0], _af[1], _af[3], _af[4], _af[6], _af[7]) }

func (_cff Matrix) Inverse() (Matrix, bool) {
	_cfb, _de := _cff[0], _cff[1]
	_fa, _cbb := _cff[3], _cff[4]
	_eca, _fag := _cff[6], _cff[7]
	_ca := _cfb*_cbb - _de*_fa
	if _dd.Abs(_ca) < _ce {
		return Matrix{}, false
	}
	_bgb, _ed := _cbb/_ca, -_de/_ca
	_ac, _ad := -_fa/_ca, _cfb/_ca
	_dfg := -(_bgb*_eca + _ac*_fag)
	_eea := -(_ed*_eca + _ad*_fag)
	return NewMatrix(_bgb, _ed, _ac, _ad, _dfg, _eea), true
}

const _ce = 1.0e-6

func (_abb Point) Interpolate(b Point, t float64) Point {
	return Point{X: (1-t)*_abb.X + t*b.X, Y: (1-t)*_abb.Y + t*b.Y}
}

func (_a Matrix) Round(precision float64) Matrix {
	for _c := range _a {
		_a[_c] = _dd.Round(_a[_c]/precision) * precision
	}
	return _a
}

func (_dda Matrix) Scale(xScale, yScale float64) Matrix {
	return _dda.Mult(ScaleMatrix(xScale, yScale))
}

func RotationMatrix(angle float64) Matrix {
	_f := _dd.Cos(angle)
	_ec := _dd.Sin(angle)
	return NewMatrix(_f, _ec, -_ec, _f, 0, 0)
}

func (_ga *Point) Transform(a, b, c, d, tx, ty float64) {
	_eg := NewMatrix(a, b, c, d, tx, ty)
	_ga.transformByMatrix(_eg)
}

func (_bf Point) String() string {
	return _d.Sprintf("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029", _bf.X, _bf.Y)
}

func (_ge *Point) transformByMatrix(_ae Matrix) { _ge.X, _ge.Y = _ae.Transform(_ge.X, _ge.Y) }

func (_ag Point) Distance(b Point) float64 { return _dd.Hypot(_ag.X-b.X, _ag.Y-b.Y) }

func (_gg Matrix) Identity() bool {
	return _gg[0] == 1 && _gg[1] == 0 && _gg[2] == 0 && _gg[3] == 0 && _gg[4] == 1 && _gg[5] == 0 && _gg[6] == 0 && _gg[7] == 0 && _gg[8] == 1
}

func NewMatrixFromTransforms(xScale, yScale, theta, tx, ty float64) Matrix {
	return IdentityMatrix().Scale(xScale, yScale).Rotate(theta).Translate(tx, ty)
}

type Matrix [9]float64

func (_fbg *Matrix) Concat(b Matrix) {
	*_fbg = Matrix{b[0]*_fbg[0] + b[1]*_fbg[3], b[0]*_fbg[1] + b[1]*_fbg[4], 0, b[3]*_fbg[0] + b[4]*_fbg[3], b[3]*_fbg[1] + b[4]*_fbg[4], 0, b[6]*_fbg[0] + b[7]*_fbg[3] + _fbg[6], b[6]*_fbg[1] + b[7]*_fbg[4] + _fbg[7], 1}
	_fbg.clampRange()
}

type Point struct {
	X float64
	Y float64
}

func (_bg Matrix) ScalingFactorY() float64 { return _dd.Hypot(_bg[3], _bg[4]) }

const _cac = 1e-6

func (_aa Matrix) Rotate(theta float64) Matrix { return _aa.Mult(RotationMatrix(theta)) }

func (_fc Matrix) Singular() bool { return _dd.Abs(_fc[0]*_fc[4]-_fc[1]*_fc[3]) < _gdd }
