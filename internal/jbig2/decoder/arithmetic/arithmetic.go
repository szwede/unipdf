//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic

import (
	_g "fmt"
	_af "github.com/szwede/unipdf/v4/common"
	_gd "github.com/szwede/unipdf/v4/internal/bitwise"
	_c "github.com/szwede/unipdf/v4/internal/jbig2/internal"
	_b "io"
	_ac "strings"
)

func (_gbd *DecoderStats) setEntry(_da int) {
	_addg := byte(_da & 0x7f)
	_gbd._gfa[_gbd._fab] = _addg
}

func (_ec *Decoder) DecodeIAID(codeLen uint64, stats *DecoderStats) (int64, error) {
	_ec._afa = 1
	var _add uint64
	for _add = 0; _add < codeLen; _add++ {
		stats.SetIndex(int32(_ec._afa))
		_acc, _ca := _ec.DecodeBit(stats)
		if _ca != nil {
			return 0, _ca
		}
		_ec._afa = (_ec._afa << 1) | int64(_acc)
	}
	_adg := _ec._afa - (1 << codeLen)
	return _adg, nil
}

func (_cc *Decoder) DecodeInt(stats *DecoderStats) (int32, error) {
	var (
		_gc, _fac        int32
		_fbd, _gdc, _bdc int
		_gcf             error
	)
	if stats == nil {
		stats = NewStats(512, 1)
	}
	_cc._afa = 1
	_gdc, _gcf = _cc.decodeIntBit(stats)
	if _gcf != nil {
		return 0, _gcf
	}
	_fbd, _gcf = _cc.decodeIntBit(stats)
	if _gcf != nil {
		return 0, _gcf
	}
	if _fbd == 1 {
		_fbd, _gcf = _cc.decodeIntBit(stats)
		if _gcf != nil {
			return 0, _gcf
		}
		if _fbd == 1 {
			_fbd, _gcf = _cc.decodeIntBit(stats)
			if _gcf != nil {
				return 0, _gcf
			}
			if _fbd == 1 {
				_fbd, _gcf = _cc.decodeIntBit(stats)
				if _gcf != nil {
					return 0, _gcf
				}
				if _fbd == 1 {
					_fbd, _gcf = _cc.decodeIntBit(stats)
					if _gcf != nil {
						return 0, _gcf
					}
					if _fbd == 1 {
						_bdc = 32
						_fac = 4436
					} else {
						_bdc = 12
						_fac = 340
					}
				} else {
					_bdc = 8
					_fac = 84
				}
			} else {
				_bdc = 6
				_fac = 20
			}
		} else {
			_bdc = 4
			_fac = 4
		}
	} else {
		_bdc = 2
		_fac = 0
	}
	for _faa := 0; _faa < _bdc; _faa++ {
		_fbd, _gcf = _cc.decodeIntBit(stats)
		if _gcf != nil {
			return 0, _gcf
		}
		_gc = (_gc << 1) | int32(_fbd)
	}
	_gc += _fac
	if _gdc == 0 {
		return _gc, nil
	} else if _gdc == 1 && _gc > 0 {
		return -_gc, nil
	}
	return 0, _c.ErrOOB
}

func (_ga *Decoder) renormalize() error {
	for {
		if _ga._bdd == 0 {
			if _abg := _ga.readByte(); _abg != nil {
				return _abg
			}
		}
		_ga._ab <<= 1
		_ga._ae <<= 1
		_ga._bdd--
		if (_ga._ab & 0x8000) != 0 {
			break
		}
	}
	_ga._ae &= 0xffffffff
	return nil
}

type Decoder struct {
	ContextSize          []uint32
	ReferedToContextSize []uint32
	_bd                  *_gd.Reader
	_bda                 uint8
	_ae                  uint64
	_ab                  uint32
	_afa                 int64
	_bdd                 int32
	_e                   int32
	_f                   int64
}

var (
	_ad = [][4]uint32{{0x5601, 1, 1, 1}, {0x3401, 2, 6, 0}, {0x1801, 3, 9, 0}, {0x0AC1, 4, 12, 0}, {0x0521, 5, 29, 0}, {0x0221, 38, 33, 0}, {0x5601, 7, 6, 1}, {0x5401, 8, 14, 0}, {0x4801, 9, 14, 0}, {0x3801, 10, 14, 0}, {0x3001, 11, 17, 0}, {0x2401, 12, 18, 0}, {0x1C01, 13, 20, 0}, {0x1601, 29, 21, 0}, {0x5601, 15, 14, 1}, {0x5401, 16, 14, 0}, {0x5101, 17, 15, 0}, {0x4801, 18, 16, 0}, {0x3801, 19, 17, 0}, {0x3401, 20, 18, 0}, {0x3001, 21, 19, 0}, {0x2801, 22, 19, 0}, {0x2401, 23, 20, 0}, {0x2201, 24, 21, 0}, {0x1C01, 25, 22, 0}, {0x1801, 26, 23, 0}, {0x1601, 27, 24, 0}, {0x1401, 28, 25, 0}, {0x1201, 29, 26, 0}, {0x1101, 30, 27, 0}, {0x0AC1, 31, 28, 0}, {0x09C1, 32, 29, 0}, {0x08A1, 33, 30, 0}, {0x0521, 34, 31, 0}, {0x0441, 35, 32, 0}, {0x02A1, 36, 33, 0}, {0x0221, 37, 34, 0}, {0x0141, 38, 35, 0}, {0x0111, 39, 36, 0}, {0x0085, 40, 37, 0}, {0x0049, 41, 38, 0}, {0x0025, 42, 39, 0}, {0x0015, 43, 40, 0}, {0x0009, 44, 41, 0}, {0x0005, 45, 42, 0}, {0x0001, 45, 43, 0}, {0x5601, 46, 46, 0}}
)

func (_de *Decoder) init() error {
	_de._f = _de._bd.AbsolutePosition()
	_ecc, _bdf := _de._bd.ReadByte()
	if _bdf != nil {
		_af.Log.Debug("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076", _bdf)
		return _bdf
	}
	_de._bda = _ecc
	_de._ae = uint64(_ecc) << 16
	if _bdf = _de.readByte(); _bdf != nil {
		return _bdf
	}
	_de._ae <<= 7
	_de._bdd -= 7
	_de._ab = 0x8000
	_de._e++
	return nil
}

func (_ecb *Decoder) decodeIntBit(_aeb *DecoderStats) (int, error) {
	_aeb.SetIndex(int32(_ecb._afa))
	_fbg, _gg := _ecb.DecodeBit(_aeb)
	if _gg != nil {
		_af.Log.Debug("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076", _gg)
		return _fbg, _gg
	}
	if _ecb._afa < 256 {
		_ecb._afa = ((_ecb._afa << uint64(1)) | int64(_fbg)) & 0x1ff
	} else {
		_ecb._afa = (((_ecb._afa<<uint64(1) | int64(_fbg)) & 511) | 256) & 0x1ff
	}
	return _fbg, nil
}

func NewStats(contextSize int32, index int32) *DecoderStats {
	return &DecoderStats{_fab: index, _ffg: contextSize, _gfa: make([]byte, contextSize), _ed: make([]byte, contextSize)}
}

func (_aef *Decoder) lpsExchange(_faad *DecoderStats, _ge int32, _cf uint32) int {
	_ccf := _faad.getMps()
	if _aef._ab < _cf {
		_faad.setEntry(int(_ad[_ge][1]))
		_aef._ab = _cf
		return int(_ccf)
	}
	if _ad[_ge][3] == 1 {
		_faad.toggleMps()
	}
	_faad.setEntry(int(_ad[_ge][2]))
	_aef._ab = _cf
	return int(1 - _ccf)
}

func (_bae *DecoderStats) cx() byte { return _bae._gfa[_bae._fab] }

func (_ee *DecoderStats) SetIndex(index int32) { _ee._fab = index }

func (_fba *Decoder) mpsExchange(_cd *DecoderStats, _dd int32) int {
	_abgf := _cd._ed[_cd._fab]
	if _fba._ab < _ad[_dd][0] {
		if _ad[_dd][3] == 1 {
			_cd.toggleMps()
		}
		_cd.setEntry(int(_ad[_dd][2]))
		return int(1 - _abgf)
	}
	_cd.setEntry(int(_ad[_dd][1]))
	return int(_abgf)
}

func (_bfd *DecoderStats) getMps() byte { return _bfd._ed[_bfd._fab] }

func (_aff *Decoder) DecodeBit(stats *DecoderStats) (int, error) {
	var (
		_gdf int
		_ba  = _ad[stats.cx()][0]
		_fa  = int32(stats.cx())
	)
	defer func() { _aff._e++ }()
	_aff._ab -= _ba
	if (_aff._ae >> 16) < uint64(_ba) {
		_gdf = _aff.lpsExchange(stats, _fa, _ba)
		if _fb := _aff.renormalize(); _fb != nil {
			return 0, _fb
		}
	} else {
		_aff._ae -= uint64(_ba) << 16
		if (_aff._ab & 0x8000) == 0 {
			_gdf = _aff.mpsExchange(stats, _fa)
			if _gf := _aff.renormalize(); _gf != nil {
				return 0, _gf
			}
		} else {
			_gdf = int(stats.getMps())
		}
	}
	return _gdf, nil
}

func (_gff *DecoderStats) toggleMps() { _gff._ed[_gff._fab] ^= 1 }

func (_ecf *DecoderStats) Copy() *DecoderStats {
	_aa := &DecoderStats{_ffg: _ecf._ffg, _gfa: make([]byte, _ecf._ffg)}
	copy(_aa._gfa, _ecf._gfa)
	return _aa
}

func New(r *_gd.Reader) (*Decoder, error) {
	_bg := &Decoder{_bd: r, ContextSize: []uint32{16, 13, 10, 10}, ReferedToContextSize: []uint32{13, 10}}
	if _d := _bg.init(); _d != nil {
		return nil, _d
	}
	return _bg, nil
}

func (_gcc *DecoderStats) String() string {
	_cg := &_ac.Builder{}
	_g.Fprintf(_cg, "S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a", len(_gcc._gfa))
	for _afe, _bddf := range _gcc._gfa {
		if _bddf != 0 {
			_g.Fprintf(_cg, "N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a", _afe, _bddf)
		}
	}
	return _cg.String()
}

func (_fe *DecoderStats) Overwrite(dNew *DecoderStats) {
	for _gb := 0; _gb < len(_fe._gfa); _gb++ {
		_fe._gfa[_gb] = dNew._gfa[_gb]
		_fe._ed[_gb] = dNew._ed[_gb]
	}
}

func (_ecfb *DecoderStats) Reset() {
	for _gfb := 0; _gfb < len(_ecfb._gfa); _gfb++ {
		_ecfb._gfa[_gfb] = 0
		_ecfb._ed[_gfb] = 0
	}
}

type DecoderStats struct {
	_fab int32
	_ffg int32
	_gfa []byte
	_ed  []byte
}

func (_ff *Decoder) readByte() error {
	if _ff._bd.AbsolutePosition() > _ff._f {
		if _, _aee := _ff._bd.Seek(-1, _b.SeekCurrent); _aee != nil {
			return _aee
		}
	}
	_acf, _gdca := _ff._bd.ReadByte()
	if _gdca != nil {
		return _gdca
	}
	_ff._bda = _acf
	if _ff._bda == 0xFF {
		_bf, _eg := _ff._bd.ReadByte()
		if _eg != nil {
			return _eg
		}
		if _bf > 0x8F {
			_ff._ae += 0xFF00
			_ff._bdd = 8
			if _, _eb := _ff._bd.Seek(-2, _b.SeekCurrent); _eb != nil {
				return _eb
			}
		} else {
			_ff._ae += uint64(_bf) << 9
			_ff._bdd = 7
		}
	} else {
		_acf, _gdca = _ff._bd.ReadByte()
		if _gdca != nil {
			return _gdca
		}
		_ff._bda = _acf
		_ff._ae += uint64(_ff._bda) << 8
		_ff._bdd = 8
	}
	_ff._ae &= 0xFFFFFFFFFF
	return nil
}
