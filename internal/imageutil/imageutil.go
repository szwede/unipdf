//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil

import (
	_d "encoding/binary"
	_fc "errors"
	_c "fmt"
	_ef "github.com/szwede/unipdf/v4/common"
	_ff "github.com/szwede/unipdf/v4/internal/bitwise"
	_g "image"
	_e "image/color"
	_bg "image/draw"
	_b "math"
)

func (_gce *Monochrome) At(x, y int) _e.Color {
	_ccebd, _ := _gce.ColorAt(x, y)
	return _ccebd
}

func (_eece *NRGBA32) Base() *ImageBase { return &_eece.ImageBase }

func _aagf(_eafae _g.Image, _acega int) (_g.Rectangle, bool, []byte) {
	_fcbg := _eafae.Bounds()
	var (
		_bbaa bool
		_ggga []byte
	)
	switch _fdff := _eafae.(type) {
	case SMasker:
		_bbaa = _fdff.HasAlpha()
	case NRGBA, RGBA, *_g.RGBA64, nrgba64, *_g.NYCbCrA:
		_ggga = make([]byte, _fcbg.Max.X*_fcbg.Max.Y*_acega)
	case *_g.Paletted:
		if !_fdff.Opaque() {
			_ggga = make([]byte, _fcbg.Max.X*_fcbg.Max.Y*_acega)
		}
	}
	return _fcbg, _bbaa, _ggga
}

func _ceg(_ebb *Monochrome, _fcf, _beg int) (*Monochrome, error) {
	if _ebb == nil {
		return nil, _fc.New("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064")
	}
	if _fcf <= 0 || _beg <= 0 {
		return nil, _fc.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030")
	}
	if _fcf == _beg {
		if _fcf == 1 {
			return _ebb.copy(), nil
		}
		if _fcf == 2 || _fcf == 4 || _fcf == 8 {
			_beb, _ggb := _fa(_ebb, _fcf)
			if _ggb != nil {
				return nil, _ggb
			}
			return _beb, nil
		}
	}
	_bfd := _fcf * _ebb.Width
	_gcc := _beg * _ebb.Height
	_ae := _edg(_bfd, _gcc)
	_aa := _ae.BytesPerLine
	var (
		_ded, _cge, _fbf, _afe, _bc int
		_bfc                        byte
		_aec                        error
	)
	for _cge = 0; _cge < _ebb.Height; _cge++ {
		_ded = _beg * _cge * _aa
		for _fbf = 0; _fbf < _ebb.Width; _fbf++ {
			if _ffd := _ebb.getBitAt(_fbf, _cge); _ffd {
				_bc = _fcf * _fbf
				for _afe = 0; _afe < _fcf; _afe++ {
					_ae.setIndexedBit(_ded*8 + _bc + _afe)
				}
			}
		}
		for _afe = 1; _afe < _beg; _afe++ {
			_bag := _ded + _afe*_aa
			for _fe := 0; _fe < _aa; _fe++ {
				if _bfc, _aec = _ae.getByte(_ded + _fe); _aec != nil {
					return nil, _aec
				}
				if _aec = _ae.setByte(_bag+_fe, _bfc); _aec != nil {
					return nil, _aec
				}
			}
		}
	}
	return _ae, nil
}

type Gray interface {
	GrayAt(_gegae, _deda int) _e.Gray
	SetGray(_effc, _bfcb int, _gbfa _e.Gray)
}

func _ffee(_gaebf _g.Image, _decfb Image, _dadb _g.Rectangle) {
	if _dbgag, _cccg := _gaebf.(SMasker); _cccg && _dbgag.HasAlpha() {
		_decfb.(SMasker).MakeAlpha()
	}
	switch _gdde := _gaebf.(type) {
	case Gray:
		_abee(_gdde, _decfb.(NRGBA), _dadb)
	case NRGBA:
		_agaa(_gdde, _decfb.(NRGBA), _dadb)
	case *_g.NYCbCrA:
		_eaef(_gdde, _decfb.(NRGBA), _dadb)
	case CMYK:
		_dbdg(_gdde, _decfb.(NRGBA), _dadb)
	case RGBA:
		_acfd(_gdde, _decfb.(NRGBA), _dadb)
	case nrgba64:
		_defg(_gdde, _decfb.(NRGBA), _dadb)
	default:
		_abd(_gaebf, _decfb, _dadb)
	}
}

func _egdc(_cbe _g.Image) (Image, error) {
	if _fafg, _eaf := _cbe.(*CMYK32); _eaf {
		return _fafg.Copy(), nil
	}
	_afb := _cbe.Bounds()
	_gca, _abc := NewImage(_afb.Max.X, _afb.Max.Y, 8, 4, nil, nil, nil)
	if _abc != nil {
		return nil, _abc
	}
	switch _gcdg := _cbe.(type) {
	case CMYK:
		_fedf(_gcdg, _gca.(CMYK), _afb)
	case Gray:
		_gaa(_gcdg, _gca.(CMYK), _afb)
	case NRGBA:
		_ecb(_gcdg, _gca.(CMYK), _afb)
	case RGBA:
		_gad(_gcdg, _gca.(CMYK), _afb)
	default:
		_abd(_cbe, _gca, _afb)
	}
	return _gca, nil
}

func (_gfg *CMYK32) Copy() Image { return &CMYK32{ImageBase: _gfg.copy()} }

func (_ebfa *CMYK32) Set(x, y int, c _e.Color) {
	_cccb := 4 * (y*_ebfa.Width + x)
	if _cccb+3 >= len(_ebfa.Data) {
		return
	}
	_bdf := _e.CMYKModel.Convert(c).(_e.CMYK)
	_ebfa.Data[_cccb] = _bdf.C
	_ebfa.Data[_cccb+1] = _bdf.M
	_ebfa.Data[_cccb+2] = _bdf.Y
	_ebfa.Data[_cccb+3] = _bdf.K
}

func _bege(_cdc _e.RGBA) _e.NRGBA {
	switch _cdc.A {
	case 0xff:
		return _e.NRGBA{R: _cdc.R, G: _cdc.G, B: _cdc.B, A: 0xff}
	case 0x00:
		return _e.NRGBA{}
	default:
		_ebde, _daea, _eeb, _aea := _cdc.RGBA()
		_ebde = (_ebde * 0xffff) / _aea
		_daea = (_daea * 0xffff) / _aea
		_eeb = (_eeb * 0xffff) / _aea
		return _e.NRGBA{R: uint8(_ebde >> 8), G: uint8(_daea >> 8), B: uint8(_eeb >> 8), A: uint8(_aea >> 8)}
	}
}

type CMYK interface {
	CMYKAt(_age, _fdd int) _e.CMYK
	SetCMYK(_ecaa, _cag int, _gega _e.CMYK)
}

func (_fggb *Gray4) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _fggb.Width, Y: _fggb.Height}}
}

func (_abff colorConverter) Convert(src _g.Image) (Image, error) { return _abff._feb(src) }

type Gray4 struct{ ImageBase }

func _fdcf(_gfd _e.RGBA) _e.CMYK {
	_egda, _cffb, _cbdb, _bffe := _e.RGBToCMYK(_gfd.R, _gfd.G, _gfd.B)
	return _e.CMYK{C: _egda, M: _cffb, Y: _cbdb, K: _bffe}
}

func ColorAtCMYK(x, y, width int, data []byte, decode []float64) (_e.CMYK, error) {
	_eag := 4 * (y*width + x)
	if _eag+3 >= len(data) {
		return _e.CMYK{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	C := data[_eag] & 0xff
	M := data[_eag+1] & 0xff
	Y := data[_eag+2] & 0xff
	K := data[_eag+3] & 0xff
	if len(decode) == 8 {
		C = uint8(uint32(LinearInterpolate(float64(C), 0, 255, decode[0], decode[1])) & 0xff)
		M = uint8(uint32(LinearInterpolate(float64(M), 0, 255, decode[2], decode[3])) & 0xff)
		Y = uint8(uint32(LinearInterpolate(float64(Y), 0, 255, decode[4], decode[5])) & 0xff)
		K = uint8(uint32(LinearInterpolate(float64(K), 0, 255, decode[6], decode[7])) & 0xff)
	}
	return _e.CMYK{C: C, M: M, Y: Y, K: K}, nil
}

func (_febg *Monochrome) ResolveDecode() error {
	if len(_febg.Decode) != 2 {
		return nil
	}
	if _febg.Decode[0] == 1 && _febg.Decode[1] == 0 {
		if _bba := _febg.InverseData(); _bba != nil {
			return _bba
		}
		_febg.Decode = nil
	}
	return nil
}

func (_ead *Monochrome) clearBit(_gadd, _bga int) { _ead.Data[_gadd] &= ^(0x80 >> uint(_bga&7)) }

func (_gbf *CMYK32) Base() *ImageBase { return &_gbf.ImageBase }

func (_caab *Gray2) Histogram() (_ffbc [256]int) {
	for _edd := 0; _edd < _caab.Width; _edd++ {
		for _egdd := 0; _egdd < _caab.Height; _egdd++ {
			_ffbc[_caab.GrayAt(_edd, _egdd).Y]++
		}
	}
	return _ffbc
}

func NewImageBase(width int, height int, bitsPerComponent int, colorComponents int, data []byte, alpha []byte, decode []float64) ImageBase {
	_dccb := ImageBase{Width: width, Height: height, BitsPerComponent: bitsPerComponent, ColorComponents: colorComponents, Data: data, Alpha: alpha, Decode: decode, BytesPerLine: BytesPerLine(width, bitsPerComponent, colorComponents)}
	if data == nil {
		_dccb.Data = make([]byte, height*_dccb.BytesPerLine)
	}
	return _dccb
}

func (_aab *Monochrome) ScaleLow(width, height int) (*Monochrome, error) {
	if width < 0 || height < 0 {
		return nil, _fc.New("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074")
	}
	_cfaf := _edg(width, height)
	_afab := make([]int, height)
	_eef := make([]int, width)
	_ccag := float64(_aab.Width) / float64(width)
	_fbd := float64(_aab.Height) / float64(height)
	for _geca := 0; _geca < height; _geca++ {
		_afab[_geca] = int(_b.Min(_fbd*float64(_geca)+0.5, float64(_aab.Height-1)))
	}
	for _cgcb := 0; _cgcb < width; _cgcb++ {
		_eef[_cgcb] = int(_b.Min(_ccag*float64(_cgcb)+0.5, float64(_aab.Width-1)))
	}
	_ecaag := -1
	_gafd := byte(0)
	for _decg := 0; _decg < height; _decg++ {
		_ffga := _afab[_decg] * _aab.BytesPerLine
		_cegd := _decg * _cfaf.BytesPerLine
		for _cdg := 0; _cdg < width; _cdg++ {
			_bbd := _eef[_cdg]
			if _bbd != _ecaag {
				_gafd = _aab.getBit(_ffga, _bbd)
				if _gafd != 0 {
					_cfaf.setBit(_cegd, _cdg)
				}
				_ecaag = _bbd
			} else {
				if _gafd != 0 {
					_cfaf.setBit(_cegd, _cdg)
				}
			}
		}
	}
	return _cfaf, nil
}

var _ NRGBA = &NRGBA16{}

func _fcdgc(_dcb CMYK, _geeag RGBA, _abeef _g.Rectangle) {
	for _faae := 0; _faae < _abeef.Max.X; _faae++ {
		for _ebaf := 0; _ebaf < _abeef.Max.Y; _ebaf++ {
			_adcc := _dcb.CMYKAt(_faae, _ebaf)
			_geeag.SetRGBA(_faae, _ebaf, _dgb(_adcc))
		}
	}
}

func FromGoImage(i _g.Image) (Image, error) {
	switch _cdcd := i.(type) {
	case Image:
		return _cdcd.Copy(), nil
	case Gray:
		return GrayConverter.Convert(i)
	case *_g.Gray16:
		return Gray16Converter.Convert(i)
	case CMYK:
		return CMYKConverter.Convert(i)
	case *_g.NRGBA64:
		return NRGBA64Converter.Convert(i)
	default:
		return NRGBAConverter.Convert(i)
	}
}

func (_eaa *NRGBA16) Copy() Image { return &NRGBA16{ImageBase: _eaa.copy()} }

func (_gbefa *RGBA32) Copy() Image { return &RGBA32{ImageBase: _gbefa.copy()} }

func _gdad(_dfad _g.Image) (Image, error) {
	if _ecae, _cefe := _dfad.(*NRGBA16); _cefe {
		return _ecae.Copy(), nil
	}
	_eagf := _dfad.Bounds()
	_bgde, _bdbe := NewImage(_eagf.Max.X, _eagf.Max.Y, 4, 3, nil, nil, nil)
	if _bdbe != nil {
		return nil, _bdbe
	}
	_ffee(_dfad, _bgde, _eagf)
	return _bgde, nil
}

func _cca(_bggd _e.NRGBA64) _e.NRGBA {
	return _e.NRGBA{R: uint8(_bggd.R >> 8), G: uint8(_bggd.G >> 8), B: uint8(_bggd.B >> 8), A: uint8(_bggd.A >> 8)}
}

func _caa() (_efe [256]uint32) {
	for _cee := 0; _cee < 256; _cee++ {
		if _cee&0x01 != 0 {
			_efe[_cee] |= 0xf
		}
		if _cee&0x02 != 0 {
			_efe[_cee] |= 0xf0
		}
		if _cee&0x04 != 0 {
			_efe[_cee] |= 0xf00
		}
		if _cee&0x08 != 0 {
			_efe[_cee] |= 0xf000
		}
		if _cee&0x10 != 0 {
			_efe[_cee] |= 0xf0000
		}
		if _cee&0x20 != 0 {
			_efe[_cee] |= 0xf00000
		}
		if _cee&0x40 != 0 {
			_efe[_cee] |= 0xf000000
		}
		if _cee&0x80 != 0 {
			_efe[_cee] |= 0xf0000000
		}
	}
	return _efe
}

func (_ffaf *ImageBase) setTwoBytes(_fdaef int, _ade uint16) error {
	if _fdaef+1 > len(_ffaf.Data)-1 {
		return _fc.New("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065")
	}
	_ffaf.Data[_fdaef] = byte((_ade & 0xff00) >> 8)
	_ffaf.Data[_fdaef+1] = byte(_ade & 0xff)
	return nil
}

func (_geea *Monochrome) ExpandBinary(factor int) (*Monochrome, error) {
	if !IsPowerOf2(uint(factor)) {
		return nil, _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064", factor)
	}
	return _fa(_geea, factor)
}

func (_aafa *Monochrome) ColorModel() _e.Model { return MonochromeModel(_aafa.ModelThreshold) }

func (_cgbca *ImageBase) newAlpha() {
	_gdg := BytesPerLine(_cgbca.Width, _cgbca.BitsPerComponent, 1)
	_cgbca.Alpha = make([]byte, _cgbca.Height*_gdg)
}

func (_bbf monochromeModel) Convert(c _e.Color) _e.Color {
	_effa := _e.GrayModel.Convert(c).(_e.Gray)
	return _dgd(_effa, _bbf)
}

func (_daeg *Monochrome) setGrayBit(_adbg, _dedg int) { _daeg.Data[_adbg] |= 0x80 >> uint(_dedg&7) }

func (_ceea *RGBA32) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _ceea.Width, Y: _ceea.Height}}
}

func _ceaf(_gdae Gray, _cfa nrgba64, _bef _g.Rectangle) {
	for _geda := 0; _geda < _bef.Max.X; _geda++ {
		for _cgff := 0; _cgff < _bef.Max.Y; _cgff++ {
			_dbg := _geddf(_cfa.NRGBA64At(_geda, _cgff))
			_gdae.SetGray(_geda, _cgff, _dbg)
		}
	}
}

var _ Image = &NRGBA64{}

func (_bcgg *Gray4) Set(x, y int, c _e.Color) {
	if x >= _bcgg.Width || y >= _bcgg.Height {
		return
	}
	_dcfe := Gray4Model.Convert(c).(_e.Gray)
	_bcgg.setGray(x, y, _dcfe)
}

func ColorAtNRGBA(x, y, width, bytesPerLine, bitsPerColor int, data, alpha []byte, decode []float64) (_e.Color, error) {
	switch bitsPerColor {
	case 4:
		return ColorAtNRGBA16(x, y, width, bytesPerLine, data, alpha, decode)
	case 8:
		return ColorAtNRGBA32(x, y, width, data, alpha, decode)
	case 16:
		return ColorAtNRGBA64(x, y, width, data, alpha, decode)
	default:
		return nil, _c.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027", bitsPerColor)
	}
}

func (_aceg *CMYK32) At(x, y int) _e.Color { _ecab, _ := _aceg.ColorAt(x, y); return _ecab }

func (_abdd *Gray4) Validate() error {
	if len(_abdd.Data) != _abdd.Height*_abdd.BytesPerLine {
		return ErrInvalidImage
	}
	return nil
}

func _gad(_bda RGBA, _fgae CMYK, _bfg _g.Rectangle) {
	for _fede := 0; _fede < _bfg.Max.X; _fede++ {
		for _dg := 0; _dg < _bfg.Max.Y; _dg++ {
			_gbd := _bda.RGBAAt(_fede, _dg)
			_fgae.SetCMYK(_fede, _dg, _fdcf(_gbd))
		}
	}
}

func _addf(_geegb _g.Image) (Image, error) {
	if _gecafg, _egfa := _geegb.(*RGBA32); _egfa {
		return _gecafg.Copy(), nil
	}
	_agaf, _ecef, _bdge := _aagf(_geegb, 1)
	_fcga := &RGBA32{ImageBase: NewImageBase(_agaf.Max.X, _agaf.Max.Y, 8, 3, nil, _bdge, nil)}
	_ccagc(_geegb, _fcga, _agaf)
	if len(_bdge) != 0 && !_ecef {
		if _efedc := _bede(_bdge, _fcga); _efedc != nil {
			return nil, _efedc
		}
	}
	return _fcga, nil
}

func (_aadd *Monochrome) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _aadd.Width, Y: _aadd.Height}}
}

func _eaef(_gbfb *_g.NYCbCrA, _gfgb NRGBA, _acgc _g.Rectangle) {
	for _dagea := 0; _dagea < _acgc.Max.X; _dagea++ {
		for _befa := 0; _befa < _acgc.Max.Y; _befa++ {
			_cfffd := _gbfb.NYCbCrAAt(_dagea, _befa)
			_gfgb.SetNRGBA(_dagea, _befa, _bbbd(_cfffd))
		}
	}
}

func MonochromeThresholdConverter(threshold uint8) ColorConverter {
	return &monochromeThresholdConverter{Threshold: threshold}
}

func _cfage(_efbfc, _ddbae RGBA, _fdeb _g.Rectangle) {
	for _ffgd := 0; _ffgd < _fdeb.Max.X; _ffgd++ {
		for _dgefb := 0; _dgefb < _fdeb.Max.Y; _dgefb++ {
			_ddbae.SetRGBA(_ffgd, _dgefb, _efbfc.RGBAAt(_ffgd, _dgefb))
		}
	}
}

func (_bagff *Gray16) Copy() Image { return &Gray16{ImageBase: _bagff.copy()} }

func (_cege *CMYK32) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtCMYK(x, y, _cege.Width, _cege.Data, _cege.Decode)
}

func _ced(_fcg, _ecf *Monochrome, _fcd []byte, _ebf int) (_bed error) {
	var (
		_efea, _ccg, _gee, _cfef, _efac, _ddd, _cgd, _cfc int
		_dce, _aad, _gbe, _agf                            uint32
		_aga, _bd                                         byte
		_afeb                                             uint16
	)
	_ccb := make([]byte, 4)
	_db := make([]byte, 4)
	for _gee = 0; _gee < _fcg.Height-1; _gee, _cfef = _gee+2, _cfef+1 {
		_efea = _gee * _fcg.BytesPerLine
		_ccg = _cfef * _ecf.BytesPerLine
		for _efac, _ddd = 0, 0; _efac < _ebf; _efac, _ddd = _efac+4, _ddd+1 {
			for _cgd = 0; _cgd < 4; _cgd++ {
				_cfc = _efea + _efac + _cgd
				if _cfc <= len(_fcg.Data)-1 && _cfc < _efea+_fcg.BytesPerLine {
					_ccb[_cgd] = _fcg.Data[_cfc]
				} else {
					_ccb[_cgd] = 0x00
				}
				_cfc = _efea + _fcg.BytesPerLine + _efac + _cgd
				if _cfc <= len(_fcg.Data)-1 && _cfc < _efea+(2*_fcg.BytesPerLine) {
					_db[_cgd] = _fcg.Data[_cfc]
				} else {
					_db[_cgd] = 0x00
				}
			}
			_dce = _d.BigEndian.Uint32(_ccb)
			_aad = _d.BigEndian.Uint32(_db)
			_gbe = _dce & _aad
			_gbe |= _gbe << 1
			_agf = _dce | _aad
			_agf &= _agf << 1
			_aad = _gbe | _agf
			_aad &= 0xaaaaaaaa
			_dce = _aad | (_aad << 7)
			_aga = byte(_dce >> 24)
			_bd = byte((_dce >> 8) & 0xff)
			_cfc = _ccg + _ddd
			if _cfc+1 == len(_ecf.Data)-1 || _cfc+1 >= _ccg+_ecf.BytesPerLine {
				if _bed = _ecf.setByte(_cfc, _fcd[_aga]); _bed != nil {
					return _c.Errorf("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d", _cfc)
				}
			} else {
				_afeb = (uint16(_fcd[_aga]) << 8) | uint16(_fcd[_bd])
				if _bed = _ecf.setTwoBytes(_cfc, _afeb); _bed != nil {
					return _c.Errorf("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064", _cfc)
				}
				_ddd++
			}
		}
	}
	return nil
}

func (_egg *CMYK32) Validate() error {
	if len(_egg.Data) != 4*_egg.Width*_egg.Height {
		return _fc.New("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073")
	}
	return nil
}

type NRGBA16 struct{ ImageBase }

func _ccd(_gbfe _e.NRGBA64) _e.RGBA {
	_bbc, _dfdc, _ccec, _gadb := _gbfe.RGBA()
	return _e.RGBA{R: uint8(_bbc >> 8), G: uint8(_dfdc >> 8), B: uint8(_ccec >> 8), A: uint8(_gadb >> 8)}
}

func _edaf(_cdbe *Monochrome, _deaa, _dafb, _aeef, _ccdaf int, _dgef RasterOperator) {
	if _deaa < 0 {
		_aeef += _deaa
		_deaa = 0
	}
	_caea := _deaa + _aeef - _cdbe.Width
	if _caea > 0 {
		_aeef -= _caea
	}
	if _dafb < 0 {
		_ccdaf += _dafb
		_dafb = 0
	}
	_agbbf := _dafb + _ccdaf - _cdbe.Height
	if _agbbf > 0 {
		_ccdaf -= _agbbf
	}
	if _aeef <= 0 || _ccdaf <= 0 {
		return
	}
	if (_deaa & 7) == 0 {
		_abe(_cdbe, _deaa, _dafb, _aeef, _ccdaf, _dgef)
	} else {
		_bfaac(_cdbe, _deaa, _dafb, _aeef, _ccdaf, _dgef)
	}
}

func (_fce *Gray8) SetGray(x, y int, g _e.Gray) {
	_dcefa := y*_fce.BytesPerLine + x
	if _dcefa > len(_fce.Data)-1 {
		return
	}
	_fce.Data[_dcefa] = g.Y
}

var _ Image = &Gray4{}

func (_gdc *Gray8) ColorModel() _e.Model { return _e.GrayModel }

func (_dage *NRGBA16) Set(x, y int, c _e.Color) {
	_gfda := y*_dage.BytesPerLine + x*3/2
	if _gfda+1 >= len(_dage.Data) {
		return
	}
	_fdbea := NRGBA16Model.Convert(c).(_e.NRGBA)
	_dage.setNRGBA(x, y, _gfda, _fdbea)
}

func _eea(_aecd, _gdag *Monochrome, _ebbae []byte, _fee int) (_afa error) {
	var (
		_aae, _fcfb, _gdec, _ede, _adf, _cdd, _eca, _fcfc int
		_acfa, _fgc, _fgd, _bce                           uint32
		_ccc, _gge                                        byte
		_bee                                              uint16
	)
	_agb := make([]byte, 4)
	_dfd := make([]byte, 4)
	for _gdec = 0; _gdec < _aecd.Height-1; _gdec, _ede = _gdec+2, _ede+1 {
		_aae = _gdec * _aecd.BytesPerLine
		_fcfb = _ede * _gdag.BytesPerLine
		for _adf, _cdd = 0, 0; _adf < _fee; _adf, _cdd = _adf+4, _cdd+1 {
			for _eca = 0; _eca < 4; _eca++ {
				_fcfc = _aae + _adf + _eca
				if _fcfc <= len(_aecd.Data)-1 && _fcfc < _aae+_aecd.BytesPerLine {
					_agb[_eca] = _aecd.Data[_fcfc]
				} else {
					_agb[_eca] = 0x00
				}
				_fcfc = _aae + _aecd.BytesPerLine + _adf + _eca
				if _fcfc <= len(_aecd.Data)-1 && _fcfc < _aae+(2*_aecd.BytesPerLine) {
					_dfd[_eca] = _aecd.Data[_fcfc]
				} else {
					_dfd[_eca] = 0x00
				}
			}
			_acfa = _d.BigEndian.Uint32(_agb)
			_fgc = _d.BigEndian.Uint32(_dfd)
			_fgd = _acfa & _fgc
			_fgd |= _fgd << 1
			_bce = _acfa | _fgc
			_bce &= _bce << 1
			_fgc = _fgd & _bce
			_fgc &= 0xaaaaaaaa
			_acfa = _fgc | (_fgc << 7)
			_ccc = byte(_acfa >> 24)
			_gge = byte((_acfa >> 8) & 0xff)
			_fcfc = _fcfb + _cdd
			if _fcfc+1 == len(_gdag.Data)-1 || _fcfc+1 >= _fcfb+_gdag.BytesPerLine {
				if _afa = _gdag.setByte(_fcfc, _ebbae[_ccc]); _afa != nil {
					return _c.Errorf("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d", _fcfc)
				}
			} else {
				_bee = (uint16(_ebbae[_ccc]) << 8) | uint16(_ebbae[_gge])
				if _afa = _gdag.setTwoBytes(_fcfc, _bee); _afa != nil {
					return _c.Errorf("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064", _fcfc)
				}
				_cdd++
			}
		}
	}
	return nil
}

func (_ffdc *Gray4) SetGray(x, y int, g _e.Gray) {
	if x >= _ffdc.Width || y >= _ffdc.Height {
		return
	}
	g = _gcdd(g)
	_ffdc.setGray(x, y, g)
}

func (_geb *Monochrome) IsUnpadded() bool { return (_geb.Width * _geb.Height) == len(_geb.Data) }

func _bede(_eabe []byte, _bcgge Image) error {
	_gced := true
	for _ecd := 0; _ecd < len(_eabe); _ecd++ {
		if _eabe[_ecd] != 0xff {
			_gced = false
			break
		}
	}
	if _gced {
		switch _fbdc := _bcgge.(type) {
		case *NRGBA32:
			_fbdc.Alpha = nil
		case *NRGBA64:
			_fbdc.Alpha = nil
		default:
			return _c.Errorf("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054", _bcgge)
		}
	}
	return nil
}

func _gf() (_dca [256]uint64) {
	for _ega := 0; _ega < 256; _ega++ {
		if _ega&0x01 != 0 {
			_dca[_ega] |= 0xff
		}
		if _ega&0x02 != 0 {
			_dca[_ega] |= 0xff00
		}
		if _ega&0x04 != 0 {
			_dca[_ega] |= 0xff0000
		}
		if _ega&0x08 != 0 {
			_dca[_ega] |= 0xff000000
		}
		if _ega&0x10 != 0 {
			_dca[_ega] |= 0xff00000000
		}
		if _ega&0x20 != 0 {
			_dca[_ega] |= 0xff0000000000
		}
		if _ega&0x40 != 0 {
			_dca[_ega] |= 0xff000000000000
		}
		if _ega&0x80 != 0 {
			_dca[_ega] |= 0xff00000000000000
		}
	}
	return _dca
}

func (_adg *ImageBase) setEightFullBytes(_efgc int, _ecc uint64) error {
	if _efgc+7 > len(_adg.Data)-1 {
		return _fc.New("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065")
	}
	_adg.Data[_efgc] = byte((_ecc & 0xff00000000000000) >> 56)
	_adg.Data[_efgc+1] = byte((_ecc & 0xff000000000000) >> 48)
	_adg.Data[_efgc+2] = byte((_ecc & 0xff0000000000) >> 40)
	_adg.Data[_efgc+3] = byte((_ecc & 0xff00000000) >> 32)
	_adg.Data[_efgc+4] = byte((_ecc & 0xff000000) >> 24)
	_adg.Data[_efgc+5] = byte((_ecc & 0xff0000) >> 16)
	_adg.Data[_efgc+6] = byte((_ecc & 0xff00) >> 8)
	_adg.Data[_efgc+7] = byte(_ecc & 0xff)
	return nil
}

func (_acd *NRGBA16) NRGBAAt(x, y int) _e.NRGBA {
	_dfbe, _ := ColorAtNRGBA16(x, y, _acd.Width, _acd.BytesPerLine, _acd.Data, _acd.Alpha, _acd.Decode)
	return _dfbe
}

type Gray8 struct{ ImageBase }

func (_bdb *Gray4) GrayAt(x, y int) _e.Gray {
	_fbfb, _ := ColorAtGray4BPC(x, y, _bdb.BytesPerLine, _bdb.Data, _bdb.Decode)
	return _fbfb
}

func init() { _gfeg() }

func _egge(_fgbc *Monochrome, _cecg, _daf, _dgfb, _cdaf int, _gfaa RasterOperator, _fef *Monochrome, _aecb, _egdg int) error {
	var (
		_gbdfe       bool
		_dfca        bool
		_dgg         int
		_egdgc       int
		_edc         int
		_ggbc        bool
		_ecaac       byte
		_agbd        int
		_edce        int
		_ccgg        int
		_gbfd, _fcdg int
	)
	_ecaf := 8 - (_cecg & 7)
	_cgag := _dbcf[_ecaf]
	_gbcc := _fgbc.BytesPerLine*_daf + (_cecg >> 3)
	_fffe := _fef.BytesPerLine*_egdg + (_aecb >> 3)
	if _dgfb < _ecaf {
		_gbdfe = true
		_cgag &= _febgc[8-_ecaf+_dgfb]
	}
	if !_gbdfe {
		_dgg = (_dgfb - _ecaf) >> 3
		if _dgg > 0 {
			_dfca = true
			_egdgc = _gbcc + 1
			_edc = _fffe + 1
		}
	}
	_agbd = (_cecg + _dgfb) & 7
	if !(_gbdfe || _agbd == 0) {
		_ggbc = true
		_ecaac = _febgc[_agbd]
		_edce = _gbcc + 1 + _dgg
		_ccgg = _fffe + 1 + _dgg
	}
	switch _gfaa {
	case PixSrc:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], _fef.Data[_fffe], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = _fef.Data[_edc+_fcdg]
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], _fef.Data[_ccgg], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixNotSrc:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], ^_fef.Data[_fffe], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = ^_fef.Data[_edc+_fcdg]
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], ^_fef.Data[_ccgg], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixSrcOrDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], _fef.Data[_fffe]|_fgbc.Data[_gbcc], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] |= _fef.Data[_edc+_fcdg]
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], _fef.Data[_ccgg]|_fgbc.Data[_edce], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixSrcAndDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], _fef.Data[_fffe]&_fgbc.Data[_gbcc], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] &= _fef.Data[_edc+_fcdg]
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], _fef.Data[_ccgg]&_fgbc.Data[_edce], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixSrcXorDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], _fef.Data[_fffe]^_fgbc.Data[_gbcc], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] ^= _fef.Data[_edc+_fcdg]
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], _fef.Data[_ccgg]^_fgbc.Data[_edce], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixNotSrcOrDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], ^(_fef.Data[_fffe])|_fgbc.Data[_gbcc], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] |= ^(_fef.Data[_edc+_fcdg])
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], ^(_fef.Data[_ccgg])|_fgbc.Data[_edce], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixNotSrcAndDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], ^(_fef.Data[_fffe])&_fgbc.Data[_gbcc], _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] &= ^_fef.Data[_edc+_fcdg]
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], ^(_fef.Data[_ccgg])&_fgbc.Data[_edce], _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixSrcOrNotDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], _fef.Data[_fffe]|^(_fgbc.Data[_gbcc]), _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = _fef.Data[_edc+_fcdg] | ^(_fgbc.Data[_egdgc+_fcdg])
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], _fef.Data[_ccgg]|^(_fgbc.Data[_edce]), _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixSrcAndNotDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], _fef.Data[_fffe]&^(_fgbc.Data[_gbcc]), _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = _fef.Data[_edc+_fcdg] &^ (_fgbc.Data[_egdgc+_fcdg])
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], _fef.Data[_ccgg]&^(_fgbc.Data[_edce]), _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixNotPixSrcOrDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], ^(_fef.Data[_fffe] | _fgbc.Data[_gbcc]), _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = ^(_fef.Data[_edc+_fcdg] | _fgbc.Data[_egdgc+_fcdg])
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], ^(_fef.Data[_ccgg] | _fgbc.Data[_edce]), _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixNotPixSrcAndDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], ^(_fef.Data[_fffe] & _fgbc.Data[_gbcc]), _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = ^(_fef.Data[_edc+_fcdg] & _fgbc.Data[_egdgc+_fcdg])
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], ^(_fef.Data[_ccgg] & _fgbc.Data[_edce]), _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	case PixNotPixSrcXorDst:
		for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
			_fgbc.Data[_gbcc] = _aaec(_fgbc.Data[_gbcc], ^(_fef.Data[_fffe] ^ _fgbc.Data[_gbcc]), _cgag)
			_gbcc += _fgbc.BytesPerLine
			_fffe += _fef.BytesPerLine
		}
		if _dfca {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				for _fcdg = 0; _fcdg < _dgg; _fcdg++ {
					_fgbc.Data[_egdgc+_fcdg] = ^(_fef.Data[_edc+_fcdg] ^ _fgbc.Data[_egdgc+_fcdg])
				}
				_egdgc += _fgbc.BytesPerLine
				_edc += _fef.BytesPerLine
			}
		}
		if _ggbc {
			for _gbfd = 0; _gbfd < _cdaf; _gbfd++ {
				_fgbc.Data[_edce] = _aaec(_fgbc.Data[_edce], ^(_fef.Data[_ccgg] ^ _fgbc.Data[_edce]), _ecaac)
				_edce += _fgbc.BytesPerLine
				_ccgg += _fef.BytesPerLine
			}
		}
	default:
		_ef.Log.Debug("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064", _gfaa)
		return _fc.New("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072")
	}
	return nil
}

func (_beacf *NRGBA16) ColorModel() _e.Model { return NRGBA16Model }

func _beagb(_fcfe int, _dbecd int) error {
	return _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", _fcfe, _dbecd)
}

func (_dacc *NRGBA16) At(x, y int) _e.Color { _ecacc, _ := _dacc.ColorAt(x, y); return _ecacc }

func (_cfg *Monochrome) setGray(_cagc int, _ffbg _e.Gray, _feac int) {
	if _ffbg.Y == 0 {
		_cfg.clearBit(_feac, _cagc)
	} else {
		_cfg.setGrayBit(_feac, _cagc)
	}
}

func (_bfdc *Monochrome) getBitAt(_cgca, _edeg int) bool {
	_cfff := _edeg*_bfdc.BytesPerLine + (_cgca >> 3)
	_ccbf := _cgca & 0x07
	_gfe := uint(7 - _ccbf)
	if _cfff > len(_bfdc.Data)-1 {
		return false
	}
	if (_bfdc.Data[_cfff]>>_gfe)&0x01 >= 1 {
		return true
	}
	return false
}

func InDelta(expected, current, delta float64) bool {
	_bfaae := expected - current
	if _bfaae <= -delta || _bfaae >= delta {
		return false
	}
	return true
}

func (_ada *CMYK32) SetCMYK(x, y int, c _e.CMYK) {
	_fdc := 4 * (y*_ada.Width + x)
	if _fdc+3 >= len(_ada.Data) {
		return
	}
	_ada.Data[_fdc] = c.C
	_ada.Data[_fdc+1] = c.M
	_ada.Data[_fdc+2] = c.Y
	_ada.Data[_fdc+3] = c.K
}

func (_eae *Gray2) GrayAt(x, y int) _e.Gray {
	_dcfa, _ := ColorAtGray2BPC(x, y, _eae.BytesPerLine, _eae.Data, _eae.Decode)
	return _dcfa
}

func _ffgc(_caba *Monochrome, _gbdf, _gfbb, _bgeb, _ccdb int, _dbda RasterOperator, _aeec *Monochrome, _aeg, _edbg int) error {
	if _caba == nil {
		return _fc.New("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070")
	}
	if _dbda == PixDst {
		return nil
	}
	switch _dbda {
	case PixClr, PixSet, PixNotDst:
		_edaf(_caba, _gbdf, _gfbb, _bgeb, _ccdb, _dbda)
		return nil
	}
	if _aeec == nil {
		_ef.Log.Debug("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064")
		return _fc.New("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070")
	}
	if _fffb := _agab(_caba, _gbdf, _gfbb, _bgeb, _ccdb, _dbda, _aeec, _aeg, _edbg); _fffb != nil {
		return _fffb
	}
	return nil
}

func (_bdee *NRGBA64) Base() *ImageBase { return &_bdee.ImageBase }

func AddDataPadding(width, height, bitsPerComponent, colorComponents int, data []byte) ([]byte, error) {
	_afcc := BytesPerLine(width, bitsPerComponent, colorComponents)
	if _afcc == width*colorComponents*bitsPerComponent/8 {
		return data, nil
	}
	_dbge := width * colorComponents * bitsPerComponent
	_accg := _afcc * 8
	_daac := 8 - (_accg - _dbge)
	_gaeg := _ff.NewReader(data)
	_ccge := _afcc - 1
	_aca := make([]byte, _ccge)
	_fdbd := make([]byte, height*_afcc)
	_adge := _ff.NewWriterMSB(_fdbd)
	var _ageb uint64
	var _agac error
	for _acad := 0; _acad < height; _acad++ {
		_, _agac = _gaeg.Read(_aca)
		if _agac != nil {
			return nil, _agac
		}
		_, _agac = _adge.Write(_aca)
		if _agac != nil {
			return nil, _agac
		}
		_ageb, _agac = _gaeg.ReadBits(byte(_daac))
		if _agac != nil {
			return nil, _agac
		}
		_, _agac = _adge.WriteBits(_ageb, _daac)
		if _agac != nil {
			return nil, _agac
		}
		_adge.FinishByte()
	}
	return _fdbd, nil
}

func (_ccbc *Monochrome) AddPadding() (_fadc error) {
	if _cbgc := ((_ccbc.Width * _ccbc.Height) + 7) >> 3; len(_ccbc.Data) < _cbgc {
		return _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073", len(_ccbc.Data), _cbgc)
	}
	_gbee := _ccbc.Width % 8
	if _gbee == 0 {
		return nil
	}
	_ceef := _ccbc.Width / 8
	_cgdgg := _ff.NewReader(_ccbc.Data)
	_bcg := make([]byte, _ccbc.Height*_ccbc.BytesPerLine)
	_dcgc := _ff.NewWriterMSB(_bcg)
	_ggc := make([]byte, _ceef)
	var (
		_afc  int
		_cgbc uint64
	)
	for _afc = 0; _afc < _ccbc.Height; _afc++ {
		if _, _fadc = _cgdgg.Read(_ggc); _fadc != nil {
			return _fadc
		}
		if _, _fadc = _dcgc.Write(_ggc); _fadc != nil {
			return _fadc
		}
		if _cgbc, _fadc = _cgdgg.ReadBits(byte(_gbee)); _fadc != nil {
			return _fadc
		}
		if _fadc = _dcgc.WriteByte(byte(_cgbc) << uint(8-_gbee)); _fadc != nil {
			return _fadc
		}
	}
	_ccbc.Data = _dcgc.Data()
	return nil
}

func (_ffa *Gray2) Set(x, y int, c _e.Color) {
	if x >= _ffa.Width || y >= _ffa.Height {
		return
	}
	_adbd := Gray2Model.Convert(c).(_e.Gray)
	_adbc := y * _ffa.BytesPerLine
	_dadff := _adbc + (x >> 2)
	_dfbg := _adbd.Y >> 6
	_ffa.Data[_dadff] = (_ffa.Data[_dadff] & (^(0xc0 >> uint(2*((x)&3))))) | (_dfbg << uint(6-2*(x&3)))
}

func (_bbe *Monochrome) copy() *Monochrome {
	_gdef := _edg(_bbe.Width, _bbe.Height)
	_gdef.ModelThreshold = _bbe.ModelThreshold
	_gdef.Data = make([]byte, len(_bbe.Data))
	copy(_gdef.Data, _bbe.Data)
	if len(_bbe.Decode) != 0 {
		_gdef.Decode = make([]float64, len(_bbe.Decode))
		copy(_gdef.Decode, _bbe.Decode)
	}
	if len(_bbe.Alpha) != 0 {
		_gdef.Alpha = make([]byte, len(_bbe.Alpha))
		copy(_gdef.Alpha, _bbe.Alpha)
	}
	return _gdef
}

func (_ecfd *ImageBase) HasAlpha() bool {
	if _ecfd.Alpha == nil {
		return false
	}
	for _eecd := range _ecfd.Alpha {
		if _ecfd.Alpha[_eecd] != 0xff {
			return true
		}
	}
	return false
}

func (_gcebd *RGBA32) RGBAAt(x, y int) _e.RGBA {
	_dcgca, _ := ColorAtRGBA32(x, y, _gcebd.Width, _gcebd.Data, _gcebd.Alpha, _gcebd.Decode)
	return _dcgca
}

func _cbbad(_gdab _e.Color) _e.Color {
	_bcbd := _e.NRGBAModel.Convert(_gdab).(_e.NRGBA)
	return _dcfb(_bcbd)
}

func NewImage(width, height, bitsPerComponent, colorComponents int, data, alpha []byte, decode []float64) (Image, error) {
	_gedbg := NewImageBase(width, height, bitsPerComponent, colorComponents, data, alpha, decode)
	var _adbda Image
	switch colorComponents {
	case 1:
		switch bitsPerComponent {
		case 1:
			_adbda = &Monochrome{ImageBase: _gedbg, ModelThreshold: 0x0f}
		case 2:
			_adbda = &Gray2{ImageBase: _gedbg}
		case 4:
			_adbda = &Gray4{ImageBase: _gedbg}
		case 8:
			_adbda = &Gray8{ImageBase: _gedbg}
		case 16:
			_adbda = &Gray16{ImageBase: _gedbg}
		}
	case 3:
		switch bitsPerComponent {
		case 4:
			_adbda = &NRGBA16{ImageBase: _gedbg}
		case 8:
			_adbda = &NRGBA32{ImageBase: _gedbg}
		case 16:
			_adbda = &NRGBA64{ImageBase: _gedbg}
		}
	case 4:
		_adbda = &CMYK32{ImageBase: _gedbg}
	}
	if _adbda == nil {
		return nil, ErrInvalidImage
	}
	return _adbda, nil
}

func (_bgbe *Gray8) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtGray8BPC(x, y, _bgbe.BytesPerLine, _bgbe.Data, _bgbe.Decode)
}

func RasterOperation(dest *Monochrome, dx, dy, dw, dh int, op RasterOperator, src *Monochrome, sx, sy int) error {
	return _ffgc(dest, dx, dy, dw, dh, op, src, sx, sy)
}

func (_dgc *NRGBA64) ColorModel() _e.Model { return _e.NRGBA64Model }

func (_dbc *Gray4) Histogram() (_fffcg [256]int) {
	for _caga := 0; _caga < _dbc.Width; _caga++ {
		for _fdfc := 0; _fdfc < _dbc.Height; _fdfc++ {
			_fffcg[_dbc.GrayAt(_caga, _fdfc).Y]++
		}
	}
	return _fffcg
}

func _cad(_daee Gray, _fdgb NRGBA, _cef _g.Rectangle) {
	for _ddfa := 0; _ddfa < _cef.Max.X; _ddfa++ {
		for _cgcca := 0; _cgcca < _cef.Max.Y; _cgcca++ {
			_bab := _gdee(_fdgb.NRGBAAt(_ddfa, _cgcca))
			_daee.SetGray(_ddfa, _cgcca, _bab)
		}
	}
}

func (_gdeed *Gray16) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtGray16BPC(x, y, _gdeed.BytesPerLine, _gdeed.Data, _gdeed.Decode)
}

func (_fdgge *NRGBA16) SetNRGBA(x, y int, c _e.NRGBA) {
	_ffe := y*_fdgge.BytesPerLine + x*3/2
	if _ffe+1 >= len(_fdgge.Data) {
		return
	}
	c = _dcfb(c)
	_fdgge.setNRGBA(x, y, _ffe, c)
}

func _bbbd(_dda _e.NYCbCrA) _e.NRGBA {
	_baf := int32(_dda.Y) * 0x10101
	_dccc := int32(_dda.Cb) - 128
	_faag := int32(_dda.Cr) - 128
	_cffa := _baf + 91881*_faag
	if uint32(_cffa)&0xff000000 == 0 {
		_cffa >>= 8
	} else {
		_cffa = ^(_cffa >> 31) & 0xffff
	}
	_dabg := _baf - 22554*_dccc - 46802*_faag
	if uint32(_dabg)&0xff000000 == 0 {
		_dabg >>= 8
	} else {
		_dabg = ^(_dabg >> 31) & 0xffff
	}
	_eab := _baf + 116130*_dccc
	if uint32(_eab)&0xff000000 == 0 {
		_eab >>= 8
	} else {
		_eab = ^(_eab >> 31) & 0xffff
	}
	return _e.NRGBA{R: uint8(_cffa >> 8), G: uint8(_dabg >> 8), B: uint8(_eab >> 8), A: _dda.A}
}

func ScaleAlphaToMonochrome(data []byte, width, height int) ([]byte, error) {
	_ce := BytesPerLine(width, 8, 1)
	if len(data) < _ce*height {
		return nil, nil
	}
	_a := &Gray8{NewImageBase(width, height, 8, 1, data, nil, nil)}
	_ca, _bb := MonochromeConverter.Convert(_a)
	if _bb != nil {
		return nil, _bb
	}
	return _ca.Base().Data, nil
}

type NRGBA64 struct{ ImageBase }

func ImgToGray(i _g.Image) *_g.Gray {
	if _cacg, _acef := i.(*_g.Gray); _acef {
		return _cacg
	}
	_geba := i.Bounds()
	_bddc := _g.NewGray(_geba)
	for _cabae := 0; _cabae < _geba.Max.X; _cabae++ {
		for _fgda := 0; _fgda < _geba.Max.Y; _fgda++ {
			_adcbe := i.At(_cabae, _fgda)
			_bddc.Set(_cabae, _fgda, _adcbe)
		}
	}
	return _bddc
}

func _abe(_dcee *Monochrome, _fcb, _dedad int, _dafg, _fcdbc int, _abaa RasterOperator) {
	var (
		_fbfd        int
		_adcf        byte
		_daef, _gafa int
		_fcfcd       int
	)
	_cbbgc := _dafg >> 3
	_bdaf := _dafg & 7
	if _bdaf > 0 {
		_adcf = _febgc[_bdaf]
	}
	_fbfd = _dcee.BytesPerLine*_dedad + (_fcb >> 3)
	switch _abaa {
	case PixClr:
		for _daef = 0; _daef < _fcdbc; _daef++ {
			_fcfcd = _fbfd + _daef*_dcee.BytesPerLine
			for _gafa = 0; _gafa < _cbbgc; _gafa++ {
				_dcee.Data[_fcfcd] = 0x0
				_fcfcd++
			}
			if _bdaf > 0 {
				_dcee.Data[_fcfcd] = _aaec(_dcee.Data[_fcfcd], 0x0, _adcf)
			}
		}
	case PixSet:
		for _daef = 0; _daef < _fcdbc; _daef++ {
			_fcfcd = _fbfd + _daef*_dcee.BytesPerLine
			for _gafa = 0; _gafa < _cbbgc; _gafa++ {
				_dcee.Data[_fcfcd] = 0xff
				_fcfcd++
			}
			if _bdaf > 0 {
				_dcee.Data[_fcfcd] = _aaec(_dcee.Data[_fcfcd], 0xff, _adcf)
			}
		}
	case PixNotDst:
		for _daef = 0; _daef < _fcdbc; _daef++ {
			_fcfcd = _fbfd + _daef*_dcee.BytesPerLine
			for _gafa = 0; _gafa < _cbbgc; _gafa++ {
				_dcee.Data[_fcfcd] = ^_dcee.Data[_fcfcd]
				_fcfcd++
			}
			if _bdaf > 0 {
				_dcee.Data[_fcfcd] = _aaec(_dcee.Data[_fcfcd], ^_dcee.Data[_fcfcd], _adcf)
			}
		}
	}
}

func _efbf(_fadf NRGBA, _agebg RGBA, _fdce _g.Rectangle) {
	for _ebbc := 0; _ebbc < _fdce.Max.X; _ebbc++ {
		for _ebeg := 0; _ebeg < _fdce.Max.Y; _ebeg++ {
			_eeefd := _fadf.NRGBAAt(_ebbc, _ebeg)
			_agebg.SetRGBA(_ebbc, _ebeg, _fabc(_eeefd))
		}
	}
}

type monochromeThresholdConverter struct{ Threshold uint8 }

func _acfd(_cdaab RGBA, _gecg NRGBA, _ebad _g.Rectangle) {
	for _bffec := 0; _bffec < _ebad.Max.X; _bffec++ {
		for _ddbg := 0; _ddbg < _ebad.Max.Y; _ddbg++ {
			_afbg := _cdaab.RGBAAt(_bffec, _ddbg)
			_gecg.SetNRGBA(_bffec, _ddbg, _bege(_afbg))
		}
	}
}

func (_dgbe *ImageBase) copy() ImageBase {
	_cbdc := *_dgbe
	_cbdc.Data = make([]byte, len(_dgbe.Data))
	copy(_cbdc.Data, _dgbe.Data)
	return _cbdc
}

func _gdee(_fde _e.NRGBA) _e.Gray {
	var _gfga _e.NRGBA
	if _fde == _gfga {
		return _e.Gray{Y: 0xff}
	}
	_baa, _cce, _beef, _ := _fde.RGBA()
	_aac := (19595*_baa + 38470*_cce + 7471*_beef + 1<<15) >> 24
	return _e.Gray{Y: uint8(_aac)}
}

func _eg(_dcg, _gb *Monochrome) (_ge error) {
	_bge := _gb.BytesPerLine
	_cg := _dcg.BytesPerLine
	_dd := _gb.BytesPerLine*4 - _dcg.BytesPerLine
	var (
		_eb, _ffb                             byte
		_af                                   uint32
		_bff, _ffc, _ac, _cb, _dad, _ed, _adb int
	)
	for _ac = 0; _ac < _gb.Height; _ac++ {
		_bff = _ac * _bge
		_ffc = 4 * _ac * _cg
		for _cb = 0; _cb < _bge; _cb++ {
			_eb = _gb.Data[_bff+_cb]
			_af = _dadf[_eb]
			_ed = _ffc + _cb*4
			if _dd != 0 && (_cb+1)*4 > _dcg.BytesPerLine {
				for _dad = _dd; _dad > 0; _dad-- {
					_ffb = byte((_af >> uint(_dad*8)) & 0xff)
					_adb = _ed + (_dd - _dad)
					if _ge = _dcg.setByte(_adb, _ffb); _ge != nil {
						return _ge
					}
				}
			} else if _ge = _dcg.setFourBytes(_ed, _af); _ge != nil {
				return _ge
			}
			if _ge = _dcg.setFourBytes(_ffc+_cb*4, _dadf[_gb.Data[_bff+_cb]]); _ge != nil {
				return _ge
			}
		}
		for _dad = 1; _dad < 4; _dad++ {
			for _cb = 0; _cb < _cg; _cb++ {
				if _ge = _dcg.setByte(_ffc+_dad*_cg+_cb, _dcg.Data[_ffc+_cb]); _ge != nil {
					return _ge
				}
			}
		}
	}
	return nil
}

func _gfeg() {
	for _aaffg := 0; _aaffg < 256; _aaffg++ {
		_dbgf[_aaffg] = uint8(_aaffg&0x1) + (uint8(_aaffg>>1) & 0x1) + (uint8(_aaffg>>2) & 0x1) + (uint8(_aaffg>>3) & 0x1) + (uint8(_aaffg>>4) & 0x1) + (uint8(_aaffg>>5) & 0x1) + (uint8(_aaffg>>6) & 0x1) + (uint8(_aaffg>>7) & 0x1)
	}
}

func _bgc(_bca int) []uint {
	var _bfa []uint
	_fdf := _bca
	_afd := _fdf / 8
	if _afd != 0 {
		for _gcf := 0; _gcf < _afd; _gcf++ {
			_bfa = append(_bfa, 8)
		}
		_ddb := _fdf % 8
		_fdf = 0
		if _ddb != 0 {
			_fdf = _ddb
		}
	}
	_bbb := _fdf / 4
	if _bbb != 0 {
		for _fda := 0; _fda < _bbb; _fda++ {
			_bfa = append(_bfa, 4)
		}
		_efaa := _fdf % 4
		_fdf = 0
		if _efaa != 0 {
			_fdf = _efaa
		}
	}
	_faf := _fdf / 2
	if _faf != 0 {
		for _egd := 0; _egd < _faf; _egd++ {
			_bfa = append(_bfa, 2)
		}
	}
	return _bfa
}

func _gga(_ggec _e.Gray) _e.Gray {
	_defb := _ggec.Y >> 6
	_defb |= _defb << 2
	_ggec.Y = _defb | _defb<<4
	return _ggec
}

func _abb(_cfgd _g.Image, _abbg Image, _aege _g.Rectangle) {
	if _cdgd, _badf := _cfgd.(SMasker); _badf && _cdgd.HasAlpha() {
		_abbg.(SMasker).MakeAlpha()
	}
	_abd(_cfgd, _abbg, _aege)
}

var (
	Gray2Model   = _e.ModelFunc(_fdgc)
	Gray4Model   = _e.ModelFunc(_cfdc)
	NRGBA16Model = _e.ModelFunc(_cbbad)
)

func (_cbbg *Gray16) At(x, y int) _e.Color { _cagd, _ := _cbbg.ColorAt(x, y); return _cagd }

var _ Gray = &Gray8{}

func _ccgd(_dff *_g.Gray, _ecbb uint8) *_g.Gray {
	_dged := _dff.Bounds()
	_gdcd := _g.NewGray(_dged)
	for _ecgc := 0; _ecgc < _dged.Dx(); _ecgc++ {
		for _gefa := 0; _gefa < _dged.Dy(); _gefa++ {
			_ffeb := _dff.GrayAt(_ecgc, _gefa)
			_gdcd.SetGray(_ecgc, _gefa, _e.Gray{Y: _dccg(_ffeb.Y, _ecbb)})
		}
	}
	return _gdcd
}

func _fb(_ga, _caf *Monochrome) (_gc error) {
	_de := _caf.BytesPerLine
	_cc := _ga.BytesPerLine
	var _gec, _cgg, _be, _dag, _ea int
	for _be = 0; _be < _caf.Height; _be++ {
		_gec = _be * _de
		_cgg = 8 * _be * _cc
		for _dag = 0; _dag < _de; _dag++ {
			if _gc = _ga.setEightBytes(_cgg+_dag*8, _cbd[_caf.Data[_gec+_dag]]); _gc != nil {
				return _gc
			}
		}
		for _ea = 1; _ea < 8; _ea++ {
			for _dag = 0; _dag < _cc; _dag++ {
				if _gc = _ga.setByte(_cgg+_ea*_cc+_dag, _ga.Data[_cgg+_dag]); _gc != nil {
					return _gc
				}
			}
		}
	}
	return nil
}

func (_fbg *Monochrome) Copy() Image {
	return &Monochrome{ImageBase: _fbg.ImageBase.copy(), ModelThreshold: _fbg.ModelThreshold}
}

func (_gebb *RGBA32) Validate() error {
	if len(_gebb.Data) != 3*_gebb.Width*_gebb.Height {
		return _fc.New("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073")
	}
	return nil
}

var _ Image = &Gray8{}

func (_fgef *Gray8) At(x, y int) _e.Color { _dfc, _ := _fgef.ColorAt(x, y); return _dfc }

func (_ggfa *NRGBA64) At(x, y int) _e.Color { _ebcb, _ := _ggfa.ColorAt(x, y); return _ebcb }

func ColorAt(x, y, width, bitsPerColor, colorComponents, bytesPerLine int, data, alpha []byte, decode []float64) (_e.Color, error) {
	switch colorComponents {
	case 1:
		return ColorAtGrayscale(x, y, bitsPerColor, bytesPerLine, data, decode)
	case 3:
		return ColorAtNRGBA(x, y, width, bytesPerLine, bitsPerColor, data, alpha, decode)
	case 4:
		return ColorAtCMYK(x, y, width, data, decode)
	default:
		return nil, _c.Errorf("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064", colorComponents)
	}
}

func _bfaac(_fcbb *Monochrome, _deab, _bdffb int, _ecfff, _cacf int, _ceefa RasterOperator) {
	var (
		_dcce  bool
		_dbac  bool
		_efb   int
		_dfbc  int
		_adeb  int
		_dacf  int
		_fcdfa bool
		_aaed  byte
	)
	_fcbf := 8 - (_deab & 7)
	_dcge := _dbcf[_fcbf]
	_dfe := _fcbb.BytesPerLine*_bdffb + (_deab >> 3)
	if _ecfff < _fcbf {
		_dcce = true
		_dcge &= _febgc[8-_fcbf+_ecfff]
	}
	if !_dcce {
		_efb = (_ecfff - _fcbf) >> 3
		if _efb != 0 {
			_dbac = true
			_dfbc = _dfe + 1
		}
	}
	_adeb = (_deab + _ecfff) & 7
	if !(_dcce || _adeb == 0) {
		_fcdfa = true
		_aaed = _febgc[_adeb]
		_dacf = _dfe + 1 + _efb
	}
	var _bgcc, _bcde int
	switch _ceefa {
	case PixClr:
		for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
			_fcbb.Data[_dfe] = _aaec(_fcbb.Data[_dfe], 0x0, _dcge)
			_dfe += _fcbb.BytesPerLine
		}
		if _dbac {
			for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
				for _bcde = 0; _bcde < _efb; _bcde++ {
					_fcbb.Data[_dfbc+_bcde] = 0x0
				}
				_dfbc += _fcbb.BytesPerLine
			}
		}
		if _fcdfa {
			for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
				_fcbb.Data[_dacf] = _aaec(_fcbb.Data[_dacf], 0x0, _aaed)
				_dacf += _fcbb.BytesPerLine
			}
		}
	case PixSet:
		for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
			_fcbb.Data[_dfe] = _aaec(_fcbb.Data[_dfe], 0xff, _dcge)
			_dfe += _fcbb.BytesPerLine
		}
		if _dbac {
			for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
				for _bcde = 0; _bcde < _efb; _bcde++ {
					_fcbb.Data[_dfbc+_bcde] = 0xff
				}
				_dfbc += _fcbb.BytesPerLine
			}
		}
		if _fcdfa {
			for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
				_fcbb.Data[_dacf] = _aaec(_fcbb.Data[_dacf], 0xff, _aaed)
				_dacf += _fcbb.BytesPerLine
			}
		}
	case PixNotDst:
		for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
			_fcbb.Data[_dfe] = _aaec(_fcbb.Data[_dfe], ^_fcbb.Data[_dfe], _dcge)
			_dfe += _fcbb.BytesPerLine
		}
		if _dbac {
			for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
				for _bcde = 0; _bcde < _efb; _bcde++ {
					_fcbb.Data[_dfbc+_bcde] = ^(_fcbb.Data[_dfbc+_bcde])
				}
				_dfbc += _fcbb.BytesPerLine
			}
		}
		if _fcdfa {
			for _bgcc = 0; _bgcc < _cacf; _bgcc++ {
				_fcbb.Data[_dacf] = _aaec(_fcbb.Data[_dacf], ^_fcbb.Data[_dacf], _aaed)
				_dacf += _fcbb.BytesPerLine
			}
		}
	}
}

func (_gdeg *Gray16) SetGray(x, y int, g _e.Gray) {
	_cagcc := (y*_gdeg.BytesPerLine/2 + x) * 2
	if _cagcc+1 >= len(_gdeg.Data) {
		return
	}
	_gdeg.Data[_cagcc] = g.Y
	_gdeg.Data[_cagcc+1] = g.Y
}

func _abd(_ebd _g.Image, _aef Image, _edf _g.Rectangle) {
	for _bfgf := 0; _bfgf < _edf.Max.X; _bfgf++ {
		for _ebe := 0; _ebe < _edf.Max.Y; _ebe++ {
			_cgdg := _ebd.At(_bfgf, _ebe)
			_aef.Set(_bfgf, _ebe, _cgdg)
		}
	}
}

func (_dedc *Monochrome) Scale(scale float64) (*Monochrome, error) {
	var _faef bool
	_fccf := scale
	if scale < 1 {
		_fccf = 1 / scale
		_faef = true
	}
	_fbc := NextPowerOf2(uint(_fccf))
	if InDelta(float64(_fbc), _fccf, 0.001) {
		if _faef {
			return _dedc.ReduceBinary(_fccf)
		}
		return _dedc.ExpandBinary(int(_fbc))
	}
	_fea := int(_b.RoundToEven(float64(_dedc.Width) * scale))
	_aefc := int(_b.RoundToEven(float64(_dedc.Height) * scale))
	return _dedc.ScaleLow(_fea, _aefc)
}

func (_fcdca *Monochrome) GrayAt(x, y int) _e.Gray {
	_bffa, _ := ColorAtGray1BPC(x, y, _fcdca.BytesPerLine, _fcdca.Data, _fcdca.Decode)
	return _bffa
}

func (_fdgf *Gray8) Set(x, y int, c _e.Color) {
	_adfa := y*_fdgf.BytesPerLine + x
	if _adfa > len(_fdgf.Data)-1 {
		return
	}
	_gaca := _e.GrayModel.Convert(c)
	_fdgf.Data[_adfa] = _gaca.(_e.Gray).Y
}

func BytesPerLine(width, bitsPerComponent, colorComponents int) int {
	return ((width*bitsPerComponent)*colorComponents + 7) >> 3
}

type Gray16 struct{ ImageBase }

func (_bdbd *Gray8) Validate() error {
	if len(_bdbd.Data) != _bdbd.Height*_bdbd.BytesPerLine {
		return ErrInvalidImage
	}
	return nil
}

func ColorAtRGBA32(x, y, width int, data, alpha []byte, decode []float64) (_e.RGBA, error) {
	_cefd := y*width + x
	_gebe := 3 * _cefd
	if _gebe+2 >= len(data) {
		return _e.RGBA{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_gcgc := uint8(0xff)
	if alpha != nil && len(alpha) > _cefd {
		_gcgc = alpha[_cefd]
	}
	_cccd, _ccga, _gbcbc := data[_gebe], data[_gebe+1], data[_gebe+2]
	if len(decode) == 6 {
		_cccd = uint8(uint32(LinearInterpolate(float64(_cccd), 0, 255, decode[0], decode[1])) & 0xff)
		_ccga = uint8(uint32(LinearInterpolate(float64(_ccga), 0, 255, decode[2], decode[3])) & 0xff)
		_gbcbc = uint8(uint32(LinearInterpolate(float64(_gbcbc), 0, 255, decode[4], decode[5])) & 0xff)
	}
	return _e.RGBA{R: _cccd, G: _ccga, B: _gbcbc, A: _gcgc}, nil
}

func _gadf(_gdaf _e.NRGBA) _e.Gray {
	_beec, _cea, _aed, _ := _gdaf.RGBA()
	_aefg := (19595*_beec + 38470*_cea + 7471*_aed + 1<<15) >> 24
	return _e.Gray{Y: uint8(_aefg)}
}

func (_cfea *Gray4) At(x, y int) _e.Color {
	_ebfg, _ := _cfea.ColorAt(x, y)
	return _ebfg
}

type shift int

func _bdcc(_bcfe _g.Image) (Image, error) {
	if _dddc, _effgc := _bcfe.(*NRGBA32); _effgc {
		return _dddc.Copy(), nil
	}
	_acbe, _cdea, _cegb := _aagf(_bcfe, 1)
	_dbdb, _eead := NewImage(_acbe.Max.X, _acbe.Max.Y, 8, 3, nil, _cegb, nil)
	if _eead != nil {
		return nil, _eead
	}
	_ffee(_bcfe, _dbdb, _acbe)
	if len(_cegb) != 0 && !_cdea {
		if _gdcf := _bede(_cegb, _dbdb); _gdcf != nil {
			return nil, _gdcf
		}
	}
	return _dbdb, nil
}

func MonochromeModel(threshold uint8) _e.Model { return monochromeModel(threshold) }

func _dgb(_ffdf _e.CMYK) _e.RGBA {
	_fcda, _dee, _adc := _e.CMYKToRGB(_ffdf.C, _ffdf.M, _ffdf.Y, _ffdf.K)
	return _e.RGBA{R: _fcda, G: _dee, B: _adc, A: 0xff}
}

func _geddf(_gaff _e.NRGBA64) _e.Gray {
	var _fdca _e.NRGBA64
	if _gaff == _fdca {
		return _e.Gray{Y: 0xff}
	}
	_bfbe, _dab, _fadg, _ := _gaff.RGBA()
	_eaga := (19595*_bfbe + 38470*_dab + 7471*_fadg + 1<<15) >> 24
	return _e.Gray{Y: uint8(_eaga)}
}

func (_fade *NRGBA16) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtNRGBA16(x, y, _fade.Width, _fade.BytesPerLine, _fade.Data, _fade.Alpha, _fade.Decode)
}

var _ Gray = &Gray2{}

type colorConverter struct {
	_feb func(_fcca _g.Image) (Image, error)
}

type RGBA32 struct{ ImageBase }

func _gace(_faff *_g.NYCbCrA, _gdaa RGBA, _cgdb _g.Rectangle) {
	for _dbdba := 0; _dbdba < _cgdb.Max.X; _dbdba++ {
		for _cfgda := 0; _cfgda < _cgdb.Max.Y; _cfgda++ {
			_bebbd := _faff.NYCbCrAAt(_dbdba, _cfgda)
			_gdaa.SetRGBA(_dbdba, _cfgda, _dbe(_bebbd))
		}
	}
}

func (_bbcf *Gray4) setGray(_gebf int, _fgeb int, _dacd _e.Gray) {
	_dcga := _fgeb * _bbcf.BytesPerLine
	_egdag := _dcga + (_gebf >> 1)
	if _egdag >= len(_bbcf.Data) {
		return
	}
	_fddg := _dacd.Y >> 4
	_bbcf.Data[_egdag] = (_bbcf.Data[_egdag] & (^(0xf0 >> uint(4*(_gebf&1))))) | (_fddg << uint(4-4*(_gebf&1)))
}

var _ _g.Image = &Gray4{}

func (_fcdf *ImageBase) setFourBytes(_gfac int, _dea uint32) error {
	if _gfac+3 > len(_fcdf.Data)-1 {
		return _c.Errorf("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065", _gfac)
	}
	_fcdf.Data[_gfac] = byte((_dea & 0xff000000) >> 24)
	_fcdf.Data[_gfac+1] = byte((_dea & 0xff0000) >> 16)
	_fcdf.Data[_gfac+2] = byte((_dea & 0xff00) >> 8)
	_fcdf.Data[_gfac+3] = byte(_dea & 0xff)
	return nil
}

func _abcd(_bcbc _g.Image) (Image, error) {
	if _cede, _bea := _bcbc.(*Gray4); _bea {
		return _cede.Copy(), nil
	}
	_fcgd := _bcbc.Bounds()
	_dbec, _beefa := NewImage(_fcgd.Max.X, _fcgd.Max.Y, 4, 1, nil, nil, nil)
	if _beefa != nil {
		return nil, _beefa
	}
	_ccda(_bcbc, _dbec, _fcgd)
	return _dbec, nil
}

func _dcfb(_cdgg _e.NRGBA) _e.NRGBA {
	_cdgg.R = _cdgg.R>>4 | (_cdgg.R>>4)<<4
	_cdgg.G = _cdgg.G>>4 | (_cdgg.G>>4)<<4
	_cdgg.B = _cdgg.B>>4 | (_cdgg.B>>4)<<4
	return _cdgg
}

func (_affd *Monochrome) Validate() error {
	if len(_affd.Data) != _affd.Height*_affd.BytesPerLine {
		return ErrInvalidImage
	}
	return nil
}

type NRGBA interface {
	NRGBAAt(_faga, _geafa int) _e.NRGBA
	SetNRGBA(_eaff, _ageag int, _afgf _e.NRGBA)
}

func (_cffac *Gray8) Histogram() (_ddba [256]int) {
	for _gaeb := 0; _gaeb < len(_cffac.Data); _gaeb++ {
		_ddba[_cffac.Data[_gaeb]]++
	}
	return _ddba
}

func _ccda(_bfge _g.Image, _ffag Image, _cada _g.Rectangle) {
	switch _gef := _bfge.(type) {
	case Gray:
		_adbf(_gef, _ffag.(Gray), _cada)
	case NRGBA:
		_dgee(_gef, _ffag.(Gray), _cada)
	case CMYK:
		_cbga(_gef, _ffag.(Gray), _cada)
	case RGBA:
		_ebag(_gef, _ffag.(Gray), _cada)
	default:
		_abd(_bfge, _ffag, _cada)
	}
}

func (_bbca *NRGBA16) Validate() error {
	if len(_bbca.Data) != 3*_bbca.Width*_bbca.Height/2 {
		return _fc.New("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073")
	}
	return nil
}

func (_cbda *Monochrome) Set(x, y int, c _e.Color) {
	_geaf := y*_cbda.BytesPerLine + x>>3
	if _geaf > len(_cbda.Data)-1 {
		return
	}
	_cafe := _cbda.ColorModel().Convert(c).(_e.Gray)
	_cbda.setGray(x, _cafe, _geaf)
}

func _geg(_ecg, _ddcb *Monochrome, _ddbc []byte, _fae int) (_ddf error) {
	var (
		_acf, _bgf, _cbde, _afg, _abfb, _eff, _ece, _ege int
		_faa, _ffbb                                      uint32
		_fed, _fff                                       byte
		_acg                                             uint16
	)
	_gde := make([]byte, 4)
	_cff := make([]byte, 4)
	for _cbde = 0; _cbde < _ecg.Height-1; _cbde, _afg = _cbde+2, _afg+1 {
		_acf = _cbde * _ecg.BytesPerLine
		_bgf = _afg * _ddcb.BytesPerLine
		for _abfb, _eff = 0, 0; _abfb < _fae; _abfb, _eff = _abfb+4, _eff+1 {
			for _ece = 0; _ece < 4; _ece++ {
				_ege = _acf + _abfb + _ece
				if _ege <= len(_ecg.Data)-1 && _ege < _acf+_ecg.BytesPerLine {
					_gde[_ece] = _ecg.Data[_ege]
				} else {
					_gde[_ece] = 0x00
				}
				_ege = _acf + _ecg.BytesPerLine + _abfb + _ece
				if _ege <= len(_ecg.Data)-1 && _ege < _acf+(2*_ecg.BytesPerLine) {
					_cff[_ece] = _ecg.Data[_ege]
				} else {
					_cff[_ece] = 0x00
				}
			}
			_faa = _d.BigEndian.Uint32(_gde)
			_ffbb = _d.BigEndian.Uint32(_cff)
			_ffbb |= _faa
			_ffbb |= _ffbb << 1
			_ffbb &= 0xaaaaaaaa
			_faa = _ffbb | (_ffbb << 7)
			_fed = byte(_faa >> 24)
			_fff = byte((_faa >> 8) & 0xff)
			_ege = _bgf + _eff
			if _ege+1 == len(_ddcb.Data)-1 || _ege+1 >= _bgf+_ddcb.BytesPerLine {
				_ddcb.Data[_ege] = _ddbc[_fed]
			} else {
				_acg = (uint16(_ddbc[_fed]) << 8) | uint16(_ddbc[_fff])
				if _ddf = _ddcb.setTwoBytes(_ege, _acg); _ddf != nil {
					return _c.Errorf("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064", _ege)
				}
				_eff++
			}
		}
	}
	return nil
}

func (_ageac *monochromeThresholdConverter) Convert(img _g.Image) (Image, error) {
	if _cbge, _fcgb := img.(*Monochrome); _fcgb {
		return _cbge.Copy(), nil
	}
	_bdff := img.Bounds()
	_ceab, _gafg := NewImage(_bdff.Max.X, _bdff.Max.Y, 1, 1, nil, nil, nil)
	if _gafg != nil {
		return nil, _gafg
	}
	_ceab.(*Monochrome).ModelThreshold = _ageac.Threshold
	for _cfag := 0; _cfag < _bdff.Max.X; _cfag++ {
		for _eeea := 0; _eeea < _bdff.Max.Y; _eeea++ {
			_aaf := img.At(_cfag, _eeea)
			_ceab.Set(_cfag, _eeea, _aaf)
		}
	}
	return _ceab, nil
}

func ColorAtGray16BPC(x, y, bytesPerLine int, data []byte, decode []float64) (_e.Gray16, error) {
	_deg := (y*bytesPerLine/2 + x) * 2
	if _deg+1 >= len(data) {
		return _e.Gray16{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_dadfe := uint16(data[_deg])<<8 | uint16(data[_deg+1])
	if len(decode) == 2 {
		_dadfe = uint16(uint64(LinearInterpolate(float64(_dadfe), 0, 65535, decode[0], decode[1])))
	}
	return _e.Gray16{Y: _dadfe}, nil
}

func (_acfc *NRGBA32) At(x, y int) _e.Color {
	_gaegf, _ := _acfc.ColorAt(x, y)
	return _gaegf
}

func (_eed *NRGBA32) NRGBAAt(x, y int) _e.NRGBA {
	_bega, _ := ColorAtNRGBA32(x, y, _eed.Width, _eed.Data, _eed.Alpha, _eed.Decode)
	return _bega
}

func _fa(_ee *Monochrome, _dc int) (*Monochrome, error) {
	if _ee == nil {
		return nil, _fc.New("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064")
	}
	if _dc == 1 {
		return _ee.copy(), nil
	}
	if !IsPowerOf2(uint(_dc)) {
		return nil, _c.Errorf("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064", _dc)
	}
	_fg := _bgc(_dc)
	return _gg(_ee, _dc, _fg)
}

func (_ddfg *ImageBase) MakeAlpha() { _ddfg.newAlpha() }

func _da(_fd, _ad *Monochrome) (_eec error) {
	_fge := _ad.BytesPerLine
	_dae := _fd.BytesPerLine
	var (
		_ba                         byte
		_df                         uint16
		_ag, _fga, _cfb, _cfe, _bbg int
	)
	for _cfb = 0; _cfb < _ad.Height; _cfb++ {
		_ag = _cfb * _fge
		_fga = 2 * _cfb * _dae
		for _cfe = 0; _cfe < _fge; _cfe++ {
			_ba = _ad.Data[_ag+_cfe]
			_df = _ebba[_ba]
			_bbg = _fga + _cfe*2
			if _fd.BytesPerLine != _ad.BytesPerLine*2 && (_cfe+1)*2 > _fd.BytesPerLine {
				_eec = _fd.setByte(_bbg, byte(_df>>8))
			} else {
				_eec = _fd.setTwoBytes(_bbg, _df)
			}
			if _eec != nil {
				return _eec
			}
		}
		for _cfe = 0; _cfe < _dae; _cfe++ {
			_bbg = _fga + _dae + _cfe
			_ba = _fd.Data[_fga+_cfe]
			if _eec = _fd.setByte(_bbg, _ba); _eec != nil {
				return _eec
			}
		}
	}
	return nil
}

var _ Image = &Gray2{}

type Image interface {
	_bg.Image
	Base() *ImageBase
	Copy() Image
	Pix() []byte
	ColorAt(_cbba, _baebc int) (_e.Color, error)
	Validate() error
}

func (_ggba *Gray16) Histogram() (_eagd [256]int) {
	for _fedd := 0; _fedd < _ggba.Width; _fedd++ {
		for _fdbe := 0; _fdbe < _ggba.Height; _fdbe++ {
			_eagd[_ggba.GrayAt(_fedd, _fdbe).Y]++
		}
	}
	return _eagd
}

func (_fdaae *RGBA32) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtRGBA32(x, y, _fdaae.Width, _fdaae.Data, _fdaae.Alpha, _fdaae.Decode)
}

func (_acged *Gray2) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _acged.Width, Y: _acged.Height}}
}

func (_eeec *ImageBase) Pix() []byte { return _eeec.Data }

func (_fdfca *NRGBA32) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtNRGBA32(x, y, _fdfca.Width, _fdfca.Data, _fdfca.Alpha, _fdfca.Decode)
}

func (_gag *Monochrome) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtGray1BPC(x, y, _gag.BytesPerLine, _gag.Data, _gag.Decode)
}

func (_aebb *Gray4) Base() *ImageBase { return &_aebb.ImageBase }

var _ _g.Image = &Gray16{}

func (_acbf *NRGBA64) Copy() Image { return &NRGBA64{ImageBase: _acbf.copy()} }

func (_ggeb *RGBA32) ColorModel() _e.Model { return _e.NRGBAModel }

func (_cdgb *RGBA32) At(x, y int) _e.Color {
	_decb, _ := _cdgb.ColorAt(x, y)
	return _decb
}

func (_defbc *NRGBA64) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtNRGBA64(x, y, _defbc.Width, _defbc.Data, _defbc.Alpha, _defbc.Decode)
}

const (
	PixSrc             RasterOperator = 0xc
	PixDst             RasterOperator = 0xa
	PixNotSrc          RasterOperator = 0x3
	PixNotDst          RasterOperator = 0x5
	PixClr             RasterOperator = 0x0
	PixSet             RasterOperator = 0xf
	PixSrcOrDst        RasterOperator = 0xe
	PixSrcAndDst       RasterOperator = 0x8
	PixSrcXorDst       RasterOperator = 0x6
	PixNotSrcOrDst     RasterOperator = 0xb
	PixNotSrcAndDst    RasterOperator = 0x2
	PixSrcOrNotDst     RasterOperator = 0xd
	PixSrcAndNotDst    RasterOperator = 0x4
	PixNotPixSrcOrDst  RasterOperator = 0x1
	PixNotPixSrcAndDst RasterOperator = 0x7
	PixNotPixSrcXorDst RasterOperator = 0x9
	PixPaint                          = PixSrcOrDst
	PixSubtract                       = PixNotSrcAndDst
	PixMask                           = PixSrcAndDst
)

func (_ebc *NRGBA32) Validate() error {
	if len(_ebc.Data) != 3*_ebc.Width*_ebc.Height {
		return _fc.New("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073")
	}
	return nil
}

var _ _g.Image = &Gray2{}

var _ NRGBA = &NRGBA32{}

type NRGBA32 struct{ ImageBase }

func (_aegc *NRGBA32) Copy() Image { return &NRGBA32{ImageBase: _aegc.copy()} }

func (_gagf *NRGBA64) Set(x, y int, c _e.Color) {
	_bddg := (y*_gagf.Width + x) * 2
	_dbb := _bddg * 3
	if _dbb+5 >= len(_gagf.Data) {
		return
	}
	_ecfe := _e.NRGBA64Model.Convert(c).(_e.NRGBA64)
	_gagf.setNRGBA64(_dbb, _ecfe, _bddg)
}

func _fdbf(_fdfe _e.CMYK) _e.Gray {
	_bfdg, _ggg, _cfbeb := _e.CMYKToRGB(_fdfe.C, _fdfe.M, _fdfe.Y, _fdfe.K)
	_daad := (19595*uint32(_bfdg) + 38470*uint32(_ggg) + 7471*uint32(_cfbeb) + 1<<7) >> 16
	return _e.Gray{Y: uint8(_daad)}
}

func GrayHistogram(g Gray) (_bcgea [256]int) {
	switch _fafd := g.(type) {
	case Histogramer:
		return _fafd.Histogram()
	case _g.Image:
		_geaa := _fafd.Bounds()
		for _gbbb := 0; _gbbb < _geaa.Max.X; _gbbb++ {
			for _bcbdc := 0; _bcbdc < _geaa.Max.Y; _bcbdc++ {
				_bcgea[g.GrayAt(_gbbb, _bcbdc).Y]++
			}
		}
		return _bcgea
	default:
		return [256]int{}
	}
}

func AutoThresholdTriangle(histogram [256]int) uint8 {
	var _dedgf, _dbdc, _dgfd, _bgga int
	for _fdba := 0; _fdba < len(histogram); _fdba++ {
		if histogram[_fdba] > 0 {
			_dedgf = _fdba
			break
		}
	}
	if _dedgf > 0 {
		_dedgf--
	}
	for _dgefe := 255; _dgefe > 0; _dgefe-- {
		if histogram[_dgefe] > 0 {
			_bgga = _dgefe
			break
		}
	}
	if _bgga < 255 {
		_bgga++
	}
	for _ffdd := 0; _ffdd < 256; _ffdd++ {
		if histogram[_ffdd] > _dbdc {
			_dgfd = _ffdd
			_dbdc = histogram[_ffdd]
		}
	}
	var _aadb bool
	if (_dgfd - _dedgf) < (_bgga - _dgfd) {
		_aadb = true
		var _acaf int
		_dfgf := 255
		for _acaf < _dfgf {
			_eedd := histogram[_acaf]
			histogram[_acaf] = histogram[_dfgf]
			histogram[_dfgf] = _eedd
			_acaf++
			_dfgf--
		}
		_dedgf = 255 - _bgga
		_dgfd = 255 - _dgfd
	}
	if _dedgf == _dgfd {
		return uint8(_dedgf)
	}
	_begeg := float64(histogram[_dgfd])
	_dgbf := float64(_dedgf - _dgfd)
	_eefd := _b.Sqrt(_begeg*_begeg + _dgbf*_dgbf)
	_begeg /= _eefd
	_dgbf /= _eefd
	_eefd = _begeg*float64(_dedgf) + _dgbf*float64(histogram[_dedgf])
	_bdda := _dedgf
	var _ebdb float64
	for _bfeg := _dedgf + 1; _bfeg <= _dgfd; _bfeg++ {
		_gbeg := _begeg*float64(_bfeg) + _dgbf*float64(histogram[_bfeg]) - _eefd
		if _gbeg > _ebdb {
			_bdda = _bfeg
			_ebdb = _gbeg
		}
	}
	_bdda--
	if _aadb {
		var _edcef int
		_cddg := 255
		for _edcef < _cddg {
			_aafe := histogram[_edcef]
			histogram[_edcef] = histogram[_cddg]
			histogram[_cddg] = _aafe
			_edcef++
			_cddg--
		}
		return uint8(255 - _bdda)
	}
	return uint8(_bdda)
}

func (_ceed *NRGBA64) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _ceed.Width, Y: _ceed.Height}}
}

func (_ggca *Gray16) ColorModel() _e.Model { return _e.Gray16Model }

func (_bbdf *Monochrome) RasterOperation(dx, dy, dw, dh int, op RasterOperator, src *Monochrome, sx, sy int) error {
	return _ffgc(_bbdf, dx, dy, dw, dh, op, src, sx, sy)
}

func _gaa(_bcf Gray, _ceb CMYK, _bgg _g.Rectangle) {
	for _ecff := 0; _ecff < _bgg.Max.X; _ecff++ {
		for _cgc := 0; _cgc < _bgg.Max.Y; _cgc++ {
			_gea := _bcf.GrayAt(_ecff, _cgc)
			_ceb.SetCMYK(_ecff, _cgc, _facg(_gea))
		}
	}
}

func _dgee(_ccbfg NRGBA, _cdgf Gray, _fadd _g.Rectangle) {
	for _ddcf := 0; _ddcf < _fadd.Max.X; _ddcf++ {
		for _cfdb := 0; _cfdb < _fadd.Max.Y; _cfdb++ {
			_baeb := _gadf(_ccbfg.NRGBAAt(_ddcf, _cfdb))
			_cdgf.SetGray(_ddcf, _cfdb, _baeb)
		}
	}
}

type ImageBase struct {
	Width, Height                     int
	BitsPerComponent, ColorComponents int
	Data, Alpha                       []byte
	Decode                            []float64
	BytesPerLine                      int
}

func _bae(_ab *Monochrome, _gda ...int) (_dde *Monochrome, _cgb error) {
	if _ab == nil {
		return nil, _fc.New("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
	}
	if len(_gda) == 0 {
		return nil, _fc.New("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e")
	}
	_bfb := _fbfc()
	_dde = _ab
	for _, _ddc := range _gda {
		if _ddc <= 0 {
			break
		}
		_dde, _cgb = _cbg(_dde, _ddc, _bfb)
		if _cgb != nil {
			return nil, _cgb
		}
	}
	return _dde, nil
}

func (_fabg *Gray8) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _fabg.Width, Y: _fabg.Height}}
}

func (_cbae *Monochrome) Histogram() (_cefg [256]int) {
	for _, _fagg := range _cbae.Data {
		_cefg[0xff] += int(_dbgf[_cbae.Data[_fagg]])
	}
	return _cefg
}

func (_bgb *Monochrome) setBit(_efaca, _acb int) {
	_bgb.Data[_efaca+(_acb>>3)] |= 0x80 >> uint(_acb&7)
}

func (_egf *CMYK32) ColorModel() _e.Model { return _e.CMYKModel }

func ColorAtNRGBA64(x, y, width int, data, alpha []byte, decode []float64) (_e.NRGBA64, error) {
	_gceb := (y*width + x) * 2
	_gcedf := _gceb * 3
	if _gcedf+5 >= len(data) {
		return _e.NRGBA64{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	const _dgefg = 0xffff
	_bffg := uint16(_dgefg)
	if alpha != nil && len(alpha) > _gceb+1 {
		_bffg = uint16(alpha[_gceb])<<8 | uint16(alpha[_gceb+1])
	}
	_cacc := uint16(data[_gcedf])<<8 | uint16(data[_gcedf+1])
	_fcdfe := uint16(data[_gcedf+2])<<8 | uint16(data[_gcedf+3])
	_dgbd := uint16(data[_gcedf+4])<<8 | uint16(data[_gcedf+5])
	if len(decode) == 6 {
		_cacc = uint16(uint64(LinearInterpolate(float64(_cacc), 0, 65535, decode[0], decode[1])) & _dgefg)
		_fcdfe = uint16(uint64(LinearInterpolate(float64(_fcdfe), 0, 65535, decode[2], decode[3])) & _dgefg)
		_dgbd = uint16(uint64(LinearInterpolate(float64(_dgbd), 0, 65535, decode[4], decode[5])) & _dgefg)
	}
	return _e.NRGBA64{R: _cacc, G: _fcdfe, B: _dgbd, A: _bffg}, nil
}

func (_fagd *CMYK32) CMYKAt(x, y int) _e.CMYK {
	_bcac, _ := ColorAtCMYK(x, y, _fagd.Width, _fagd.Data, _fagd.Decode)
	return _bcac
}

func ColorAtGray4BPC(x, y, bytesPerLine int, data []byte, decode []float64) (_e.Gray, error) {
	_edaa := y*bytesPerLine + x>>1
	if _edaa >= len(data) {
		return _e.Gray{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_fbfa := data[_edaa] >> uint(4-(x&1)*4) & 0xf
	if len(decode) == 2 {
		_fbfa = uint8(uint32(LinearInterpolate(float64(_fbfa), 0, 15, decode[0], decode[1])) & 0xf)
	}
	return _e.Gray{Y: _fbfa * 17 & 0xff}, nil
}

func ColorAtGrayscale(x, y, bitsPerColor, bytesPerLine int, data []byte, decode []float64) (_e.Color, error) {
	switch bitsPerColor {
	case 1:
		return ColorAtGray1BPC(x, y, bytesPerLine, data, decode)
	case 2:
		return ColorAtGray2BPC(x, y, bytesPerLine, data, decode)
	case 4:
		return ColorAtGray4BPC(x, y, bytesPerLine, data, decode)
	case 8:
		return ColorAtGray8BPC(x, y, bytesPerLine, data, decode)
	case 16:
		return ColorAtGray16BPC(x, y, bytesPerLine, data, decode)
	default:
		return nil, _c.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027", bitsPerColor)
	}
}

func _dbe(_faac _e.NYCbCrA) _e.RGBA {
	_agea, _ddbce, _cffe, _dfa := _bbbd(_faac).RGBA()
	return _e.RGBA{R: uint8(_agea >> 8), G: uint8(_ddbce >> 8), B: uint8(_cffe >> 8), A: uint8(_dfa >> 8)}
}

func _gac(_beeg _e.RGBA) _e.Gray {
	_bdfg := (19595*uint32(_beeg.R) + 38470*uint32(_beeg.G) + 7471*uint32(_beeg.B) + 1<<7) >> 16
	return _e.Gray{Y: uint8(_bdfg)}
}

func _adbf(_dbga, _cbbc Gray, _dacb _g.Rectangle) {
	for _gfb := 0; _gfb < _dacb.Max.X; _gfb++ {
		for _egcg := 0; _egcg < _dacb.Max.Y; _egcg++ {
			_cbbc.SetGray(_gfb, _egcg, _dbga.GrayAt(_gfb, _egcg))
		}
	}
}

func _badd(_cdf int, _effe int) int {
	if _cdf < _effe {
		return _cdf
	}
	return _effe
}

const (
	_fcgbf shift = iota
	_aefb
)

func (_egfb *CMYK32) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _egfb.Width, Y: _egfb.Height}}
}

func _ccagc(_dddd _g.Image, _fcba Image, _abce _g.Rectangle) {
	if _fbaf, _cedfb := _dddd.(SMasker); _cedfb && _fbaf.HasAlpha() {
		_fcba.(SMasker).MakeAlpha()
	}
	switch _dccf := _dddd.(type) {
	case Gray:
		_daefd(_dccf, _fcba.(RGBA), _abce)
	case NRGBA:
		_efbf(_dccf, _fcba.(RGBA), _abce)
	case *_g.NYCbCrA:
		_gace(_dccf, _fcba.(RGBA), _abce)
	case CMYK:
		_fcdgc(_dccf, _fcba.(RGBA), _abce)
	case RGBA:
		_cfage(_dccf, _fcba.(RGBA), _abce)
	case nrgba64:
		_gagd(_dccf, _fcba.(RGBA), _abce)
	default:
		_abd(_dddd, _fcba, _abce)
	}
}

func (_bbae *Gray16) GrayAt(x, y int) _e.Gray {
	_aee, _ := _bbae.ColorAt(x, y)
	return _e.Gray{Y: uint8(_aee.(_e.Gray16).Y >> 8)}
}

func (_dbf *Gray2) Copy() Image { return &Gray2{ImageBase: _dbf.copy()} }

func ColorAtNRGBA32(x, y, width int, data, alpha []byte, decode []float64) (_e.NRGBA, error) {
	_cfbb := y*width + x
	_gbdfa := 3 * _cfbb
	if _gbdfa+2 >= len(data) {
		return _e.NRGBA{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_cgae := uint8(0xff)
	if alpha != nil && len(alpha) > _cfbb {
		_cgae = alpha[_cfbb]
	}
	_agd, _dgdg, _gcg := data[_gbdfa], data[_gbdfa+1], data[_gbdfa+2]
	if len(decode) == 6 {
		_efgg := LinearInterpolate(float64(_agd), 0, 255.0, decode[0], decode[1])
		_ebgf := LinearInterpolate(float64(_dgdg), 0, 255.0, decode[2], decode[3])
		_bgec := LinearInterpolate(float64(_gcg), 0, 255.0, decode[4], decode[5])
		if _efgg <= 1.0 && _ebgf <= 1.0 && _bgec <= 1.0 {
			_efgg *= 255.0
			_ebgf *= 255.0
			_bgec *= 255.0
		}
		_agd = uint8(_efgg) & 0xff
		_dgdg = uint8(_ebgf) & 0xff
		_gcg = uint8(_bgec) & 0xff
	}
	return _e.NRGBA{R: _agd, G: _dgdg, B: _gcg, A: _cgae}, nil
}

var _ Gray = &Gray4{}

func IsPowerOf2(n uint) bool { return n > 0 && (n&(n-1)) == 0 }

var _ _g.Image = &NRGBA32{}

func NextPowerOf2(n uint) uint {
	if IsPowerOf2(n) {
		return n
	}
	return 1 << (_agfd(n) + 1)
}

func (_fddgb *RGBA32) Base() *ImageBase { return &_fddgb.ImageBase }

var _ _g.Image = &RGBA32{}

func (_fdaa *NRGBA64) Validate() error {
	if len(_fdaa.Data) != 3*2*_fdaa.Width*_fdaa.Height {
		return _fc.New("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073")
	}
	return nil
}

func _edg(_cfbf, _dfb int) *Monochrome {
	return &Monochrome{ImageBase: NewImageBase(_cfbf, _dfb, 1, 1, nil, nil, nil), ModelThreshold: 0x0f}
}

func _fdgc(_fdfb _e.Color) _e.Color {
	_dcfd := _e.GrayModel.Convert(_fdfb).(_e.Gray)
	return _gga(_dcfd)
}

func (_babf *Monochrome) ReduceBinary(factor float64) (*Monochrome, error) {
	_bcge := _agfd(uint(factor))
	if !IsPowerOf2(uint(factor)) {
		_bcge++
	}
	_deeb := make([]int, _bcge)
	for _fdbb := range _deeb {
		_deeb[_fdbb] = 4
	}
	_gcae, _cadd := _bae(_babf, _deeb...)
	if _cadd != nil {
		return nil, _cadd
	}
	return _gcae, nil
}

func IsGrayImgBlackAndWhite(i *_g.Gray) bool { return _gff(i) }

var _ Image = &NRGBA16{}

var _ Gray = &Gray16{}

func (_aaff *Gray16) Set(x, y int, c _e.Color) {
	_dcab := (y*_aaff.BytesPerLine/2 + x) * 2
	if _dcab+1 >= len(_aaff.Data) {
		return
	}
	_bbfg := _e.Gray16Model.Convert(c).(_e.Gray16)
	_aaff.Data[_dcab], _aaff.Data[_dcab+1] = uint8(_bbfg.Y>>8), uint8(_bbfg.Y&0xff)
}

func (_edb *Monochrome) SetGray(x, y int, g _e.Gray) {
	_eda := y*_edb.BytesPerLine + x>>3
	if _eda > len(_edb.Data)-1 {
		return
	}
	g = _dgd(g, monochromeModel(_edb.ModelThreshold))
	_edb.setGray(x, g, _eda)
}

func (_gceg *Gray4) ColorModel() _e.Model { return Gray4Model }

var _ Image = &RGBA32{}

func _daefd(_acfe Gray, _gdac RGBA, _edgg _g.Rectangle) {
	for _daec := 0; _daec < _edgg.Max.X; _daec++ {
		for _ebea := 0; _ebea < _edgg.Max.Y; _ebea++ {
			_bdgf := _acfe.GrayAt(_daec, _ebea)
			_gdac.SetRGBA(_daec, _ebea, _gecd(_bdgf))
		}
	}
}

func (_dbd *ImageBase) setEightPartlyBytes(_aeee, _ceggb int, _bdd uint64) (_dbgfb error) {
	var (
		_bfgb byte
		_ddfb int
	)
	for _fbge := 1; _fbge <= _ceggb; _fbge++ {
		_ddfb = 64 - _fbge*8
		_bfgb = byte(_bdd >> uint(_ddfb) & 0xff)
		if _dbgfb = _dbd.setByte(_aeee+_fbge-1, _bfgb); _dbgfb != nil {
			return _dbgfb
		}
	}
	_bde := _dbd.BytesPerLine*8 - _dbd.Width
	if _bde == 0 {
		return nil
	}
	_ddfb -= 8
	_bfgb = byte(_bdd>>uint(_ddfb)&0xff) << uint(_bde)
	if _dbgfb = _dbd.setByte(_aeee+_ceggb, _bfgb); _dbgfb != nil {
		return _dbgfb
	}
	return nil
}

var _ Image = &Monochrome{}

func _cbga(_cdee CMYK, _egeb Gray, _gggd _g.Rectangle) {
	for _fgad := 0; _fgad < _gggd.Max.X; _fgad++ {
		for _abcb := 0; _abcb < _gggd.Max.Y; _abcb++ {
			_baff := _fdbf(_cdee.CMYKAt(_fgad, _abcb))
			_egeb.SetGray(_fgad, _abcb, _baff)
		}
	}
}

func _ebag(_fbbb RGBA, _eac Gray, _eebe _g.Rectangle) {
	for _bbbb := 0; _bbbb < _eebe.Max.X; _bbbb++ {
		for _cgffg := 0; _cgffg < _eebe.Max.Y; _cgffg++ {
			_gfa := _gac(_fbbb.RGBAAt(_bbbb, _cgffg))
			_eac.SetGray(_bbbb, _cgffg, _gfa)
		}
	}
}

var _ Image = &CMYK32{}

func _aaec(_afad, _cdce, _bdce byte) byte { return (_afad &^ (_bdce)) | (_cdce & _bdce) }

func (_eggg *NRGBA32) setRGBA(_bcga int, _fca _e.NRGBA) {
	_fdde := 3 * _bcga
	_eggg.Data[_fdde] = _fca.R
	_eggg.Data[_fdde+1] = _fca.G
	_eggg.Data[_fdde+2] = _fca.B
	if _bcga < len(_eggg.Alpha) {
		_eggg.Alpha[_bcga] = _fca.A
	}
}

var _ _g.Image = &NRGBA64{}

func (_gdgc *NRGBA32) SetNRGBA(x, y int, c _e.NRGBA) {
	_gdf := y*_gdgc.Width + x
	_cbf := 3 * _gdf
	if _cbf+2 >= len(_gdgc.Data) {
		return
	}
	_gdgc.setRGBA(_gdf, c)
}

var _dbgf [256]uint8

func (_cde *Gray16) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _cde.Width, Y: _cde.Height}}
}

func _ecb(_efg NRGBA, _gab CMYK, _adac _g.Rectangle) {
	for _ccf := 0; _ccf < _adac.Max.X; _ccf++ {
		for _gaf := 0; _gaf < _adac.Max.Y; _gaf++ {
			_bad := _efg.NRGBAAt(_ccf, _gaf)
			_gab.SetCMYK(_ccf, _gaf, _acge(_bad))
		}
	}
}

func _gg(_bf *Monochrome, _cf int, _ffg []uint) (*Monochrome, error) {
	_dcf := _cf * _bf.Width
	_ggd := _cf * _bf.Height
	_ec := _edg(_dcf, _ggd)
	for _fad, _gd := range _ffg {
		var _fcc error
		switch _gd {
		case 2:
			_fcc = _da(_ec, _bf)
		case 4:
			_fcc = _eg(_ec, _bf)
		case 8:
			_fcc = _fb(_ec, _bf)
		}
		if _fcc != nil {
			return nil, _fcc
		}
		if _fad != len(_ffg)-1 {
			_bf = _ec.copy()
		}
	}
	return _ec, nil
}

func _bbfc(_fagdf _g.Image, _ffgac uint8) *_g.Gray {
	_debe := _fagdf.Bounds()
	_bccd := _g.NewGray(_debe)
	var (
		_eafg  _e.Color
		_bdabg _e.Gray
	)
	for _edbd := 0; _edbd < _debe.Max.X; _edbd++ {
		for _egee := 0; _egee < _debe.Max.Y; _egee++ {
			_eafg = _fagdf.At(_edbd, _egee)
			_bccd.Set(_edbd, _egee, _eafg)
			_bdabg = _bccd.GrayAt(_edbd, _egee)
			_bccd.SetGray(_edbd, _egee, _e.Gray{Y: _dccg(_bdabg.Y, _ffgac)})
		}
	}
	return _bccd
}

func (_acee *NRGBA16) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _acee.Width, Y: _acee.Height}}
}

func (_dabf *Gray8) Base() *ImageBase { return &_dabf.ImageBase }

func (_beac *Gray8) GrayAt(x, y int) _e.Gray {
	_defa, _ := ColorAtGray8BPC(x, y, _beac.BytesPerLine, _beac.Data, _beac.Decode)
	return _defa
}

func (_dgfe *Gray8) Copy() Image { return &Gray8{ImageBase: _dgfe.copy()} }

func _cbg(_fag *Monochrome, _egc int, _ged []byte) (_abf *Monochrome, _fdb error) {
	const _cd = "\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079"
	if _fag == nil {
		return nil, _fc.New("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
	}
	if _egc < 1 || _egc > 4 {
		return nil, _fc.New("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d")
	}
	if _fag.Height <= 1 {
		return nil, _fc.New("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027")
	}
	_abf = _edg(_fag.Width/2, _fag.Height/2)
	if _ged == nil {
		_ged = _fbfc()
	}
	_cdb := _badd(_fag.BytesPerLine, 2*_abf.BytesPerLine)
	switch _egc {
	case 1:
		_fdb = _geg(_fag, _abf, _ged, _cdb)
	case 2:
		_fdb = _ced(_fag, _abf, _ged, _cdb)
	case 3:
		_fdb = _eea(_fag, _abf, _ged, _cdb)
	case 4:
		_fdb = _aba(_fag, _abf, _ged, _cdb)
	}
	if _fdb != nil {
		return nil, _fdb
	}
	return _abf, nil
}

func _fedf(_cdaa, _bceg CMYK, _cgf _g.Rectangle) {
	for _cegg := 0; _cegg < _cgf.Max.X; _cegg++ {
		for _dec := 0; _dec < _cgf.Max.Y; _dec++ {
			_bceg.SetCMYK(_cegg, _dec, _cdaa.CMYKAt(_cegg, _dec))
		}
	}
}

func (_cead *Monochrome) setIndexedBit(_gcac int) { _cead.Data[(_gcac >> 3)] |= 0x80 >> uint(_gcac&7) }

func (_gbfaf *Gray2) Validate() error {
	if len(_gbfaf.Data) != _gbfaf.Height*_gbfaf.BytesPerLine {
		return ErrInvalidImage
	}
	return nil
}

func (_cab *Gray2) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtGray2BPC(x, y, _cab.BytesPerLine, _cab.Data, _cab.Decode)
}

func (_edgd *NRGBA32) Bounds() _g.Rectangle {
	return _g.Rectangle{Max: _g.Point{X: _edgd.Width, Y: _edgd.Height}}
}

var _ RGBA = &RGBA32{}

func _acge(_fdae _e.NRGBA) _e.CMYK {
	_cceb, _gaae, _febf, _ := _fdae.RGBA()
	_dge, _eba, _cgcc, _dgbc := _e.RGBToCMYK(uint8(_cceb>>8), uint8(_gaae>>8), uint8(_febf>>8))
	return _e.CMYK{C: _dge, M: _eba, Y: _cgcc, K: _dgbc}
}

var _ _g.Image = &Gray8{}

func (_dgbb *NRGBA64) NRGBA64At(x, y int) _e.NRGBA64 {
	_aeed, _ := ColorAtNRGBA64(x, y, _dgbb.Width, _dgbb.Data, _dgbb.Alpha, _dgbb.Decode)
	return _aeed
}

func (_cfda *ImageBase) getByte(_gcdc int) (byte, error) {
	if _gcdc > len(_cfda.Data)-1 || _gcdc < 0 {
		return 0, _c.Errorf("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065", _gcdc)
	}
	return _cfda.Data[_gcdc], nil
}

var _ _g.Image = &Monochrome{}

func ColorAtGray8BPC(x, y, bytesPerLine int, data []byte, decode []float64) (_e.Gray, error) {
	_agcg := y*bytesPerLine + x
	if _agcg >= len(data) {
		return _e.Gray{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_dbea := data[_agcg]
	if len(decode) == 2 {
		_dbea = uint8(uint32(LinearInterpolate(float64(_dbea), 0, 255, decode[0], decode[1])) & 0xff)
	}
	return _e.Gray{Y: _dbea}, nil
}

func ColorAtNRGBA16(x, y, width, bytesPerLine int, data, alpha []byte, decode []float64) (_e.NRGBA, error) {
	_gebcg := y*bytesPerLine + x*3/2
	if _gebcg+1 >= len(data) {
		return _e.NRGBA{}, _beagb(x, y)
	}
	const (
		_ccaa = 0xf
		_bbcc = uint8(0xff)
	)
	_ceae := _bbcc
	if alpha != nil {
		_bdba := y * BytesPerLine(width, 4, 1)
		if _bdba < len(alpha) {
			if x%2 == 0 {
				_ceae = (alpha[_bdba] >> uint(4)) & _ccaa
			} else {
				_ceae = alpha[_bdba] & _ccaa
			}
			_ceae |= _ceae << 4
		}
	}
	var _gfec, _daged, _cfdg uint8
	if x*3%2 == 0 {
		_gfec = (data[_gebcg] >> uint(4)) & _ccaa
		_daged = data[_gebcg] & _ccaa
		_cfdg = (data[_gebcg+1] >> uint(4)) & _ccaa
	} else {
		_gfec = data[_gebcg] & _ccaa
		_daged = (data[_gebcg+1] >> uint(4)) & _ccaa
		_cfdg = data[_gebcg+1] & _ccaa
	}
	if len(decode) == 6 {
		_gfec = uint8(uint32(LinearInterpolate(float64(_gfec), 0, 15, decode[0], decode[1])) & 0xf)
		_daged = uint8(uint32(LinearInterpolate(float64(_daged), 0, 15, decode[2], decode[3])) & 0xf)
		_cfdg = uint8(uint32(LinearInterpolate(float64(_cfdg), 0, 15, decode[4], decode[5])) & 0xf)
	}
	return _e.NRGBA{R: (_gfec << 4) | (_gfec & 0xf), G: (_daged << 4) | (_daged & 0xf), B: (_cfdg << 4) | (_cfdg & 0xf), A: _ceae}, nil
}

type monochromeModel uint8

func _bdfb(_eeeb *Monochrome, _bfda, _efad, _ffagf, _eccd int, _efeg RasterOperator, _effff *Monochrome, _ccbb, _daeb int) error {
	var (
		_gaaae       bool
		_bedd        bool
		_afff        byte
		_bfbg        int
		_bbafce      int
		_daca        int
		_bgag        int
		_bdga        bool
		_baaab       int
		_beae        int
		_gafgb       int
		_abaf        bool
		_becf        byte
		_dabfb       int
		_aefa        int
		_cebe        int
		_beab        byte
		_gbga        int
		_gcff        int
		_fabgf       uint
		_geeg        uint
		_eagag       byte
		_aabc        shift
		_cfcc        bool
		_gbcb        bool
		_aacg, _cdbc int
	)
	if _ccbb&7 != 0 {
		_gcff = 8 - (_ccbb & 7)
	}
	if _bfda&7 != 0 {
		_bbafce = 8 - (_bfda & 7)
	}
	if _gcff == 0 && _bbafce == 0 {
		_eagag = _dbcf[0]
	} else {
		if _bbafce > _gcff {
			_fabgf = uint(_bbafce - _gcff)
		} else {
			_fabgf = uint(8 - (_gcff - _bbafce))
		}
		_geeg = 8 - _fabgf
		_eagag = _dbcf[_fabgf]
	}
	if (_bfda & 7) != 0 {
		_gaaae = true
		_bfbg = 8 - (_bfda & 7)
		_afff = _dbcf[_bfbg]
		_daca = _eeeb.BytesPerLine*_efad + (_bfda >> 3)
		_bgag = _effff.BytesPerLine*_daeb + (_ccbb >> 3)
		_gbga = 8 - (_ccbb & 7)
		if _bfbg > _gbga {
			_aabc = _fcgbf
			if _ffagf >= _gcff {
				_cfcc = true
			}
		} else {
			_aabc = _aefb
		}
	}
	if _ffagf < _bfbg {
		_bedd = true
		_afff &= _febgc[8-_bfbg+_ffagf]
	}
	if !_bedd {
		_baaab = (_ffagf - _bfbg) >> 3
		if _baaab != 0 {
			_bdga = true
			_beae = _eeeb.BytesPerLine*_efad + ((_bfda + _bbafce) >> 3)
			_gafgb = _effff.BytesPerLine*_daeb + ((_ccbb + _bbafce) >> 3)
		}
	}
	_dabfb = (_bfda + _ffagf) & 7
	if !(_bedd || _dabfb == 0) {
		_abaf = true
		_becf = _febgc[_dabfb]
		_aefa = _eeeb.BytesPerLine*_efad + ((_bfda + _bbafce) >> 3) + _baaab
		_cebe = _effff.BytesPerLine*_daeb + ((_ccbb + _bbafce) >> 3) + _baaab
		if _dabfb > int(_geeg) {
			_gbcb = true
		}
	}
	switch _efeg {
	case PixSrc:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], _beab, _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = _beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], _beab, _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixNotSrc:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], ^_beab, _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = ^_beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], ^_beab, _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixSrcOrDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], _beab|_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] |= _beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], _beab|_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixSrcAndDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], _beab&_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] &= _beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], _beab&_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixSrcXorDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], _beab^_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] ^= _beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], _beab^_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixNotSrcOrDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], ^_beab|_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] |= ^_beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], ^_beab|_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixNotSrcAndDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], ^_beab&_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] &= ^_beab
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], ^_beab&_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixSrcOrNotDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], _beab|^_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = _beab | ^_eeeb.Data[_beae+_cdbc]
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], _beab|^_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixSrcAndNotDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], _beab&^_eeeb.Data[_daca], _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = _beab &^ _eeeb.Data[_beae+_cdbc]
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], _beab&^_eeeb.Data[_aefa], _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixNotPixSrcOrDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], ^(_beab | _eeeb.Data[_daca]), _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = ^(_beab | _eeeb.Data[_beae+_cdbc])
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], ^(_beab | _eeeb.Data[_aefa]), _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixNotPixSrcAndDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], ^(_beab & _eeeb.Data[_daca]), _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = ^(_beab & _eeeb.Data[_beae+_cdbc])
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], ^(_beab & _eeeb.Data[_aefa]), _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	case PixNotPixSrcXorDst:
		if _gaaae {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				if _aabc == _fcgbf {
					_beab = _effff.Data[_bgag] << _fabgf
					if _cfcc {
						_beab = _aaec(_beab, _effff.Data[_bgag+1]>>_geeg, _eagag)
					}
				} else {
					_beab = _effff.Data[_bgag] >> _geeg
				}
				_eeeb.Data[_daca] = _aaec(_eeeb.Data[_daca], ^(_beab ^ _eeeb.Data[_daca]), _afff)
				_daca += _eeeb.BytesPerLine
				_bgag += _effff.BytesPerLine
			}
		}
		if _bdga {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				for _cdbc = 0; _cdbc < _baaab; _cdbc++ {
					_beab = _aaec(_effff.Data[_gafgb+_cdbc]<<_fabgf, _effff.Data[_gafgb+_cdbc+1]>>_geeg, _eagag)
					_eeeb.Data[_beae+_cdbc] = ^(_beab ^ _eeeb.Data[_beae+_cdbc])
				}
				_beae += _eeeb.BytesPerLine
				_gafgb += _effff.BytesPerLine
			}
		}
		if _abaf {
			for _aacg = 0; _aacg < _eccd; _aacg++ {
				_beab = _effff.Data[_cebe] << _fabgf
				if _gbcb {
					_beab = _aaec(_beab, _effff.Data[_cebe+1]>>_geeg, _eagag)
				}
				_eeeb.Data[_aefa] = _aaec(_eeeb.Data[_aefa], ^(_beab ^ _eeeb.Data[_aefa]), _becf)
				_aefa += _eeeb.BytesPerLine
				_cebe += _effff.BytesPerLine
			}
		}
	default:
		_ef.Log.Debug("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064", _efeg)
		return _fc.New("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064")
	}
	return nil
}

func _gecd(_dba _e.Gray) _e.RGBA { return _e.RGBA{R: _dba.Y, G: _dba.Y, B: _dba.Y, A: 0xff} }

type CMYK32 struct{ ImageBase }

func _fbfc() (_aecg []byte) {
	_aecg = make([]byte, 256)
	for _fgeg := 0; _fgeg < 256; _fgeg++ {
		_cfbe := byte(_fgeg)
		_aecg[_cfbe] = (_cfbe & 0x01) | ((_cfbe & 0x04) >> 1) | ((_cfbe & 0x10) >> 2) | ((_cfbe & 0x40) >> 3) | ((_cfbe & 0x02) << 3) | ((_cfbe & 0x08) << 2) | ((_cfbe & 0x20) << 1) | (_cfbe & 0x80)
	}
	return _aecg
}

var (
	MonochromeConverter = ConverterFunc(_abcc)
	Gray2Converter      = ConverterFunc(_fedc)
	Gray4Converter      = ConverterFunc(_abcd)
	GrayConverter       = ConverterFunc(_aagc)
	Gray16Converter     = ConverterFunc(_faagc)
	NRGBA16Converter    = ConverterFunc(_gdad)
	NRGBAConverter      = ConverterFunc(_bdcc)
	NRGBA64Converter    = ConverterFunc(_fbgb)
	RGBAConverter       = ConverterFunc(_addf)
	CMYKConverter       = ConverterFunc(_egdc)
)

func (_bbfe *NRGBA16) Base() *ImageBase { return &_bbfe.ImageBase }

func (_cgdd *Gray2) At(x, y int) _e.Color {
	_bbaf, _ := _cgdd.ColorAt(x, y)
	return _bbaf
}

type Gray2 struct{ ImageBase }

var (
	_febgc = []byte{0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF}
	_dbcf  = []byte{0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF}
)

func (_bbge *NRGBA32) ColorModel() _e.Model { return _e.NRGBAModel }

func (_bfce *Gray4) Copy() Image { return &Gray4{ImageBase: _bfce.copy()} }

func _abcc(_gdd _g.Image) (Image, error) {
	if _ddad, _ggdc := _gdd.(*Monochrome); _ggdc {
		return _ddad, nil
	}
	_dgf := _gdd.Bounds()
	var _aeac Gray
	switch _aead := _gdd.(type) {
	case Gray:
		_aeac = _aead
	case NRGBA:
		_aeac = &Gray8{ImageBase: NewImageBase(_dgf.Max.X, _dgf.Max.Y, 8, 1, nil, nil, nil)}
		_cad(_aeac, _aead, _dgf)
	case nrgba64:
		_aeac = &Gray8{ImageBase: NewImageBase(_dgf.Max.X, _dgf.Max.Y, 8, 1, nil, nil, nil)}
		_ceaf(_aeac, _aead, _dgf)
	default:
		_gedb, _cfbea := GrayConverter.Convert(_gdd)
		if _cfbea != nil {
			return nil, _cfbea
		}
		_aeac = _gedb.(Gray)
	}
	_cfd, _ggdg := NewImage(_dgf.Max.X, _dgf.Max.Y, 1, 1, nil, nil, nil)
	if _ggdg != nil {
		return nil, _ggdg
	}
	_bcc := _cfd.(*Monochrome)
	_ebee := AutoThresholdTriangle(GrayHistogram(_aeac))
	for _acgb := 0; _acgb < _dgf.Max.X; _acgb++ {
		for _cggf := 0; _cggf < _dgf.Max.Y; _cggf++ {
			_cba := _dgd(_aeac.GrayAt(_acgb, _cggf), monochromeModel(_ebee))
			_bcc.SetGray(_acgb, _cggf, _cba)
		}
	}
	return _cfd, nil
}

func (_acc *Gray4) ColorAt(x, y int) (_e.Color, error) {
	return ColorAtGray4BPC(x, y, _acc.BytesPerLine, _acc.Data, _acc.Decode)
}

type ColorConverter interface {
	Convert(_cec _g.Image) (Image, error)
}

func _fac(_gedd, _gcd int, _gba []byte) *Monochrome {
	_ggf := _edg(_gedd, _gcd)
	_ggf.Data = _gba
	return _ggf
}

func (_abg *Gray2) Base() *ImageBase { return &_abg.ImageBase }

func _fabc(_ffgg _e.NRGBA) _e.RGBA {
	_aff, _bcad, _egef, _eggb := _ffgg.RGBA()
	return _e.RGBA{R: uint8(_aff >> 8), G: uint8(_bcad >> 8), B: uint8(_egef >> 8), A: uint8(_eggb >> 8)}
}

func _gcdd(_bdbg _e.Gray) _e.Gray {
	_bdbg.Y >>= 4
	_bdbg.Y |= _bdbg.Y << 4
	return _bdbg
}

func (_bcag *ImageBase) GetAlpha() []byte { return _bcag.Alpha }

func _aba(_fcfg, _efab *Monochrome, _aeb []byte, _fab int) (_cac error) {
	var (
		_fcdc, _gbed, _eee, _dcc, _ace, _effg, _dcef, _daa int
		_cae, _aag                                         uint32
		_bffb, _cda                                        byte
		_bdc                                               uint16
	)
	_def := make([]byte, 4)
	_fgab := make([]byte, 4)
	for _eee = 0; _eee < _fcfg.Height-1; _eee, _dcc = _eee+2, _dcc+1 {
		_fcdc = _eee * _fcfg.BytesPerLine
		_gbed = _dcc * _efab.BytesPerLine
		for _ace, _effg = 0, 0; _ace < _fab; _ace, _effg = _ace+4, _effg+1 {
			for _dcef = 0; _dcef < 4; _dcef++ {
				_daa = _fcdc + _ace + _dcef
				if _daa <= len(_fcfg.Data)-1 && _daa < _fcdc+_fcfg.BytesPerLine {
					_def[_dcef] = _fcfg.Data[_daa]
				} else {
					_def[_dcef] = 0x00
				}
				_daa = _fcdc + _fcfg.BytesPerLine + _ace + _dcef
				if _daa <= len(_fcfg.Data)-1 && _daa < _fcdc+(2*_fcfg.BytesPerLine) {
					_fgab[_dcef] = _fcfg.Data[_daa]
				} else {
					_fgab[_dcef] = 0x00
				}
			}
			_cae = _d.BigEndian.Uint32(_def)
			_aag = _d.BigEndian.Uint32(_fgab)
			_aag &= _cae
			_aag &= _aag << 1
			_aag &= 0xaaaaaaaa
			_cae = _aag | (_aag << 7)
			_bffb = byte(_cae >> 24)
			_cda = byte((_cae >> 8) & 0xff)
			_daa = _gbed + _effg
			if _daa+1 == len(_efab.Data)-1 || _daa+1 >= _gbed+_efab.BytesPerLine {
				_efab.Data[_daa] = _aeb[_bffb]
				if _cac = _efab.setByte(_daa, _aeb[_bffb]); _cac != nil {
					return _c.Errorf("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d", _daa)
				}
			} else {
				_bdc = (uint16(_aeb[_bffb]) << 8) | uint16(_aeb[_cda])
				if _cac = _efab.setTwoBytes(_daa, _bdc); _cac != nil {
					return _c.Errorf("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064", _daa)
				}
				_effg++
			}
		}
	}
	return nil
}

func ColorAtGray1BPC(x, y, bytesPerLine int, data []byte, decode []float64) (_e.Gray, error) {
	_efgd := y*bytesPerLine + x>>3
	if _efgd >= len(data) {
		return _e.Gray{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_befb := data[_efgd] >> uint(7-(x&7)) & 1
	if len(decode) == 2 {
		_befb = uint8(LinearInterpolate(float64(_befb), 0.0, 1.0, decode[0], decode[1])) & 1
	}
	return _e.Gray{Y: _befb * 255}, nil
}

func _cfdc(_acba _e.Color) _e.Color {
	_fecf := _e.GrayModel.Convert(_acba).(_e.Gray)
	return _gcdd(_fecf)
}

func _cdeed(_cggfg *_g.Gray16, _dfef uint8) *_g.Gray {
	_fcbbd := _cggfg.Bounds()
	_fbbbb := _g.NewGray(_fcbbd)
	for _dgbg := 0; _dgbg < _fcbbd.Dx(); _dgbg++ {
		for _dfgc := 0; _dfgc < _fcbbd.Dy(); _dfgc++ {
			_bddf := _cggfg.Gray16At(_dgbg, _dfgc)
			_fbbbb.SetGray(_dgbg, _dfgc, _e.Gray{Y: _dccg(uint8(_bddf.Y/256), _dfef)})
		}
	}
	return _fbbbb
}

func _facg(_geed _e.Gray) _e.CMYK { return _e.CMYK{K: 0xff - _geed.Y} }

var (
	_ebba = _bebb()
	_dadf = _caa()
	_cbd  = _gf()
)

func (_afaa *Monochrome) InverseData() error {
	return _afaa.RasterOperation(0, 0, _afaa.Width, _afaa.Height, PixNotDst, nil, 0, 0)
}

func (_ebda *Monochrome) Base() *ImageBase { return &_ebda.ImageBase }

func (_baaa *ImageBase) setByte(_abcf int, _bffd byte) error {
	if _abcf > len(_baaa.Data)-1 {
		return _fc.New("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065")
	}
	_baaa.Data[_abcf] = _bffd
	return nil
}

type SMasker interface {
	HasAlpha() bool
	GetAlpha() []byte
	MakeAlpha()
}

func _agab(_gebc *Monochrome, _dbgea, _accgc int, _dgea, _fdgg int, _cfae RasterOperator, _gaaa *Monochrome, _feg, _agca int) error {
	var _ffcd, _cdcf, _agbb, _gecaf int
	if _dbgea < 0 {
		_feg -= _dbgea
		_dgea += _dbgea
		_dbgea = 0
	}
	if _feg < 0 {
		_dbgea -= _feg
		_dgea += _feg
		_feg = 0
	}
	_ffcd = _dbgea + _dgea - _gebc.Width
	if _ffcd > 0 {
		_dgea -= _ffcd
	}
	_cdcf = _feg + _dgea - _gaaa.Width
	if _cdcf > 0 {
		_dgea -= _cdcf
	}
	if _accgc < 0 {
		_agca -= _accgc
		_fdgg += _accgc
		_accgc = 0
	}
	if _agca < 0 {
		_accgc -= _agca
		_fdgg += _agca
		_agca = 0
	}
	_agbb = _accgc + _fdgg - _gebc.Height
	if _agbb > 0 {
		_fdgg -= _agbb
	}
	_gecaf = _agca + _fdgg - _gaaa.Height
	if _gecaf > 0 {
		_fdgg -= _gecaf
	}
	if _dgea <= 0 || _fdgg <= 0 {
		return nil
	}
	var _eeef error
	switch {
	case _dbgea&7 == 0 && _feg&7 == 0:
		_eeef = _aaa(_gebc, _dbgea, _accgc, _dgea, _fdgg, _cfae, _gaaa, _feg, _agca)
	case _dbgea&7 == _feg&7:
		_eeef = _egge(_gebc, _dbgea, _accgc, _dgea, _fdgg, _cfae, _gaaa, _feg, _agca)
	default:
		_eeef = _bdfb(_gebc, _dbgea, _accgc, _dgea, _fdgg, _cfae, _gaaa, _feg, _agca)
	}
	if _eeef != nil {
		return _eeef
	}
	return nil
}

func _fbgb(_dgfbg _g.Image) (Image, error) {
	if _eeaf, _gecc := _dgfbg.(*NRGBA64); _gecc {
		return _eeaf.Copy(), nil
	}
	_fedb, _acaa, _efega := _aagf(_dgfbg, 2)
	_ddbaa, _gedad := NewImage(_fedb.Max.X, _fedb.Max.Y, 16, 3, nil, _efega, nil)
	if _gedad != nil {
		return nil, _gedad
	}
	_abb(_dgfbg, _ddbaa, _fedb)
	if len(_efega) != 0 && !_acaa {
		if _gbaf := _bede(_efega, _ddbaa); _gbaf != nil {
			return nil, _gbaf
		}
	}
	return _ddbaa, nil
}

type RGBA interface {
	RGBAAt(_gbdc, _dfaa int) _e.RGBA
	SetRGBA(_feba, _bgca int, _degb _e.RGBA)
}

func ConverterFunc(converterFunc func(_fgde _g.Image) (Image, error)) ColorConverter {
	return colorConverter{_feb: converterFunc}
}

func _eadfa(_aeba uint8) bool {
	if _aeba == 0 || _aeba == 255 {
		return true
	}
	return false
}

var ErrInvalidImage = _fc.New("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073")

func (_decfd *Gray2) SetGray(x, y int, gray _e.Gray) {
	_effb := _gga(gray)
	_gedbc := y * _decfd.BytesPerLine
	_ecac := _gedbc + (x >> 2)
	if _ecac >= len(_decfd.Data) {
		return
	}
	_egb := _effb.Y >> 6
	_decfd.Data[_ecac] = (_decfd.Data[_ecac] & (^(0xc0 >> uint(2*((x)&3))))) | (_egb << uint(6-2*(x&3)))
}

func (_gae *Monochrome) getBit(_bfe, _gcca int) uint8 {
	return _gae.Data[_bfe+(_gcca>>3)] >> uint(7-(_gcca&7)) & 1
}

var _ _g.Image = &NRGBA16{}

func ColorAtGray2BPC(x, y, bytesPerLine int, data []byte, decode []float64) (_e.Gray, error) {
	_fgb := y*bytesPerLine + x>>2
	if _fgb >= len(data) {
		return _e.Gray{}, _c.Errorf("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029", x, y)
	}
	_bbag := data[_fgb] >> uint(6-(x&3)*2) & 3
	if len(decode) == 2 {
		_bbag = uint8(uint32(LinearInterpolate(float64(_bbag), 0, 3.0, decode[0], decode[1])) & 3)
	}
	return _e.Gray{Y: _bbag * 85}, nil
}

func _dbdg(_cccgf CMYK, _ggdge NRGBA, _becfa _g.Rectangle) {
	for _badb := 0; _badb < _becfa.Max.X; _badb++ {
		for _edef := 0; _edef < _becfa.Max.Y; _edef++ {
			_fdaca := _cccgf.CMYKAt(_badb, _edef)
			_ggdge.SetNRGBA(_badb, _edef, _aadf(_fdaca))
		}
	}
}

func _gff(_dgcg *_g.Gray) bool {
	for _bdeb := 0; _bdeb < len(_dgcg.Pix); _bdeb++ {
		if !_eadfa(_dgcg.Pix[_bdeb]) {
			return false
		}
	}
	return true
}

type Histogramer interface{ Histogram() [256]int }

func (_fggf *Gray16) Validate() error {
	if len(_fggf.Data) != _fggf.Height*_fggf.BytesPerLine {
		return ErrInvalidImage
	}
	return nil
}

var _ Image = &Gray16{}

func (_bagf *Gray16) Base() *ImageBase { return &_bagf.ImageBase }

func _faagc(_add _g.Image) (Image, error) {
	if _ccad, _acec := _add.(*Gray16); _acec {
		return _ccad.Copy(), nil
	}
	_dece := _add.Bounds()
	_gbae, _eeee := NewImage(_dece.Max.X, _dece.Max.Y, 16, 1, nil, nil, nil)
	if _eeee != nil {
		return nil, _eeee
	}
	_ccda(_add, _gbae, _dece)
	return _gbae, nil
}

func GetConverter(bitsPerComponent, colorComponents int) (ColorConverter, error) {
	switch colorComponents {
	case 1:
		switch bitsPerComponent {
		case 1:
			return MonochromeConverter, nil
		case 2:
			return Gray2Converter, nil
		case 4:
			return Gray4Converter, nil
		case 8:
			return GrayConverter, nil
		case 16:
			return Gray16Converter, nil
		}
	case 3:
		switch bitsPerComponent {
		case 4:
			return NRGBA16Converter, nil
		case 8:
			return NRGBAConverter, nil
		case 16:
			return NRGBA64Converter, nil
		}
	case 4:
		return CMYKConverter, nil
	}
	return nil, _c.Errorf("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064", bitsPerComponent, colorComponents)
}

func (_gegc *NRGBA16) setNRGBA(_agag, _fdbbc, _bgab int, _eaac _e.NRGBA) {
	if _agag*3%2 == 0 {
		_gegc.Data[_bgab] = (_eaac.R>>4)<<4 | (_eaac.G >> 4)
		_gegc.Data[_bgab+1] = (_eaac.B>>4)<<4 | (_gegc.Data[_bgab+1] & 0xf)
	} else {
		_gegc.Data[_bgab] = (_gegc.Data[_bgab] & 0xf0) | (_eaac.R >> 4)
		_gegc.Data[_bgab+1] = (_eaac.G>>4)<<4 | (_eaac.B >> 4)
	}
	if _gegc.Alpha != nil {
		_bddb := _fdbbc * BytesPerLine(_gegc.Width, 4, 1)
		if _bddb < len(_gegc.Alpha) {
			if _agag%2 == 0 {
				_gegc.Alpha[_bddb] = (_eaac.A>>uint(4))<<uint(4) | (_gegc.Alpha[_bgab] & 0xf)
			} else {
				_gegc.Alpha[_bddb] = (_gegc.Alpha[_bddb] & 0xf0) | (_eaac.A >> uint(4))
			}
		}
	}
}

func _aadf(_ebbg _e.CMYK) _e.NRGBA {
	_ebg, _fdg, _abfa := _e.CMYKToRGB(_ebbg.C, _ebbg.M, _ebbg.Y, _ebbg.K)
	return _e.NRGBA{R: _ebg, G: _fdg, B: _abfa, A: 0xff}
}

func _fedc(_agc _g.Image) (Image, error) {
	if _efff, _gdefb := _agc.(*Gray2); _gdefb {
		return _efff.Copy(), nil
	}
	_gabe := _agc.Bounds()
	_fdea, _edee := NewImage(_gabe.Max.X, _gabe.Max.Y, 2, 1, nil, nil, nil)
	if _edee != nil {
		return nil, _edee
	}
	_ccda(_agc, _fdea, _gabe)
	return _fdea, nil
}

func (_bac *RGBA32) Set(x, y int, c _e.Color) {
	_cbgb := y*_bac.Width + x
	_bccc := 3 * _cbgb
	if _bccc+2 >= len(_bac.Data) {
		return
	}
	_gfgd := _e.RGBAModel.Convert(c).(_e.RGBA)
	_bac.setRGBA(_cbgb, _gfgd)
}

func _bebb() (_fbb [256]uint16) {
	for _efa := 0; _efa < 256; _efa++ {
		if _efa&0x01 != 0 {
			_fbb[_efa] |= 0x3
		}
		if _efa&0x02 != 0 {
			_fbb[_efa] |= 0xc
		}
		if _efa&0x04 != 0 {
			_fbb[_efa] |= 0x30
		}
		if _efa&0x08 != 0 {
			_fbb[_efa] |= 0xc0
		}
		if _efa&0x10 != 0 {
			_fbb[_efa] |= 0x300
		}
		if _efa&0x20 != 0 {
			_fbb[_efa] |= 0xc00
		}
		if _efa&0x40 != 0 {
			_fbb[_efa] |= 0x3000
		}
		if _efa&0x80 != 0 {
			_fbb[_efa] |= 0xc000
		}
	}
	return _fbb
}

func _dgd(_decf _e.Gray, _gead monochromeModel) _e.Gray {
	if _decf.Y > uint8(_gead) {
		return _e.Gray{Y: _b.MaxUint8}
	}
	return _e.Gray{}
}

func _aagc(_egba _g.Image) (Image, error) {
	if _cafb, _bcgd := _egba.(*Gray8); _bcgd {
		return _cafb.Copy(), nil
	}
	_bbafc := _egba.Bounds()
	_bdg, _cbef := NewImage(_bbafc.Max.X, _bbafc.Max.Y, 8, 1, nil, nil, nil)
	if _cbef != nil {
		return nil, _cbef
	}
	_ccda(_egba, _bdg, _bbafc)
	return _bdg, nil
}

func _aaa(_gdeedd *Monochrome, _ecbd, _cgce, _cfbg, _baffa int, _beagg RasterOperator, _gbg *Monochrome, _fdbbb, _bfbb int) error {
	var (
		_gbef         byte
		_bec          int
		_bfaf         int
		_cbdaf, _baee int
		_eeeg, _dcaba int
	)
	_dbeb := _cfbg >> 3
	_daead := _cfbg & 7
	if _daead > 0 {
		_gbef = _febgc[_daead]
	}
	_bec = _gbg.BytesPerLine*_bfbb + (_fdbbb >> 3)
	_bfaf = _gdeedd.BytesPerLine*_cgce + (_ecbd >> 3)
	switch _beagg {
	case PixSrc:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = _gbg.Data[_cbdaf]
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], _gbg.Data[_cbdaf], _gbef)
			}
		}
	case PixNotSrc:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = ^(_gbg.Data[_cbdaf])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], ^_gbg.Data[_cbdaf], _gbef)
			}
		}
	case PixSrcOrDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] |= _gbg.Data[_cbdaf]
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], _gbg.Data[_cbdaf]|_gdeedd.Data[_baee], _gbef)
			}
		}
	case PixSrcAndDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] &= _gbg.Data[_cbdaf]
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], _gbg.Data[_cbdaf]&_gdeedd.Data[_baee], _gbef)
			}
		}
	case PixSrcXorDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] ^= _gbg.Data[_cbdaf]
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], _gbg.Data[_cbdaf]^_gdeedd.Data[_baee], _gbef)
			}
		}
	case PixNotSrcOrDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] |= ^(_gbg.Data[_cbdaf])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], ^(_gbg.Data[_cbdaf])|_gdeedd.Data[_baee], _gbef)
			}
		}
	case PixNotSrcAndDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] &= ^(_gbg.Data[_cbdaf])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], ^(_gbg.Data[_cbdaf])&_gdeedd.Data[_baee], _gbef)
			}
		}
	case PixSrcOrNotDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = _gbg.Data[_cbdaf] | ^(_gdeedd.Data[_baee])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], _gbg.Data[_cbdaf]|^(_gdeedd.Data[_baee]), _gbef)
			}
		}
	case PixSrcAndNotDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = _gbg.Data[_cbdaf] &^ (_gdeedd.Data[_baee])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], _gbg.Data[_cbdaf]&^(_gdeedd.Data[_baee]), _gbef)
			}
		}
	case PixNotPixSrcOrDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = ^(_gbg.Data[_cbdaf] | _gdeedd.Data[_baee])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], ^(_gbg.Data[_cbdaf] | _gdeedd.Data[_baee]), _gbef)
			}
		}
	case PixNotPixSrcAndDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = ^(_gbg.Data[_cbdaf] & _gdeedd.Data[_baee])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], ^(_gbg.Data[_cbdaf] & _gdeedd.Data[_baee]), _gbef)
			}
		}
	case PixNotPixSrcXorDst:
		for _eeeg = 0; _eeeg < _baffa; _eeeg++ {
			_cbdaf = _bec + _eeeg*_gbg.BytesPerLine
			_baee = _bfaf + _eeeg*_gdeedd.BytesPerLine
			for _dcaba = 0; _dcaba < _dbeb; _dcaba++ {
				_gdeedd.Data[_baee] = ^(_gbg.Data[_cbdaf] ^ _gdeedd.Data[_baee])
				_baee++
				_cbdaf++
			}
			if _daead > 0 {
				_gdeedd.Data[_baee] = _aaec(_gdeedd.Data[_baee], ^(_gbg.Data[_cbdaf] ^ _gdeedd.Data[_baee]), _gbef)
			}
		}
	default:
		_ef.Log.Debug("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076", _beagg)
		return _fc.New("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072")
	}
	return nil
}

func _agfd(_gbc uint) uint {
	var _baad uint
	for _gbc != 0 {
		_gbc >>= 1
		_baad++
	}
	return _baad - 1
}

var _ Image = &NRGBA32{}

func ImgToBinary(i _g.Image, threshold uint8) *_g.Gray {
	switch _acac := i.(type) {
	case *_g.Gray:
		if _gff(_acac) {
			return _acac
		}
		return _ccgd(_acac, threshold)
	case *_g.Gray16:
		return _cdeed(_acac, threshold)
	default:
		return _bbfc(_acac, threshold)
	}
}

func (_fgf *Gray2) ColorModel() _e.Model { return Gray2Model }

func (_bgdf *ImageBase) setEightBytes(_cecc int, _eafa uint64) error {
	_aebc := _bgdf.BytesPerLine - (_cecc % _bgdf.BytesPerLine)
	if _bgdf.BytesPerLine != _bgdf.Width>>3 {
		_aebc--
	}
	if _aebc >= 8 {
		return _bgdf.setEightFullBytes(_cecc, _eafa)
	}
	return _bgdf.setEightPartlyBytes(_cecc, _aebc, _eafa)
}

type Monochrome struct {
	ImageBase
	ModelThreshold uint8
}

func (_bdea *NRGBA64) SetNRGBA64(x, y int, c _e.NRGBA64) {
	_fgca := (y*_bdea.Width + x) * 2
	_gaaef := _fgca * 3
	if _gaaef+5 >= len(_bdea.Data) {
		return
	}
	_bdea.setNRGBA64(_gaaef, c, _fgca)
}

func LinearInterpolate(x, xmin, xmax, ymin, ymax float64) float64 {
	if _b.Abs(xmax-xmin) < 0.000001 {
		return ymin
	}
	_ecee := ymin + (x-xmin)*(ymax-ymin)/(xmax-xmin)
	return _ecee
}

type nrgba64 interface {
	NRGBA64At(_dcca, _fecfg int) _e.NRGBA64
	SetNRGBA64(_eacd, _gcdcd int, _ceff _e.NRGBA64)
}

func (_fabd *NRGBA32) Set(x, y int, c _e.Color) {
	_acgd := y*_fabd.Width + x
	_deb := 3 * _acgd
	if _deb+2 >= len(_fabd.Data) {
		return
	}
	_dfda := _e.NRGBAModel.Convert(c).(_e.NRGBA)
	_fabd.setRGBA(_acgd, _dfda)
}

func _gagd(_bgdg nrgba64, _cegda RGBA, _fbda _g.Rectangle) {
	for _abbge := 0; _abbge < _fbda.Max.X; _abbge++ {
		for _fgfa := 0; _fgfa < _fbda.Max.Y; _fgfa++ {
			_abaag := _bgdg.NRGBA64At(_abbge, _fgfa)
			_cegda.SetRGBA(_abbge, _fgfa, _ccd(_abaag))
		}
	}
}

var _ Gray = &Monochrome{}

func _abee(_cedf Gray, _aecgc NRGBA, _gbde _g.Rectangle) {
	for _cecga := 0; _cecga < _gbde.Max.X; _cecga++ {
		for _egcc := 0; _egcc < _gbde.Max.Y; _egcc++ {
			_abeb := _cedf.GrayAt(_cecga, _egcc)
			_aecgc.SetNRGBA(_cecga, _egcc, _ccbe(_abeb))
		}
	}
}

func _agaa(_cdbca, _effd NRGBA, _afdb _g.Rectangle) {
	for _fdac := 0; _fdac < _afdb.Max.X; _fdac++ {
		for _dbdd := 0; _dbdd < _afdb.Max.Y; _dbdd++ {
			_effd.SetNRGBA(_fdac, _dbdd, _cdbca.NRGBAAt(_fdac, _dbdd))
		}
	}
}

func (_eggd *RGBA32) SetRGBA(x, y int, c _e.RGBA) {
	_efaag := y*_eggd.Width + x
	_cfga := 3 * _efaag
	if _cfga+2 >= len(_eggd.Data) {
		return
	}
	_eggd.setRGBA(_efaag, c)
}

type RasterOperator int

func _ccbe(_bcb _e.Gray) _e.NRGBA { return _e.NRGBA{R: _bcb.Y, G: _bcb.Y, B: _bcb.Y, A: 0xff} }

func _dccg(_ffbba, _fgbg uint8) uint8 {
	if _ffbba < _fgbg {
		return 255
	}
	return 0
}

func (_bfdgg *RGBA32) setRGBA(_cebc int, _edea _e.RGBA) {
	_bbde := 3 * _cebc
	_bfdgg.Data[_bbde] = _edea.R
	_bfdgg.Data[_bbde+1] = _edea.G
	_bfdgg.Data[_bbde+2] = _edea.B
	if _cebc < len(_bfdgg.Alpha) {
		_bfdgg.Alpha[_cebc] = _edea.A
	}
}

func _defg(_bgfc nrgba64, _gfc NRGBA, _afcd _g.Rectangle) {
	for _bced := 0; _bced < _afcd.Max.X; _bced++ {
		for _eeag := 0; _eeag < _afcd.Max.Y; _eeag++ {
			_cggd := _bgfc.NRGBA64At(_bced, _eeag)
			_gfc.SetNRGBA(_bced, _eeag, _cca(_cggd))
		}
	}
}

func (_bcda *NRGBA64) setNRGBA64(_fedg int, _aadda _e.NRGBA64, _bfea int) {
	_bcda.Data[_fedg] = uint8(_aadda.R >> 8)
	_bcda.Data[_fedg+1] = uint8(_aadda.R & 0xff)
	_bcda.Data[_fedg+2] = uint8(_aadda.G >> 8)
	_bcda.Data[_fedg+3] = uint8(_aadda.G & 0xff)
	_bcda.Data[_fedg+4] = uint8(_aadda.B >> 8)
	_bcda.Data[_fedg+5] = uint8(_aadda.B & 0xff)
	if _bfea+1 < len(_bcda.Alpha) {
		_bcda.Alpha[_bfea] = uint8(_aadda.A >> 8)
		_bcda.Alpha[_bfea+1] = uint8(_aadda.A & 0xff)
	}
}
