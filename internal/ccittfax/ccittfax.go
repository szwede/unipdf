//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package ccittfax

import (
	_f "errors"
	_b "github.com/szwede/unipdf/internal/bitwise"
	_ec "io"
	_fa "math"
)

func (_acbf *treeNode) set(_ffeab bool, _fca *treeNode) {
	if !_ffeab {
		_acbf._dfbe = _fca
	} else {
		_acbf._ggbc = _fca
	}
}

func init() {
	_fb = &treeNode{_dbdb: true, _ebad: _ef}
	_fae = &treeNode{_ebad: _bf, _ggbc: _fb}
	_fae._dfbe = _fae
	_bc = &tree{_ddg: &treeNode{}}
	if _cc := _bc.fillWithNode(12, 0, _fae); _cc != nil {
		panic(_cc.Error())
	}
	if _cd := _bc.fillWithNode(12, 1, _fb); _cd != nil {
		panic(_cd.Error())
	}
	_d = &tree{_ddg: &treeNode{}}
	for _dg := 0; _dg < len(_ag); _dg++ {
		for _ce := 0; _ce < len(_ag[_dg]); _ce++ {
			if _aab := _d.fill(_dg+2, int(_ag[_dg][_ce]), int(_dd[_dg][_ce])); _aab != nil {
				panic(_aab.Error())
			}
		}
	}
	if _cec := _d.fillWithNode(12, 0, _fae); _cec != nil {
		panic(_cec.Error())
	}
	if _ea := _d.fillWithNode(12, 1, _fb); _ea != nil {
		panic(_ea.Error())
	}
	_a = &tree{_ddg: &treeNode{}}
	for _ba := 0; _ba < len(_gd); _ba++ {
		for _cg := 0; _cg < len(_gd[_ba]); _cg++ {
			if _da := _a.fill(_ba+4, int(_gd[_ba][_cg]), int(_dgc[_ba][_cg])); _da != nil {
				panic(_da.Error())
			}
		}
	}
	if _ceb := _a.fillWithNode(12, 0, _fae); _ceb != nil {
		panic(_ceb.Error())
	}
	if _bg := _a.fillWithNode(12, 1, _fb); _bg != nil {
		panic(_bg.Error())
	}
	_aa = &tree{_ddg: &treeNode{}}
	if _ed := _aa.fill(4, 1, _c); _ed != nil {
		panic(_ed.Error())
	}
	if _ac := _aa.fill(3, 1, _g); _ac != nil {
		panic(_ac.Error())
	}
	if _ga := _aa.fill(1, 1, 0); _ga != nil {
		panic(_ga.Error())
	}
	if _gae := _aa.fill(3, 3, 1); _gae != nil {
		panic(_gae.Error())
	}
	if _cgg := _aa.fill(6, 3, 2); _cgg != nil {
		panic(_cgg.Error())
	}
	if _bd := _aa.fill(7, 3, 3); _bd != nil {
		panic(_bd.Error())
	}
	if _fab := _aa.fill(3, 2, -1); _fab != nil {
		panic(_fab.Error())
	}
	if _bda := _aa.fill(6, 2, -2); _bda != nil {
		panic(_bda.Error())
	}
	if _ff := _aa.fill(7, 2, -3); _ff != nil {
		panic(_ff.Error())
	}
}

var _dd = [...][]uint16{{3, 2}, {1, 4}, {6, 5}, {7}, {9, 8}, {10, 11, 12}, {13, 14}, {15}, {16, 17, 0, 18, 64}, {24, 25, 23, 22, 19, 20, 21, 1792, 1856, 1920}, {1984, 2048, 2112, 2176, 2240, 2304, 2368, 2432, 2496, 2560, 52, 55, 56, 59, 60, 320, 384, 448, 53, 54, 50, 51, 44, 45, 46, 47, 57, 58, 61, 256, 48, 49, 62, 63, 30, 31, 32, 33, 40, 41, 128, 192, 26, 27, 28, 29, 34, 35, 36, 37, 38, 39, 42, 43}, {640, 704, 768, 832, 1280, 1344, 1408, 1472, 1536, 1600, 1664, 1728, 512, 576, 896, 960, 1024, 1088, 1152, 1216}}

func NewDecoder(data []byte, options DecodeOptions) (*Decoder, error) {
	_egf := &Decoder{_fbf: _b.NewReader(data), _cf: options.Columns, _abd: options.Rows, _gbga: options.DamagedRowsBeforeError, _bed: make([]byte, (options.Columns+7)/8), _gafc: make([]int, options.Columns+2), _ccd: make([]int, options.Columns+2), _ca: options.EncodedByteAligned, _fabe: options.BlackIsOne, _fd: options.EndOfLine, _gf: options.EndOfBlock}
	switch {
	case options.K == 0:
		_egf._egg = _bgb
		if len(data) < 20 {
			return nil, _f.New("\u0074o\u006f\u0020\u0073\u0068o\u0072\u0074\u0020\u0063\u0063i\u0074t\u0066a\u0078\u0020\u0073\u0074\u0072\u0065\u0061m")
		}
		_bfb := data[:20]
		if _bfb[0] != 0 || (_bfb[1]>>4 != 1 && _bfb[1] != 1) {
			_egf._egg = _af
			_eaa := (uint16(_bfb[0])<<8 + uint16(_bfb[1]&0xff)) >> 4
			for _cff := 12; _cff < 160; _cff++ {
				_eaa = (_eaa << 1) + uint16((_bfb[_cff/8]>>uint16(7-(_cff%8)))&0x01)
				if _eaa&0xfff == 1 {
					_egf._egg = _bgb
					break
				}
			}
		}
	case options.K < 0:
		_egf._egg = _dfc
	case options.K > 0:
		_egf._egg = _bgb
		_egf._fe = true
	}
	switch _egf._egg {
	case _af, _bgb, _dfc:
	default:
		return nil, _f.New("\u0075\u006ek\u006e\u006f\u0077\u006e\u0020\u0063\u0063\u0069\u0074\u0074\u0066\u0061\u0078\u002e\u0044\u0065\u0063\u006f\u0064\u0065\u0072\u0020ty\u0070\u0065")
	}
	return _egf, nil
}

func (_gdf *tree) fillWithNode(_eeeg, _bab int, _geg *treeNode) error {
	_dbfa := _gdf._ddg
	for _acb := 0; _acb < _eeeg; _acb++ {
		_afcc := uint(_eeeg - 1 - _acb)
		_eaf := ((_bab >> _afcc) & 1) != 0
		_dec := _dbfa.walk(_eaf)
		if _dec != nil {
			if _dec._dbdb {
				return _f.New("\u006e\u006f\u0064\u0065\u0020\u0069\u0073\u0020\u006c\u0065\u0061\u0066\u002c\u0020\u006eo\u0020o\u0074\u0068\u0065\u0072\u0020\u0066\u006f\u006c\u006c\u006f\u0077\u0069\u006e\u0067")
			}
			_dbfa = _dec
			continue
		}
		if _acb == _eeeg-1 {
			_dec = _geg
		} else {
			_dec = &treeNode{}
		}
		if _bab == 0 {
			_dec._bgd = true
		}
		_dbfa.set(_eaf, _dec)
		_dbfa = _dec
	}
	return nil
}

func (_fbe *Encoder) encodeG4(_egb [][]byte) []byte {
	_aggc := make([][]byte, len(_egb))
	copy(_aggc, _egb)
	_aggc = _eea(_aggc)
	var _bcge []byte
	var _ebb int
	for _gcc := 1; _gcc < len(_aggc); _gcc++ {
		if _fbe.Rows > 0 && !_fbe.EndOfBlock && _gcc == (_fbe.Rows+1) {
			break
		}
		var _edbc []byte
		var _fg, _ecbc, _gee int
		_ceg := _ebb
		_efeg := -1
		for _efeg < len(_aggc[_gcc]) {
			_fg = _agf(_aggc[_gcc], _efeg)
			_ecbc = _faab(_aggc[_gcc], _aggc[_gcc-1], _efeg)
			_gee = _agf(_aggc[_gcc-1], _ecbc)
			if _gee < _fg {
				_edbc, _ceg = _baf(_edbc, _ceg, _ecg)
				_efeg = _gee
			} else {
				if _fa.Abs(float64(_ecbc-_fg)) > 3 {
					_edbc, _ceg, _efeg = _dfgd(_aggc[_gcc], _edbc, _ceg, _efeg, _fg)
				} else {
					_edbc, _ceg = _agbd(_edbc, _ceg, _fg, _ecbc)
					_efeg = _fg
				}
			}
		}
		_bcge = _fbe.appendEncodedRow(_bcge, _edbc, _ebb)
		if _fbe.EncodedByteAlign {
			_ceg = 0
		}
		_ebb = _ceg % 8
	}
	if _fbe.EndOfBlock {
		_dgb, _ := _agb(_ebb)
		_bcge = _fbe.appendEncodedRow(_bcge, _dgb, _ebb)
	}
	return _bcge
}

var _ag = [...][]uint16{{0x2, 0x3}, {0x2, 0x3}, {0x2, 0x3}, {0x3}, {0x4, 0x5}, {0x4, 0x5, 0x7}, {0x4, 0x7}, {0x18}, {0x17, 0x18, 0x37, 0x8, 0xf}, {0x17, 0x18, 0x28, 0x37, 0x67, 0x68, 0x6c, 0x8, 0xc, 0xd}, {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f, 0x24, 0x27, 0x28, 0x2b, 0x2c, 0x33, 0x34, 0x35, 0x37, 0x38, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xda, 0xdb}, {0x4a, 0x4b, 0x4c, 0x4d, 0x52, 0x53, 0x54, 0x55, 0x5a, 0x5b, 0x64, 0x65, 0x6c, 0x6d, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77}}

type treeNode struct {
	_dfbe *treeNode
	_ggbc *treeNode
	_ebad int
	_bgd  bool
	_dbdb bool
}

func init() {
	_de = make(map[int]code)
	_de[0] = code{Code: 13<<8 | 3<<6, BitsWritten: 10}
	_de[1] = code{Code: 2 << (5 + 8), BitsWritten: 3}
	_de[2] = code{Code: 3 << (6 + 8), BitsWritten: 2}
	_de[3] = code{Code: 2 << (6 + 8), BitsWritten: 2}
	_de[4] = code{Code: 3 << (5 + 8), BitsWritten: 3}
	_de[5] = code{Code: 3 << (4 + 8), BitsWritten: 4}
	_de[6] = code{Code: 2 << (4 + 8), BitsWritten: 4}
	_de[7] = code{Code: 3 << (3 + 8), BitsWritten: 5}
	_de[8] = code{Code: 5 << (2 + 8), BitsWritten: 6}
	_de[9] = code{Code: 4 << (2 + 8), BitsWritten: 6}
	_de[10] = code{Code: 4 << (1 + 8), BitsWritten: 7}
	_de[11] = code{Code: 5 << (1 + 8), BitsWritten: 7}
	_de[12] = code{Code: 7 << (1 + 8), BitsWritten: 7}
	_de[13] = code{Code: 4 << 8, BitsWritten: 8}
	_de[14] = code{Code: 7 << 8, BitsWritten: 8}
	_de[15] = code{Code: 12 << 8, BitsWritten: 9}
	_de[16] = code{Code: 5<<8 | 3<<6, BitsWritten: 10}
	_de[17] = code{Code: 6 << 8, BitsWritten: 10}
	_de[18] = code{Code: 2 << 8, BitsWritten: 10}
	_de[19] = code{Code: 12<<8 | 7<<5, BitsWritten: 11}
	_de[20] = code{Code: 13 << 8, BitsWritten: 11}
	_de[21] = code{Code: 13<<8 | 4<<5, BitsWritten: 11}
	_de[22] = code{Code: 6<<8 | 7<<5, BitsWritten: 11}
	_de[23] = code{Code: 5 << 8, BitsWritten: 11}
	_de[24] = code{Code: 2<<8 | 7<<5, BitsWritten: 11}
	_de[25] = code{Code: 3 << 8, BitsWritten: 11}
	_de[26] = code{Code: 12<<8 | 10<<4, BitsWritten: 12}
	_de[27] = code{Code: 12<<8 | 11<<4, BitsWritten: 12}
	_de[28] = code{Code: 12<<8 | 12<<4, BitsWritten: 12}
	_de[29] = code{Code: 12<<8 | 13<<4, BitsWritten: 12}
	_de[30] = code{Code: 6<<8 | 8<<4, BitsWritten: 12}
	_de[31] = code{Code: 6<<8 | 9<<4, BitsWritten: 12}
	_de[32] = code{Code: 6<<8 | 10<<4, BitsWritten: 12}
	_de[33] = code{Code: 6<<8 | 11<<4, BitsWritten: 12}
	_de[34] = code{Code: 13<<8 | 2<<4, BitsWritten: 12}
	_de[35] = code{Code: 13<<8 | 3<<4, BitsWritten: 12}
	_de[36] = code{Code: 13<<8 | 4<<4, BitsWritten: 12}
	_de[37] = code{Code: 13<<8 | 5<<4, BitsWritten: 12}
	_de[38] = code{Code: 13<<8 | 6<<4, BitsWritten: 12}
	_de[39] = code{Code: 13<<8 | 7<<4, BitsWritten: 12}
	_de[40] = code{Code: 6<<8 | 12<<4, BitsWritten: 12}
	_de[41] = code{Code: 6<<8 | 13<<4, BitsWritten: 12}
	_de[42] = code{Code: 13<<8 | 10<<4, BitsWritten: 12}
	_de[43] = code{Code: 13<<8 | 11<<4, BitsWritten: 12}
	_de[44] = code{Code: 5<<8 | 4<<4, BitsWritten: 12}
	_de[45] = code{Code: 5<<8 | 5<<4, BitsWritten: 12}
	_de[46] = code{Code: 5<<8 | 6<<4, BitsWritten: 12}
	_de[47] = code{Code: 5<<8 | 7<<4, BitsWritten: 12}
	_de[48] = code{Code: 6<<8 | 4<<4, BitsWritten: 12}
	_de[49] = code{Code: 6<<8 | 5<<4, BitsWritten: 12}
	_de[50] = code{Code: 5<<8 | 2<<4, BitsWritten: 12}
	_de[51] = code{Code: 5<<8 | 3<<4, BitsWritten: 12}
	_de[52] = code{Code: 2<<8 | 4<<4, BitsWritten: 12}
	_de[53] = code{Code: 3<<8 | 7<<4, BitsWritten: 12}
	_de[54] = code{Code: 3<<8 | 8<<4, BitsWritten: 12}
	_de[55] = code{Code: 2<<8 | 7<<4, BitsWritten: 12}
	_de[56] = code{Code: 2<<8 | 8<<4, BitsWritten: 12}
	_de[57] = code{Code: 5<<8 | 8<<4, BitsWritten: 12}
	_de[58] = code{Code: 5<<8 | 9<<4, BitsWritten: 12}
	_de[59] = code{Code: 2<<8 | 11<<4, BitsWritten: 12}
	_de[60] = code{Code: 2<<8 | 12<<4, BitsWritten: 12}
	_de[61] = code{Code: 5<<8 | 10<<4, BitsWritten: 12}
	_de[62] = code{Code: 6<<8 | 6<<4, BitsWritten: 12}
	_de[63] = code{Code: 6<<8 | 7<<4, BitsWritten: 12}
	_ded = make(map[int]code)
	_ded[0] = code{Code: 53 << 8, BitsWritten: 8}
	_ded[1] = code{Code: 7 << (2 + 8), BitsWritten: 6}
	_ded[2] = code{Code: 7 << (4 + 8), BitsWritten: 4}
	_ded[3] = code{Code: 8 << (4 + 8), BitsWritten: 4}
	_ded[4] = code{Code: 11 << (4 + 8), BitsWritten: 4}
	_ded[5] = code{Code: 12 << (4 + 8), BitsWritten: 4}
	_ded[6] = code{Code: 14 << (4 + 8), BitsWritten: 4}
	_ded[7] = code{Code: 15 << (4 + 8), BitsWritten: 4}
	_ded[8] = code{Code: 19 << (3 + 8), BitsWritten: 5}
	_ded[9] = code{Code: 20 << (3 + 8), BitsWritten: 5}
	_ded[10] = code{Code: 7 << (3 + 8), BitsWritten: 5}
	_ded[11] = code{Code: 8 << (3 + 8), BitsWritten: 5}
	_ded[12] = code{Code: 8 << (2 + 8), BitsWritten: 6}
	_ded[13] = code{Code: 3 << (2 + 8), BitsWritten: 6}
	_ded[14] = code{Code: 52 << (2 + 8), BitsWritten: 6}
	_ded[15] = code{Code: 53 << (2 + 8), BitsWritten: 6}
	_ded[16] = code{Code: 42 << (2 + 8), BitsWritten: 6}
	_ded[17] = code{Code: 43 << (2 + 8), BitsWritten: 6}
	_ded[18] = code{Code: 39 << (1 + 8), BitsWritten: 7}
	_ded[19] = code{Code: 12 << (1 + 8), BitsWritten: 7}
	_ded[20] = code{Code: 8 << (1 + 8), BitsWritten: 7}
	_ded[21] = code{Code: 23 << (1 + 8), BitsWritten: 7}
	_ded[22] = code{Code: 3 << (1 + 8), BitsWritten: 7}
	_ded[23] = code{Code: 4 << (1 + 8), BitsWritten: 7}
	_ded[24] = code{Code: 40 << (1 + 8), BitsWritten: 7}
	_ded[25] = code{Code: 43 << (1 + 8), BitsWritten: 7}
	_ded[26] = code{Code: 19 << (1 + 8), BitsWritten: 7}
	_ded[27] = code{Code: 36 << (1 + 8), BitsWritten: 7}
	_ded[28] = code{Code: 24 << (1 + 8), BitsWritten: 7}
	_ded[29] = code{Code: 2 << 8, BitsWritten: 8}
	_ded[30] = code{Code: 3 << 8, BitsWritten: 8}
	_ded[31] = code{Code: 26 << 8, BitsWritten: 8}
	_ded[32] = code{Code: 27 << 8, BitsWritten: 8}
	_ded[33] = code{Code: 18 << 8, BitsWritten: 8}
	_ded[34] = code{Code: 19 << 8, BitsWritten: 8}
	_ded[35] = code{Code: 20 << 8, BitsWritten: 8}
	_ded[36] = code{Code: 21 << 8, BitsWritten: 8}
	_ded[37] = code{Code: 22 << 8, BitsWritten: 8}
	_ded[38] = code{Code: 23 << 8, BitsWritten: 8}
	_ded[39] = code{Code: 40 << 8, BitsWritten: 8}
	_ded[40] = code{Code: 41 << 8, BitsWritten: 8}
	_ded[41] = code{Code: 42 << 8, BitsWritten: 8}
	_ded[42] = code{Code: 43 << 8, BitsWritten: 8}
	_ded[43] = code{Code: 44 << 8, BitsWritten: 8}
	_ded[44] = code{Code: 45 << 8, BitsWritten: 8}
	_ded[45] = code{Code: 4 << 8, BitsWritten: 8}
	_ded[46] = code{Code: 5 << 8, BitsWritten: 8}
	_ded[47] = code{Code: 10 << 8, BitsWritten: 8}
	_ded[48] = code{Code: 11 << 8, BitsWritten: 8}
	_ded[49] = code{Code: 82 << 8, BitsWritten: 8}
	_ded[50] = code{Code: 83 << 8, BitsWritten: 8}
	_ded[51] = code{Code: 84 << 8, BitsWritten: 8}
	_ded[52] = code{Code: 85 << 8, BitsWritten: 8}
	_ded[53] = code{Code: 36 << 8, BitsWritten: 8}
	_ded[54] = code{Code: 37 << 8, BitsWritten: 8}
	_ded[55] = code{Code: 88 << 8, BitsWritten: 8}
	_ded[56] = code{Code: 89 << 8, BitsWritten: 8}
	_ded[57] = code{Code: 90 << 8, BitsWritten: 8}
	_ded[58] = code{Code: 91 << 8, BitsWritten: 8}
	_ded[59] = code{Code: 74 << 8, BitsWritten: 8}
	_ded[60] = code{Code: 75 << 8, BitsWritten: 8}
	_ded[61] = code{Code: 50 << 8, BitsWritten: 8}
	_ded[62] = code{Code: 51 << 8, BitsWritten: 8}
	_ded[63] = code{Code: 52 << 8, BitsWritten: 8}
	_aabe = make(map[int]code)
	_aabe[64] = code{Code: 3<<8 | 3<<6, BitsWritten: 10}
	_aabe[128] = code{Code: 12<<8 | 8<<4, BitsWritten: 12}
	_aabe[192] = code{Code: 12<<8 | 9<<4, BitsWritten: 12}
	_aabe[256] = code{Code: 5<<8 | 11<<4, BitsWritten: 12}
	_aabe[320] = code{Code: 3<<8 | 3<<4, BitsWritten: 12}
	_aabe[384] = code{Code: 3<<8 | 4<<4, BitsWritten: 12}
	_aabe[448] = code{Code: 3<<8 | 5<<4, BitsWritten: 12}
	_aabe[512] = code{Code: 3<<8 | 12<<3, BitsWritten: 13}
	_aabe[576] = code{Code: 3<<8 | 13<<3, BitsWritten: 13}
	_aabe[640] = code{Code: 2<<8 | 10<<3, BitsWritten: 13}
	_aabe[704] = code{Code: 2<<8 | 11<<3, BitsWritten: 13}
	_aabe[768] = code{Code: 2<<8 | 12<<3, BitsWritten: 13}
	_aabe[832] = code{Code: 2<<8 | 13<<3, BitsWritten: 13}
	_aabe[896] = code{Code: 3<<8 | 18<<3, BitsWritten: 13}
	_aabe[960] = code{Code: 3<<8 | 19<<3, BitsWritten: 13}
	_aabe[1024] = code{Code: 3<<8 | 20<<3, BitsWritten: 13}
	_aabe[1088] = code{Code: 3<<8 | 21<<3, BitsWritten: 13}
	_aabe[1152] = code{Code: 3<<8 | 22<<3, BitsWritten: 13}
	_aabe[1216] = code{Code: 119 << 3, BitsWritten: 13}
	_aabe[1280] = code{Code: 2<<8 | 18<<3, BitsWritten: 13}
	_aabe[1344] = code{Code: 2<<8 | 19<<3, BitsWritten: 13}
	_aabe[1408] = code{Code: 2<<8 | 20<<3, BitsWritten: 13}
	_aabe[1472] = code{Code: 2<<8 | 21<<3, BitsWritten: 13}
	_aabe[1536] = code{Code: 2<<8 | 26<<3, BitsWritten: 13}
	_aabe[1600] = code{Code: 2<<8 | 27<<3, BitsWritten: 13}
	_aabe[1664] = code{Code: 3<<8 | 4<<3, BitsWritten: 13}
	_aabe[1728] = code{Code: 3<<8 | 5<<3, BitsWritten: 13}
	_fcb = make(map[int]code)
	_fcb[64] = code{Code: 27 << (3 + 8), BitsWritten: 5}
	_fcb[128] = code{Code: 18 << (3 + 8), BitsWritten: 5}
	_fcb[192] = code{Code: 23 << (2 + 8), BitsWritten: 6}
	_fcb[256] = code{Code: 55 << (1 + 8), BitsWritten: 7}
	_fcb[320] = code{Code: 54 << 8, BitsWritten: 8}
	_fcb[384] = code{Code: 55 << 8, BitsWritten: 8}
	_fcb[448] = code{Code: 100 << 8, BitsWritten: 8}
	_fcb[512] = code{Code: 101 << 8, BitsWritten: 8}
	_fcb[576] = code{Code: 104 << 8, BitsWritten: 8}
	_fcb[640] = code{Code: 103 << 8, BitsWritten: 8}
	_fcb[704] = code{Code: 102 << 8, BitsWritten: 9}
	_fcb[768] = code{Code: 102<<8 | 1<<7, BitsWritten: 9}
	_fcb[832] = code{Code: 105 << 8, BitsWritten: 9}
	_fcb[896] = code{Code: 105<<8 | 1<<7, BitsWritten: 9}
	_fcb[960] = code{Code: 106 << 8, BitsWritten: 9}
	_fcb[1024] = code{Code: 106<<8 | 1<<7, BitsWritten: 9}
	_fcb[1088] = code{Code: 107 << 8, BitsWritten: 9}
	_fcb[1152] = code{Code: 107<<8 | 1<<7, BitsWritten: 9}
	_fcb[1216] = code{Code: 108 << 8, BitsWritten: 9}
	_fcb[1280] = code{Code: 108<<8 | 1<<7, BitsWritten: 9}
	_fcb[1344] = code{Code: 109 << 8, BitsWritten: 9}
	_fcb[1408] = code{Code: 109<<8 | 1<<7, BitsWritten: 9}
	_fcb[1472] = code{Code: 76 << 8, BitsWritten: 9}
	_fcb[1536] = code{Code: 76<<8 | 1<<7, BitsWritten: 9}
	_fcb[1600] = code{Code: 77 << 8, BitsWritten: 9}
	_fcb[1664] = code{Code: 24 << (2 + 8), BitsWritten: 6}
	_fcb[1728] = code{Code: 77<<8 | 1<<7, BitsWritten: 9}
	_bfc = make(map[int]code)
	_bfc[1792] = code{Code: 1 << 8, BitsWritten: 11}
	_bfc[1856] = code{Code: 1<<8 | 4<<5, BitsWritten: 11}
	_bfc[1920] = code{Code: 1<<8 | 5<<5, BitsWritten: 11}
	_bfc[1984] = code{Code: 1<<8 | 2<<4, BitsWritten: 12}
	_bfc[2048] = code{Code: 1<<8 | 3<<4, BitsWritten: 12}
	_bfc[2112] = code{Code: 1<<8 | 4<<4, BitsWritten: 12}
	_bfc[2176] = code{Code: 1<<8 | 5<<4, BitsWritten: 12}
	_bfc[2240] = code{Code: 1<<8 | 6<<4, BitsWritten: 12}
	_bfc[2304] = code{Code: 1<<8 | 7<<4, BitsWritten: 12}
	_bfc[2368] = code{Code: 1<<8 | 12<<4, BitsWritten: 12}
	_bfc[2432] = code{Code: 1<<8 | 13<<4, BitsWritten: 12}
	_bfc[2496] = code{Code: 1<<8 | 14<<4, BitsWritten: 12}
	_bfc[2560] = code{Code: 1<<8 | 15<<4, BitsWritten: 12}
	_ffd = make(map[int]byte)
	_ffd[0] = 0xFF
	_ffd[1] = 0xFE
	_ffd[2] = 0xFC
	_ffd[3] = 0xF8
	_ffd[4] = 0xF0
	_ffd[5] = 0xE0
	_ffd[6] = 0xC0
	_ffd[7] = 0x80
	_ffd[8] = 0x00
}

func (_cae *Decoder) decode1D() error {
	var (
		_ecaa int
		_eeb  error
	)
	_dfb := true
	_cae._ddb = 0
	for {
		var _cdbc int
		if _dfb {
			_cdbc, _eeb = _cae.decodeRun(_a)
		} else {
			_cdbc, _eeb = _cae.decodeRun(_d)
		}
		if _eeb != nil {
			return _eeb
		}
		_ecaa += _cdbc
		_cae._ccd[_cae._ddb] = _ecaa
		_cae._ddb++
		_dfb = !_dfb
		if _ecaa >= _cae._cf {
			break
		}
	}
	return nil
}

func (_ggb *Decoder) decode2D() error {
	_ggb._agc = _ggb._ddb
	_ggb._ccd, _ggb._gafc = _ggb._gafc, _ggb._ccd
	_dde := true
	var (
		_cda bool
		_cdg int
		_gge error
	)
	_ggb._ddb = 0
_bfe:
	for _cdg < _ggb._cf {
		_ad := _aa._ddg
		for {
			_cda, _gge = _ggb._fbf.ReadBool()
			if _gge != nil {
				return _gge
			}
			_ad = _ad.walk(_cda)
			if _ad == nil {
				continue _bfe
			}
			if !_ad._dbdb {
				continue
			}
			switch _ad._ebad {
			case _g:
				var _cgeg int
				if _dde {
					_cgeg, _gge = _ggb.decodeRun(_a)
				} else {
					_cgeg, _gge = _ggb.decodeRun(_d)
				}
				if _gge != nil {
					return _gge
				}
				_cdg += _cgeg
				_ggb._ccd[_ggb._ddb] = _cdg
				_ggb._ddb++
				if _dde {
					_cgeg, _gge = _ggb.decodeRun(_d)
				} else {
					_cgeg, _gge = _ggb.decodeRun(_a)
				}
				if _gge != nil {
					return _gge
				}
				_cdg += _cgeg
				_ggb._ccd[_ggb._ddb] = _cdg
				_ggb._ddb++
			case _c:
				_fag := _ggb.getNextChangingElement(_cdg, _dde) + 1
				if _fag >= _ggb._agc {
					_cdg = _ggb._cf
				} else {
					_cdg = _ggb._gafc[_fag]
				}
			default:
				_cee := _ggb.getNextChangingElement(_cdg, _dde)
				if _cee >= _ggb._agc || _cee == -1 {
					_cdg = _ggb._cf + _ad._ebad
				} else {
					_cdg = _ggb._gafc[_cee] + _ad._ebad
				}
				_ggb._ccd[_ggb._ddb] = _cdg
				_ggb._ddb++
				_dde = !_dde
			}
			continue _bfe
		}
	}
	return nil
}

func _fac(_eaeb []byte, _fdba int) ([]byte, int) { return _baf(_eaeb, _fdba, _ecg) }

type tree struct{ _ddg *treeNode }

func _dae(_afgd, _eggb int) code {
	var _gfad code
	switch _eggb - _afgd {
	case -1:
		_gfad = _be
	case -2:
		_gfad = _gbd
	case -3:
		_gfad = _bag
	case 0:
		_gfad = _eg
	case 1:
		_gfad = _df
	case 2:
		_gfad = _db
	case 3:
		_gfad = _gbg
	}
	return _gfad
}

func _agb(_abdg int) ([]byte, int) {
	var _ecdc []byte
	for _ggbb := 0; _ggbb < 2; _ggbb++ {
		_ecdc, _abdg = _baf(_ecdc, _abdg, _gb)
	}
	return _ecdc, _abdg % 8
}

var (
	_de   map[int]code
	_ded  map[int]code
	_aabe map[int]code
	_fcb  map[int]code
	_bfc  map[int]code
	_ffd  map[int]byte
	_gb   = code{Code: 1 << 4, BitsWritten: 12}
	_cca  = code{Code: 3 << 3, BitsWritten: 13}
	_ab   = code{Code: 2 << 3, BitsWritten: 13}
	_ecg  = code{Code: 1 << 12, BitsWritten: 4}
	_dc   = code{Code: 1 << 13, BitsWritten: 3}
	_eg   = code{Code: 1 << 15, BitsWritten: 1}
	_be   = code{Code: 3 << 13, BitsWritten: 3}
	_gbd  = code{Code: 3 << 10, BitsWritten: 6}
	_bag  = code{Code: 3 << 9, BitsWritten: 7}
	_df   = code{Code: 2 << 13, BitsWritten: 3}
	_db   = code{Code: 2 << 10, BitsWritten: 6}
	_gbg  = code{Code: 2 << 9, BitsWritten: 7}
)

func _dfgd(_cdgb, _fad []byte, _cfgg, _aeb, _ddc int) ([]byte, int, int) {
	_agd := _agf(_cdgb, _ddc)
	_faae := _aeb >= 0 && _cdgb[_aeb] == _beb || _aeb == -1
	_fad, _cfgg = _baf(_fad, _cfgg, _dc)
	var _age int
	if _aeb > -1 {
		_age = _ddc - _aeb
	} else {
		_age = _ddc - _aeb - 1
	}
	_fad, _cfgg = _bcdf(_fad, _cfgg, _age, _faae)
	_faae = !_faae
	_ebdd := _agd - _ddc
	_fad, _cfgg = _bcdf(_fad, _cfgg, _ebdd, _faae)
	_aeb = _agd
	return _fad, _cfgg, _aeb
}

func _bcdf(_geb []byte, _dba int, _dab int, _fbc bool) ([]byte, int) {
	var (
		_gdbf code
		_dbee bool
	)
	for !_dbee {
		_gdbf, _dab, _dbee = _ccdg(_dab, _fbc)
		_geb, _dba = _baf(_geb, _dba, _gdbf)
	}
	return _geb, _dba
}

type DecodeOptions struct {
	Columns                int
	Rows                   int
	K                      int
	EncodedByteAligned     bool
	BlackIsOne             bool
	EndOfBlock             bool
	EndOfLine              bool
	DamagedRowsBeforeError int
}

func _agf(_eae []byte, _fcff int) int {
	if _fcff >= len(_eae) {
		return _fcff
	}
	if _fcff < -1 {
		_fcff = -1
	}
	var _gdc byte
	if _fcff > -1 {
		_gdc = _eae[_fcff]
	} else {
		_gdc = _beb
	}
	_acd := _fcff + 1
	for _acd < len(_eae) {
		if _eae[_acd] != _gdc {
			break
		}
		_acd++
	}
	return _acd
}

func _bcgb(_cccf []byte, _aff int, _ecab code) ([]byte, int) {
	_gaa := true
	var _aae []byte
	_aae, _aff = _baf(nil, _aff, _ecab)
	_eec := 0
	var _aaa int
	for _eec < len(_cccf) {
		_aaa, _eec = _ffgb(_cccf, _gaa, _eec)
		_aae, _aff = _bcdf(_aae, _aff, _aaa, _gaa)
		_gaa = !_gaa
	}
	return _aae, _aff % 8
}

func (_ae *Decoder) decodeRowType6() error {
	if _ae._ca {
		_ae._fbf.Align()
	}
	if _ae._gf {
		_ae._fbf.Mark()
		_bcbc, _dga := _ae.tryFetchEOL()
		if _dga != nil {
			return _dga
		}
		if _bcbc {
			_bcbc, _dga = _ae.tryFetchEOL()
			if _dga != nil {
				return _dga
			}
			if _bcbc {
				return _ec.EOF
			}
		}
		_ae._fbf.Reset()
	}
	return _ae.decode2D()
}

func (_dedf *Encoder) Encode(pixels [][]byte) []byte {
	if _dedf.BlackIs1 {
		_beb = 0
		_gbde = 1
	} else {
		_beb = 1
		_gbde = 0
	}
	if _dedf.K == 0 {
		return _dedf.encodeG31D(pixels)
	}
	if _dedf.K > 0 {
		return _dedf.encodeG32D(pixels)
	}
	if _dedf.K < 0 {
		return _dedf.encodeG4(pixels)
	}
	return nil
}

var _dgc = [...][]uint16{{2, 3, 4, 5, 6, 7}, {128, 8, 9, 64, 10, 11}, {192, 1664, 16, 17, 13, 14, 15, 1, 12}, {26, 21, 28, 27, 18, 24, 25, 22, 256, 23, 20, 19}, {33, 34, 35, 36, 37, 38, 31, 32, 29, 53, 54, 39, 40, 41, 42, 43, 44, 30, 61, 62, 63, 0, 320, 384, 45, 59, 60, 46, 49, 50, 51, 52, 55, 56, 57, 58, 448, 512, 640, 576, 47, 48}, {1472, 1536, 1600, 1728, 704, 768, 832, 896, 960, 1024, 1088, 1152, 1216, 1280, 1344, 1408}, {}, {1792, 1856, 1920}, {1984, 2048, 2112, 2176, 2240, 2304, 2368, 2432, 2496, 2560}}

func (_gaf tiffType) String() string {
	switch _gaf {
	case _af:
		return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u004d\u006f\u0064i\u0066\u0069\u0065\u0064\u0048\u0075\u0066\u0066\u006d\u0061n\u0052\u006c\u0065"
	case _bgb:
		return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u0054\u0034"
	case _dfc:
		return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u0054\u0036"
	default:
		return "\u0075n\u0064\u0065\u0066\u0069\u006e\u0065d"
	}
}

var (
	_fb  *treeNode
	_fae *treeNode
	_d   *tree
	_a   *tree
	_bc  *tree
	_aa  *tree
	_ef  = -2000
	_bf  = -1000
	_c   = -3000
	_g   = -4000
)

var (
	_ffg = _f.New("\u0063\u0063\u0069\u0074tf\u0061\u0078\u0020\u0063\u006f\u0072\u0072\u0075\u0070\u0074\u0065\u0064\u0020\u0052T\u0043")
	_gba = _f.New("\u0063\u0063\u0069\u0074tf\u0061\u0078\u0020\u0045\u004f\u004c\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064")
)

func _cga(_gca int) ([]byte, int) {
	var _dce []byte
	for _dfg := 0; _dfg < 6; _dfg++ {
		_dce, _gca = _baf(_dce, _gca, _cca)
	}
	return _dce, _gca % 8
}

func _agbd(_aabg []byte, _aec, _eee, _daf int) ([]byte, int) {
	_eabd := _dae(_eee, _daf)
	_aabg, _aec = _baf(_aabg, _aec, _eabd)
	return _aabg, _aec
}

func (_dda *Decoder) decodeG32D() error {
	_dda._agc = _dda._ddb
	_dda._ccd, _dda._gafc = _dda._gafc, _dda._ccd
	_ee := true
	var (
		_gfa bool
		_bfd int
		_efb error
	)
	_dda._ddb = 0
_fec:
	for _bfd < _dda._cf {
		_bcb := _aa._ddg
		for {
			_gfa, _efb = _dda._fbf.ReadBool()
			if _efb != nil {
				return _efb
			}
			_bcb = _bcb.walk(_gfa)
			if _bcb == nil {
				continue _fec
			}
			if !_bcb._dbdb {
				continue
			}
			switch _bcb._ebad {
			case _g:
				var _edg int
				if _ee {
					_edg, _efb = _dda.decodeRun(_a)
				} else {
					_edg, _efb = _dda.decodeRun(_d)
				}
				if _efb != nil {
					return _efb
				}
				_bfd += _edg
				_dda._ccd[_dda._ddb] = _bfd
				_dda._ddb++
				if _ee {
					_edg, _efb = _dda.decodeRun(_d)
				} else {
					_edg, _efb = _dda.decodeRun(_a)
				}
				if _efb != nil {
					return _efb
				}
				_bfd += _edg
				_dda._ccd[_dda._ddb] = _bfd
				_dda._ddb++
			case _c:
				_dbf := _dda.getNextChangingElement(_bfd, _ee) + 1
				if _dbf >= _dda._agc {
					_bfd = _dda._cf
				} else {
					_bfd = _dda._gafc[_dbf]
				}
			default:
				_cdb := _dda.getNextChangingElement(_bfd, _ee)
				if _cdb >= _dda._agc || _cdb == -1 {
					_bfd = _dda._cf + _bcb._ebad
				} else {
					_bfd = _dda._gafc[_cdb] + _bcb._ebad
				}
				_dda._ccd[_dda._ddb] = _bfd
				_dda._ddb++
				_ee = !_ee
			}
			continue _fec
		}
	}
	return nil
}

func (_ace *Decoder) decodeRowType2() error {
	if _ace._ca {
		_ace._fbf.Align()
	}
	if _gg := _ace.decode1D(); _gg != nil {
		return _gg
	}
	return nil
}

func (_dfcg *Encoder) appendEncodedRow(_ccef, _cddc []byte, _abb int) []byte {
	if len(_ccef) > 0 && _abb != 0 && !_dfcg.EncodedByteAlign {
		_ccef[len(_ccef)-1] = _ccef[len(_ccef)-1] | _cddc[0]
		_ccef = append(_ccef, _cddc[1:]...)
	} else {
		_ccef = append(_ccef, _cddc...)
	}
	return _ccef
}

func (_cef *Decoder) looseFetchEOL() (bool, error) {
	_cde, _afg := _cef._fbf.ReadBits(12)
	if _afg != nil {
		return false, _afg
	}
	switch _cde {
	case 0x1:
		return true, nil
	case 0x0:
		for {
			_bbgg, _fecd := _cef._fbf.ReadBool()
			if _fecd != nil {
				return false, _fecd
			}
			if _bbgg {
				return true, nil
			}
		}
	default:
		return false, nil
	}
}

type tiffType int

func (_ffe *Decoder) Read(in []byte) (int, error) {
	if _ffe._fee != nil {
		return 0, _ffe._fee
	}
	_bff := len(in)
	var (
		_ged int
		_gdg int
	)
	for _bff != 0 {
		if _ffe._bb >= _ffe._ge {
			if _ecb := _ffe.fetch(); _ecb != nil {
				_ffe._fee = _ecb
				return 0, _ecb
			}
		}
		if _ffe._ge == -1 {
			return _ged, _ec.EOF
		}
		switch {
		case _bff <= _ffe._ge-_ffe._bb:
			_efc := _ffe._bed[_ffe._bb : _ffe._bb+_bff]
			for _, _eab := range _efc {
				if !_ffe._fabe {
					_eab = ^_eab
				}
				in[_gdg] = _eab
				_gdg++
			}
			_ged += len(_efc)
			_ffe._bb += len(_efc)
			return _ged, nil
		default:
			_bdad := _ffe._bed[_ffe._bb:]
			for _, _bca := range _bdad {
				if !_ffe._fabe {
					_bca = ^_bca
				}
				in[_gdg] = _bca
				_gdg++
			}
			_ged += len(_bdad)
			_ffe._bb += len(_bdad)
			_bff -= len(_bdad)
		}
	}
	return _ged, nil
}

func _ebd(_cfg int) ([]byte, int) {
	var _gbgd []byte
	for _bcd := 0; _bcd < 6; _bcd++ {
		_gbgd, _cfg = _baf(_gbgd, _cfg, _gb)
	}
	return _gbgd, _cfg % 8
}

func (_bea *treeNode) walk(_efae bool) *treeNode {
	if _efae {
		return _bea._ggbc
	}
	return _bea._dfbe
}

func _ccdg(_edbf int, _gcd bool) (code, int, bool) {
	if _edbf < 64 {
		if _gcd {
			return _ded[_edbf], 0, true
		}
		return _de[_edbf], 0, true
	}
	_bba := _edbf / 64
	if _bba > 40 {
		return _bfc[2560], _edbf - 2560, false
	}
	if _bba > 27 {
		return _bfc[_bba*64], _edbf - _bba*64, false
	}
	if _gcd {
		return _fcb[_bba*64], _edbf - _bba*64, false
	}
	return _aabe[_bba*64], _edbf - _bba*64, false
}

func (_cgb *Decoder) decodeRow() (_gedg error) {
	if !_cgb._gf && _cgb._abd > 0 && _cgb._abd == _cgb._afb {
		return _ec.EOF
	}
	switch _cgb._egg {
	case _af:
		_gedg = _cgb.decodeRowType2()
	case _bgb:
		_gedg = _cgb.decodeRowType4()
	case _dfc:
		_gedg = _cgb.decodeRowType6()
	}
	if _gedg != nil {
		return _gedg
	}
	_afc := 0
	_cebg := true
	_cgb._cb = 0
	for _fbd := 0; _fbd < _cgb._ddb; _fbd++ {
		_eb := _cgb._cf
		if _fbd != _cgb._ddb {
			_eb = _cgb._ccd[_fbd]
		}
		if _eb > _cgb._cf {
			_eb = _cgb._cf
		}
		_efa := _afc / 8
		for _afc%8 != 0 && _eb-_afc > 0 {
			var _eca byte
			if !_cebg {
				_eca = 1 << uint(7-(_afc%8))
			}
			_cgb._bed[_efa] |= _eca
			_afc++
		}
		if _afc%8 == 0 {
			_efa = _afc / 8
			var _gbe byte
			if !_cebg {
				_gbe = 0xff
			}
			for _eb-_afc > 7 {
				_cgb._bed[_efa] = _gbe
				_afc += 8
				_efa++
			}
		}
		for _eb-_afc > 0 {
			if _afc%8 == 0 {
				_cgb._bed[_efa] = 0
			}
			var _cge byte
			if !_cebg {
				_cge = 1 << uint(7-(_afc%8))
			}
			_cgb._bed[_efa] |= _cge
			_afc++
		}
		_cebg = !_cebg
	}
	if _afc != _cgb._cf {
		return _f.New("\u0073\u0075\u006d\u0020\u006f\u0066 \u0072\u0075\u006e\u002d\u006c\u0065\u006e\u0067\u0074\u0068\u0073\u0020\u0064\u006f\u0065\u0073\u0020\u006e\u006f\u0074 \u0065\u0071\u0075\u0061\u006c\u0020\u0073\u0063\u0061\u006e\u0020\u006c\u0069\u006ee\u0020w\u0069\u0064\u0074\u0068")
	}
	_cgb._ge = (_afc + 7) / 8
	_cgb._afb++
	return nil
}

func (_ffc *Decoder) tryFetchEOL() (bool, error) {
	_cbda, _ebf := _ffc._fbf.ReadBits(12)
	if _ebf != nil {
		return false, _ebf
	}
	return _cbda == 0x1, nil
}

func (_cecb *Encoder) encodeG31D(_gadc [][]byte) []byte {
	var _gdb []byte
	_gff := 0
	for _cbe := range _gadc {
		if _cecb.Rows > 0 && !_cecb.EndOfBlock && _cbe == _cecb.Rows {
			break
		}
		_eaaf, _bddg := _bcgb(_gadc[_cbe], _gff, _gb)
		_gdb = _cecb.appendEncodedRow(_gdb, _eaaf, _gff)
		if _cecb.EncodedByteAlign {
			_bddg = 0
		}
		_gff = _bddg
	}
	if _cecb.EndOfBlock {
		_fdg, _ := _ebd(_gff)
		_gdb = _cecb.appendEncodedRow(_gdb, _fdg, _gff)
	}
	return _gdb
}

func _eea(_eaag [][]byte) [][]byte {
	_bgad := make([]byte, len(_eaag[0]))
	for _fdgf := range _bgad {
		_bgad[_fdgf] = _beb
	}
	_eaag = append(_eaag, []byte{})
	for _cccfd := len(_eaag) - 1; _cccfd > 0; _cccfd-- {
		_eaag[_cccfd] = _eaag[_cccfd-1]
	}
	_eaag[0] = _bgad
	return _eaag
}

func (_bbg *Decoder) decoderRowType41D() error {
	if _bbg._ca {
		_bbg._fbf.Align()
	}
	_bbg._fbf.Mark()
	var (
		_bgg bool
		_cad error
	)
	if _bbg._fd {
		_bgg, _cad = _bbg.tryFetchEOL()
		if _cad != nil {
			return _cad
		}
		if !_bgg {
			return _gba
		}
	} else {
		_bgg, _cad = _bbg.looseFetchEOL()
		if _cad != nil {
			return _cad
		}
	}
	if !_bgg {
		_bbg._fbf.Reset()
	}
	if _bgg && _bbg._gf {
		_bbg._fbf.Mark()
		for _faa := 0; _faa < 5; _faa++ {
			_bgg, _cad = _bbg.tryFetchEOL()
			if _cad != nil {
				if _f.Is(_cad, _ec.EOF) {
					if _faa == 0 {
						break
					}
					return _ffg
				}
			}
			if _bgg {
				continue
			}
			if _faa > 0 {
				return _ffg
			}
			break
		}
		if _bgg {
			return _ec.EOF
		}
		_bbg._fbf.Reset()
	}
	if _cad = _bbg.decode1D(); _cad != nil {
		return _cad
	}
	return nil
}

func _baf(_cbf []byte, _cgc int, _aeg code) ([]byte, int) {
	_gec := 0
	for _gec < _aeg.BitsWritten {
		_gde := _cgc / 8
		_fdb := _cgc % 8
		if _gde >= len(_cbf) {
			_cbf = append(_cbf, 0)
		}
		_afgf := 8 - _fdb
		_cgga := _aeg.BitsWritten - _gec
		if _afgf > _cgga {
			_afgf = _cgga
		}
		if _gec < 8 {
			_cbf[_gde] = _cbf[_gde] | byte(_aeg.Code>>uint(8+_fdb-_gec))&_ffd[8-_afgf-_fdb]
		} else {
			_cbf[_gde] = _cbf[_gde] | (byte(_aeg.Code<<uint(_gec-8))&_ffd[8-_afgf])>>uint(_fdb)
		}
		_cgc += _afgf
		_gec += _afgf
	}
	return _cbf, _cgc
}

var _gd = [...][]uint16{{0x7, 0x8, 0xb, 0xc, 0xe, 0xf}, {0x12, 0x13, 0x14, 0x1b, 0x7, 0x8}, {0x17, 0x18, 0x2a, 0x2b, 0x3, 0x34, 0x35, 0x7, 0x8}, {0x13, 0x17, 0x18, 0x24, 0x27, 0x28, 0x2b, 0x3, 0x37, 0x4, 0x8, 0xc}, {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x1a, 0x1b, 0x2, 0x24, 0x25, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x3, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x4, 0x4a, 0x4b, 0x5, 0x52, 0x53, 0x54, 0x55, 0x58, 0x59, 0x5a, 0x5b, 0x64, 0x65, 0x67, 0x68, 0xa, 0xb}, {0x98, 0x99, 0x9a, 0x9b, 0xcc, 0xcd, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb}, {}, {0x8, 0xc, 0xd}, {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f}}

func _fcg(_ebe, _abbg []byte, _cbb int, _ccf bool) int {
	_edf := _agf(_abbg, _cbb)
	if _edf < len(_abbg) && (_cbb == -1 && _abbg[_edf] == _beb || _cbb >= 0 && _cbb < len(_ebe) && _ebe[_cbb] == _abbg[_edf] || _cbb >= len(_ebe) && _ccf && _abbg[_edf] == _beb || _cbb >= len(_ebe) && !_ccf && _abbg[_edf] == _gbde) {
		_edf = _agf(_abbg, _edf)
	}
	return _edf
}

func (_ccc *Encoder) encodeG32D(_cdd [][]byte) []byte {
	var _efab []byte
	var _bcbb int
	for _dbb := 0; _dbb < len(_cdd); _dbb += _ccc.K {
		if _ccc.Rows > 0 && !_ccc.EndOfBlock && _dbb == _ccc.Rows {
			break
		}
		_ffee, _bdg := _bcgb(_cdd[_dbb], _bcbb, _cca)
		_efab = _ccc.appendEncodedRow(_efab, _ffee, _bcbb)
		if _ccc.EncodedByteAlign {
			_bdg = 0
		}
		_bcbb = _bdg
		for _ecgc := _dbb + 1; _ecgc < (_dbb+_ccc.K) && _ecgc < len(_cdd); _ecgc++ {
			if _ccc.Rows > 0 && !_ccc.EndOfBlock && _ecgc == _ccc.Rows {
				break
			}
			_ecgcf, _bcg := _baf(nil, _bcbb, _ab)
			var _gc, _ddag, _cdf int
			_ddf := -1
			for _ddf < len(_cdd[_ecgc]) {
				_gc = _agf(_cdd[_ecgc], _ddf)
				_ddag = _faab(_cdd[_ecgc], _cdd[_ecgc-1], _ddf)
				_cdf = _agf(_cdd[_ecgc-1], _ddag)
				if _cdf < _gc {
					_ecgcf, _bcg = _fac(_ecgcf, _bcg)
					_ddf = _cdf
				} else {
					if _fa.Abs(float64(_ddag-_gc)) > 3 {
						_ecgcf, _bcg, _ddf = _dfgd(_cdd[_ecgc], _ecgcf, _bcg, _ddf, _gc)
					} else {
						_ecgcf, _bcg = _agbd(_ecgcf, _bcg, _gc, _ddag)
						_ddf = _gc
					}
				}
			}
			_efab = _ccc.appendEncodedRow(_efab, _ecgcf, _bcbb)
			if _ccc.EncodedByteAlign {
				_bcg = 0
			}
			_bcbb = _bcg % 8
		}
	}
	if _ccc.EndOfBlock {
		_eff, _ := _cga(_bcbb)
		_efab = _ccc.appendEncodedRow(_efab, _eff, _bcbb)
	}
	return _efab
}

const (
	_ tiffType = iota
	_af
	_bgb
	_dfc
)

func (_dbe *Decoder) fetch() error {
	if _dbe._ge == -1 {
		return nil
	}
	if _dbe._bb < _dbe._ge {
		return nil
	}
	_dbe._ge = 0
	_acc := _dbe.decodeRow()
	if _acc != nil {
		if !_f.Is(_acc, _ec.EOF) {
			return _acc
		}
		if _dbe._ge != 0 {
			return _acc
		}
		_dbe._ge = -1
	}
	_dbe._bb = 0
	return nil
}

func (_cgf *Decoder) getNextChangingElement(_eba int, _caed bool) int {
	_fbg := 0
	if !_caed {
		_fbg = 1
	}
	_cbd := int(uint32(_cgf._cb)&0xFFFFFFFE) + _fbg
	if _cbd > 2 {
		_cbd -= 2
	}
	if _eba == 0 {
		return _cbd
	}
	for _eaaa := _cbd; _eaaa < _cgf._agc; _eaaa += 2 {
		if _eba < _cgf._gafc[_eaaa] {
			_cgf._cb = _eaaa
			return _eaaa
		}
	}
	return -1
}

func (_afd *tree) fill(_agbdf, _gbc, _bcea int) error {
	_egc := _afd._ddg
	for _ebbf := 0; _ebbf < _agbdf; _ebbf++ {
		_ecf := _agbdf - 1 - _ebbf
		_deg := ((_gbc >> uint(_ecf)) & 1) != 0
		_eaef := _egc.walk(_deg)
		if _eaef != nil {
			if _eaef._dbdb {
				return _f.New("\u006e\u006f\u0064\u0065\u0020\u0069\u0073\u0020\u006c\u0065\u0061\u0066\u002c\u0020\u006eo\u0020o\u0074\u0068\u0065\u0072\u0020\u0066\u006f\u006c\u006c\u006f\u0077\u0069\u006e\u0067")
			}
			_egc = _eaef
			continue
		}
		_eaef = &treeNode{}
		if _ebbf == _agbdf-1 {
			_eaef._ebad = _bcea
			_eaef._dbdb = true
		}
		if _gbc == 0 {
			_eaef._bgd = true
		}
		_egc.set(_deg, _eaef)
		_egc = _eaef
	}
	return nil
}

func (_ega *Decoder) decodeRowType4() error {
	if !_ega._fe {
		return _ega.decoderRowType41D()
	}
	if _ega._ca {
		_ega._fbf.Align()
	}
	_ega._fbf.Mark()
	_aaf, _bdd := _ega.tryFetchEOL()
	if _bdd != nil {
		return _bdd
	}
	if !_aaf && _ega._fd {
		_ega._gafca++
		if _ega._gafca > _ega._gbga {
			return _gba
		}
		_ega._fbf.Reset()
	}
	if !_aaf {
		_ega._fbf.Reset()
	}
	_efe, _bdd := _ega._fbf.ReadBool()
	if _bdd != nil {
		return _bdd
	}
	if _efe {
		if _aaf && _ega._gf {
			if _bdd = _ega.tryFetchRTC2D(); _bdd != nil {
				return _bdd
			}
		}
		_bdd = _ega.decode1D()
	} else {
		_bdd = _ega.decode2D()
	}
	if _bdd != nil {
		return _bdd
	}
	return nil
}

type Encoder struct {
	K                      int
	EndOfLine              bool
	EncodedByteAlign       bool
	Columns                int
	Rows                   int
	EndOfBlock             bool
	BlackIs1               bool
	DamagedRowsBeforeError int
}

var (
	_beb  byte = 1
	_gbde byte = 0
)

func (_afcd *Decoder) decodeRun(_fbga *tree) (int, error) {
	var _ggec int
	_cdae := _fbga._ddg
	for {
		_ecd, _dbd := _afcd._fbf.ReadBool()
		if _dbd != nil {
			return 0, _dbd
		}
		_cdae = _cdae.walk(_ecd)
		if _cdae == nil {
			return 0, _f.New("\u0075\u006e\u006bno\u0077\u006e\u0020\u0063\u006f\u0064\u0065\u0020\u0069n\u0020H\u0075f\u0066m\u0061\u006e\u0020\u0052\u004c\u0045\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
		}
		if _cdae._dbdb {
			_ggec += _cdae._ebad
			switch {
			case _cdae._ebad >= 64:
				_cdae = _fbga._ddg
			case _cdae._ebad >= 0:
				return _ggec, nil
			default:
				return _afcd._cf, nil
			}
		}
	}
}

func (_gfe *Decoder) tryFetchEOL1() (bool, error) {
	_agg, _cce := _gfe._fbf.ReadBits(13)
	if _cce != nil {
		return false, _cce
	}
	return _agg == 0x3, nil
}

func (_ffdc *Decoder) tryFetchRTC2D() (_bdac error) {
	_ffdc._fbf.Mark()
	var _ffea bool
	for _ade := 0; _ade < 5; _ade++ {
		_ffea, _bdac = _ffdc.tryFetchEOL1()
		if _bdac != nil {
			if _f.Is(_bdac, _ec.EOF) {
				if _ade == 0 {
					break
				}
				return _ffg
			}
		}
		if _ffea {
			continue
		}
		if _ade > 0 {
			return _ffg
		}
		break
	}
	if _ffea {
		return _ec.EOF
	}
	_ffdc._fbf.Reset()
	return _bdac
}

type Decoder struct {
	_cf    int
	_abd   int
	_afb   int
	_bed   []byte
	_gbga  int
	_fe    bool
	_edb   bool
	_acf   bool
	_fabe  bool
	_fd    bool
	_gf    bool
	_ca    bool
	_ge    int
	_bb    int
	_gafc  []int
	_ccd   []int
	_agc   int
	_ddb   int
	_gafca int
	_cb    int
	_fbf   *_b.Reader
	_egg   tiffType
	_fee   error
}

type code struct {
	Code        uint16
	BitsWritten int
}

func _ffgb(_baa []byte, _cfga bool, _agbb int) (int, int) {
	_bga := 0
	for _agbb < len(_baa) {
		if _cfga {
			if _baa[_agbb] != _beb {
				break
			}
		} else {
			if _baa[_agbb] != _gbde {
				break
			}
		}
		_bga++
		_agbb++
	}
	return _bga, _agbb
}

func _faab(_ebdc, _dgf []byte, _dbbf int) int {
	_ccb := _agf(_dgf, _dbbf)
	if _ccb < len(_dgf) && (_dbbf == -1 && _dgf[_ccb] == _beb || _dbbf >= 0 && _dbbf < len(_ebdc) && _ebdc[_dbbf] == _dgf[_ccb] || _dbbf >= len(_ebdc) && _ebdc[_dbbf-1] != _dgf[_ccb]) {
		_ccb = _agf(_dgf, _ccb)
	}
	return _ccb
}
